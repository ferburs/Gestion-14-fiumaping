// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../mappedin-js/@packages/internal/mvf-utils
//   ../mappedin-js/@mappedin/mvf
//   ../mappedin-js/@packages/internal/common/pubsub
//   ../mappedin-js/@packages/internal/mvf-utils/mvf-utils
//   ../mappedin-js/@packages/internal/common/Mappedin.Logger
//   ../mappedin-js/geojson
//   ../mappedin-js/@packages/internal/common
//   ../mappedin-js/@mappedin/core-sdk
//   ../mappedin-js/@packages/internal/mvf-utils/tokens/token-manager
//   ../mappedin-js/@packages/internal/outdoor-context-v4
//   ../mappedin-js/@packages/internal/geojson-navigator
//   ../mappedin-js/@mappedin/mvf-core
//   ../mappedin-js/three
//   ../mappedin-js/zod
//   ../mappedin-js/@packages/internal/shave-text/shave-text
//   ../mappedin-js/@tweenjs/tween.js
//   ../mappedin-js/@turf/turf
//   ../mappedin-js/troika-three-text
//   ../mappedin-js/@packages/internal/quad-tree
//   ../mappedin-js/@mappedin/core-sdk/src/components/text3d
//   ../mappedin-js/minisearch
//   ../mappedin-js/three/examples/jsm/loaders/GLTFLoader.js
//   ../mappedin-js/@mapbox/point-geometry
//   ../mappedin-js/@maplibre/maplibre-gl-style-spec
//   ../mappedin-js/gl-matrix
//   ../mappedin-js/@mapbox/vector-tile
//   ../mappedin-js/potpack
//   ../mappedin-js/@mapbox/tiny-sdf
//   ../mappedin-js/kdbush
//   ../mappedin-js/supercluster
//   ../mappedin-js/geojson-vt

declare module '@mappedin/mappedin-js' {
    import MapData from '@mappedin/mappedin-js/mappedin-js/src/map-data';
    import type { TEvents, TEventPayload, TClickPayload, THoverPayload, TFloorChangeReason } from '@mappedin/mappedin-js/mappedin-js/src/events';
    import type { TGetMapDataOptions, TGetMapDataWithAccessTokenOptions, TGetMapDataWithCredentialsOptions, TGetMapDataSharedOptions } from '@packages/internal/mvf-utils';
    import { parseMVF, unzipMVF } from '@packages/internal/mvf-utils';
    import type { Floor } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    import type { ParsedMVF as TMVF, StyleCollection as TMVFStyleCollection, Style as TMVFStyle, LineStringStyle as TMVFLineStringStyle, PolygonStyle as TMVFPolygonStyle, PointStyle as TMVFPointStyle, ParsedMVFLocalePack, OperationHours, SiblingGroup, LocationState } from '@mappedin/mvf';
    import { MapView } from '@mappedin/mappedin-js/mappedin-js/src/map-view';
    export type { Text3D as Text3DApi } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/text3d';
    import type { InsetPadding, InsetPaddingOption, Shading, PaintStyle, LineStyle, Text3DState, AddText3DOptions, UpdatableText3DState, InitializeText3DState, EnvMapOptions, MapViewState, UpdateModelState, InitializeModelState, WatermarkUpdateOptions } from '@mappedin/mappedin-js/geojson/src';
    import { enableTestMode, preloadFont } from '@mappedin/mappedin-js/geojson/src';
    export type { PubSub } from '@packages/internal/common/pubsub';
    import type { TMappedinMapLibreOverlayEvents } from '@mappedin/mappedin-js/mappedin-js/src/maplibre-overlay';
    import { MappedinMapLibreOverlay } from '@mappedin/mappedin-js/mappedin-js/src/maplibre-overlay';
    import type { LanguagePackHydrationItem, TImagePlacementOptions } from '@mappedin/mappedin-js/mappedin-js/src/types';
    import { MAPPEDIN_COLORS } from '@mappedin/mappedin-js/mappedin-js/src/constants';
    import { type Environment } from '@packages/internal/mvf-utils/mvf-utils';
    import type { TBlueDotEvents, TBlueDotAction, TBlueDotState, GeolocationPositionExtended, TFollowMode, TFollowCameraOptions } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/blue-dot/blue-dot';
    import type { TExpandOptions, TStackedMapsEvents, TStackedMapsState } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/stacked-maps/stacked-maps';
    export { setLoggerLevel, E_SDK_LOG_LEVEL } from '@packages/internal/common/Mappedin.Logger';
    /**
        * @internal
        * @hidden
        * Must be called before {@link show3dMap}
        */
    export function __setWatermarkOnClickFn(fn: () => void): void;
    /**
        * Represents all the available antialiasing options.
        */
    type TAntialiasingOptions = {
            /**
                * Enable antialiasing. Only works when device supports WebGL2.
                *
                * @default true
                */
            enabled?: boolean;
            /**
                * Change the quality of antialiasing in the scene. Greater quality means less noise, but worse performance.
                *
                * @default 'medium'
                */
            quality?: 'low' | 'medium' | 'high' | 'ultra';
    };
    /**
        * @interface
        * Options for the watermark.
        */
    export type TWatermarkOptions = WatermarkUpdateOptions;
    /**
        * Options for showing a 3D map.
        *
        * @experimental
        */
    type TShow3DMapOptions = {
            /**
                * The outdoor view options.
                */
            outdoorView?: {
                    /**
                        * The token is used to fetch outdoor tiles, which will then be rendered.
                        */
                    token?: string;
                    /**
                        * A url to a style specification conforming to the [Maplibre Style Spec](https://maplibre.org/maplibre-style-spec/).
                        * Use the {@link Environment | `environment`} setting to switch environments.
                        */
                    style?: string;
                    /**
                        * Enable or disable the outdoor view.
                        */
                    enabled?: boolean;
                    /**
                        * Layers that should be hidden by geometry. This is useful when you want to hide certain layers when they are below the geometry.
                        * @default ['building', 'building-top']
                        */
                    layersHiddenByGeometry?: string[];
                    /**
                        * Reduces the pixel ratio for MapLibre rendering to improve framerate performance.
                        * When enabled, the rendering quality will be lower but performance will be better,
                        * which can be useful on devices with high-DPI displays or limited GPU capabilities.
                        *
                        * @default false
                        */
                    lowDpi?: boolean;
            };
            /**
                * The initial bearing of the map, in degrees.
                *
                * @default 0
                */
            bearing?: number;
            /**
                * The initial pitch of the map, in degrees.
                *
                * @default 45
                */
            pitch?: number;
            /**
                * The initial zoom level of the map, in mercator zoom levels.
                * If it is not specified, it will default to the level that fits the map bounds.
                */
            zoomLevel?: number;
            /**
                * The screen offsets of the map, in screen pixels.
                */
            screenOffsets?: InsetPadding;
            /**
                * Whether or not to automatically add labels and interactivity to the map. Set to
                * false if you need finer control over what is labelled or interactive.
                *
                * @hidden
                * @default true
                */
            auto?: boolean;
            /**
                * Antialiasing settings.
                *
                * TODO: Maybe we don't expose all of these settings.
                * @hidden
                * @default true
                */
            antialiasing?: boolean | TAntialiasingOptions;
            /**
                * @experimental
                *
                * Enable debug mode to check the visual representation of performance stats.
                * @default false
                */
            debug?: boolean;
            /**
                * Options when showing the watermark.
                *
                * @hidden
                */
            watermark?: TWatermarkOptions;
            /**
                * Options for the attribution control.
                *
                * @hidden
                */
            attribution?: {
                    /**
                        * Custom attribution content.
                        */
                    custom?: string[];
                    /**
                        * Attribution position.
                        * @default 'bottom-right'
                        */
                    position?: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';
                    /**
                        * Whether to show a feedback link next to the attributions.
                        * @default true
                        */
                    feedback?: boolean;
            };
            /**
                * First floor to be rendered.
                * By default, floor with the elevation that's closest to 0 is rendered. All floors will be sorted by elevation in ascending order.
                */
            initialFloor?: Floor | string;
            /**
                * Enable shading of bottoms of geometry along with outlines to make geometry stand out.
                * @default true
                * @deprecated Use `style.shading`.
                */
            shadingAndOutlines?: boolean;
            /**
                * Specify a color for the top of wall geometry.
                * @deprecated Use `style.wallTopColor`.
                */
            wallTopColor?: string;
            /**
                * Style options for the map.
                * @experimental
                */
            style?: {
                    /**
                        * Background color. Only relevant if outdoor map is disabled.
                        */
                    backgroundColor?: string;
                    /**
                        * Background alpha value. Only relevant if outdoor map is disabled.
                        */
                    backgroundAlpha?: number;
                    /**
                        * Set the global shading for all elements. True will use default values, false will disable shading.
                        * @default true
                        */
                    shading?: boolean | Shading;
                    /**
                        * Set the global outlines for all elements. True will enable outlines, false will disable them.
                        * @default true
                        */
                    outlines?: boolean;
                    /**
                        * Specify a color for the top of wall geometry.
                        */
                    wallTopColor?: string;
            };
            /**
                * @experimental
                * @internal
                */
            multiFloorView?: {
                    enabled?: boolean;
                    floorHeight?: number;
                    updateCameraElevationOnFloorChange?: boolean;
            };
            /**
                * @experimental
                * @internal
                * @default false
                */
            keepOutdoorGeometryVisible?: boolean;
            /**
                * @experimental
                *
                * Enable occlusion of labels, markers and floors.
                */
            occlusion?: {
                    /**
                        * Enable occlusion.
                        * @default false
                        */
                    enabled?: boolean;
            };
            /**
                * @experimental
                * @internal
                */
            imagePlacementOptions?: TImagePlacementOptions;
            /**
                * Enable or disable the flip of images to face the camera.
                * @default true
                */
            flipImagesToFaceCamera?: boolean;
            /**
                * Automatically inject necessary styles into the document head. If `false`, the `index.css` file needs to be manually imported.
                *
                * ```ts
                * import '@mappedin/mappedin-js/lib/index.css';
                * ...
                * await show3dMap(...);
                * ```
                *
                * @default true
                */
            injectStyles?: boolean;
            /**
                * @hidden
                * @internal
                */
            onWebGLContextCreationError?: (event: Event) => void;
            /**
                * @hidden
                * @internal
                */
            onWebGLContextLost?: (event: Event) => void;
            /**
                * @hidden
                * @internal
                */
            onWebGLContextRestored?: (event: Event) => void;
            /**
                * @hidden
                * @internal
                */
            onWebGLRendererError?: (error: Error) => void;
    };
    /**
        * @internal
        * @deprecated Use {@link hydrateMapData} instead.
        *
        * Returns a {@link MapData} instance from a parsed MVF object.
        */
    export const hydrateMapDataFromMVF: (mvf: TMVF, options?: TGetMapDataWithCredentialsOptions & {
            languagePacks?: LanguagePackHydrationItem[];
    }) => Promise<MapData>;
    /**
        * @internal
        * @deprecated Use {@link getMapData} and enterprise will be inferred from key/secret.
        */
    export function setUseEnterpriseAPI(value: boolean): void;
    export type THydrateMapDataBundle = {
            type: 'binary';
            options?: {
                    enterprise?: boolean;
            };
            languagePacks?: {
                    language: {
                            code: string;
                            name: string;
                    };
                    localePack: Uint8Array;
            }[];
            main: Uint8Array;
    } | {
            type: 'json';
            options?: {
                    enterprise?: boolean;
            };
            languagePacks?: {
                    language: {
                            code: string;
                            name: string;
                    };
                    localePack: ParsedMVFLocalePack;
            }[];
            main: TMVF;
    };
    /**
        * Load a MapData instance from a backup including language packs. Pass in userOptions to ensure outdoor view is available.
        */
    export const hydrateMapData: (backup: THydrateMapDataBundle | TMVF, userOptions?: TGetMapDataOptions) => Promise<MapData>;
    /**
        * Asynchronously retrieves map data ({@link MapData}) based on user-provided options.
        *
        * @experimental
        * @param userOptions {TGetMapDataOptions} Options provided by the user to retrieve map data.
        * @returns {Promise<MapData>} Promise resolving to the MapData.
        * @example
        * const data = await getMapData({ key: 'api_key', secret: 'api_secret', mapId: 'id' });
        */
    export const getMapData: (userOptions: TGetMapDataOptions) => Promise<MapData>;
    /**
        * @internal
        * @deprecated Use {@link getMapData} and enterprise will be inferred from key/secret.
        */
    export const getMapDataEnterprise: (userOptions: TGetMapDataOptions) => Promise<MapData>;
    /**
        * Mappedin JS makes use of MapLibre to render the outdoor portion of the map. Mappedin JS exposes this layer through {@link MapView.OutoorMap} and can be used to add additional layers as described in the [Outdoor Map Guide](https://developer.mappedin.com/web-sdk/outdoor-map).
        *
        * It is also possible to utilize the opposite architecture, by adding a MapView to a MapLibre Map.
        * This is accomplished by using {@link MappedinMapLibreOverlay} class. It allows a developer to easily add a Mappedin indoor map to an existing MapLibre based app.
        *
        * Refer to the [Mappedin MapLibre Overlay](https://developer.mappedin.com/web-sdk/mappedin-maplibre-overlay) for more information and interactive examples.
    
        * @experimental
        */
    export const createMapLibreOverlay: (mapData: MapData, showMapOptions?: TShow3DMapOptions) => MappedinMapLibreOverlay;
    export const show3dMap: (el: HTMLElement, mapData: MapData, options?: TShow3DMapOptions) => Promise<MapView>;
    /**
        * @internal
        * @deprecated Use {@link show3dMap} instead.
        */
    export const show3dMapGeojson: (el: HTMLElement, mapData: MapData, options?: TShow3DMapOptions) => Promise<MapView>;
    export { parseMVF, unzipMVF, enableTestMode, preloadFont, MAPPEDIN_COLORS };
    export type { MapView, MapData, MapViewState, MappedinMapLibreOverlay, TMappedinMapLibreOverlayEvents, TBlueDotEvents, TBlueDotAction, TBlueDotState, GeolocationPositionExtended, TStackedMapsEvents, TExpandOptions, TStackedMapsState, TFollowMode, TFollowCameraOptions, TEvents, TEventPayload, TFloorChangeReason, TClickPayload, THoverPayload, TShow3DMapOptions, TGetMapDataOptions, TGetMapDataWithAccessTokenOptions, TGetMapDataWithCredentialsOptions, TGetMapDataSharedOptions, TAntialiasingOptions, TMVF, PaintStyle, LineStyle, EnvMapOptions, Shading, TMVFStyleCollection, TMVFStyle, TMVFLineStringStyle, TMVFPolygonStyle, TMVFPointStyle, Environment, InsetPadding, InsetPaddingOption, OperationHours, SiblingGroup, LocationState, Text3DState, AddText3DOptions, UpdatableText3DState, InitializeText3DState, UpdateModelState, InitializeModelState, };
    export type * from 'geojson';
    export type { TUpdateState, TUpdateStates, TLabelState, TGeometryState, TModelState, TShapeState, TDoorsState, TImageState, TWallsState, TCameraAnimationOptions, TAnimationOptions, TFocusOnOptions, TEasingFunction, TCameraTarget, TNavigationTarget, TDirectionZone, TAddMarkerOptions, TAddPathOptions, TLabelAppearance, TAddLabelOptions, TAddModelOptions, TAddModel, TAddImageOptions, TGetDirectionsOptions, TCollisionRankingTier, TMarkerAnchor, TDirectionInstruction, TDirectionInstructionAction, TGetState, TMarkerState, TBlueDotOptions, TBlueDotPositionUpdate, TFocusTarget, IFocusable, IAnchorable, TMapDataObjectTypes, TFloorState, TFacadeState, } from '@mappedin/mappedin-js/mappedin-js/src/types';
    export { WALLS, DOORS } from '@mappedin/mappedin-js/mappedin-js/src/types';
    export type { Label, Marker, Path, PathSegment, Shape, CameraTransform, Model, Image, Text3D, } from '@mappedin/mappedin-js/mappedin-js/src/map-view-objects';
    export type { Debug } from '@mappedin/mappedin-js/mappedin-js/src/debug';
    export type { Navigation, TNavigationOptions } from '@mappedin/mappedin-js/mappedin-js/src/navigation';
    export type { TSpaceType } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    export { Coordinate, Annotation, Connection, Door, Floor, FloorStack, MapObject, PointOfInterest, Space, ImageMetaData, Hyperlink, EnterpriseLocation, EnterpriseCategory, EnterpriseVenue, LocationProfile, LocationCategory, Facade, Node, Area, type Places, } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    export type { Camera, Models, Labels, BlueDot, Markers, Paths, Exporter, Directions, Style, Shapes, Outdoor, Images, StackedMaps, DynamicFocus, } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson';
    export type { SearchResult, SearchResultItem, SearchResultEnterpriseCategory, SearchResultEnterpriseLocations, SearchResultPlaces, SearchOptions, Search, Suggestion, MatchInfo, } from '@mappedin/mappedin-js/mappedin-js/src/search';
    export type { TFindNearestOptions, TFindNearestResult, TQueriables, Query } from '@mappedin/mappedin-js/mappedin-js/src/query';
    export type { Analytics, TAnalyticsUpdateState } from '@mappedin/mappedin-js/mappedin-js/src/analytics';
}

declare module '@mappedin/mappedin-js/mappedin-js/src/map-data' {
    import { Analytics } from '@mappedin/mappedin-js/mappedin-js/src/analytics';
    import { PubSub } from '@packages/internal/common';
    import type { TSearchOptions } from '@packages/internal/mvf-utils';
    import type { Connection, Door, Floor, MapDataInternal, Space, MapObject, PointOfInterest, Annotation, Coordinate, FloorStack, Node, Facade, Area, EnterpriseCategory, EnterpriseLocation, EnterpriseVenue, LocationProfile, LocationCategory } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    import { Search } from '@mappedin/mappedin-js/mappedin-js/src/search';
    import type { TNavigationTarget, TGetDirectionsOptions, TMapDataObjectTypes } from '@mappedin/mappedin-js/mappedin-js/src/types';
    import type { Directions } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/directions';
    import type { Query } from '@mappedin/mappedin-js/mappedin-js/src/query';
    import type { IGeoJSONData } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/types';
    /**
        * A WeakMap to associate {@link MapData} instances with their internal representation.
        * We need a way to get the internal data object from the API
        *
        * @internal
        */
    export const MapDataInternalByMapData: WeakMap<MapData, MapDataInternal>;
    /**
        * Represents the data for a map, providing access to map elements
        * like spaces, floors, and points of interest.
        */
    class MapData extends PubSub<{
            'language-change': {
                    code: string;
                    name: string;
            };
    }> {
            #private;
            Analytics: Analytics;
            /**
                * Search API for MapData
                *
                * @example
                * // Enable search
                * const mapData = await getMapData({ search: { enabled: true } });
                * // or
                * await mapData.Search.enable();
                *
                * // Perform a search query
                * const results = await mapData.Search.query('Coffee Shop');
                * console.log(results.locations);
                *
                * // Get search suggestions
                * const suggestions = await mapData.Search.suggest('Coff');
                * console.log(suggestions);
                */
            Search: Search;
            Query: Query;
            /**
                * Constructs a new instance of {@link MapData}.
                *
                * @internal
                */
            constructor(internal: MapDataInternal, { search }?: {
                    search?: TSearchOptions;
            });
            /**
                * Get the current environment.
                *
                * @example
                * const env = mapData.getEnv();
                * console.log(env.baseUri); // Get the API URL for the current environment
                */
            getEnv(): {
                    readonly baseUri: string;
                    readonly baseAuthUri: string;
                    readonly analyticsBaseUri: string;
                    readonly tileServerUri: string;
            };
            /**
                * Get an access token for use with Mappedin's API.
                *
                * @returns {string} The current access token
                */
            getAccessToken(): string | undefined;
            /**
                * The name of the map.
                *
                * @returns {string} The name of the map.
                */
            get mapName(): string;
            /**
                * The approximate center coordinate ({@link Coordinate}) of the map.
                *
                * @returns {Coordinate} The center coordinate of the map.
                */
            get mapCenter(): Coordinate;
            /**
                * The organization ID of the map.
                *
                * @returns {string} The organization ID of the map.
                */
            get organizationId(): string;
            /**
                * The token is used to fetch outdoor tiles.
                *
                * @returns {string | undefined} The outdoor view token.
                */
            get outdoorViewToken(): string | undefined;
            /**
                * Retrieves all map elements of a specific type.
                *
                * @param type The type of elements to retrieve (e.g., 'space', 'object').
                * @returns An array of elements of the given type.
                * @example
                * const spaces = mapData.getByType('space');
                */
            getByType(type: string): object[];
            /**
                * @returns The spaces ({@link Space}) on the map.
                * @example
                * const spaces = mapData.getByType('space');
                */
            getByType(type: 'space'): Space[];
            /**
                * @returns The doors ({@link Door}) on the map.
                * @example
                * const doors = mapData.getByType('door');
                */
            getByType(type: 'door'): Door[];
            /**
                * @returns The floors ({@link Floor}) on the map.
                * @example
                * const floors = mapData.getByType('floor');
                */
            getByType(type: 'floor'): Floor[];
            /**
                * @returns The stacks of floors ({@link FloorStack}) within the map.
                * @example
                * const floorStacks = mapData.getByType('floor-stack');
                */
            getByType(type: 'floor-stack'): FloorStack[];
            /**
                * @returns The facades ({@link Facade}) within the map.
                * @example
                * const facades = mapData.getByType('facade');
                */
            getByType(type: 'facade'): Facade[];
            /**
                * @returns The connections ({@link Connection}) on the map.
                * @example
                * const connections = mapData.getByType('connection');
                */
            getByType(type: 'connection'): Connection[];
            /**
                * @returns The objects ({@link MapObject}) on the map.
                * @example
                * const objects = mapData.getByType('object');
                */
            getByType(type: 'object'): MapObject[];
            /**
                * @returns The points of interest ({@link PointOfInterest}) on the map.
                * @example
                * const pointsOfInterest = mapData.getByType('point-of-interest');
                */
            getByType(type: 'point-of-interest'): PointOfInterest[];
            /**
                * @returns The annotations ({@link Annotation}) on the map.
                * @example
                * const annotations = mapData.getByType('annotation');
                */
            getByType(type: 'annotation'): Annotation[];
            /**
                * @returns The areas ({@link Area}) on the map.
                * @example
                * const areas = mapData.getByType('area');
                */
            getByType(type: 'area'): Area[];
            /**
                * @returns The nodes ({@link Node}) on the map.
                * @example
                * const nodes = mapData.getByType('node');
                */
            getByType(type: 'node'): Node[];
            /**
                * @returns The location profiles ({@link LocationProfile}) on the map.
                * @example
                * const locationProfiles = mapData.getByType('location-profile');
                */
            getByType(type: 'location-profile'): LocationProfile[];
            /**
                * @returns The location categories ({@link LocationCategory}) on the map.
                * @example
                * const locationCategories = mapData.getByType('location-category');
                */
            getByType(type: 'location-category'): LocationCategory[];
            /**
                * @returns The enterprise locations ({@link EnterpriseLocation}) on the map.
                * @example
                * const enterpriseLocations = mapData.getByType('enterprise-location');
                */
            getByType(type: 'enterprise-location'): EnterpriseLocation[];
            /**
                * @returns The enterprise categories ({@link EnterpriseCategory}) on the map.
                * @example
                * const enterpriseCategories = mapData.getByType('enterprise-category');
                */
            getByType(type: 'enterprise-category'): EnterpriseCategory[];
            /**
                * @returns The enterprise venue ({@link EnterpriseVenue}) on the map.
                * @example
                * const enterpriseVenue = mapData.getByType('enterprise-venue');
                */
            getByType(type: 'enterprise-venue'): EnterpriseVenue | undefined;
            /**
                * Retrieves a specific map feature by its type and ID.
                *
                * @param type The type of the element to retrieve (e.g., 'space', 'object').
                * @param id The ID of the element.
                * @returns The feature with the given type and ID, or `undefined` if it does not exist.
                * @example
                * const space = mapData.getById('space', 'space-id');
                */
            getById<T extends keyof TMapDataObjectTypes>(type: T, id: string): TMapDataObjectTypes[T] | undefined;
            /**
                * Retrieves an array of map features by their type and shared external ID.
                *
                * @param type The type of the element to retrieve (e.g., 'space', 'object').
                * @param externalId The external ID of the element.
                * @returns An array of features with the given type and external ID if they exist.
                * @example
                * const spaces = mapData.getByExternalId('space', 'space-external-id');
                */
            getByExternalId<T extends keyof Omit<TMapDataObjectTypes, 'annotation' | 'facade'>>(type: T, externalId: string): TMapDataObjectTypes[T][];
            /**
                * Get the GeoJSON for a map data object on the map.
                * @param mapDataObject
                */
            getGeoJSON<T extends IGeoJSONData>(mapDataObject: T): T['geoJSON'];
            /**
                * Changes the language of the map data.
                *
                * @param localeCode The ISO 639-1 language code to change to (e.g., 'en' for English, 'fr' for French). Check ({@link EnterpriseVenue.languages}) for available languages
                * @returns A promise that resolves when the language change is complete.
                * @throws An error if the language change fails.
                * @example
                * try {
                *   await mapData.changeLanguage('fr');
                *   console.log('Language changed to French');
                * } catch (error) {
                *   console.error('Failed to change language:', error);
                * }
                */
            changeLanguage(localeCode: string): Promise<void>;
            /**
                * @internal
                */
            get currentLanguage(): import("@mappedin/mvf").Language | undefined;
            /**
                * Retrieves the natural bearing of the map, which is the angle, in degrees, the map is considered to be "naturally oriented" towards.
                * Typically the angle perpendicular to the street the map is facing, or the main entrance. Other print maps inside the map may have this direction be up.
                * 90 degrees means East is "up"
                *
                * @returns The natural bearing of the map.
                */
            get naturalBearing(): number;
            /**
                * Retrieves directions ({@link Directions}) from one navigable point ({@link TNavigationTarget}) to another on the map.
                *
                * @param from The starting point for navigation.
                * @param to The destination point.
                * @param options Optional parameters for getting directions.
                * @returns Directions from the start to the destination point.
                * @example
                * const directions = map.getDirections(space1, space2);
                */
            getDirections: (from: TNavigationTarget | TNavigationTarget[], to: TNavigationTarget | TNavigationTarget[], options?: TGetDirectionsOptions) => Directions | undefined;
            /**
                * Retrieves directions ({@link Directions}) from one navigable point ({@link TNavigationTarget}) to multiple destination points on the map.
                *
                * @param from The starting point for navigation.
                * @param to The destination points.
                * @param options Optional parameters for getting directions.
                * @returns Directions from the start to the destination points.
                * @example
                * const directions = map.getDirections(space1, [space2, space3]);
                */
            getDirectionsMultiDestination: (from: TNavigationTarget, to: (TNavigationTarget | TNavigationTarget[])[], options?: TGetDirectionsOptions) => Directions[] | undefined;
            /**
                * Retrieves the distance between two navigable points ({@link TNavigationTarget}) on the map.
                *
                * @param from The starting point.
                * @param to The destination point.
                * @returns The distance between the start and destination points in meters.
                */
            getDistance(from: Space | Door | Coordinate | MapObject | PointOfInterest | Annotation | Node | EnterpriseLocation | Area, to: Space | Door | Coordinate | MapObject | PointOfInterest | Annotation | Node | EnterpriseLocation | Area): number;
            /**
                * Creates a backup of the map data including language packs.
                * @internal
                */
            toBinaryBundle({ downloadLanguagePacks }?: {
                    downloadLanguagePacks?: boolean;
            }): Promise<void | import(".").THydrateMapDataBundle>;
            toJSONBundle({ downloadLanguagePacks }?: {
                    downloadLanguagePacks?: boolean;
            }): Promise<import(".").THydrateMapDataBundle>;
    }
    export default MapData;
    /**
        * @internal
        */
    export function getMapDataInternal(mapData: MapData): MapDataInternal;
}

declare module '@mappedin/mappedin-js/mappedin-js/src/events' {
    import type { ClickPayload } from '@mappedin/core-sdk';
    import type { TStackedMapsEvents } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/stacked-maps/stacked-maps';
    import type { Coordinate, Facade, Floor, MapObject, Space } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    import type { Label, Marker, Model, Path } from '@mappedin/mappedin-js/mappedin-js/src/map-view-objects';
    import type { CameraTransform } from '@mappedin/mappedin-js/mappedin-js/src/map-view-objects/camera-transform';
    import type { TBlueDotEvents } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/blue-dot';
    import type { TDirectionInstruction } from '@mappedin/mappedin-js/mappedin-js/src/types';
    import type { Directions } from '@mappedin/mappedin-js/mappedin-js/src';
    export type TFloorChangeReason = '' | 'blue-dot-floor-change' | 'stacked-maps-elevation-change' | 'navigation-connection-click' | 'dynamic-focus';
    export type TClickPayload = {
            /**
                * The coordinate of the interaction.
                */
            coordinate: Coordinate;
            /**
                * The interactive paths which the user interaction passed through.
                */
            paths: Path[];
            /**
                * The interactive spaces which the user interaction passed through.
                */
            spaces: Space[];
            /**
                * The interactive objects which the user interaction passed through.
                */
            objects: MapObject[];
            /**
                * The markers which the user interaction passed through.
                */
            markers: Marker[];
            /**
                * The models which the user interaction passed through.
                */
            models: Model[];
            /**
                * The interactive labels which the user interaction passed through.
                */
            labels: Label[];
            /**
                * The interactive floors which the user interaction passed through.
                */
            floors: Floor[];
            /**
                * Details about the pointer event which triggered the interaction.
                */
            pointerEvent: ClickPayload['pointerEvent'];
            /**
                * The interactive facades which the user interaction passed through.
                */
            facades: Facade[];
            /**
                * Whether the user clicked on the Blue Dot.
                */
            blueDot: boolean;
    };
    export type THoverPayload = Omit<TClickPayload, 'pointerEvent'>;
    export type TFloorChangePayload = {
            /**
                * The floor that is being changed to.
                */
            floor: Floor;
            /**
                * The floor that is being changed from.
                */
            previousFloor: Floor;
            /**
                * The reason for the floor change.
                */
            reason?: TFloorChangeReason;
    };
    /**
        * Defines the structure and types of events emitted in the context of the map.
        */
    export type TEvents = {
            /**
                * Emitted when the map is clicked or tapped on a touch screen.
                */
            click: TClickPayload;
            /**
                * Emitted when the map is hovered over with a mouse.
                */
            hover: Omit<THoverPayload, 'pointerEvent'>;
            /**
                * Emitted when the camera's view changes.
                *
                */
            'camera-change': CameraTransform;
            /**
                * Emitted when a floor change starts.
                */
            'floor-change-start': TFloorChangePayload;
            /**
                * Emitted after the floor change is complete.
                */
            'floor-change': TFloorChangePayload;
            /**
                * Only emitted when dynamic focus is enabled. Emitted when a different facade recieves
                * focus due to the camera moving. This always occurs when the active floor changes to
                * a different floor stack, but may also occur when the camera moves without the active
                * floor changing.
                *
                * @property {Facade[]} facades - The facades that are in focus.
                */
            'dynamic-focus-change': {
                    facades: Facade[];
            };
            /**
                * Emitted when the outdoor view is fully loaded and displayed.
                */
            'outdoor-view-loaded': undefined;
            /**
                * Emitted when the outdoor style is loaded or changed.
                */
            'outdoor-style-loaded': undefined;
            /**
                * Emitted when a user interaction with the map starts (e.g., dragging the map).
                */
            'user-interaction-start': undefined;
            /**
                * Emitted when a user interaction with the map ends.
                */
            'user-interaction-end': undefined;
            /**
                * Emitted when the Blue Dot's position is updated.
                */
            'blue-dot-position-update': TBlueDotEvents['position-update'];
            /**
                * Emitted when the Blue Dot's state changes.
                */
            'blue-dot-state-change': TBlueDotEvents['state-change'];
            /**
                * Emitted when the Blue Dot encounters an error.
                */
            'blue-dot-error': TBlueDotEvents['error'];
            /**
                * Emitted when the Blue Dot's follow mode changes.
                */
            'blue-dot-follow-change': TBlueDotEvents['follow-change'];
            /**
                * Emitted when a navigation connection is clicked.
                */
            'navigation-connection-click': {
                    fromFloor?: Floor;
                    toFloor: Floor;
                    instruction: TDirectionInstruction;
            };
            /**
                * Emitted when the active path changes.
                */
            'navigation-active-path-change': {
                    directions: Directions;
                    path: Path;
            };
            /**
                * Emitted before the scene is drawn to the screen.
                */
            'pre-render': undefined;
            /**
                * Emitted when resize happened.
                */
            resize: undefined;
            /**
                * Emitted after the scene is drawn to the screen.
                */
            'post-render': undefined;
    } & TStackedMapsEvents;
    export type TEventPayload<EventName extends keyof TEvents> = TEvents[EventName] extends {
            data: null;
    } ? TEvents[EventName]['data'] : TEvents[EventName];
    export type GeoJSONTEvents = TEvents & {
            hover: {
                    coordinate: Coordinate;
                    spaces: Space[];
                    objects: MapObject[];
                    markers: Marker[];
                    labels: Label[];
                    floors: Floor[];
                    blueDot: boolean;
            };
    };
}

declare module '@mappedin/mappedin-js/mappedin-js/src/map-data-objects' {
    import Node from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/node';
    import Area from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/area';
    import Door from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/door';
    import Space from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/space';
    import Floor from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/floor';
    import Connection from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/connection';
    import MapObject from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/object';
    import Coordinate from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/coordinate';
    import PointOfInterest from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/poi';
    import Annotation from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/annotation';
    import Hyperlink from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/hyperlink';
    import ImageMetaData from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/image';
    import FloorStack from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/floor-stack';
    import Facade from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/facade';
    import type { MapDataRecords, EnterpriseMapDataRecords } from '@mappedin/mappedin-js/mappedin-js/src/utils/data-creation';
    import type { AnnotationCollection, ParsedMVF, Connection as MVFConnection, EntranceCollection, NodeCollection, ObstructionCollection, SpaceCollection, FloorProperties as MVFFloor, FloorStack as MVFFloorStack, Language, AreaCollection, TilesetStyle } from '@mappedin/mvf';
    import { AnalyticsInternal } from '@mappedin/mappedin-js/mappedin-js/src/analytics';
    import EnterpriseLocation from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/location';
    import EnterpriseCategory from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/category';
    import EnterpriseVenue from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/venue';
    import { PubSub } from '@packages/internal/common';
    import type { LanguagePack, LanguagePackRecords, Places, TMapDataInternalOptions } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/types';
    import { type LocalePackUrls } from '@packages/internal/mvf-utils';
    import type { EnvControl, TGetMapDataOptions } from '@packages/internal/mvf-utils/mvf-utils';
    import type { TMapDataObjectTypes, TGetDirectionsOptions, TNavigationTarget } from '@mappedin/mappedin-js/mappedin-js/src/types';
    import { type Directions, DirectionsInternal } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/directions';
    import { type THydrateMapDataBundle } from '@mappedin/mappedin-js/mappedin-js/src';
    import { Query } from '@mappedin/mappedin-js/mappedin-js/src/query';
    import LocationProfile from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/location-profile';
    import LocationCategory from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/location-category';
    import type { TokenManager } from '@packages/internal/mvf-utils/tokens/token-manager';
    /**
        * Internal class representing detailed map data.
        *
        * @internal
        */
    class MapDataInternal extends PubSub<{
            'language-change': {
                    code: string;
                    name: string;
            };
    }> {
            #private;
            Analytics: AnalyticsInternal;
            Query: Query;
            /**
                * Represents the parsed Mappedin Venue Format (MVF) data.
                */
            readonly mvf: ParsedMVF;
            /**
                * The token is used to fetch outdoor tiles, which will then be rendered.
                */
            readonly outdoorViewToken?: string;
            /**
                * Represents a map of space IDs to node IDs.
                */
            readonly spaceIdsByDestinationNodeId: Record<string, string[]>;
            /**
                * Represents a map of obstruction IDs to entrance node IDs.
                */
            readonly objectEntranceNodeIdsByObstructionId: Record<string, string[]>;
            /**
                * Represents a map of entrance IDs to obstruction IDs.
                */
            readonly obstructionIdByEntranceId: Record<string, string>;
            readonly venue?: EnterpriseVenue;
            readonly tokenManager?: TokenManager;
            directions: DirectionsInternal;
            enterpriseMode: boolean;
            nodesById: MapDataRecords['nodesById'];
            spacesById: MapDataRecords['spacesById'];
            floorsById: MapDataRecords['floorsById'];
            floorStacksById: MapDataRecords['floorStacksById'];
            facadesById: MapDataRecords['facadesById'];
            facadesBySpaceId: MapDataRecords['facadesBySpaceId'];
            connectionsById: MapDataRecords['connectionsById'];
            objectsById: MapDataRecords['objectsById'];
            doorsById: MapDataRecords['doorsById'];
            pointsOfInterestById: MapDataRecords['poisById'];
            annotationsById: MapDataRecords['annotationsById'];
            areasById: MapDataRecords['areasById'];
            locationProfilesById: MapDataRecords['locationProfilesById'];
            locationCategoriesById: MapDataRecords['locationCategoriesById'];
            locationProfilesByExternalId: MapDataRecords['locationProfilesByExternalId'];
            locationsById: EnterpriseMapDataRecords['locationsById'];
            locationProfilesByCategoryId: MapDataRecords['locationProfilesByCategoryId'];
            locationCategoriesByParentId: MapDataRecords['locationCategoriesByParentId'];
            categoriesById: EnterpriseMapDataRecords['categoriesById'];
            doorsByNodeId: MapDataRecords['doorsByNodeId'];
            mvfLocationsBySpaceId: EnterpriseMapDataRecords['mvfLocationsBySpaceId'];
            locationIdsByNodeId: EnterpriseMapDataRecords['locationIdsByNodeId'];
            spaceIdsByNodeId: EnterpriseMapDataRecords['spaceIdsByNodeId'];
            mvfAnnotationsById: MapDataRecords['mvfAnnotationsById'];
            mvfConnectionsById: MapDataRecords['mvfConnectionsById'];
            mvfConnectionsByNodeId: MapDataRecords['mvfConnectionsByNodeId'];
            mvfConnectionIdsByLatLon: MapDataRecords['mvfConnectionIdsByLatLon'];
            mvfEntrancesById: MapDataRecords['mvfEntrancesById'];
            mvfNodesById: MapDataRecords['mvfNodesById'];
            mvfObstructionById: MapDataRecords['mvfObstructionById'];
            mvfSpacesById: MapDataRecords['mvfSpacesById'];
            mvfFloorsById: MapDataRecords['mvfFloorsById'];
            mvfFloorStacksById: MapDataRecords['mvfFloorStacksById'];
            mvfAreasById: MapDataRecords['mvfAreasById'];
            connectionSpaceIdsByLatLon: MapDataRecords['connectionIdsByLatLon'];
            locationProfilesByAttachedFeatureId: MapDataRecords['locationProfilesByAttachedFeatureId'];
            spacesByExternalId: MapDataRecords['spacesByExternalId'];
            nodesByExternalId: MapDataRecords['nodesByExternalId'];
            objectsByExternalId: MapDataRecords['objectsByExternalId'];
            poisByExternalId: MapDataRecords['poisByExternalId'];
            floorsByExternalId: MapDataRecords['floorsByExternalId'];
            floorStacksByExternalId: MapDataRecords['floorStacksByExternalId'];
            doorsByExternalId: MapDataRecords['doorsByExternalId'];
            areasByExternalId: MapDataRecords['areasByExternalId'];
            connectionsByExternalId: EnterpriseMapDataRecords['connectionsByExternalId'];
            locationsByExternalId: EnterpriseMapDataRecords['locationsByExternalId'];
            categoriesByExternalId: EnterpriseMapDataRecords['categoriesByExternalId'];
            mvfNodesByFloorId: MapDataRecords['mvfNodesByFloorId'];
            mvfSpacesByFloorId: MapDataRecords['mvfSpacesByFloorId'];
            mvfPoisByFloorId: MapDataRecords['mvfPoisByFloorId'];
            mvfEntrancesByFloorId: MapDataRecords['mvfEntrancesByFloorId'];
            mvfAnnotationsByFloorId: MapDataRecords['mvfAnnotationsByFloorId'];
            localePacksUrls: LocalePackUrls;
            currentLanguage?: Language;
            /**
                * These represent maps of diffed objects that are used to store the translated values
                */
            languagePacks: {
                    [languageCode: string]: LanguagePack;
            };
            tilesets: {
                    [tilesetId: string]: TilesetStyle;
            };
            binaryBundle?: Uint8Array;
            envControl: EnvControl;
            getMapDataOptions?: TGetMapDataOptions;
            /**
                * @internal
                */
            constructor(mvf: ParsedMVF, options: TMapDataInternalOptions);
            getEnv(): {
                    readonly baseUri: string;
                    readonly baseAuthUri: string;
                    readonly analyticsBaseUri: string;
                    readonly tileServerUri: string;
            };
            /**
                * Retrieves the map name.
                *
                * @returns {string} The name of the map.
                */
            get mapName(): string;
            get organizationId(): string;
            get mapCenter(): Coordinate;
            get naturalBearing(): number;
            /**
                * Retrieves all spaces in the map.
                *
                * @returns {Space[]} An array of Space objects.
                */
            get spaces(): Space[];
            /**
                * Retrieves all objects in the map.
                *
                * @returns {MapObject[]} An array of MapObject objects.
                */
            get objects(): MapObject[];
            /**
                * Retrieves all connections in the map.
                *
                * @returns {Connection[]} An array of Connection objects.
                */
            get connections(): Connection[];
            /**
                * Retrieves all floors in the map.
                *
                * @returns {Floor[]} An array of Floor objects.
                */
            get floors(): Floor[];
            get floorStacks(): FloorStack[];
            get facades(): Facade[];
            /**
                * Retrieves all doors in the map.
                *
                * @internal
                * @hidden
                * @returns {Door[]} An array of Door objects.
                */
            get doors(): Door[];
            /**
                * Retrieves all points of interest in the map.
                *
                * @returns {PointOfInterest[]} An array of PointOfInterest objects.
                */
            get pointsOfInterest(): PointOfInterest[];
            /**
                * Retrieves all annotations in the map.
                *
                * @returns {Annotation[]} An array of Annotation objects.
                */
            get annotations(): Annotation[];
            get areas(): Area[];
            /**
                * Retrieves all nodes in the map.
                *
                * @returns {Annotation[]} An array of Annotation objects.
                */
            get nodes(): Node[];
            get locations(): EnterpriseLocation[];
            get categories(): EnterpriseCategory[];
            get locationProfiles(): LocationProfile[];
            get locationCategories(): LocationCategory[];
            get mvfFloors(): MVFFloor[];
            get mvfFloorStacks(): MVFFloorStack[];
            getByType(type: string): object[];
            getByType(type: 'location-profile'): LocationProfile[];
            getByType(type: 'location-category'): LocationCategory[];
            getByType(type: 'space'): Space[];
            getByType(type: 'area'): Area[];
            getByType(type: 'door'): Door[];
            getByType(type: 'floor'): Floor[];
            getByType(type: 'floor-stack'): FloorStack[];
            getByType(type: 'connection'): Connection[];
            getByType(type: 'object'): MapObject[];
            getByType(type: 'point-of-interest'): PointOfInterest[];
            getByType(type: 'annotation'): Annotation[];
            getByType(type: 'node'): Node[];
            getByType(type: 'enterprise-location'): EnterpriseLocation[];
            getByType(type: 'enterprise-category'): EnterpriseCategory[];
            getByType(type: 'enterprise-venue'): EnterpriseVenue | undefined;
            getByType(type: 'facade'): Facade[];
            /**
                * Retrieves an object by its type and ID.
                *
                * @param type The type of the object (e.g., 'space', 'door').
                * @param id The ID of the object.
                * @returns The requested object, or undefined if not found.
                */
            getById<T extends keyof TMapDataObjectTypes>(type: T, id: string): TMapDataObjectTypes[T] | undefined;
            getByExternalId<T extends keyof Omit<TMapDataObjectTypes, 'annotation' | 'facade'>>(type: T, externalId: string): TMapDataObjectTypes[T][];
            getMapDataById(id: string): Places | undefined;
            /**
                * Retrieves a feature by its type and ID from the Mappedin Venue Format (MVF) data.
                *
                * @param type The type of the feature (e.g., 'space', 'node').
                * @param id The ID of the feature.
                * @returns The requested MVF feature or undefined if not found.
                */
            getMVFFeatureById(type: 'space', id: string): SpaceCollection['features'][number] | undefined;
            getMVFFeatureById(type: 'node', id: string): NodeCollection['features'][number] | undefined;
            getMVFFeatureById(type: 'obstruction', id: string): ObstructionCollection['features'][number] | undefined;
            getMVFFeatureById(type: 'floor', id: string): MVFFloor | undefined;
            getMVFFeatureById(type: 'floor-stack', id: string): MVFFloorStack | undefined;
            getMVFFeatureById(type: 'connection', id: string): MVFConnection | undefined;
            getMVFFeatureById(type: 'entrance', id: string): EntranceCollection['features'][number] | undefined;
            getMVFFeatureById(type: 'annotation', id: string): AnnotationCollection['features'][number] | undefined;
            getMVFFeatureById(type: 'area', id: string): AreaCollection['features'][number] | undefined;
            getMVFFeatureById(type: string, id: string): object | undefined;
            getMVFFeatureByNodeId(type: 'connection', id: string): MVFConnection | undefined;
            /**
                * Retrieves all MVF features of a given type. Safer than referencing the mvf's deprecated collections directly.
                */
            getMVFFeatureByType(type: 'floor-stack'): MVFFloorStack[];
            getMVFFeatureByType(type: 'floor'): MVFFloor[];
            getPropTranslation<T extends keyof LanguagePackRecords, P extends keyof NonNullable<NonNullable<LanguagePackRecords[T]>[string]>>(type: T, prop: P, id: string, fallback: NonNullable<NonNullable<LanguagePackRecords[T]>[string]>[P]): string | NonNullable<NonNullable<LanguagePackRecords[T]>[string]>[P] | undefined;
            /**
                * change the langauge of the data objects in mapdata
                */
            changeLanguage(languageCode: string): Promise<void>;
            getDirectionsMultiDestination: (from: TNavigationTarget | TNavigationTarget[], to: TNavigationTarget | (TNavigationTarget | TNavigationTarget[])[], opt?: TGetDirectionsOptions) => Directions | Directions[] | undefined;
            getDirections: (from: TNavigationTarget | TNavigationTarget[], to: TNavigationTarget | (TNavigationTarget | TNavigationTarget[])[], opt?: TGetDirectionsOptions & {
                    multiDestination?: boolean;
            }) => Directions | Directions[] | undefined;
            getDistance(from: Space | Door | Coordinate | MapObject | PointOfInterest | Annotation | Node | EnterpriseLocation | Area, to: Space | Door | Coordinate | MapObject | PointOfInterest | Annotation | Node | EnterpriseLocation | Area): number;
            transformImageRequest: (url: string) => Promise<{
                    url: string;
            }>;
            toJSONBundle({ downloadLanguagePacks, }?: {
                    downloadLanguagePacks?: boolean;
            }): Promise<THydrateMapDataBundle>;
            toBinaryBundle({ downloadLanguagePacks, }?: {
                    downloadLanguagePacks?: boolean;
            }): Promise<THydrateMapDataBundle | void>;
            /**
                * Cleans up resources used by the instance.
                *
                * @internal
                */
            destroy(): void;
    }
    export { Node, Area, MapDataInternal, Space, Floor, FloorStack, Facade, Connection, MapObject, Door, Coordinate, PointOfInterest, Annotation, Hyperlink, ImageMetaData, EnterpriseLocation, EnterpriseCategory, EnterpriseVenue, LocationCategory, LocationProfile, };
    export type { TSpaceType } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/space';
    export type { Places };
}

declare module '@mappedin/mappedin-js/mappedin-js/src/map-view' {
    import type { RendererCore, WatermarkUpdateOptions } from '@mappedin/mappedin-js/geojson/src';
    import { PubSub } from '@packages/internal/common';
    import { type TEvents, type TShow3DMapOptions } from '@mappedin/mappedin-js/mappedin-js/src';
    import type { Navigation } from '@mappedin/mappedin-js/mappedin-js/src/navigation';
    import type { Camera, Labels, Markers, Models, Paths, Exporter, Directions, Style, Outdoor, Images, DynamicFocus } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson';
    import type { BlueDot } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/blue-dot/blue-dot';
    import type MapData from '@mappedin/mappedin-js/mappedin-js/src/map-data';
    import { Coordinate } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    import type { Annotation, Door, Floor, MapObject, PointOfInterest, Space, Node, EnterpriseLocation, FloorStack, Facade } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    import type { TCoordinateParams } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/coordinate';
    import type { DOORS, WALLS, TGetDirectionsOptions, TGetState, TNavigationTarget, TUpdateState, TUpdateStates, GlobalState, UpdateGlobalState } from '@mappedin/mappedin-js/mappedin-js/src/types';
    import type { Label, Marker, Image, Shape, Text3D as Text3DView, Model, Path } from '@mappedin/mappedin-js/mappedin-js/src/map-view-objects';
    import type { TEventPayload } from '@mappedin/mappedin-js/mappedin-js/src/events';
    import type { Shapes } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/shapes';
    import type { StackedMaps, TCollapseOptions, TExpandOptions } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/stacked-maps/stacked-maps';
    import type { InspectorOption } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/inspector/inspector';
    import { Debug } from '@mappedin/mappedin-js/mappedin-js/src/debug';
    import type { Text3D } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/text3d';
    import type { PathSegment } from '@mappedin/mappedin-js/mappedin-js/src/map-view-objects/path';
    /**
        * The MapView class is the main class for rendering and interacting with the map.
        *
        * It provides a set of controls for manipulating the map's elements and state.
        *
        * For help getting started, refer to the [Getting Started Guide](https://developer.mappedin.com/web-sdk/getting-started).
        */
    export class MapView extends PubSub<TEvents> {
            #private;
            /**
                * Controls for the map's camera.
                */
            Camera: Camera;
            /**
                * Controls for the map's labels.
                */
            Labels: Labels;
            /**
                * @experimental
                * Controls for the map's 3D texts.
                */
            Text3D: Text3D;
            /**
                * Controls for the map's markers.
                */
            Markers: Markers;
            /**
                * Controls for the map's markers.
                */
            Images: Images;
            /**
                * Controls for the map's models.
                */
            Models: Models;
            /**
                * Controls for the map's paths.
                */
            Paths: Paths;
            /**
                * Controls for the map's 3D exporter.
                * @hidden
                */
            Exporter: Exporter;
            /**
                * Controls for the map's navigation.
                */
            Navigation: Navigation;
            /**
                * @experimental
                * Controls for BlueDot positioning.
                */
            BlueDot: BlueDot;
            /**
                * Controls for the indoor map's style.
                */
            Style: Style;
            /**
                * Controls custom GeoJSON geometry on the map
                */
            Shapes: Shapes;
            /**
                * Controls for the outdoor map.
                */
            Outdoor: Outdoor;
            /**
                * Controls for Stacked Maps.
                */
            get StackedMaps(): StackedMaps;
            /**
                * @internal
                * @experimental
                */
            get DynamicFocus(): DynamicFocus;
            /**
                * @internal
                */
            constructor(rendererCore: RendererCore);
            /**
                * Updates the state ({@link TUpdateState}) of a given target on the map.
                *
                * The following table maps targets to states.
                *
                * | target    | state          |
                * |-----------|----------------|
                * | {@link Door}        | {@link TDoorsState}           |
                * | {@link Facade}      | {@link TGeometryState}        |
                * | {@link Label}       | {@link TLabelState}           |
                * | {@link MapObject}   | {@link TGeometryState}        |
                * | {@link Marker}      | {@link TMarkerState}          |
                * | {@link Model}       | {@link UpdateModelState}      |
                * | {@link Path}        | {@link TGeometryState}        |
                * | {@link PathSegment} | {@link TGeometryState}        |
                * | {@link Space}       | {@link TGeometryState}        |
                * | {@link Shape}       | {@link TShapeState}           |
                * | {@link Text3DView}  | {@link UpdatableText3DState}  |
                * | {@link DOORS}       | {@link TDoorsState}           |
                * | {@link WALLS}       | {@link TWallsState}           |
                *
                * @param target The target to update.
                * @param state The new state to apply to the target.
                * @example
                * // Update the color of a space to red.
                * map.updateState(space, { color: 'red' });
                */
            updateState<T extends Space | Text3DView | MapObject | Label | Marker | Shape | Door | Facade | Floor | WALLS | DOORS | Model | Path | PathSegment>(target: T, state: TUpdateState<T>): any;
            updateState<T extends string & NonNullable<unknown>>(target: T, state: TUpdateStates): any;
            /**
                * Update global state of the MapView
                */
            updateGlobalState(update: UpdateGlobalState): void;
            /**
                * Get global state of the MapView
                */
            getGlobalState(): GlobalState;
            update: () => void;
            /**
                * Retrieves the map data for the current map.
                * @returns The {@link MapData} for the current map.
                */
            getMapData(): {
                    [x: string]: MapData;
            };
            /**
                * Retrieves the dimensions of the map's canvas.
                *
                * @returns An object containing the width and height of the canvas.
                */
            getDimensions(): {
                    width: number;
                    height: number;
            };
            /**
                * @experimental
                */
            expand(opts?: TExpandOptions): Promise<void>;
            /**
                * @experimental
                * @hidden
                */
            collapse(opts?: TCollapseOptions): Promise<void>;
            /**
                * Adds a map to the MapView.
                * @param mapData The map data to add.
                * @returns A promise that resolves with the added map data.
                * @hidden
                */
            addMap(mapData: MapData, options?: TShow3DMapOptions): Promise<MapData>;
            /**
                * Sets the current floor ({@link Floor}) of the map.
                * @param floor The floor or floor ID to set.
                */
            setFloor(floor: Floor | string): void;
            /**
                * Sets the current floor stack ({@link FloorStack}) of the map. The default floor of the stack will be set as the current floor.
                * @param floorStack The floor stack or floor stack ID to set.
                */
            setFloorStack(floorStack: FloorStack | string): void;
            /**
                * The current floor stack ({@link FloorStack}) of the map.
                */
            get currentFloorStack(): FloorStack;
            /**
                * The current floor ({@link Floor}) of the map.
                */
            get currentFloor(): Floor;
            /**
                * Updates the watermark on the map.
                *
                * @param options {WatermarkOptions}
                * @hidden
                */
            updateWatermark(options: WatermarkUpdateOptions): void;
            getState<T extends Space | Model | Text3DView | MapObject | Label | Marker | Image | Shape | Path | PathSegment | Floor | string>(target: T): TGetState<T>;
            setHoverColor(c: string): void;
            getHoverColor(): string | undefined;
            /**
                * @internal
                */
            convertAltitudeToMercatorZoomLevel(altitude: number): number;
            /**
                * @internal
                */
            convertMercatorZoomLevelToAltitude(zoomLevel: number): number;
            /**
                * Determines if a given target is within the viewport.
                *
                * This method checks if the specified target, such as a Space, MapObject, Label, Marker, or string identifier,
                * is currently within the visible area of the map viewport. Note that this method returns `true` even if the
                * target is not visible (e.g., its visibility is set to false).
                *
                * @param target - The target to check for viewport inclusion. This can be a Space, MapObject, Label, Marker, or string identifier.
                * @returns A boolean indicating whether the target is within the viewport.
                */
            isInView(target: Space | MapObject | Label | Marker | string): boolean;
            /**
                * Retrieves directions ({@link Directions}) from one navigable point ({@link TNavigationTarget}) to another on the map.
                *
                * @param from The starting point for navigation.
                * @param to The destination point.
                * @param options Optional parameters for getting directions.
                * @returns Directions from the start to the destination point.
                * @example
                * const directions = map.getDirections(space1, space2);
                */
            getDirections: (from: TNavigationTarget | TNavigationTarget[], to: TNavigationTarget | TNavigationTarget[], options?: TGetDirectionsOptions) => Directions | undefined;
            /**
                * Retrieves directions ({@link Directions}) from one navigable point ({@link TNavigationTarget}) to multiple destination points on the map.
                *
                * @param from The starting point for navigation.
                * @param to The destination points.
                * @param options Optional parameters for getting directions.
                * @returns Directions from the start to the destination points.
                */
            getDirectionsMultiDestination: (from: TNavigationTarget, to: (TNavigationTarget | TNavigationTarget[])[], options?: TGetDirectionsOptions) => Directions[] | undefined;
            /**
                * Retrieves the distance between two navigable points ({@link TNavigationTarget}) on the map.
                *
                * @param from The starting point.
                * @param to The destination point.
                * @returns The distance between the start and destination points in meters.
                */
            getDistance(from: Space | Door | Coordinate | MapObject | PointOfInterest | Annotation | Node | EnterpriseLocation, to: Space | Door | Coordinate | MapObject | PointOfInterest | Annotation | Node | EnterpriseLocation): number | undefined;
            /**
                * Creates a {@link Coordinate} on the map.
                *
                * @param latitude The latitude of the coordinate.
                * @param longitude The longitude of the coordinate.
                * @param floor Optional floor information if applicable.
                * @returns The created Coordinate object.
                * @example
                * // Create a coordinate at the CN Tower.
                * const coord = map.createCoordinate(43.642567, -79.387054);
                *
                * // Alternatively, you can directly use the Coordinate constructor:
                * import { Coordinate } from '@mappedin/mappedin-js';
                * const coord = new Coordinate(43.642567, -79.387054, floor?.id);
                */
            createCoordinate(latitude: number, longitude: number, floor?: Floor): Coordinate;
            /**
                * Creates a {@link Coordinate} on the map using a params object.
                *
                * @param params An object containing the coordinate parameters.
                * @param params.latitude The latitude of the coordinate in decimal degrees.
                * @param params.longitude The longitude of the coordinate in decimal degrees.
                * @param params.floorId Optional ID of the floor this coordinate is on.
                * @param params.verticalOffset Optional vertical offset from the floor in meters.
                * @returns The created Coordinate object.
                * @example
                * // Create a coordinate at the CN Tower using params object.
                * const coord = map.createCoordinate({
                *   latitude: 43.642567,
                *   longitude: -79.387054
                * });
                *
                * // Alternatively, you can directly use the Coordinate constructor:
                * import { Coordinate } from '@mappedin/mappedin-js';
                * const coord = new Coordinate({
                *   latitude: 43.642567,
                *   longitude: -79.387054,
                *   floorId: 'floor1',
                *   verticalOffset: 10
                * });
                */
            createCoordinate(params: TCoordinateParams): Coordinate;
            /**
                * Create a {@link Coordinate} from an X and Y position measured in pixels from the top left
                * corner of the map canvas.
                *
                * @experimental
                */
            createCoordinateFromScreenCoordinate(x: number, y: number, floor?: Floor): Coordinate | undefined;
            /**
                * Get the X and Y of a {@link Coordinate} measured from the top left corner of the map canvas.
                *
                * @experimental
                */
            getScreenCoordinateFromCoordinate(coordinate: Coordinate): {
                    x: number;
                    y: number;
            };
            /**
                * @hidden
                * @experimental
                */
            auto(): {
                    labels: Label[];
            };
            /**
                * Subscribe a function to an event.
                *
                * @param eventName An event name which, when fired, will call the provided
                * function.
                * @param fn A callback that gets called when the corresponding event is fired. The
                * callback will get passed an argument with a type that's one of event payloads.
                * @example
                * // Subscribe to the 'click' event
                * const handler = (event) => {
                *  const { coordinate } = event;
                *  const { latitude, longitude } = coordinate;
                * 	console.log(`Map was clicked at ${latitude}, ${longitude}`);
                * };
                * mapView.on('click', handler);
                */
            on: <EventName extends keyof TEvents>(eventName: EventName, fn: (payload: TEventPayload<EventName>) => void) => void;
            /**
                * Unsubscribe a function previously subscribed with {@link on}
                *
                * @param eventName An event name to which the provided function was previously
                * subscribed.
                * @param fn A function that was previously passed to {@link on}. The function must
                * have the same reference as the function that was subscribed.
                * @example
                * // Unsubscribe from the 'click' event
                * const handler = (event) => {
                *  const { coordinate } = event;
                *  const { latitude, longitude } = coordinate;
                * 	console.log(`Map was clicked at ${latitude}, ${longitude}`);
                * };
                * mapView.off('click', handler);
                */
            off: <EventName extends keyof TEvents>(eventName: EventName, fn: (payload: TEventPayload<EventName>) => void) => void;
            /**
                * @internal
                */
            get __core(): RendererCore;
            /**
                * Clears all added elements from the map.
                */
            clear(): void;
            /**
                * Destroys the MapView.
                */
            destroy(): void;
            /**
                * @experimental
                * Enable debug interface. Learn more about the debug interface in the [Debug Mode Guide](https://developer.mappedin.com/web-sdk/getting-started#debug-mode).
                */
            enableDebug(opitons?: InspectorOption): Promise<void>;
            /**
                * @experimental
                * @internal
                */
            Debug: Debug;
            /**
                * Takes a screenshot of the current scene and returns it as a data URL.
                *
                * NOTE: This only captures the 3D scene, not the UI elements like labels, markers, etc.
                * Also, this does not cause the screenshot to be saved to the user's device, it only returns
                * the data.
                * @returns A Promise that resolves with the screenshot as a base64-encoded data URL string
                * @experimental
                */
            takeScreenshot(): Promise<string>;
    }
}

declare module '@mappedin/mappedin-js/mappedin-js/src/api-geojson/text3d' {
    import { Space } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    import type { TAddText3DOptions } from '@mappedin/mappedin-js/mappedin-js/src/types';
    import type { CurrentMapGetter } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/types';
    import { Text3D as Text3DView } from '@mappedin/mappedin-js/mappedin-js/src/map-view-objects';
    export class Text3D {
            #private;
            /**
                * @internal
                */
            constructor({ currentMapGetter }: {
                    currentMapGetter: CurrentMapGetter;
            });
            /**
                * Creates polygon labels for all spaces.
                *
                * @param  options - Configuration options for text label creation
                * @returns  An array of Text3DView instances representing the created labels. If the space is already labeled, the designated Text3D instance will be returned.
                *
                * @example
                * ```typescript
                * const labels = mapView.Text3D.labelAll({
                *   // optional configuration options
                * });
                * ```
                */
            labelAll(options?: TAddText3DOptions): Text3DView[];
            /**
                * Creates a 3D text label for a given space.
                *
                * @param  target - The target space or enterprise space to label.
                * @param content - The content of the label. If not provided, target.name will be used
                * @param  options={} - Configuration options for the text label creation.
                * @returns  An array of Text3DView instances representing the created labels.
                *
                * @throws {Error} If the target is not a Space.
                *
                * @example
                * ```typescript
                * const labels = mapView.Text3D.label(space, "Label Content", { fontSize: 12 });
                * ```
                */
            label(target: Space, content?: string, options?: TAddText3DOptions): Text3DView | undefined;
            /**
                * Removes one or more Text3D labels from the map
                *
                * @param target - Can be either:
                * - A single Text3DView instance
                * - An array of Text3DView instances
                * - A string ID of the Text3DView to remove
                *
                * @example
                * ```typescript
                * // Remove single text label
                * mapView.Text3D.remove(text);
                *
                * // Remove multiple text labels
                * mapView.Text3D.remove([text, text]);
                *
                * // Remove by ID
                * mapView.Text3D.remove("text3d-123");
                * ```
                */
            remove(text3dView: Text3DView): void;
            remove(id: string): void;
            /**
                * Removes all Text3D labels from the current map
                *
                * @example
                * ```typescript
                * mapView.Text3D.removeAll();
                * ```
                */
            removeAll(): void;
    }
}

declare module '@mappedin/mappedin-js/geojson/src' {
    import type { MarkerState, AddMarkerOptions } from '@mappedin/mappedin-js/geojson/src/components/marker';
    import type { PathState, AddPathOptions } from '@mappedin/mappedin-js/geojson/src/components/path';
    import type { AddLabelOptions, LabelAppearance, LabelState } from '@mappedin/mappedin-js/geojson/src/components/label';
    import type { GroupContainerState } from '@mappedin/mappedin-js/geojson/src/entities/group-container';
    import type { GeometryGroupState } from '@mappedin/mappedin-js/geojson/src/entities/geometry-group';
    import type { Position } from '@mappedin/mappedin-js/geojson/src/types/geometry';
    import type { InsetPadding, InsetPaddingOption, RendererCoreOptions, ClickPayload, HoverPayload, CameraPayload, MapEvent, MapEventPayload, EnvMapOptions } from '@mappedin/mappedin-js/geojson/src/types';
    import type { GeometryState } from '@mappedin/mappedin-js/geojson/src/components/mesh';
    import type { ShapeState, CustomGeometryBuilder } from '@mappedin/mappedin-js/geojson/src/components/custom';
    import type { ModelState, UpdateModelState, InitializeModelState } from '@mappedin/mappedin-js/geojson/src/components/model';
    import RendererCore, { type MapViewState } from '@mappedin/mappedin-js/geojson/src/renderer';
    import type { Camera, AnimateToOptions, FocusOnOptions, EasingCurve } from '@mappedin/mappedin-js/geojson/src/camera';
    import { mountSceneGraphVisualizer } from '@mappedin/mappedin-js/geojson/examples/src/utils/scene-graph-visualizer';
    import '../../packages/outdoor-context-v4/css/maplibre-gl.css';
    import type { CollisionRankingTier } from '@mappedin/mappedin-js/geojson/src/utils/collision-ranking-tier';
    export type { Text3DState } from '@mappedin/mappedin-js/geojson/src/components/text3d';
    export { TEXT3D_STYLE_UPDATE_PROPS } from '@mappedin/mappedin-js/geojson/src/entities/utils';
    export { Navigator } from '@mappedin/mappedin-js/packages/geojson-navigator';
    export { interpolate, debounce } from '@mappedin/mappedin-js/geojson/src/utils';
    export { MAPPEDIN_LAYER_ID } from '@mappedin/mappedin-js/geojson/src/utils/constants';
    export type { DebugState, Debug } from '@mappedin/mappedin-js/geojson/src/utils/debug';
    /**
      * Enable test mode for the renderer. This will disable the WebGLRenderer and WebGL1Renderer and replace them with a dummy object
      * so you can run tests against it
      */
    export { enableTestMode } from '@mappedin/mappedin-js/geojson/src/services/test-mode';
    export { mountSceneGraphVisualizer };
    export type { EntityId, EntityState, LineStyle, PaintStyle, ModelProperties, Shading, ImagePlacementOptions, } from '@mappedin/mappedin-js/geojson/src/types';
    export type * from 'geojson';
    export type { WatermarkUpdateOptions, WatermarkOptions, WatermarkPosition } from '@mappedin/mappedin-js/geojson/src/systems/watermark/system';
    export { preloadFont } from '@mappedin/mappedin-js/geojson/src/systems/text3d/system';
    export type { GLTFExportOptions } from '@mappedin/mappedin-js/geojson/src/systems/exporter';
    export type { AttributionControlOptions, AttributionPosition } from '@mappedin/mappedin-js/geojson/src/systems/html-controls/system';
    export type { Text3DStyle, ModelStyle } from '@mappedin/mappedin-js/geojson/src/components/styles';
    export type { AddText3DOptions, InitializeText3DState, UpdatableText3DState } from '@mappedin/mappedin-js/geojson/src/components/text3d';
    export { ATTRIBUTION_POSITIONS } from '@mappedin/mappedin-js/geojson/src/systems/html-controls/system';
    export { ANIMATION_TWEENS } from '@mappedin/mappedin-js/geojson/src/camera';
    export type { AddPathOptions, AddMarkerOptions, AddLabelOptions, AnimateToOptions, FocusOnOptions, MapViewState, MarkerState, PathState, GroupContainerState, GeometryGroupState, ShapeState, CustomGeometryBuilder, LabelState, GeometryState, ModelState, UpdateModelState, InitializeModelState, EasingCurve, Camera, InsetPadding, InsetPaddingOption, Position, ClickPayload, HoverPayload, CameraPayload, MapEvent, MapEventPayload, CollisionRankingTier, LabelAppearance, RendererCore, EnvMapOptions, RendererCoreOptions, };
    export function createRenderer(container: HTMLElement, options?: RendererCoreOptions & {
        [key: string]: any;
    }): Promise<RendererCore>;
}

declare module '@mappedin/mappedin-js/mappedin-js/src/maplibre-overlay' {
    import { MapView } from '@mappedin/mappedin-js/mappedin-js/src/map-view';
    import type MapData from '@mappedin/mappedin-js/mappedin-js/src/map-data';
    import { type TShow3DMapOptions } from '@mappedin/mappedin-js/mappedin-js/src';
    import type { Position } from '@mappedin/core-sdk';
    import type { IControl } from '@packages/internal/outdoor-context-v4';
    import { PubSub } from '@packages/internal/common';
    export type TMappedinMapLibreOverlayEvents = {
            /**
                * Event emitted when the MappedinMap is loaded
                */
            loaded: {
                    /**
                        * MapView instance
                        */
                    mapView: MapView;
                    /**
                        * MapData instance
                        */
                    mapData: MapData;
            };
    };
    /**
        * Mappedin JS makes use of MapLibre to render the outdoor portion of the map. Mappedin JSexposes this layer through {@link MapView.OutoorMap} and can be used to add additional layers as described in the [Outdoor Map Guide](https://developer.mappedin.com/web-sdk/outdoor-map).
        *
        * It is also possible to utilize the opposite architecture, by adding a MapView to a MapLibre Map.
        * This is accomplished by using this MappedinMapLibreOverlay class. It allows a developer to easily add a Mappedin indoor map to an existing MapLibre based app.
        *
        * Use {@link createMapLibreOverlay} to instantiate this class.
        *
        * Refer to the [Mappedin MapLibre Overlay](https://developer.mappedin.com/web-sdk/mappedin-maplibre-overlay) for more information and interactive examples.
        */
    export class MappedinMapLibreOverlay extends PubSub<TMappedinMapLibreOverlayEvents> implements IControl {
            #private;
            static instance: MappedinMapLibreOverlay;
            /** @internal */
            constructor(origin: Position | undefined, mapData: MapData, options?: TShow3DMapOptions);
            /** @internal */
            onAdd(map: any): HTMLDivElement;
            /** @internal */
            onRemove(): void;
            /**
                * Subscribe to an event.
                * @example
                * ```ts
                * const handler = ({ mapView, mapData }) => {
                *  console.log('MapView loaded');
                * };
                * overlay.on('loaded', handler);
                * ```
                */
            on: <EventName extends keyof TMappedinMapLibreOverlayEvents>(eventName: EventName, fn: (payload: TMappedinMapLibreOverlayEvents[EventName] extends {
                    data: null;
            } ? TMappedinMapLibreOverlayEvents[EventName]["data"] : TMappedinMapLibreOverlayEvents[EventName]) => void) => void;
            /**
                * Unsubscribe from an event.
                * @example
                * ```ts
                * const handler = ({ mapView, mapData }) => {
                *  console.log('MapView loaded');
                * };
                * overlay.off('loaded', handler);
                * ```
                */
            off: <EventName extends keyof TMappedinMapLibreOverlayEvents>(eventName: EventName, fn: (payload: TMappedinMapLibreOverlayEvents[EventName] extends {
                    data: null;
            } ? TMappedinMapLibreOverlayEvents[EventName]["data"] : TMappedinMapLibreOverlayEvents[EventName]) => void) => void;
    }
}

declare module '@mappedin/mappedin-js/mappedin-js/src/types' {
    import type { Feature, MultiPolygon, Polygon } from 'geojson';
    import type { Coordinate, Floor, Door, Space, MapObject, PointOfInterest, Connection, EnterpriseLocation, Node, Area, Facade, FloorStack, Annotation, EnterpriseCategory, EnterpriseVenue, LocationCategory, LocationProfile } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    import type { Label, Marker, Model, Image, Shape, Text3D, Path } from '@mappedin/mappedin-js/mappedin-js/src/map-view-objects';
    import type { Language, ParsedMVFLocalePack } from '@mappedin/mvf';
    import type { InsetPaddingOption, UpdatableText3DState, Text3DState, AddText3DOptions, EnvMapOptions, InitializeModelState, ModelState, UpdateModelState as GeoJsonUpdateModelState, ImagePlacementOptions, LabelAppearance } from '@mappedin/mappedin-js/geojson/src';
    import type { PathSegment } from '@mappedin/mappedin-js/mappedin-js/src/map-view-objects/path';
    export type UpdateModelState = Omit<GeoJsonUpdateModelState, 'position' | 'scale'> & {
            position?: Coordinate;
            scale?: number | [number, number, number];
    };
    export type DeepRequired<T> = Required<{
            [K in keyof T]: T[K] extends Required<T[K]> ? T[K] : DeepRequired<T[K]>;
    }>;
    export type DeepPartial<T> = Partial<{
            [K in keyof T]: T[K] extends Partial<T[K]> ? DeepPartial<T[K]> : T[K];
    }>;
    export type CancellablePromise<T> = {
            promise: Promise<T>;
            cancel: () => void;
    };
    /**
        * @hidden
        */
    export type { GLTFExportOptions } from '@mappedin/core-sdk';
    /**
        * Represents an action within a direction instruction.
        */
    export type TDirectionInstructionAction = {
            /**
                * Type of action required at this step (e.g., 'Departure', 'Arrival', 'Turn').
                */
            type: 'Departure' | 'TakeConnection' | 'ExitConnection' | 'Turn' | 'Arrival';
            /**
                * Bearing direction for this action (e.g., 'Straight', 'Right', 'Left').
                */
            bearing?: 'Straight' | 'Right' | 'SlightRight' | 'Left' | 'SlightLeft';
            /**
                * A reference position for the action.
                *
                * @internal
                */
            referencePosition?: string;
            /**
                * The {@link Floor} from which this action starts.
                */
            fromFloor?: Floor;
            /**
                * The target {@link Floor}  for this action.
                */
            toFloor?: Floor;
            /**
                * Connection object related to the action.
                * This represents the specific connection (e.g., elevator, stairs) involved in the current direction step.
                */
            connection?: Connection;
            /**
                * The direction of the connection (e.g., 'up', 'down').
                */
            direction?: 'up' | 'down' | 'none';
            /**
                * The type of the connection (e.g., 'elevator', 'escalator').
                * @deprecated in favor of `connection.type`
                */
            connectionType?: string;
    };
    /**
        * Represents a single instruction in a set of directions between two points.
        */
    export type TDirectionInstruction = {
            /**
                * The action ({@link TDirectionInstructionAction}) to be taken for this instruction.
                */
            action: TDirectionInstructionAction;
            /**
                * Distance in meters covered in this instruction step.
                */
            distance: number;
            /**
                * The {@link Coordinate} at which this instruction applies.
                */
            coordinate: Coordinate;
            /**
                * @internal
                */
            node: Node;
    };
    /**
        * Defines the state for a label when its appearance is updated.
        */
    export type TLabelState = Omit<Required<TAddLabelOptions>, 'id'> & {
            text: string;
            type: 'label';
    };
    /**
        * Defines the state for a model
        */
    export type TModelState = {
            type: 'model';
    } & Omit<ModelState, 'position' | 'parent'> & {
            position: Coordinate;
    };
    /**
        * Defines the state for an image when its appearance is updated.
        */
    export type TImageState = {
            type: 'image';
    };
    export type TWallsState = {
            type: 'walls';
            /**
                * Color of the walls.
                */
            color: string | 'initial';
            /**
                * Color of the top of walls, if not set, defaults to the color.
                */
            topColor?: string | 'initial';
            /**
                * Texture to apply to the geometry element.
                */
            texture?: {
                    url?: string;
            };
            /**
                * Top texture to apply to the geometry element.
                */
            topTexture?: {
                    url?: string;
            };
            /**
                * Visibility of the walls.
                */
            visible: boolean;
            /**
                * Height of the walls.
                */
            height?: number;
            /**
                * Opacity of the walls.
                */
            opacity?: number;
    };
    export type TDoorsState = {
            type: 'doors';
            /**
                * Color of the doors.
                */
            color: string | 'initial';
            /**
                * Color of the top of doors, if not set, defaults to the color.
                */
            topColor?: string | 'initial';
            /**
                * Texture to apply to the geometry element.
                */
            texture?: {
                    url?: string;
            };
            /**
                * Top texture to apply to the geometry element.
                */
            topTexture?: {
                    url?: string;
            };
            /**
                * Visibility of the doors.
                */
            visible: boolean;
            /**
                * Opacity of the doors.
                */
            opacity: number;
    };
    export type TMarkerState = Omit<Required<TAddMarkerOptions>, 'id' | 'zIndex'> & {
            type: 'marker';
            /**
                * HTML element for the marker.
                */
            element: HTMLElement;
            /**
                * The z-index of the marker. Can be used used in conjunction with rank: 'always-visible' override the default distance from the camera based
                * sorting of markers and show certain markers always in front
                */
            zIndex?: number;
            /**
                * Whether the Marker is enabled.
                */
            enabled: boolean;
    };
    export type TPathState = {
            type: 'path';
            /**
                * The color of the path.
                */
            color: string;
    };
    /**
        * Represents the state of a shape.
        */
    export type TShapeState = {
            /**
                * The type of the shape.
                */
            type: 'Shape';
            /**
                * Whether Shape is visible
                */
            visible: boolean;
            /**
                * The altitude of the shape.
                */
            altitude: number;
            /**
                * The color of the shape.
                */
            color: string;
            /**
                * The height of the shape.
                * Height cannot be updated at this time
                */
            height: number;
            /**
                * The opacity of the shape.
                */
            opacity: number;
    };
    export type TFacadeState = {
            type: 'facade';
            /**
                * The opacity of the facade.
                */
            opacity: number;
    };
    /**
        * Defines the state for geometry elements like {@link Space} when updated.
        */
    export type TGeometryState = {
            type: 'geometry';
            /**
                * geometry gets rendered if true
                */
            visible: boolean;
            /**
                * Color of the geometry element. Color can be set using CSS colors names `DarkGoldenRod`, as Hex strings `#0000FF` or the rgb values `rgb(255,0,0)`.
                */
            color: string | 'initial';
            /**
                * Color of the geometry element's top. Color can be set using CSS colors names `DarkGoldenRod`, as Hex strings `#0000FF` or the rgb values `rgb(255,0,0)`.
                */
            topColor?: string | 'initial';
            /**
                * Color of the geometry element when hovered over. Color can be set using CSS colors names `DarkGoldenRod`, as Hex strings `#0000FF` or the rgb values `rgb(255,0,0)`.
                */
            hoverColor?: string | 'initial';
            /**
                * Indicates if the geometry element is interactive. Color can be set using CSS colors names `DarkGoldenRod`, as Hex strings `#0000FF` or the rgb values `rgb(255,0,0)`.
                */
            interactive: boolean;
            /**
                * Opacity of the geometry element.
                */
            opacity: number;
            /**
                * Height of the geometry element in meters.
                */
            height: number;
            /**
                * Texture to apply to the geometry element.
                */
            texture?: {
                    url: string;
            };
            /**
                * Top texture to apply to the geometry element.
                */
            topTexture?: {
                    url: string;
            };
            flipImageToFaceCamera?: boolean;
    };
    export type TFloorState = {
            type: 'floor';
            /**
                * State of the geometry on the floor.
                */
            geometry: {
                    /**
                        * Opacity of the floor geometry.
                        */
                    opacity: number;
            };
    };
    export enum WALLS {
            Exterior = "exterior-walls",
            Interior = "interior-walls"
    }
    export enum DOORS {
            Interior = "interior-doors",
            Exterior = "exterior-doors"
    }
    /**
        * The type for updating the state of map elements (colors, texts, etc.).
        */
    export type TUpdateState<T> = T extends WALLS ? Partial<TWallsState> : T extends DOORS | Door ? Partial<TDoorsState> : T extends Model ? Partial<UpdateModelState> : T extends Marker ? Partial<TMarkerState> : T extends Label ? Partial<TLabelState> : T extends Space | MapObject ? Partial<TGeometryState> : T extends Floor ? Partial<TFloorState> : T extends Facade ? Partial<TFacadeState> : T extends Shape ? Partial<Omit<TShapeState, 'height' | 'type'>> : T extends Text3D ? UpdatableText3DState : T extends Path ? Partial<TPathState> : T extends PathSegment ? Partial<TPathState> : T extends string ? Record<string, any> : never;
    export type TUpdateStates = Partial<Omit<TGeometryState, 'interactive' | 'hoverColor' | 'type'>> | Partial<TMarkerState> | Partial<TLabelState> | Partial<TGeometryState> | Partial<TPathState>;
    export type TGetState<T> = T extends WALLS ? TWallsState | undefined : T extends DOORS ? TDoorsState | undefined : T extends Marker ? TMarkerState | undefined : T extends Shape ? TShapeState | undefined : T extends Model ? TModelState | undefined : T extends Label ? TLabelState | undefined : T extends Image ? TImageState | undefined : T extends Text3D ? Text3DState | undefined : T extends Space | MapObject ? TGeometryState | undefined : T extends Floor ? TFloorState | undefined : T extends Facade ? TFacadeState | undefined : T extends Path ? TPathState | undefined : T extends PathSegment ? TPathState | undefined : T extends string ? TLabelState | TGeometryState | TMarkerState | TModelState | TPathState | undefined : never;
    /**
        * Options for {@link Camera} animations on the map.
        */
    export type TCameraAnimationOptions = {
            /**
                * Duration of the animation in milliseconds.
                */
            duration?: number;
            /**
                * Easing function to use for the animation.
                */
            easing?: TEasingFunction;
            /**
                * Whether the current animation will be interrupted, or must complete before starting any new animations
                * @default: true
                */
            interruptible?: boolean;
    };
    /**
        * Options for controlling animations on the map.
        */
    export type TAnimationOptions = {
            /**
                * Duration of the animation in milliseconds.
                * @default 1000
                */
            duration?: number;
            /**
                * Easing function to use for the animation.
                * @default 'ease-in-out'
                */
            easing?: TEasingFunction;
    };
    /**
        * Types of easing for animations.
        *
        * Linear: This function implies a constant rate of change. It means the animation proceeds at the same speed from start to end. There's no acceleration or deceleration, giving a very mechanical feel.
        *
        * Ease-in: This function causes the animation to start slowly and then speed up as it progresses. Initially, there's gradual acceleration, and as the function moves forward, the rate of change increases.
        *
        * Ease-out: Contrary to ease-in, ease-out makes the animation start quickly and then slow down towards the end. It begins with a faster rate of change and gradually decelerates.
        *
        * Ease-in-out: This function combines both ease-in and ease-out. The animation starts slowly, speeds up in the middle, and then slows down again towards the end. It offers a balance of acceleration and deceleration.
        *
        * @see https://developer.mozilla.org/en-US/docs/Web/CSS/animation-timing-function
        */
    export type TEasingFunction = 'linear' | 'ease-in' | 'ease-out' | 'ease-in-out';
    /**
        * Options for focusing the {@link Camera} on a target.
        */
    export type TFocusOnOptions = TCameraAnimationOptions & {
            /**
                * Minimum zoom level when focusing on a target in mercator zoom levels.
                *
                * @see https://wiki.openstreetmap.org/wiki/Zoom_levels
                */
            minZoomLevel?: number;
            /**
                * Maximum zoom level when focusing on a target in mercator zoom levels.
                *
                * @see https://wiki.openstreetmap.org/wiki/Zoom_levels
                */
            maxZoomLevel?: number;
            /**
                * Camera bearing when focusing on a target in degrees clockwise from North. 0 degrees is North, 90 degrees is East, 180 degrees is South, and 270 degrees is West.
                */
            bearing?: number;
            /**
                * Camera pitch when focusing on a target, in degrees.
                */
            pitch?: number;
            /**
                * Axis aligned padding to add to the bounding box in meters.
                */
            axisAlignedPadding?: {
                    /**
                        * Vertical padding to add to the bounding box in meters along the elevation axis.
                        */
                    vertical?: number;
            };
            screenOffsets?: InsetPaddingOption;
            /**
                * Whether the current animation will be interrupted, or must complete before starting any new animations
                * @default: true
                */
            interruptible?: boolean;
    };
    /**
        * Defines the target for camera operations.
        */
    export type TCameraTarget = {
            /**
                * Center {@link Coordinate} for the camera target.
                */
            center?: Coordinate;
            /**
                * Zoom level for the camera target in mercator zoom levels.
                *
                * @see https://wiki.openstreetmap.org/wiki/Zoom_levels
                */
            zoomLevel?: number;
            /**
                * Bearing for the camera target in degrees clockwise from North. 0 degrees is North, 90 degrees is East, 180 degrees is South, and 270 degrees is West.
                */
            bearing?: number;
            /**
                * Pitch for the camera target in degrees.
                */
            pitch?: number;
    };
    /**
        * Defines the target for navigation operations.
        */
    export type TNavigationTarget = LocationProfile | Annotation | Space | MapObject | Coordinate | Door | PointOfInterest | Connection | EnterpriseLocation | Node | Area | Facade;
    /**
        * Defines the special zone for navigation operations.
        */
    export type TDirectionZone = {
            /**
                * The zone geometry.
                */
            geometry: Feature<MultiPolygon | Polygon>;
            /**
                * The additional cost for navigation through the zone, from 0 to Infinity.
                * The final cost is calculated as the sum of basic cost that comes from the {@link MapData}
                * and the additional zone cost.
                * A additional zone cost of 0 will make the zone free to navigate through
                * A additional zone cost of Infinity will make the zone impossible to navigate through
                */
            cost: number;
            /**
                * The zone's floor, defaults to the all floors if not provided.
                */
            floor?: Floor;
    };
    /**
        * Options for controlling the behavior of a {@link Path}.
        */
    export type TAddPathOptions = {
            /**
                * Path Colour. Color can be set using CSS colors names `DarkGoldenRod`, as Hex strings `#0000FF` or the rgb values `rgb(255,0,0)`.
                *
                * @defaultValue #4b90e2
                */
            color?: string;
            /**
                * Accent color that is applied to the path pulse and path arrows
                *
                * @defaultValue '#ffffff'
                */
            accentColor?: string;
            /**
                * Number of iterations to pulse to indicate direction.
                *
                * @defaultValue 1
                */
            pulseIterations?: number;
            /**
                * How many milliseconds to wait before starting the next pulse after the current pulse travels the entirety of the path.
                *
                * @defaultValue 750
                */
            pulsePauseDuration?: number;
            /**
                * Radius of path at nearest zoom, in metres.
                *
                * @defaultValue 0.2
                */
            nearRadius?: number;
            /**
                * Radius of path at furthest zoom, in metres.
                *
                * @defaultValue 0.4
                */
            farRadius?: number;
            /**
                * The zoom level at which the path should be at its near radius. This will default to the Camera maxZoomLevel.
                */
            nearZoomLevel?: number;
            /**
                * The zoom level at which the path should be at its far radius. This will default to the Camera minZoomLevel.
                */
            farZoomLevel?: number;
            /**
                * Duration of path drawing in milliseconds.
                *
                * @defaultValue 1500
                */
            drawDuration?: number;
            /**
                * Show arrows on path.
                *
                * @defaultValue false
                */
            displayArrowsOnPath?: boolean;
            /**
                * Animate arrows on path.
                *
                * @defaultValue true
                */
            animateArrowsOnPath?: boolean;
            /**
                * Flatten the path to a 2D line.
                *
                * @defaultValue false
                */
            flattenPath?: boolean;
            /**
                * Show an animated pulse indicating the direction of travel.
                *
                * @defaultValue true
                */
            showPulse?: boolean;
            /**
                * Animate the drawing of the path in the direction of travel.
                *
                * @defaultValue true
                */
            animateDrawing?: boolean;
            /**
                * Whether the path should be clickable.
                *
                * @defaultValue false
                */
            interactive?: boolean;
            /**
                * The path will be adjusted vertically to the tallest altitude along the path.
                * The altitude is in meters.
                *
                * @defaultValue false
                */
            adjustedAltitude?: boolean;
            /**
                * The maximum altitude of the path in meters.
                * The altitude is in meters.
                *
                * @defaultValue Infinite
                */
            maxAdjustedAltitude?: number;
            /**
                * The minimum altitude of the path in meters.
                * The altitude is in meters.
                *
                * @defaultValue -Infinite
                */
            minAdjustedAltitude?: number;
    };
    /**
        * Control how a {@link Label} looks
        * @interface
        */
    export type TLabelAppearance = LabelAppearance;
    /**
        * Defines the priority levels for collider collision handling, allowing customization of collider visibility in congested areas.
        *
        * | Value  | Description                                                                                                                             |
        * |--------|-----------------------------------------------------------------------------------------------------------------------------------------|
        * | low    | Colliders with this ranking have a low visibility priority and will be hidden in favor of higher-ranked colliders in crowded areas.     |
        * | medium | Colliders with this ranking have a standard visibility priority and may be hidden in favor of higher-ranked colliders in crowded areas. |
        * | high   | These colliders are given higher visibility priority than 'medium' priority.                                                            |
        * | always-visible | Colliders with this ranking will not be hidden, ensuring their constant visibility regardless of crowding. |
        *
        * Use this type to fine-tune the visibility of colliders, enhancing map readability and user experience by prioritizing important information.
        */
    export type TCollisionRankingTier = 'low' | 'medium' | 'high' | 'always-visible';
    /**
        * Defines the anchor point for a Marker, offering a selection of intuitive string options to pinpoint where the marker should be anchored. Choose from:
        *
        * | Value    | Description                                                                   |
        * |----------|-------------------------------------------------------------------------------|
        * | 'center' | Anchors the marker at its center, offering a balanced and centered appearance.|
        * | 'top'    | Anchors the marker at the top, ideal for marking locations from above.        |
        * | 'left'   | Anchors the marker on the left side, useful for when space is limited on the right.|
        * | 'bottom' | Anchors the marker at the bottom, suitable for hanging markers or when space is limited above.|
        * | 'top-left'  | Anchors the marker at the top-left corner. |
        * | 'top-right'  | Anchors the marker at the top-right corner. |
        * | 'bottom-left'  | Anchors the marker at the bottom-left corner. |
        * | 'bottom-right'  | Anchors the marker at the bottom-right corner. |
        *
        */
    export type TMarkerAnchor = 'center' | 'top' | 'left' | 'bottom' | 'right' | 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';
    /**
        * Options for controlling the behavior of the {@link Directions}.
        */
    export type TGetDirectionsOptions = {
            /**
                * If true directions will only take accessible routes
                *
                * @default false
                */
            accessible?: boolean;
            /**
                * Enable or disable line-of-sight directions smoothing.
                * With this option enabled, the directions will be simplified to provide a more visually appealing path and shorter instructions.
                *
                * Can be a boolean to enable or disable smoothing, or an object with a radius property to specify the line of sight radius in metres.
                *
                * @default true
                *
                * @example
                * ```ts
                * // Enable smoothing with a radius of 3 metres
                * mapView.getDirections(firstSpace, secondSpace, {
                * 	 smoothing: {
                *     radius: 3,
                *   }
                * })
                * ```
                */
            smoothing?: boolean | {
                    enabled?: boolean;
                    radius: number;
            };
            /**
                * Defines the special zones for navigation operations.
                *
                * @example
                * ```ts
                * mapView.getDirections(firstSpace, secondSpace, {
                *   zones: [
                *     {
                *       geometry: polygon as Feature<Polygon>,
                *       // The additional cost for navigation through the zone, from 0 to Infinity.
                *       // The final cost is calculated as the sum of basic cost that comes from the {@MapData}
                *       // and the additional zone cost.
                *       // A additional cost of 0 will make the zone free to navigate through
                *       // A additional cost of Infinity will make the zone impossible to navigate through
                *       cost: Infinity,
                *       floor: mapView.currentFloor,
                *     },
                *   ],
                * });
                * ```
                */
            zones?: TDirectionZone[];
            /**
                * @experimental
                * Enterprise only. Connections that should not be used for directions.
                *
                * If a connection is excluded, it will not be used in the directions even if it is the shortest (or only) path.
                * If there is no path that does not include the these connections, the directions will be undefined.
                */
            excludedConnections?: Connection[];
    };
    /**
        * The target for the add model operation.
        */
    export type TAddModel = {
            /**
                * The target for the model to be placed on.
                */
            target: IAnchorable;
            /**
                * Optional. Determines the opacity of the model.
                * @default 1
                */
            opacity?: number;
            /**
                * Optional. Determines the rotation of the model, in degrees.
                * @default [0, 0, 0]
                */
            rotation?: [number, number, number];
            /**
                * Optional. Determines the scale of the model. Can be a single number to scale uniformly in all dimensions,
                * or an array of three numbers [x, y, z] to scale differently in each dimension.
                * @default [1, 1, 1]
                */
            scale?: number | [number, number, number];
            /**
                * Whether the Model should be clickable
                * @default false
                */
            interactive?: boolean;
            /**
                * Vertical offset of the model in meters.
                */
            verticalOffset?: number;
    };
    /**
        * Options for controlling the behavior of a {@link Model}.
        */
    export type TAddModelOptions = Omit<InitializeModelState, 'scale' | 'url'> & {
            scale?: number | [number, number, number];
    };
    /**
        * @interface
        */
    export type TAddText3DOptions = AddText3DOptions;
    /**
        * Options for controlling the behavior of an {@link Image}.
        */
    export type TAddImageOptions = {
            /**
                * @internal
                */
            id?: string;
            /**
                * Width of the image in meters.
                */
            width: number;
            /**
                * Height of the image in meters.
                */
            height: number;
            /**
                * Rotation of the image in degrees clockwise from North. 0 degrees is North, 90 degrees is East, 180 degrees is South, and 270 degrees is West.
                *
                * @default 0
                */
            rotation?: number;
            /**
                * Vertical offset of the image in meters.
                *
                * @default 0
                */
            verticalOffset?: number;
            /**
                * Attempt to keep the image facing the camera as much as possible
                *
                * @default false
                */
            flipImageToFaceCamera?: boolean;
    };
    /**
        * Options for controlling the behavior of a {@link Marker}.
        */
    export type TAddMarkerOptions = {
            /**
                * Optional. Determines the collision ranking tier of the marker, which influences its visibility in relation to other colliders.
                * For the possible values ('medium', 'high', 'always-visible') and their impact on label visibility, see {@link TCollisionRankingTier}.
                */
            rank?: TCollisionRankingTier | 'initial';
            /**
                * Optional. Specifies the anchor point of the marker, determining its position relative to its coordinates.
                * If a list is provided, the marker will be anchored to the first anchor point that is available.
                *
                * The active anchor will be exposed as a DOM attribute `data-anchor` on the marker element.
                *
                * For the possible values and their descriptions, see {@link TMarkerAnchor}.
                */
            anchor?: TMarkerAnchor | TMarkerAnchor[];
            /**
                * Whether the {@link Marker} should be clickable.
                * If `true` the marker will be registered in the SDK interaction events.
                * If `'pointer-events-auto'` the marker will receive browser pointer events.
                * @default false
                */
            interactive?: boolean | 'pointer-events-auto';
            /**
                * @internal
                */
            id?: string;
            /**
                * Dynamic resize of the marker. If set to true, the marker will resize based on the content.
                */
            dynamicResize?: boolean;
            /**
                * Whether the marker is enabled.
                */
            enabled?: boolean;
            /**
                * The z-index of the marker. Can be used used in conjunction with rank: 'always-visible' override the default distance from the camera based
                * sorting of markers and show certain markers always in front
                */
            zIndex?: number;
    };
    /**
        * Options for creating a new {@link Label} with {@link Labels.add}.
        */
    export type TAddLabelOptions = {
            /**
                * Optional. Determines the collision ranking tier of the label, which influences its visibility in relation to other colliders.
                * For the possible values ('medium', 'high', 'always-visible') and their impact on label visibility, see {@link TCollisionRankingTier}.
                */
            rank?: TCollisionRankingTier | 'initial';
            /**
                * Customize the appearance of the {@link Label} and its pin
                */
            appearance?: TLabelAppearance;
            /**
                * Whether the Label should be clickable.
                * @default false
                */
            interactive?: boolean;
            /**
                * @internal
                */
            id?: string;
            /**
                * Whether the label is enabled.
                */
            enabled?: boolean;
    };
    export type TBlueDotOptions = {
            /**
                * The radius of the BlueDot in pixels. The BlueDot will maintain this size clamped to a minimum of 0.35 metres.
                * @default 10
                */
            radius?: number;
            /**
                * The color of the BlueDot core element.
                * @default #2266ff
                */
            color?: string;
            /**
                * The color of the BlueDot when it has timed out and gone inactive.
                * @default #808080
                */
            inactiveColor?: string;
            /**
                * Options for the accuracy ring around the BlueDot.
                */
            accuracyRing?: {
                    /**
                        * The color of the accuracy ring.
                        * @default #2266ff
                        */
                    color?: string;
                    /**
                        * The opacity of the accuracy ring.
                        * @default 0.3
                        */
                    opacity?: number;
            };
            /**
                * Options for the heading directional indicator.
                */
            heading?: {
                    /**
                        * The color of the heading cone.
                        * @default #2266ff
                        */
                    color?: string;
                    /**
                        * The opacity of the heading cone.
                        * @default 0.7
                        */
                    opacity?: number;
            };
            /**
                * The duration of the timeout in milliseconds.
                * If the BlueDot does not receive a position update within this time, it will grey out until a position is received.
                * @default 30000
                */
            timeout?: number;
            /**
                * Whether to watch the device's position.
                * @default true
                */
            watchDevicePosition?: boolean;
            /**
                * Whether to log debug messages.
                * @default false
                */
            debug?: boolean;
    };
    /**
        * Position update options for the {@link BlueDot.update} method.
        */
    export type TBlueDotPositionUpdate = {
            /**
                * Latitude to override.
                * Set to `'device'` to reset to the device's latitude.
                */
            latitude?: GeolocationPosition['coords']['latitude'] | 'device' | undefined;
            /**
                * Longitude to override.
                * Set to `'device'` to reset to the device's longitude.
                */
            longitude?: GeolocationPosition['coords']['longitude'] | 'device' | undefined;
            /**
                * Accuracy to override.
                * Set to `'device'` to reset to the device's accuracy.
                * Set to `undefined` to disable the accuracy ring.
                */
            accuracy?: GeolocationPosition['coords']['accuracy'] | 'device' | undefined;
            /**
                * Heading to override.
                * Set to `'device'` to reset to the device's heading.
                * Set to `undefined` to disable the heading indicator.
                */
            heading?: GeolocationPosition['coords']['heading'] | 'device' | undefined;
            /**
                * Floor or floorId to override.
                * Set to `'device'` to reset to the device's floor level.
                * Set to `undefined` to disable floor level and show the BlueDot on all floors.
                */
            floorOrFloorId?: Floor | string | 'device' | undefined;
    };
    export type LanguagePackHydrationItem = {
            language: Language;
            localePack: ParsedMVFLocalePack;
    };
    export type GlobalState = {
            /**
                * The color of the background, in hex format(#000000).
                */
            backgroundColor: string;
            /**
                * The alpha value of the background, between 0 and 1.
                * @default 1
                */
            backgroundAlpha: number;
            /**
                * environment map for reflections.
                * @default 'basic'
                */
            environment: EnvMapOptions;
            text3d: {
                    /**
                        * hover color of the text3d
                        */
                    hoverColor: string;
            };
            geometry: {
                    /**
                        * hover color of the geometries
                        */
                    hoverColor: string;
            };
    };
    export type UpdateGlobalState = DeepPartial<GlobalState>;
    /**
        * A map element that can be focused on by the camera.
        */
    export type TFocusTarget = Coordinate | Space | Area | MapObject | Floor | Shape;
    /**
        * A class that implements IFocusable can be focused on by the camera.
        */
    export interface IFocusable {
            get focusTarget(): TFocusTarget | TFocusTarget[];
    }
    export interface INavigatable {
            get navigationTarget(): TNavigationTarget | TNavigationTarget[];
    }
    /**
        * A class that implements IAnchorable can have 2D elements like {@link Label}s and {@link Marker}s anchored to it.
        */
    export interface IAnchorable {
            get anchorTarget(): Coordinate;
    }
    /**
        * Associates MapData type strings with their corresponding classes.
        */
    export type TMapDataObjectTypes = {
            'location-profile': LocationProfile;
            'location-category': LocationCategory;
            node: Node;
            space: Space;
            door: Door;
            floor: Floor;
            'floor-stack': FloorStack;
            connection: Connection;
            object: MapObject;
            'point-of-interest': PointOfInterest;
            annotation: Annotation;
            'enterprise-location': EnterpriseLocation;
            'enterprise-category': EnterpriseCategory;
            'enterprise-venue': EnterpriseVenue;
            area: Area;
            facade: Facade;
    };
    /**
        * @interface
        * @internal
        */
    export type TImagePlacementOptions = ImagePlacementOptions;
    export type TCameraInteractionsSetOptions = {
            /**
                * Whether to enable panning.
                */
            pan?: boolean;
            /**
                * Whether to enable zooming.
                */
            zoom?: boolean;
            /**
                * Whether to enable bearing and pitch.
                */
            bearingAndPitch?: boolean;
    };
}

declare module '@mappedin/mappedin-js/mappedin-js/src/constants' {
    export const FLOOR_HEIGHT = 10;
    /**
      * Default map options used if no custom options are provided.
      *
      * @internal
      */
    export const DEFAULT_MAP_OPTIONS: {
        auto: true;
        debug: false;
        pitch: number;
        bearing: number;
        antialiasing: {
            enabled: true;
        };
        shadingAndOutlines: true;
        outdoorView: {
            layersHiddenByGeometry: string[];
        };
        imagePlacementOptions: {
            mode: "default";
        };
        flipImagesToFaceCamera: true;
        multiFloorView: {
            enabled: false;
            floorHeight: number;
        };
    };
    export const EXTERIOR_WALLS_ID = "ExteriorWalls";
    export const WALLS_ID = "Walls";
    export const ADD_MAP_FOCUS_ON_DURATION = 0;
    export const INTERIOR_DOORS_ID = "InteriorDoors";
    export const EXTERIOR_DOORS_ID = "ExteriorDoors";
    export const GEOMETRY_LAYER = "GeometryLayer";
    export const LABELS_LAYER = "LabelsLayer";
    export const MARKERS_LAYER = "MarkersLayer";
    export const FOOTPRINT_LAYER = "FootprintLayer";
    export const OCCLUSION_LAYER = "OcclusionLayer";
    export const IMAGES_LAYER = "ImagesLayer";
    export const FACADES_LAYER = "FacadesLayer";
    export const SELF_SERVE_API_AUDIENCE: string[];
    export const ENTERPRISE_API_AUDIENCE: string[];
    export const MAPPEDIN_COLORS: {
        orange: string;
        teal: string;
        lightTeal: string;
    };
}

declare module '@mappedin/mappedin-js/mappedin-js/src/api-geojson/blue-dot/blue-dot' {
    import type { EasingCurve, RendererCore } from '@mappedin/core-sdk';
    import { PubSub } from '@packages/internal/common';
    import { Coordinate, type Floor } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    import type { TBlueDotOptions, TBlueDotPositionUpdate } from '@mappedin/mappedin-js/mappedin-js/src/types';
    import type { GeoJsonApi } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/api';
    export const GEOMETRY_ID = "blue-dot";
    export type TBlueDotEvents = {
            /**
                * Emitted when the Blue Dot's position is updated.
                */
            'position-update': {
                    floor: Floor | undefined;
                    heading: GeolocationPosition['coords']['heading'] | undefined;
                    accuracy: GeolocationPosition['coords']['accuracy'] | undefined;
                    coordinate: Coordinate;
            };
            /**
                * Emitted when the Blue Dot's state changes.
                */
            'state-change': {
                    /**
                        * The new state of the Blue Dot.
                        */
                    state: TBlueDotState;
                    /**
                        * The action that caused the state change.
                        */
                    action: TBlueDotAction;
            };
            /**
                * Emitted when the Blue Dot encounters an error.
                */
            error: GeolocationPositionError;
            /**
                * Emitted when the Blue Dot's following state changes.
                */
            'follow-change': {
                    /**
                        * Whether the Blue Dot is following the user.
                        */
                    following: boolean;
                    /**
                        * The mode the Blue Dot is following the user in.
                        */
                    mode?: TFollowMode;
            };
    };
    export type TBlueDotState = 'hidden' | 'active' | 'inactive' | 'disabled';
    export type TBlueDotAction = 'timeout' | 'error' | 'position-update' | 'enable' | 'disable';
    export type TBlueDotPositionUpdateWithFloor = Omit<TBlueDotPositionUpdate, 'floorOrFloorId'> & {
            floor?: Floor | 'device' | undefined;
    };
    /**
        * @experimental
        *
        * Mappedin JS can use the location provided from an indoor positioning system to display a BlueDot on the map, indicating the user's position.
        *
        * This class is accessed using {@link MapView.BlueDot}.
        *
        * Further details and interactive examples can be found in the [BlueDot Guide](https://developer.mappedin.com/web-sdk/blue-dot).
        */
    export class BlueDot extends PubSub<TBlueDotEvents> {
            #private;
            state: TBlueDotState;
            following: boolean;
            /**
                * The direction the user is facing in degrees from north clockwise.
                * @see https://developer.mozilla.org/en-US/docs/Web/API/GeolocationCoordinates/heading
                */
            get heading(): GeolocationPosition['coords']['heading'] | undefined;
            /**
                * The accuracy of the current position in metres.
                */
            get accuracy(): GeolocationPosition['coords']['accuracy'] | undefined;
            /**
                * The coordinate of the current position.
                */
            get coordinate(): Coordinate | undefined;
            /**
                * The floor the Blue Dot is currently on. If undefined, the Blue Dot will appear on every floor.
                */
            get floor(): Floor | undefined;
            /**
                * @internal
                */
            constructor(core: RendererCore, geoJSONApi: GeoJsonApi);
            /**
                * Enable the Blue Dot. It will be hidden until a position is received either from the browser or by calling {@link BlueDot.update}.
                * @param options - The options to setup the Blue Dot.
                */
            enable(options?: TBlueDotOptions): void;
            /**
                * Disable the Blue Dot. It will be hidden and no longer update.
                */
            disable(): void;
            /**
                * Enable or disable the devices's geolocation listener to automatically position the Blue Dot.
                * If enabled, the device will request permission to access the user's precise location.
                * @param watch - Whether to enable or disable the listener.
                */
            watchDevicePosition(watch: boolean): void;
            /**
                * Manually override some position properties of the Blue Dot.
                * Accepts a full GeolocationPosition object or a partial {@link TBlueDotPositionUpdate} object.
                * @example Manually set the accuracy and heading
                * ```ts
                * api.BlueDot.update({ accuracy: 10, heading: 90 });
                * ```
                * @example Reset accuracy and heading to device values
                * ```ts
                * api.BlueDot.update({ accuracy: 'device', heading: 'device' });
                * ```
                */
            update(position: GeolocationPositionExtended | TBlueDotPositionUpdate | undefined): void;
            /**
                * Sets the camera to follow the Blue Dot's position as it updates. User interaction will cancel following automatically.
                */
            follow: (mode: TFollowMode, cameraOptions?: TFollowCameraOptions) => void;
    }
    export type TFollowMode = 
    /** Camera position follows the Blue Dot's position. */
    'position-only'
    /** Camera position follows the Blue Dot's position. Camera bearing matches the Blue Dot's heading. */
     | 'position-and-heading'
    /** Camera position follows the Blue Dot's position. Camera bearing is calculated based on the Navigation path. */
     | 'position-and-path-direction'
    /** Disables follow mode */
     | false;
    export type TFollowCameraOptions = {
            /**
                * @default 21
                */
            zoomLevel?: number;
            /**
                * @default 45
                */
            pitch?: number;
            /**
                * Camera bearing in degrees clockwise from North. 0 is North, 90 is East, 180 is South, 270 is West.
                * This option is only available in 'position-only' mode. In all other modes, the bearing will be calculated automatically.
                * @default undefined
                */
            bearing?: number;
            /**
                * @default undefined
                */
            elevation?: number;
            /**
                * @default 1000
                */
            duration?: number;
            /**
                * @default 'ease-in-out'
                */
            easing?: EasingCurve;
    };
    type TStateTransitions = {
            [Action in TBlueDotAction]?: TBlueDotState;
    };
    type TStateMachine = {
            [State in TBlueDotState]: {
                    actions: TStateTransitions;
            };
    };
    export const stateMachine: TStateMachine;
    export type GeolocationPositionExtended = GeolocationPosition & {
            coords: GeolocationPosition['coords'] & {
                    readonly floorLevel?: number;
            };
    };
    export {};
}

declare module '@mappedin/mappedin-js/mappedin-js/src/api-geojson/stacked-maps/stacked-maps' {
    import type { GeojsonApiMapObject } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/map-object';
    import { PubSub } from '@packages/internal/common';
    import { type Floor } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    import { type TCameraAnimationOptions } from '@mappedin/mappedin-js/mappedin-js/src';
    export const GAP_BELOW_FLOORS = 50;
    export const DEBUG = false;
    export const DURATION = 1000;
    export type TStackedMapsState = 
    /**
        * Expands the floor stack.
        */
    'expanded'
    /**
        * Collapses the floor stack.
        */
     | 'collapsed';
    export type TStackedMapsEvents = {
            'stacked-maps-state-change': {
                    state: TStackedMapsState;
            };
    };
    export type TExpandOptions = TCameraAnimationOptions & {
            /**
                * The floors to include in the stack.
                */
            includedFloors?: Floor[];
            /**
                * The distance between floors in the stack in meters.
                * - When set to 'auto', the system automatically calculates the optimal distance
                *   needed to visually separate first two floors in the current view.
                * - When set to a numeric value, that exact distance in meters is used between each floor.
                * @default 50
                *
                * @example
                * // Use automatic distance calculation
                * await mapView.StackedMaps.expand({ distanceBetweenFloors: 'auto' });
                * console.log(mapView.distanceBetweenFloors) // output: computed value
                *
                * // Use fixed distance of 75 meters between floors
                * mapView.StackedMaps.expand({ distanceBetweenFloors: 75 });
                * console.log(mapView.distanceBetweenFloors) // output: 75 as specified
                */
            distanceBetweenFloors?: number | 'auto';
            /**
                * The pan mode to use when animating the camera.
                * @default 'elevation'
                */
            cameraPanMode?: 'default' | 'elevation';
            /**
                * Whether to change the floor on elevation changes.
                * @default true
                */
            changeFloorOnElevationChanges?: boolean;
    };
    export type TCollapseOptions = TCameraAnimationOptions;
    type CurrentMapGetter = () => GeojsonApiMapObject | undefined;
    /**
        * Stacked Maps enables multi floor visualization. It allows for multiple floors of a building to be shown together as a stack of floors in an accordion style view.
        *
        * This class is accessed using {@link MapView.StackedMaps}.
        *
        * Refer to the [Stacked Maps Guide](https://developer.mappedin.com/web-sdk/stacked-maps) for more information and interactive examples.
        *
        * @experimental
        */
    export class StackedMaps extends PubSub<TStackedMapsEvents> {
            #private;
            get state(): TStackedMapsState;
            /**
                * @internal
                */
            constructor({ currentMapGetter }: {
                    currentMapGetter: CurrentMapGetter;
            });
            /**
                * Whether the floor stack is expanded.
                */
            get expanded(): boolean;
            /**
                * Gets the distance between floors in meters.
                *
                * This property returns different values based on how the `expand()` method was called:
                *
                * - When `expand()` was called with `distanceBetweenFloors: 'auto'`, this returns the computed
                *   value needed to visually separate the first two floors in clip space.
                * - When `expand()` was called with a numeric value (e.g., `distanceBetweenFloors: 50`),
                *   this returns that specified value.
    
                     * This value is cached for performance until `clearCachedFloorSeparationDistance()` is called
                     * to force a recalculation.
                *
                * @example
                * // Using automatic floor separation distance
                * await mapView.StackedMaps.expand({ distanceBetweenFloors: 'auto' });
                * console.log(mapView.StackedMaps.distanceBetweenFloors); // Returns computed separation value
                *
                * // Using fixed floor separation distance
                * await mapView.StackedMaps.expand({ distanceBetweenFloors: 50 });
                * console.log(mapView.StackedMaps.distanceBetweenFloors); // Returns 50
                */
            get distanceBetweenFloors(): number;
            /**
                * Clears the cached value for the computed distance between floors.
                *
                * Call this method to invalidate the calculation of the optimal distance between floors
                * when using `distanceBetweenFloors: 'auto'` option with the expand() method. This is useful
                * when the camera position or viewport has changed significantly, which may affect the optimal
                * floor separation distance.
                *
                * @example
                * // Force recalculation before expanding with auto distance
                * mapView.StackedMaps.clearCachedFloorSeparationDistance();
                * await mapView.StackedMaps.expand({ distanceBetweenFloors: 'auto' });
                */
            clearCachedFloorSeparationDistance(): void;
            /**
                * The factor of the expanded floor stack. 0 is collapsed, 1 is fully expanded.
                */
            expandedFactor: number;
            /**
                * The floors included in the stack.
                */
            get includedFloors(): Floor[];
            /**
                * The visibility mode for the stacked maps. 'all-floors' will show all floors, 'only-current-floor' will only show the current floor in the stack.
                * @default 'all-floors'
                */
            get floorVisibilityMode(): "all-floors" | "only-current-floor";
            /**
                * Set the visibility mode for the stacked maps.
                * @param mode The visibility mode to set. Either `all-floors` or `only-current-floor`.
                */
            setFloorVisiblityMode(mode: 'all-floors' | 'only-current-floor'): void;
            /**
                * Set whether to listen to camera elevation changes to automatically change the floor. When enabled, the `mapView.on('floor-change')` event is fired
                */
            changeFloorOnElevationChanges(value: boolean): void;
            /**
                * Expand the floor stack.
                * @param opts Optional settings for the expansion.
                */
            expand(opts?: TExpandOptions): Promise<void>;
            /**
                * Collapse the floor stack.
                * @param opts Optional settings for the collapse.
                */
            collapse(opts?: TCollapseOptions): Promise<void>;
            destroy(): void;
    }
    export {};
}

declare module '@mappedin/mappedin-js/mappedin-js/src/map-view-objects' {
    export { Label } from '@mappedin/mappedin-js/mappedin-js/src/map-view-objects/label';
    export { Marker } from '@mappedin/mappedin-js/mappedin-js/src/map-view-objects/marker';
    export { Image } from '@mappedin/mappedin-js/mappedin-js/src/map-view-objects/image';
    export { Model } from '@mappedin/mappedin-js/mappedin-js/src/map-view-objects/model';
    export { Path, PathSegment } from '@mappedin/mappedin-js/mappedin-js/src/map-view-objects/path';
    export { CameraTransform } from '@mappedin/mappedin-js/mappedin-js/src/map-view-objects/camera-transform';
    export { Shape } from '@mappedin/mappedin-js/mappedin-js/src/map-view-objects/shape';
    export { Text3D } from '@mappedin/mappedin-js/mappedin-js/src/map-view-objects/text3d';
}

declare module '@mappedin/mappedin-js/mappedin-js/src/debug' {
    import type { RendererCore } from '@mappedin/core-sdk';
    export class Debug {
        state: RendererCore['Debug']['state'];
        constructor(core: RendererCore);
        update: RendererCore['Debug']['update'];
    }
}

declare module '@mappedin/mappedin-js/mappedin-js/src/navigation' {
    import { type TDirectionInstruction } from '@mappedin/mappedin-js/mappedin-js/src';
    import type { Directions, GeoJsonApi } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson';
    import type { GeojsonApiMapObject } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/map-object';
    import type { Floor, FloorStack } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    import { Path, Marker } from '@mappedin/mappedin-js/mappedin-js/src/map-view-objects';
    import type { RendererCore } from '@mappedin/core-sdk';
    /**
        * Options for navigation.
        */
    export type TNavigationOptions = {
            /**
                * Controls whether the map should be set to the floor of the connection point when a connection point is clicked.
                * @default true
                */
            setMapOnConnectionClick?: boolean;
            /**
                * Controls whether the map should be set to the floor of the departure point when the path is drawn.
                * @default true
                */
            setMapToDeparture?: boolean;
            /**
                * Controls whether markers are created for the departure, destination, and connection points.
                */
            createMarkers?: {
                    /**
                        * Controls whether a marker is created for the departure point and allows a custom marker to be created.
                        * @default true
                        */
                    departure?: boolean | ((instruction: TDirectionInstruction) => Marker);
                    /**
                        * Controls whether a marker is created for the destination point and allows a custom marker to be created.
                        * @default true
                        */
                    destination?: boolean | ((instruction: TDirectionInstruction) => Marker);
                    /**
                        * Controls whether markers are created for connection points and allows a custom marker to be created.
                        * @default true
                        */
                    connection?: boolean | ((instruction: TDirectionInstruction) => Marker);
            };
            /**
                * Path Options for the non-current path in multi-destination mode.
                */
            inactivePathOptions?: {
                    /**
                        * Duration in milliseconds for the path to be drawn.
                        * @default 1000
                        */
                    drawDuration?: number;
                    /**
                        * The color of the path.
                        * @default '#40A9FF'
                        */
                    color?: string;
                    /**
                        * Whether the path should be clickable.
                        *
                        * @defaultValue false
                        */
                    interactive?: boolean;
                    /**
                        * The accent color of the path. This is applied to arrows if they are displayed
                        * @default 'blue'
                        */
                    accentColor?: string;
                    /**
                        * The radius of the path near the markers.
                        * @default 0.25
                        */
                    nearRadius?: number;
                    /**
                        * The zoom level at which the path should be at its near radius. This will default to the Camera maxZoomLevel.
                        */
                    nearZoomLevel?: number;
                    /**
                        * The radius of the path far from the markers.
                        * @default 1
                        */
                    farRadius?: number;
                    /**
                        * The zoom level at which the path should be at its far radius. This will default to the Camera minZoomLevel.
                        */
                    farZoomLevel?: number;
                    /**
                        * Controls whether arrows are displayed on the path.
                        * @default false
                        */
                    displayArrowsOnPath?: boolean;
                    /**
                        * Controls whether arrows are animated.
                        * @default false
                        */
                    animateArrowsOnPath?: boolean;
            };
            /**
                * Options for the path.
                */
            pathOptions?: {
                    /**
                        * Duration in milliseconds for the path to be drawn.
                        * @default 1000
                        */
                    drawDuration?: number;
                    /**
                        * The color of the path.
                        * @default '#40A9FF'
                        */
                    color?: string;
                    /**
                        * Whether the path should be clickable.
                        *
                        * @defaultValue false
                        */
                    interactive?: boolean;
                    /**
                        * The accent color of the path. This is applied to arrows if they are displayed
                        * @default 'blue'
                        */
                    accentColor?: string;
                    /**
                        * The radius of the path near the markers.
                        * @default 0.25
                        */
                    nearRadius?: number;
                    /**
                        * The zoom level at which the path should be at its near radius. This will default to the Camera maxZoomLevel.
                        */
                    nearZoomLevel?: number;
                    /**
                        * The radius of the path far from the markers.
                        * @default 1
                        */
                    farRadius?: number;
                    /**
                        * The zoom level at which the path should be at its far radius. This will default to the Camera minZoomLevel.
                        */
                    farZoomLevel?: number;
                    /**
                        * Controls whether arrows are displayed on the path.
                        * @default false
                        */
                    displayArrowsOnPath?: boolean;
                    /**
                        * Controls whether arrows are animated.
                        * @default false
                        */
                    animateArrowsOnPath?: boolean;
            };
            /**
                * Options for the markers at the departure and destination.
                */
            markerOptions?: {
                    /**
                        * The color of the departure marker.
                        * @default '#1890FF'
                        */
                    departureColor?: string;
                    /**
                        * The color of the destination marker.
                        * @default '#722ED1'
                        */
                    destinationColor?: string;
            };
    };
    /**
        * When a user needs to get from point A to point B, drawing a path on the map helps them to navigate to their destination. It can help them to visualize the route they'll need to take, like a good treasure map.
    
        * Navigation is a helper class to display wayfinding easily on the map. Functionality of Navigation could be replicated by drawing the paths using {@link Paths} and adding well designed tooltips at connection points.
        *
        * This class is accessed using {@link MapView.Navigation}.
        *
        * {@link Navigation.draw} allows for easily drawing multiple components that make up a wayfinding illustration. It shows a human figure to mark the start point, a path with animated directional arrows, pulses in the direction of travel and a pin to mark the destination. Each of these components can be customized to match an app's style.
        *
        * Refer to the [Drawing Navigation](https://developer.mappedin.com/web-sdk/wayfinding#drawing-navigation) in the Wayfinding Guide for more information and interactive examples.
        */
    export class Navigation {
            #private;
            /**
                * @internal
                */
            get currentMap(): GeojsonApiMapObject;
            /**
                * Returns true if the navigation is for a multi-floor path.
                */
            get isMultiFloor(): boolean;
            /**
                * @internal
                */
            constructor(core: RendererCore, geoJSONApi: GeoJsonApi, currentMapGetter: CurrentMapGetter);
            /**
                * @internal
                */
            getPathById(id: string): {
                    path: Path;
                    entityIds: string[];
            } | undefined;
            /**
                * @internal
                */
            getMarkerById(id: string): {
                    instruction: TDirectionInstruction;
                    marker: Marker;
            } | undefined;
            /**
                * @internal
                */
            get paths(): Path[];
            /**
                * The currently active directions.
                */
            get activeDirections(): Directions | undefined;
            /**
                * The currently active path.
                */
            get activePath(): Path | undefined;
            /**
                * The current list of floor stacks along the navigation paths.
                */
            get floorStacks(): FloorStack[];
            /**
                * The current list of floors along the navigation paths.
                */
            get floors(): Floor[];
            /**
                * Sets the active path by index.
                */
            setActivePathByIndex(target: number): void;
            /**
                * Sets the active path.
                */
            setActivePath(target: Path): void;
            /**
                * Sets the active path by directions.
                */
            setActivePathByDirections(target: Directions): void;
            /**
                * @internal
                */
            drawSync(directions: Directions | Directions[], options?: TNavigationOptions): void;
            /**
                * Draws the specified directions on the map.
                * @param directions The directions to be drawn.
                * @param options Optional additional options for the navigation.
                */
            draw(directions: Directions | Directions[], options?: TNavigationOptions): Promise<unknown>;
            /**
                * Clears any drawn navigation paths or directions from the map.
                */
            clear(): void;
    }
    type CurrentMapGetter = () => GeojsonApiMapObject | undefined;
    export {};
}

declare module '@mappedin/mappedin-js/mappedin-js/src/api-geojson' {
    export { GeoJsonApi } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/api';
    export { BlueDot } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/blue-dot';
    export { Camera } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/camera';
    export { Labels } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/labels';
    export { Markers } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/markers';
    export { Shapes } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/shapes';
    export { Models } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/models';
    export { Paths } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/paths';
    export { Navigation } from '@mappedin/mappedin-js/mappedin-js/src/navigation/index';
    export { Exporter } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/exporter';
    export { Directions } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/directions';
    export { Style } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/style';
    export { default as Outdoor } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/outdoor';
    export { Images } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/images';
    export { StackedMaps } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/stacked-maps/stacked-maps';
    export { DynamicFocus } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/dynamic-focus';
}

declare module '@mappedin/mappedin-js/mappedin-js/src/search' {
    export type { SearchResult, SearchResultItem, SearchOptions, Suggestion, SearchResultEnterpriseCategory, SearchResultEnterpriseLocations, SearchResultPlaces, MatchInfo, } from '@mappedin/mappedin-js/mappedin-js/src/search/internal';
    export type { SearchState } from '@mappedin/mappedin-js/mappedin-js/src/search/external';
    export { Search } from '@mappedin/mappedin-js/mappedin-js/src/search/external';
}

declare module '@mappedin/mappedin-js/mappedin-js/src/query' {
    export { Query } from '@mappedin/mappedin-js/mappedin-js/src/query/external';
    export type { TFindNearestOptions, TFindNearestResult, TQueriables } from '@mappedin/mappedin-js/mappedin-js/src/query/external';
}

declare module '@mappedin/mappedin-js/mappedin-js/src/analytics' {
    export { Analytics, AnalyticsInternal } from '@mappedin/mappedin-js/mappedin-js/src/analytics/customer';
    export type { AnalyticsUpdateOptions, AnalyticState, TAnalyticsUpdateState } from '@mappedin/mappedin-js/mappedin-js/src/analytics/customer';
}

declare module '@mappedin/mappedin-js/mappedin-js/src/api-geojson/directions' {
    import type { ParsedMVF } from '@mappedin/mvf';
    import type { DirectionsCollection } from '@packages/internal/geojson-navigator';
    import { Navigator } from '@packages/internal/geojson-navigator';
    import { Connection, Coordinate, Node, type MapDataInternal } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    import type { TDirectionInstruction, TDirectionZone, TNavigationTarget } from '@mappedin/mappedin-js/mappedin-js/src/types';
    /**
        * Represents a set of directions between two points.
        *
        * Directions are used to represent the path between two points on the map,
        * as well as the instructions to follow the path.
        */
    export class Directions {
            #private;
            /**
                * @internal
                */
            constructor(directions: DirectionsCollection, mapData: MapDataInternal, from: TNavigationTarget[], to: TNavigationTarget[]);
            /**
                * @internal
                */
            get path(): Node[];
            /**
                * The selected departure.
                */
            get departure(): TNavigationTarget;
            /**
                * The selected destination.
                */
            get destination(): TNavigationTarget;
            /**
                * All the coordinates ({@link Coordinate}) of the directions.
                */
            get coordinates(): Coordinate[];
            /**
                * The total distance of the path in meters.
                */
            get distance(): number;
            /**
                * The array of instructions ({@link TDirectionInstruction}).
                */
            get instructions(): TDirectionInstruction[];
    }
    export class DirectionsInternal {
            navigator: Navigator;
            /**
                * @hidden
                */
            constructor({ nodes, geojsonCollection, connections, groupBy, multiplicativeDistanceWeightScaling, }: {
                    nodes: ParsedMVF['node.geojson'];
                    geojsonCollection: ParsedMVF['obstruction'] | ParsedMVF['space'];
                    connections: ParsedMVF['connection.json'];
                    groupBy?: string;
                    multiplicativeDistanceWeightScaling?: boolean;
            });
            /**
                * Get directions between two navigation targets.
                *
                * @hidden
                * @param from
                * @param to
                * @param options
                * @param mapData
                */
            getDirections: (from: TNavigationTarget[], to: TNavigationTarget[], options: {
                    accessible: boolean;
                    smoothing: {
                            enabled: boolean;
                            radius: number;
                    };
                    zones: TDirectionZone[];
                    excludedConnections: Connection[];
            }, mapData: MapDataInternal) => Directions | undefined;
            /**
                * Get the node IDs that should be excluded from the navigation graph.
                *
                * @hidden
                * @param excludedConnections {Connection[]}
                */
            getExcludedNodeIds: (excludedConnections: Connection[]) => string[];
            /**
                * Get the node IDs of connections that do not match the accessibility setting provided.
                * A disabled connection node is a connection node that acts as a regular node
                * (ie. the edges that would cause a floor change are ignored).
                *
                * @hidden
                * @param accessible {boolean}
                */
            getDisabledConnectionNodeIds: (accessible: boolean) => string[];
    }
    /**
        * Get the nodes from the navigation target.
        *
        * @hidden
        * @param target
        * @param mapData
        */
    export function getNodesFromTarget(target: TNavigationTarget, mapData: MapDataInternal): string[];
}

declare module '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/types' {
    import type Area from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/area';
    import type Door from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/door';
    import type Floor from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/floor';
    import type Space from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/space';
    import type PointOfInterest from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/poi';
    import type Annotation from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/annotation';
    import type Connection from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/connection';
    import type MapObject from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/object';
    import type { EnterpriseLocation as MvfEnterpriseLocation, EnterpriseCategory as MvfEnterpriseCategory, ParsedMVFLocalePack, Feature, FloorStack as MvfFloorStack, FloorProperties as MvfFloor } from '@mappedin/mvf';
    import type { PartialExcept } from '@mappedin/mvf-core';
    import type { LocalePackUrls } from '@packages/internal/mvf-utils';
    import type { LanguagePackHydrationItem } from '@mappedin/mappedin-js/mappedin-js/src/types';
    import type { EnvControl, TGetMapDataOptions } from '@packages/internal/mvf-utils/mvf-utils';
    import { TokenManager } from '@packages/internal/mvf-utils/tokens/token-manager';
    /**
        * Places are the main objects that can be searched for.
        */
    export type Places = Space | Floor | Door | Connection | MapObject | PointOfInterest | Annotation | Area;
    export type LocationWithLocale = PartialExcept<MvfEnterpriseLocation, 'id'>;
    export type CategoryWithLocale = PartialExcept<MvfEnterpriseCategory, 'id'>;
    export type FloorStackWithLocale = PartialExcept<MvfFloorStack, 'id'>;
    export type FloorWithLocale = PartialExcept<MvfFloor, 'id'>;
    export type LanguagePackRecords = {
            'enterprise-location': Record<string, LocationWithLocale> | undefined;
            'enterprise-category': Record<string, CategoryWithLocale> | undefined;
            'floor-stack': Record<string, FloorStackWithLocale> | undefined;
            floor: Record<string, FloorWithLocale> | undefined;
    };
    export type LanguagePack = {
            type: 'downloaded';
            data: ParsedMVFLocalePack;
            optimized: LanguagePackRecords;
    } | {
            type: 'initial';
            optimized: LanguagePackRecords;
    };
    export type TMapDataInternalOptions = {
            env?: EnvControl;
            enterprise?: boolean;
            outdoorViewToken?: string;
            localePacksUrls?: LocalePackUrls;
            languagePacks?: LanguagePackHydrationItem[];
            binaryBundle?: Uint8Array;
            tokenManager?: TokenManager;
            getMapDataOptions?: TGetMapDataOptions;
    };
    /**
        * A class that implements IGeoJSONData has a underlying GeoJSON datathat can be accessed.
        */
    export interface IGeoJSONData {
            /** Gets the underlying GeoJSON Feature representation of this object. */
            geoJSON: Feature<any, null>;
    }
}

declare module '@mappedin/mappedin-js/mappedin-js/src/map-view-objects/camera-transform' {
    import type { Camera } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson';
    /**
        * Class representing camera transformation data.
        */
    export class CameraTransform {
            #private;
            /**
                * @internal
                */
            constructor(camera: Camera);
            /**
                * Getter for the center coordinate of the camera.
                *
                * @returns Center Coordinate.
                */
            get center(): import("..").Coordinate;
            /**
                * Getter for the camera's bearing in degrees.
                *
                * @returns Camera bearing in degrees.
                */
            get bearing(): number;
            /**
                * Getter for the camera's pitch in degrees.
                *
                * @returns Camera pitch in degrees.
                */
            get pitch(): number;
            /**
                * Getter for the camera's zoom level in mercator zoom levels.
                *
                * @see https://wiki.openstreetmap.org/wiki/Zoom_levels
                *
                * @returns Zoom level in mercator zoom levels.
                */
            get zoomLevel(): number;
    }
}

declare module '@mappedin/mappedin-js/mappedin-js/src/api-geojson/blue-dot' {
    export { BlueDot } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/blue-dot/blue-dot';
    export type { TBlueDotEvents, GeolocationPositionExtended, TFollowCameraOptions, TFollowMode } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/blue-dot/blue-dot';
}

declare module '@mappedin/mappedin-js/mappedin-js/src' {
    import MapData from '@mappedin/mappedin-js/mappedin-js/src/map-data';
    import type { TEvents, TEventPayload, TClickPayload, THoverPayload, TFloorChangeReason } from '@mappedin/mappedin-js/mappedin-js/src/events';
    import type { TGetMapDataOptions, TGetMapDataWithAccessTokenOptions, TGetMapDataWithCredentialsOptions, TGetMapDataSharedOptions } from '@packages/internal/mvf-utils';
    import { parseMVF, unzipMVF } from '@packages/internal/mvf-utils';
    import type { Floor } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    import type { ParsedMVF as TMVF, StyleCollection as TMVFStyleCollection, Style as TMVFStyle, LineStringStyle as TMVFLineStringStyle, PolygonStyle as TMVFPolygonStyle, PointStyle as TMVFPointStyle, ParsedMVFLocalePack, OperationHours, SiblingGroup, LocationState } from '@mappedin/mvf';
    import { MapView } from '@mappedin/mappedin-js/mappedin-js/src/map-view';
    export type { Text3D as Text3DApi } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/text3d';
    import type { InsetPadding, InsetPaddingOption, Shading, PaintStyle, LineStyle, Text3DState, AddText3DOptions, UpdatableText3DState, InitializeText3DState, EnvMapOptions, MapViewState, UpdateModelState, InitializeModelState, WatermarkUpdateOptions } from '@mappedin/mappedin-js/geojson/src';
    import { enableTestMode, preloadFont } from '@mappedin/mappedin-js/geojson/src';
    export type { PubSub } from '@packages/internal/common/pubsub';
    import type { TMappedinMapLibreOverlayEvents } from '@mappedin/mappedin-js/mappedin-js/src/maplibre-overlay';
    import { MappedinMapLibreOverlay } from '@mappedin/mappedin-js/mappedin-js/src/maplibre-overlay';
    import type { LanguagePackHydrationItem, TImagePlacementOptions } from '@mappedin/mappedin-js/mappedin-js/src/types';
    import { MAPPEDIN_COLORS } from '@mappedin/mappedin-js/mappedin-js/src/constants';
    import { type Environment } from '@packages/internal/mvf-utils/mvf-utils';
    import type { TBlueDotEvents, TBlueDotAction, TBlueDotState, GeolocationPositionExtended, TFollowMode, TFollowCameraOptions } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/blue-dot/blue-dot';
    import type { TExpandOptions, TStackedMapsEvents, TStackedMapsState } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/stacked-maps/stacked-maps';
    export { setLoggerLevel, E_SDK_LOG_LEVEL } from '@packages/internal/common/Mappedin.Logger';
    /**
        * @internal
        * @hidden
        * Must be called before {@link show3dMap}
        */
    export function __setWatermarkOnClickFn(fn: () => void): void;
    /**
        * Represents all the available antialiasing options.
        */
    type TAntialiasingOptions = {
            /**
                * Enable antialiasing. Only works when device supports WebGL2.
                *
                * @default true
                */
            enabled?: boolean;
            /**
                * Change the quality of antialiasing in the scene. Greater quality means less noise, but worse performance.
                *
                * @default 'medium'
                */
            quality?: 'low' | 'medium' | 'high' | 'ultra';
    };
    /**
        * @interface
        * Options for the watermark.
        */
    export type TWatermarkOptions = WatermarkUpdateOptions;
    /**
        * Options for showing a 3D map.
        *
        * @experimental
        */
    type TShow3DMapOptions = {
            /**
                * The outdoor view options.
                */
            outdoorView?: {
                    /**
                        * The token is used to fetch outdoor tiles, which will then be rendered.
                        */
                    token?: string;
                    /**
                        * A url to a style specification conforming to the [Maplibre Style Spec](https://maplibre.org/maplibre-style-spec/).
                        * Use the {@link Environment | `environment`} setting to switch environments.
                        */
                    style?: string;
                    /**
                        * Enable or disable the outdoor view.
                        */
                    enabled?: boolean;
                    /**
                        * Layers that should be hidden by geometry. This is useful when you want to hide certain layers when they are below the geometry.
                        * @default ['building', 'building-top']
                        */
                    layersHiddenByGeometry?: string[];
                    /**
                        * Reduces the pixel ratio for MapLibre rendering to improve framerate performance.
                        * When enabled, the rendering quality will be lower but performance will be better,
                        * which can be useful on devices with high-DPI displays or limited GPU capabilities.
                        *
                        * @default false
                        */
                    lowDpi?: boolean;
            };
            /**
                * The initial bearing of the map, in degrees.
                *
                * @default 0
                */
            bearing?: number;
            /**
                * The initial pitch of the map, in degrees.
                *
                * @default 45
                */
            pitch?: number;
            /**
                * The initial zoom level of the map, in mercator zoom levels.
                * If it is not specified, it will default to the level that fits the map bounds.
                */
            zoomLevel?: number;
            /**
                * The screen offsets of the map, in screen pixels.
                */
            screenOffsets?: InsetPadding;
            /**
                * Whether or not to automatically add labels and interactivity to the map. Set to
                * false if you need finer control over what is labelled or interactive.
                *
                * @hidden
                * @default true
                */
            auto?: boolean;
            /**
                * Antialiasing settings.
                *
                * TODO: Maybe we don't expose all of these settings.
                * @hidden
                * @default true
                */
            antialiasing?: boolean | TAntialiasingOptions;
            /**
                * @experimental
                *
                * Enable debug mode to check the visual representation of performance stats.
                * @default false
                */
            debug?: boolean;
            /**
                * Options when showing the watermark.
                *
                * @hidden
                */
            watermark?: TWatermarkOptions;
            /**
                * Options for the attribution control.
                *
                * @hidden
                */
            attribution?: {
                    /**
                        * Custom attribution content.
                        */
                    custom?: string[];
                    /**
                        * Attribution position.
                        * @default 'bottom-right'
                        */
                    position?: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';
                    /**
                        * Whether to show a feedback link next to the attributions.
                        * @default true
                        */
                    feedback?: boolean;
            };
            /**
                * First floor to be rendered.
                * By default, floor with the elevation that's closest to 0 is rendered. All floors will be sorted by elevation in ascending order.
                */
            initialFloor?: Floor | string;
            /**
                * Enable shading of bottoms of geometry along with outlines to make geometry stand out.
                * @default true
                * @deprecated Use `style.shading`.
                */
            shadingAndOutlines?: boolean;
            /**
                * Specify a color for the top of wall geometry.
                * @deprecated Use `style.wallTopColor`.
                */
            wallTopColor?: string;
            /**
                * Style options for the map.
                * @experimental
                */
            style?: {
                    /**
                        * Background color. Only relevant if outdoor map is disabled.
                        */
                    backgroundColor?: string;
                    /**
                        * Background alpha value. Only relevant if outdoor map is disabled.
                        */
                    backgroundAlpha?: number;
                    /**
                        * Set the global shading for all elements. True will use default values, false will disable shading.
                        * @default true
                        */
                    shading?: boolean | Shading;
                    /**
                        * Set the global outlines for all elements. True will enable outlines, false will disable them.
                        * @default true
                        */
                    outlines?: boolean;
                    /**
                        * Specify a color for the top of wall geometry.
                        */
                    wallTopColor?: string;
            };
            /**
                * @experimental
                * @internal
                */
            multiFloorView?: {
                    enabled?: boolean;
                    floorHeight?: number;
                    updateCameraElevationOnFloorChange?: boolean;
            };
            /**
                * @experimental
                * @internal
                * @default false
                */
            keepOutdoorGeometryVisible?: boolean;
            /**
                * @experimental
                *
                * Enable occlusion of labels, markers and floors.
                */
            occlusion?: {
                    /**
                        * Enable occlusion.
                        * @default false
                        */
                    enabled?: boolean;
            };
            /**
                * @experimental
                * @internal
                */
            imagePlacementOptions?: TImagePlacementOptions;
            /**
                * Enable or disable the flip of images to face the camera.
                * @default true
                */
            flipImagesToFaceCamera?: boolean;
            /**
                * Automatically inject necessary styles into the document head. If `false`, the `index.css` file needs to be manually imported.
                *
                * ```ts
                * import '@mappedin/mappedin-js/lib/index.css';
                * ...
                * await show3dMap(...);
                * ```
                *
                * @default true
                */
            injectStyles?: boolean;
            /**
                * @hidden
                * @internal
                */
            onWebGLContextCreationError?: (event: Event) => void;
            /**
                * @hidden
                * @internal
                */
            onWebGLContextLost?: (event: Event) => void;
            /**
                * @hidden
                * @internal
                */
            onWebGLContextRestored?: (event: Event) => void;
            /**
                * @hidden
                * @internal
                */
            onWebGLRendererError?: (error: Error) => void;
    };
    /**
        * @internal
        * @deprecated Use {@link hydrateMapData} instead.
        *
        * Returns a {@link MapData} instance from a parsed MVF object.
        */
    export const hydrateMapDataFromMVF: (mvf: TMVF, options?: TGetMapDataWithCredentialsOptions & {
            languagePacks?: LanguagePackHydrationItem[];
    }) => Promise<MapData>;
    /**
        * @internal
        * @deprecated Use {@link getMapData} and enterprise will be inferred from key/secret.
        */
    export function setUseEnterpriseAPI(value: boolean): void;
    export type THydrateMapDataBundle = {
            type: 'binary';
            options?: {
                    enterprise?: boolean;
            };
            languagePacks?: {
                    language: {
                            code: string;
                            name: string;
                    };
                    localePack: Uint8Array;
            }[];
            main: Uint8Array;
    } | {
            type: 'json';
            options?: {
                    enterprise?: boolean;
            };
            languagePacks?: {
                    language: {
                            code: string;
                            name: string;
                    };
                    localePack: ParsedMVFLocalePack;
            }[];
            main: TMVF;
    };
    /**
        * Load a MapData instance from a backup including language packs. Pass in userOptions to ensure outdoor view is available.
        */
    export const hydrateMapData: (backup: THydrateMapDataBundle | TMVF, userOptions?: TGetMapDataOptions) => Promise<MapData>;
    /**
        * Asynchronously retrieves map data ({@link MapData}) based on user-provided options.
        *
        * @experimental
        * @param userOptions {TGetMapDataOptions} Options provided by the user to retrieve map data.
        * @returns {Promise<MapData>} Promise resolving to the MapData.
        * @example
        * const data = await getMapData({ key: 'api_key', secret: 'api_secret', mapId: 'id' });
        */
    export const getMapData: (userOptions: TGetMapDataOptions) => Promise<MapData>;
    /**
        * @internal
        * @deprecated Use {@link getMapData} and enterprise will be inferred from key/secret.
        */
    export const getMapDataEnterprise: (userOptions: TGetMapDataOptions) => Promise<MapData>;
    /**
        * Mappedin JS makes use of MapLibre to render the outdoor portion of the map. Mappedin JS exposes this layer through {@link MapView.OutoorMap} and can be used to add additional layers as described in the [Outdoor Map Guide](https://developer.mappedin.com/web-sdk/outdoor-map).
        *
        * It is also possible to utilize the opposite architecture, by adding a MapView to a MapLibre Map.
        * This is accomplished by using {@link MappedinMapLibreOverlay} class. It allows a developer to easily add a Mappedin indoor map to an existing MapLibre based app.
        *
        * Refer to the [Mappedin MapLibre Overlay](https://developer.mappedin.com/web-sdk/mappedin-maplibre-overlay) for more information and interactive examples.
    
        * @experimental
        */
    export const createMapLibreOverlay: (mapData: MapData, showMapOptions?: TShow3DMapOptions) => MappedinMapLibreOverlay;
    export const show3dMap: (el: HTMLElement, mapData: MapData, options?: TShow3DMapOptions) => Promise<MapView>;
    /**
        * @internal
        * @deprecated Use {@link show3dMap} instead.
        */
    export const show3dMapGeojson: (el: HTMLElement, mapData: MapData, options?: TShow3DMapOptions) => Promise<MapView>;
    export { parseMVF, unzipMVF, enableTestMode, preloadFont, MAPPEDIN_COLORS };
    export type { MapView, MapData, MapViewState, MappedinMapLibreOverlay, TMappedinMapLibreOverlayEvents, TBlueDotEvents, TBlueDotAction, TBlueDotState, GeolocationPositionExtended, TStackedMapsEvents, TExpandOptions, TStackedMapsState, TFollowMode, TFollowCameraOptions, TEvents, TEventPayload, TFloorChangeReason, TClickPayload, THoverPayload, TShow3DMapOptions, TGetMapDataOptions, TGetMapDataWithAccessTokenOptions, TGetMapDataWithCredentialsOptions, TGetMapDataSharedOptions, TAntialiasingOptions, TMVF, PaintStyle, LineStyle, EnvMapOptions, Shading, TMVFStyleCollection, TMVFStyle, TMVFLineStringStyle, TMVFPolygonStyle, TMVFPointStyle, Environment, InsetPadding, InsetPaddingOption, OperationHours, SiblingGroup, LocationState, Text3DState, AddText3DOptions, UpdatableText3DState, InitializeText3DState, UpdateModelState, InitializeModelState, };
    export type * from 'geojson';
    export type { TUpdateState, TUpdateStates, TLabelState, TGeometryState, TModelState, TShapeState, TDoorsState, TImageState, TWallsState, TCameraAnimationOptions, TAnimationOptions, TFocusOnOptions, TEasingFunction, TCameraTarget, TNavigationTarget, TDirectionZone, TAddMarkerOptions, TAddPathOptions, TLabelAppearance, TAddLabelOptions, TAddModelOptions, TAddModel, TAddImageOptions, TGetDirectionsOptions, TCollisionRankingTier, TMarkerAnchor, TDirectionInstruction, TDirectionInstructionAction, TGetState, TMarkerState, TBlueDotOptions, TBlueDotPositionUpdate, TFocusTarget, IFocusable, IAnchorable, TMapDataObjectTypes, TFloorState, TFacadeState, } from '@mappedin/mappedin-js/mappedin-js/src/types';
    export { WALLS, DOORS } from '@mappedin/mappedin-js/mappedin-js/src/types';
    export type { Label, Marker, Path, PathSegment, Shape, CameraTransform, Model, Image, Text3D, } from '@mappedin/mappedin-js/mappedin-js/src/map-view-objects';
    export type { Debug } from '@mappedin/mappedin-js/mappedin-js/src/debug';
    export type { Navigation, TNavigationOptions } from '@mappedin/mappedin-js/mappedin-js/src/navigation';
    export type { TSpaceType } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    export { Coordinate, Annotation, Connection, Door, Floor, FloorStack, MapObject, PointOfInterest, Space, ImageMetaData, Hyperlink, EnterpriseLocation, EnterpriseCategory, EnterpriseVenue, LocationProfile, LocationCategory, Facade, Node, Area, type Places, } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    export type { Camera, Models, Labels, BlueDot, Markers, Paths, Exporter, Directions, Style, Shapes, Outdoor, Images, StackedMaps, DynamicFocus, } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson';
    export type { SearchResult, SearchResultItem, SearchResultEnterpriseCategory, SearchResultEnterpriseLocations, SearchResultPlaces, SearchOptions, Search, Suggestion, MatchInfo, } from '@mappedin/mappedin-js/mappedin-js/src/search';
    export type { TFindNearestOptions, TFindNearestResult, TQueriables, Query } from '@mappedin/mappedin-js/mappedin-js/src/query';
    export type { Analytics, TAnalyticsUpdateState } from '@mappedin/mappedin-js/mappedin-js/src/analytics';
}

declare module '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/node' {
    import type { NodeCollection } from '@mappedin/mvf';
    import Coordinate from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/coordinate';
    import type { EnterpriseLocation, MapDataInternal, Space } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    import type Floor from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/floor';
    import BaseMetaData from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/base-metadata-object';
    import type { IGeoJSONData } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/types';
    import type { IAnchorable, IFocusable } from '@mappedin/mappedin-js/mappedin-js/src/types';
    /**
        * A class representing {@link Path} node data within the map.
        *
        * Nodes are used to define points in the map's pathfinding graph.
        *
        */
    class Node extends BaseMetaData implements IGeoJSONData, IFocusable, IAnchorable {
            #private;
            /**
                * @internal
                */
            static readonly __type = "node";
            /**
                * @internal
                */
            readonly __type = "node";
            /**
                * Checks if the provided instance is of type Node.
                *
                * @param instance The instance to check.
                * @returns {boolean} True if the instance is a Node, false otherwise.
                */
            static is(instance: object): instance is Node;
            /**
                * @internal
                */
            constructor(data: MapDataInternal, options: {
                    floorId: string;
                    mvfData: NodeCollection['features'][number];
            });
            /** @internal */
            get locations(): EnterpriseLocation[];
            /**
                * Gets the {@link Space} object associated with the node.
                */
            get space(): Space | undefined;
            /**
                * Gets the {@link Floor} associated with the node.
                *
                * @returns {Floor} The floor object.
                * @throws Will throw an error if the floor is not found.
                */
            get floor(): Floor;
            /**
                * Gets the {@link Coordinate} of the node.
                *
                * @returns {Coordinate} The node's coordinate.
                */
            get coordinate(): Coordinate;
            /**
                * Gets the external ID of the node.
                *
                * @returns {string} The external ID of the node.
                */
            get externalId(): string;
            /**
                * Gets the neighboring nodes of this node.
                *
                * @returns {Node[]} An array of neighboring Node objects.
                */
            get neighbors(): Node[];
            /**
                * Gets the underlying GeoJSON Feature representation of this Node.
                */
            get geoJSON(): {
                    properties: null;
                    type: import("@mappedin/mvf").FeatureType;
                    geometry: import("@mappedin/mvf").Point;
            };
            /** @internal */
            get focusTarget(): Coordinate;
            /** @internal */
            get anchorTarget(): Coordinate;
            /**
                * Serializes the node data to JSON.
                *
                * @returns An object representing the node.
                */
            toJSON(): {
                    id: string;
                    floor: string;
                    coordinate: {
                            latitude: number;
                            longitude: number;
                            floor: string | undefined;
                            verticalOffset: number;
                    };
                    neighbors: string[];
            };
            /**
                * Cleans up resources used by the instance.
                *
                * @internal
                */
            destroy(): void;
    }
    export default Node;
}

declare module '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/area' {
    import type { AreaCollection } from '@mappedin/mvf';
    import { Coordinate, type MapDataInternal } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    import type Floor from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/floor';
    import type { IGeoJSONData } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/types';
    import type { IAnchorable, IFocusable } from '@mappedin/mappedin-js/mappedin-js/src/types';
    import DetailedMapData from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/detailed-map-data';
    /**
        * An Area represents some grouping of multiple pieces of geometry, not
        * necessarily bounded by walls or any other physical feature of the map.
        *
        * Areas are currently in a preview state, and may have changes to existing
        * functionality or new features added in the future.
        */
    class Area extends DetailedMapData<AreaCollection['features'][number]> implements IGeoJSONData, IFocusable, IAnchorable {
            #private;
            /**
                * @internal
                */
            static readonly __type = "area";
            /**
                * @internal
                */
            readonly __type = "area";
            /**
                * Checks if the provided instance is of type Area.
                *
                * @param instance The instance to check.
                * @returns {boolean} True if the instance is a Area, false otherwise.
                */
            static is(instance: object): instance is Area;
            /**
                * @internal
                */
            constructor(data: MapDataInternal, options: {
                    floorId: string;
                    mvfData: AreaCollection['features'][number];
            });
            /**
                * Gets the center {@link Coordinate} of the area.
                *
                * @returns {Coordinate} The area's center coordinate.
                */
            get center(): Coordinate;
            /**
                * Gets the {@link Floor} object associated with the area.
                *
                * @returns {Floor} The floor object.
                * @throws Will throw an error if the floor is not found.
                */
            get floor(): Floor;
            /**
                * Gets the underlying GeoJSON Feature representation of this Area.
                */
            get geoJSON(): {
                    properties: null;
                    type: import("@mappedin/mvf").FeatureType;
                    geometry: import("@mappedin/mvf").Polygon;
            };
            /** @internal */
            get focusTarget(): this;
            /** @internal */
            get anchorTarget(): Coordinate;
            /**
                * Serializes the space data to JSON.
                *
                * @returns An object representing the space.
                */
            toJSON(): {
                    id: string;
                    name: string;
                    floor: string;
            };
            /**
                * Cleans up resources used by the instance.
                *
                * @internal
                */
            destroy(): void;
    }
    export default Area;
}

declare module '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/door' {
    import type { EntranceCollection } from '@mappedin/mvf';
    import Coordinate from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/coordinate';
    import type Floor from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/floor';
    import type { MapDataInternal } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    import type { IGeoJSONData } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/types';
    import type { IAnchorable, IFocusable } from '@mappedin/mappedin-js/mappedin-js/src/types';
    import DetailedMapData from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/detailed-map-data';
    /**
        * A class representing door data within the map.
        *
        * Doors are hidden by default. Doors can be made visible by setting their `visible` property to `true`.
        *
        * ```typescript
        * //Make interior doors visible and brown.
        * mapView.updateState(DOORS.Interior, {
        * 	visible: true,
        * 	color: '#5C4033',
        * 	opacity: 0.6,
        * });
    
        * //Make exterior doors visible and black.
        * mapView.updateState(DOORS.Exterior, {
        * 	visible: true,
        * 	color: 'black',
        * 	opacity: 0.6,
        * });
        * ```
        * Doors can also be made visible on an individual basis by passing in a {@link Door} object to {@link MapView.updateState}.
        *
        * Refer to the [Door Guide](https://developer.mappedin.com/web-sdk/spaces#doors) for more information and interactive examples.
        *
        * Door appearance can be customized by changing the color or adding a texture to the top or sides of a door.
        * Refer to the [Textures & Colors Guide](https://developer.mappedin.com/web-sdk/images-textures#textures--colors) for more information and interactive examples.
        *
        */
    class Door extends DetailedMapData<EntranceCollection['features'][number]> implements IGeoJSONData, IFocusable, IAnchorable {
            #private;
            /**
                * @internal
                */
            static readonly __type = "door";
            /**
                * @internal
                */
            readonly __type = "door";
            /**
                * Checks if the provided instance is of type Door.
                *
                * @param instance The instance to check.
                * @returns {boolean} True if the instance is a Door, false otherwise.
                */
            static is(instance: object): instance is Door;
            /**
                * @internal
                */
            constructor(data: MapDataInternal, options: {
                    floorId: string;
                    mvfData: EntranceCollection['features'][number];
            });
            /**
                * Gets the {@link Floor} object associated with the door.
                *
                * @returns {Floor} The floor object.
                * @throws Will throw an error if the floor is not found.
                */
            get floor(): Floor;
            /**
                * Calculates and gets the center {@link Coordinate} of the door.
                *
                * @returns {Coordinate} The center coordinate.
                */
            get center(): Coordinate;
            /**
                * Gets whether this door is an exterior door.
                */
            get isExterior(): boolean;
            /**
                * Gets the underlying GeoJSON Feature representation of this Door.
                */
            get geoJSON(): {
                    properties: null;
                    type: import("@mappedin/mvf").FeatureType;
                    geometry: import("@mappedin/mvf").LineString;
            };
            /** @internal */
            get focusTarget(): Coordinate;
            /** @internal */
            get anchorTarget(): Coordinate;
            /**
                * Converts the door information to a JSON object.
                *
                * @returns An object representing the door.
                */
            toJSON(): {
                    id: string;
                    name: string;
                    floor: string;
                    center: {
                            latitude: number;
                            longitude: number;
                            floor: string | undefined;
                            verticalOffset: number;
                    };
            };
            /**
                * Cleans up resources used by the instance.
                *
                * @internal
                */
            destroy(): void;
    }
    export default Door;
}

declare module '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/space' {
    import type { SpaceCollection } from '@mappedin/mvf';
    import Coordinate from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/coordinate';
    import type { EnterpriseLocation, MapDataInternal } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    import type Floor from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/floor';
    import type { IGeoJSONData } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/types';
    import type Door from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/door';
    import type { IAnchorable, IFocusable } from '@mappedin/mappedin-js/mappedin-js/src/types';
    import DetailedMapData from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/detailed-map-data';
    /**
        * Represents the various types of spaces that can be defined within a map.
        * - 'room': A standard room or enclosed area.
        * - 'hallway': A passageway connecting rooms.
        * - 'exterior': An outdoor area.
        * - 'void': An undefined or non-specific space.
        * - 'connection.stairs': A stairway connecting different floors.
        * - 'connection.elevator': An elevator connecting different floors.
        * - 'poi': A point of interest within the map.
        */
    export type TSpaceType = 'room' | 'hallway' | 'exterior' | 'void' | 'connection.stairs' | 'connection.elevator' | 'poi';
    /**
        * A Space represents an area enclosed by walls, such as a hall or room. Spaces can be Interactive and have Labels and Markers added to them.
        * Spaces can also be customized with a color, texture and hover color.
        *
        * Refer to the [Spaces Guide](https://developer.mappedin.com/web-sdk/spaces) for more information and interactive examples.
        */
    class Space extends DetailedMapData<SpaceCollection['features'][number]> implements IGeoJSONData, IFocusable, IAnchorable {
            #private;
            /**
                * @internal
                */
            static readonly __type = "space";
            /**
                * @internal
                */
            readonly __type = "space";
            /**
                * @internal
                * @hidden
                */
            getMvfData(): import("@mappedin/mvf").Feature<import("@mappedin/mvf").Polygon | import("@mappedin/mvf").LineString | import("@mappedin/mvf").Point, import("@mappedin/mvf").SpaceProperties>;
            /**
                * Checks if the provided instance is of type Space.
                *
                * @param instance The instance to check.
                * @returns {boolean} True if the instance is a Space, false otherwise.
                */
            static is(instance: object): instance is Space;
            /**
                * @internal
                */
            constructor(data: MapDataInternal, options: {
                    floorId: string;
                    mvfData: SpaceCollection['features'][number];
            });
            /**
                * Gets the type/kind of the space.
                *
                * @returns {TSpaceType} The type of the space.
                */
            get type(): TSpaceType;
            /**
                * @internal
                */
            get locations(): EnterpriseLocation[];
            /**
                * Gets the {@link Floor} object associated with the space.
                *
                * @returns {Floor} The floor object.
                * @throws Will throw an error if the floor is not found.
                */
            get floor(): Floor;
            /**
                * Gets the array of {@link Door}s associated with the space.
                *
                * @returns {Door[]} The doors array.
                */
            get doors(): Door[];
            /**
                * Gets the center {@link Coordinate} of the space.
                *
                * @returns {Coordinate} The space's center coordinate.
                */
            get center(): Coordinate;
            /**
                * Gets the underlying GeoJSON Feature representation of this Space.
                */
            get geoJSON(): {
                    properties: null;
                    type: import("@mappedin/mvf").FeatureType;
                    geometry: import("@mappedin/mvf").Polygon | import("@mappedin/mvf").LineString | import("@mappedin/mvf").Point;
            };
            /** @internal */
            get focusTarget(): Coordinate | this;
            /** @internal */
            get anchorTarget(): Coordinate;
            /**
                * Serializes the space data to JSON.
                *
                * @returns An object representing the space.
                */
            toJSON(): {
                    id: string;
                    name: string;
                    type: TSpaceType;
                    floor: string;
                    center: {
                            latitude: number;
                            longitude: number;
                            floor: string | undefined;
                            verticalOffset: number;
                    };
            };
            /**
                * Cleans up resources used by the instance.
                *
                * @internal
                */
            destroy(): void;
    }
    export const VALID_SPACE_TYPES: TSpaceType[];
    /**
        * validates space type and fallback to room
        */
    export function validateSpaceType(input: string | null | undefined): TSpaceType;
    export default Space;
}

declare module '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/floor' {
    import type { Feature, FloorCollection, MultiPolygon, Polygon } from '@mappedin/mvf';
    import type { Annotation, Connection, Door, MapDataInternal, PointOfInterest, Space, MapObject, FloorStack } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    import BaseMapData from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/base-object';
    import type { IFocusable } from '@mappedin/mappedin-js/mappedin-js/src/types';
    /**
        * A class representing floor data within the map.
        *
        * Floors are used to represent different levels within a map, each containing various map elements.
        */
    class Floor extends BaseMapData implements IFocusable {
            #private;
            /**
                * @internal
                */
            static readonly __type = "floor";
            /**
                * @internal
                */
            readonly __type = "floor";
            /**
                * Checks if the provided instance is of type Floor.
                *
                * @param instance The instance to check.
                * @returns {boolean} True if the instance is a Floor, false otherwise.
                */
            static is(instance: object): instance is Floor;
            /**
                * @internal
                */
            constructor(data: MapDataInternal, options: {
                    mvfData: FloorCollection['features'][number];
            });
            /** @internal */
            get focusTarget(): this;
            /**
                * Gets the name of the floor.
                *
                * @returns {string} The name of the floor.
                */
            get name(): string;
            /**
                * Gets the short name of the floor (i.e. "F1", "L, "2", etc.).
                * Used in space constrained lists and Often aligns with what is displayed on an elevator.
                *
                * @returns {string} The short name of the floor.
                */
            get shortName(): string;
            /**
                * Gets the external ID of the floor.
                *
                * @returns {string} The external ID of the floor.
                */
            get externalId(): string;
            /**
                * Gets the elevation of the floor.
                *
                * @returns {number} The elevation of the floor.
                */
            get elevation(): number;
            /**
                * Gets the spaces ({@link Space}) located on this floor.
                *
                * @returns {Space[]} An array of Space objects on this floor.
                */
            get spaces(): Space[];
            /**
                * Gets the underlying GeoJSON Feature representation of this Space.
                */
            get geoJSON(): Feature<Polygon | MultiPolygon, null>;
            /**
                * Gets the objects ({@link MapObject}) located on this floor.
                *
                * @returns {MapObject[]} An array of MapObject objects on this floor.
                */
            get objects(): MapObject[];
            /**
                * Gets the connections ({@link Connection}) associated with this floor.
                *
                * @returns {Connection[]} An array of Connection objects linked to this floor.
                */
            get connections(): Connection[];
            /**
                * Gets the doors ({@link Door}) located on this floor.
                *
                * @returns {Door[]} An array of Door objects on this floor.
                */
            get doors(): Door[];
            /**
                * Gets the annotations ({@link Annotation}) associated with this floor.
                *
                * @returns {Annotation[]} An array of Annotation objects linked to this floor.
                */
            get annotations(): Annotation[];
            /**
                * Gets the points of interest ({@link PointOfInterest}) located on this floor.
                *
                * @returns {PointOfInterest[]} An array of PointOfInterest objects on this floor.
                */
            get pois(): PointOfInterest[];
            /**
                * Gets the FloorStack ({@link FloorStack}) that this floor belongs to.
                *
                * @returns {FloorStack} The FloorStack that this floor belongs to.
                */
            get floorStack(): FloorStack;
            /**
                * Serializes the floor data to JSON.
                *
                * @returns An object representing the floor.
                */
            toJSON(): {
                    id: string;
                    name: string;
                    shortName: string;
                    elevation: number;
                    spaces: string[];
                    objects: string[];
                    connections: string[];
                    doors: string[];
                    annotations: string[];
                    pois: string[];
            };
            /**
                * Cleans up resources used by the instance.
                *
                * @internal
                */
            destroy(): void;
    }
    export default Floor;
}

declare module '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/connection' {
    import type { Feature, FeatureCollection, Point, SpaceProperties, Connection as MVFConnection } from '@mappedin/mvf';
    import Coordinate from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/coordinate';
    import type Node from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/node';
    import type { Floor, LocationProfile, MapDataInternal } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    import type { IFocusable } from '@mappedin/mappedin-js/mappedin-js/src/types';
    import DetailedMapData from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/detailed-map-data';
    /**
        * A class representing connection data within the map.
        *
        * Connections are used to represent pathways between different map nodes.
        */
    class Connection extends DetailedMapData<Feature<Point, SpaceProperties> | Feature<Point, MVFConnection>> implements IFocusable {
            #private;
            /**
                * @internal
                */
            static readonly __type = "connection";
            /**
                * @internal
                */
            readonly __type = "connection";
            /**
                * Checks if the provided instance is of type Connection.
                *
                * @param instance The instance to check.
                * @returns {boolean} True if the instance is a Connection, false otherwise.
                */
            static is(instance: object): instance is Connection;
            /**
                * @internal
                */
            constructor(data: MapDataInternal, options: {
                    mvfDataByFloorId: Record<string, FeatureCollection<Point, SpaceProperties>['features'][number]> | Record<string, Feature<Point, MVFConnection>>;
                    accessible?: boolean;
            });
            /**
                * Whether the connection is accessible. For example elevators are accessible while stairs are not.
                *
                * @returns {boolean} Whether the connection is accessible.
                */
            get accessible(): boolean;
            /**
                * Gets the type of the connection.
                *
                * @returns {string} The type of the connection.
                */
            get type(): string;
            /**
                * Extra properties of the connection.
                *
                * @returns {Record<string, unknown> | undefined} Extra properties of the connection.
                */
            get extra(): Record<string, unknown> | undefined;
            /**
                * Gets the coordinates ({@link Coordinate}) of the connection.
                *
                * @returns {Coordinate[]} An array of coordinates for the connection.
                */
            get coordinates(): Coordinate[];
            /**
                * Gets the nodes ({@link Node}) associated with the connection.
                */
            get nodes(): Node[];
            /**
                * Gets the floors ({@link Floor}) associated with the connection.
                *
                * @returns {Floor[]} An array of floors for the connection.
                */
            get floors(): Floor[];
            /**
                * Gets the location profiles ({@link LocationProfile}) associated with the connection.
                */
            get locationProfiles(): LocationProfile[];
            /** @internal */
            get focusTarget(): Coordinate[];
            /**
                * Serializes the connection data to JSON.
                *
                * @returns An object representing the connection.
                */
            toJSON(): {
                    id: string;
                    name: string;
                    type: string;
                    externalId: string;
                    coordinates: {
                            latitude: number;
                            longitude: number;
                            floor: string | undefined;
                            verticalOffset: number;
                    }[];
                    floors: string[];
                    extra: Record<string, unknown> | undefined;
            };
            /**
                * Cleans up resources used by the instance.
                *
                * @internal
                */
            destroy(): void;
    }
    export default Connection;
}

declare module '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/object' {
    import type { ObstructionCollection } from '@mappedin/mvf';
    import Coordinate from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/coordinate';
    import type { MapDataInternal } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    import type Floor from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/floor';
    import type { IGeoJSONData } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/types';
    import type { IAnchorable, IFocusable } from '@mappedin/mappedin-js/mappedin-js/src/types';
    import DetailedMapData from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/detailed-map-data';
    /**
        * A class representing generic map object data within the map.
        *
        * It could represent various objects on the map, such as desks, chairs, etc.
        *
        * MapObject appearance can be customized by changing the color or adding a texture to its top or sides.
        * Refer to the [Textures & Colors Guide](https://developer.mappedin.com/web-sdk/images-textures#textures--colors) for more information and interactive examples.
        */
    export class MapObject extends DetailedMapData<ObstructionCollection['features'][number]> implements IGeoJSONData, IFocusable, IAnchorable {
            #private;
            /**
                * @internal
                */
            static readonly __type = "object";
            /**
                * @internal
                */
            readonly __type = "object";
            /**
                * Checks if the provided instance is of type MapObject.
                *
                * @param instance The instance to check.
                * @returns {boolean} True if the instance is a MapObject, false otherwise.
                */
            static is(instance: object): instance is MapObject;
            /**
                * @internal
                */
            constructor(data: MapDataInternal, options: {
                    floorId: string;
                    mvfData: ObstructionCollection['features'][number];
            });
            /**
                * Gets the type of the MapObject.
                *
                * @returns {string} The kind of the object.
                */
            get type(): string;
            /**
                * Gets the {@link Floor} associated with the MapObject.
                *
                * @returns {Floor} The floor object.
                * @throws Will throw an error if the floor is not found.
                */
            get floor(): Floor;
            /**
                * Gets the center {@link Coordinate} of the MapObject.
                *
                * @returns {Coordinate} The object's center coordinate.
                */
            get center(): Coordinate;
            /**
                * Gets the underlying GeoJSON Feature representation of this Object.
                */
            get geoJSON(): {
                    properties: null;
                    type: import("@mappedin/mvf").FeatureType;
                    geometry: import("@mappedin/mvf").Polygon | import("@mappedin/mvf").LineString;
            };
            /** @internal */
            get anchorTarget(): Coordinate;
            /** @internal */
            get focusTarget(): Coordinate | this;
            /**
                * Serializes the MapObject data to JSON.
                *
                * @returns An object representing the MapObject.
                */
            toJSON(): {
                    id: string;
                    name: string;
                    type: string;
                    floor: string;
                    center: {
                            latitude: number;
                            longitude: number;
                            floor: string | undefined;
                            verticalOffset: number;
                    };
            };
            /**
                * Cleans up resources used by the instance.
                *
                * @internal
                */
            destroy(): void;
    }
    export default MapObject;
}

declare module '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/coordinate' {
    import type { IFocusable, IAnchorable } from '@mappedin/mappedin-js/mappedin-js/src/types';
    /**
        * Parameters for creating a Coordinate.
        */
    export type TCoordinateParams = {
            /**
                * The latitude of the coordinate in decimal degrees.
                */
            latitude: number;
            /**
                * The longitude of the coordinate in decimal degrees.
                */
            longitude: number;
            /**
                * Optional ID of the floor this coordinate is on.
                */
            floorId?: string;
            /**
                * Optional vertical offset from the floor in meters.
                */
            verticalOffset?: number;
    };
    /**
        * Class representing a pseudo-mercator coordinate.
        *
        * The Pseudo-Mercator projection is a type of cylindrical and conformal map projection.
        * It is identified as EPSG:3857 ({@link https://epsg.io/3857}).
        * This projection is a modified version of the traditional Mercator projection,
        * which is commonly used in marine navigation.
        */
    class Coordinate implements IFocusable, IAnchorable {
            /**
                * @internal
                */
            static readonly __type = "coordinate";
            /**
                * @internal
                */
            readonly __type = "coordinate";
            id: string;
            /**
                * The latitude of the coordinate.
                * @type {number}
                */
            readonly latitude: number;
            /**
                * The longitude of the coordinate.
                * @type {number}
                */
            readonly longitude: number;
            /**
                * The floor ID of the coordinate.
                */
            readonly floorId?: string;
            /**
                * The vertical position of the coordinate, offset from the floor.
                */
            readonly verticalOffset: number;
            /**
                * Checks if the provided instance is of type Coordinate.
                *
                * @param instance The instance to check.
                * @returns {boolean} True if the instance is a Coordinate, false otherwise.
                */
            static is(instance: object): instance is Coordinate;
            /**
                * Creates a new Coordinate instance.
                *
                * @param latitudeOrParams Either a latitude number or a TCoordinateParams object containing coordinate details
                */
            constructor(latitudeOrParams: TCoordinateParams);
            /**
                * @deprecated
                * @internal
                */
            constructor(latitudeOrParams: number, longitude: number, floorId?: string);
            /**
                * @internal
                */
            get anchorTarget(): this;
            /**
                * @internal
                */
            get focusTarget(): this;
            /**
                * Checks if this coordinate is equal to another coordinate.
                *
                * @param coordinate The coordinate to compare with.
                * @returns {boolean} True if coordinates are equal, false otherwise.
                */
            isEqual(coordinate: Coordinate): boolean;
            /**
                * Serializes the coordinate data to JSON.
                *
                * @returns An object representing the coordinate.
                */
            toJSON(): {
                    latitude: number;
                    longitude: number;
                    floor: string | undefined;
                    verticalOffset: number;
            };
            /**
                * Cleans up resources used by the instance.
                *
                * @internal
                */
            destroy(): void;
    }
    export default Coordinate;
}

declare module '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/poi' {
    import type { FeatureCollection, Point, SpaceProperties } from '@mappedin/mvf';
    import type { Floor, MapDataInternal } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    import Coordinate from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/coordinate';
    import type { IGeoJSONData } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/types';
    import type { IAnchorable, IFocusable } from '@mappedin/mappedin-js/mappedin-js/src/types';
    import DetailedMapData from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/detailed-map-data';
    /**
        * A class representing point of interest data within the map.
        *
        * Points of interest are used to represent specific points
        * on the map with additional information(e.g. ATMs, Water Fountains).
        */
    class PointOfInterest extends DetailedMapData<FeatureCollection<Point, SpaceProperties>['features'][number]> implements IGeoJSONData, IFocusable, IAnchorable {
            #private;
            /**
                * @internal
                */
            static readonly __type = "point-of-interest";
            /**
                * @internal
                */
            readonly __type = "point-of-interest";
            /**
                * Checks if the provided instance is of type PointOfInterest.
                *
                * @param instance The instance to check.
                * @returns {boolean} True if the instance is a PointOfInterest, false otherwise.
                */
            static is(instance: object): instance is PointOfInterest;
            /**
                * @internal
                */
            constructor(data: MapDataInternal, options: {
                    floorId: string;
                    mvfData: FeatureCollection<Point, SpaceProperties>['features'][number];
            });
            /**
                * Gets the {@link Floor} object associated with the POI.
                *
                * @returns {Floor} The floor object.
                * @throws Will throw an error if the floor is not found.
                */
            get floor(): Floor;
            /**
                * Gets the {@link Coordinate} of the POI.
                *
                * @returns {Coordinate} The POI's coordinate.
                */
            get coordinate(): Coordinate;
            /**
                * Gets the underlying GeoJSON Feature representation of this PointOfInterest.
                */
            get geoJSON(): {
                    properties: null;
                    type: import("@mappedin/mvf").FeatureType;
                    geometry: Point;
            };
            /** @internal */
            get focusTarget(): Coordinate;
            /** @internal */
            get anchorTarget(): Coordinate;
            /**
                * Serializes the POI data to JSON.
                *
                * @returns An object representing the POI.
                */
            toJSON(): {
                    id: string;
                    name: string;
                    floor: string;
                    coordinate: {
                            latitude: number;
                            longitude: number;
                            floor: string | undefined;
                            verticalOffset: number;
                    };
            };
            /**
                * Cleans up resources used by the instance.
                *
                * @internal
                */
            destroy(): void;
    }
    export default PointOfInterest;
}

declare module '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/annotation' {
    import type { AnnotationCollection } from '@mappedin/mvf';
    import type { Floor, MapDataInternal } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    import Coordinate from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/coordinate';
    import type { IGeoJSONData } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/types';
    import type { IAnchorable, IFocusable } from '@mappedin/mappedin-js/mappedin-js/src/types';
    import DetailedMapData from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/detailed-map-data';
    /**
        * A class representing annotation data within the map.
        *
        * Annotations are used to mark specific points or areas on the map with additional information.
        * It includes some details on a map that may be relevant to safety or accessibility (e.g. Fire Extinguishers).
        * Refer to the [Annotation Guide](https://developer.mappedin.com/web-sdk/annotations) for more information.
        */
    class Annotation extends DetailedMapData<AnnotationCollection['features'][number]> implements IGeoJSONData, IFocusable, IAnchorable {
            #private;
            /**
                * @internal
                */
            static readonly __type = "annotation";
            /**
                * @internal
                */
            readonly __type = "annotation";
            /**
                * Checks if the provided instance is of type Annotation.
                *
                * @param instance The instance to check.
                * @returns {boolean} True if the instance is an Annotation, false otherwise.
                */
            static is(instance: object): instance is Annotation;
            /**
                * @internal
                */
            constructor(data: MapDataInternal, options: {
                    floorId: string;
                    mvfData: AnnotationCollection['features'][number];
            });
            /**
                * Gets the group of the annotation.
                *
                * @returns {string} The annotation group.
                */
            get group(): string;
            /**
                * Gets the type of the annotation.
                *
                * @returns {string} The annotation type.
                */
            get type(): string;
            /**
                * Gets the center {@link Coordinate} of the annotation.
                *
                * @returns {Coordinate} The annotation's coordinate.
                */
            get coordinate(): Coordinate;
            /**
                * Gets the {@link Floor} object associated with the annotation.
                *
                * @returns {Floor} The floor object.
                * @throws Will throw an error if the floor is not found.
                */
            get floor(): Floor;
            /**
                * Gets the underlying GeoJSON Feature representation of this Annotation.
                */
            get geoJSON(): {
                    properties: null;
                    type: import("@mappedin/mvf").FeatureType;
                    geometry: import("@mappedin/mvf").Point;
            };
            /** @internal */
            get focusTarget(): Coordinate;
            /** @internal */
            get anchorTarget(): Coordinate;
            /**
                * Converts the annotation information to a JSON object.
                *
                * @returns An object representing the annotation.
                */
            toJSON(): {
                    id: string;
                    group: string;
                    type: string;
                    coordinate: {
                            latitude: number;
                            longitude: number;
                            floor: string | undefined;
                            verticalOffset: number;
                    };
            };
            /**
                * Cleans up resources used by the instance.
                *
                * @internal
                */
            destroy(): void;
    }
    export default Annotation;
}

declare module '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/hyperlink' {
    import type { LocationLink, Hyperlink as MVFHyperlink } from '@mappedin/mvf';
    import BaseMetaData from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/base-metadata-object';
    /**
        * A class representing hyperlink link data within the map.
        */
    class Hyperlink extends BaseMetaData {
            #private;
            /**
                * @internal
                */
            static readonly __type = "hyperlink";
            /**
                * Checks if the provided instance is of type Hyperlink.
                *
                * @param instance The instance to check.
                * @returns {boolean} True if the instance is a Hyperlink, false otherwise.
                */
            static is(instance: object): instance is Hyperlink;
            /**
                * @internal
                */
            constructor(options: {
                    mvfData: MVFHyperlink | LocationLink;
            });
            /**
                * Gets the url of the hyperlink.
                *
                * @returns {string} The url of the hyperlink.
                */
            get url(): string;
            /**
                * Gets the name of the hyperlink.
                *
                * @returns {string | undefined } The name of the hyperlink.
                */
            get name(): string | undefined;
            /**
                * Serializes the hyperlink data to JSON.
                *
                * @returns An object representing the hyperlink.
                */
            toJSON(): {
                    id: string;
                    url: string;
                    name: string | undefined;
            };
            /**
                * Cleans up resources used by the instance.
                *
                * @internal
                */
            destroy(): void;
    }
    export default Hyperlink;
}

declare module '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/image' {
    import type { Image as MVFImage } from '@mappedin/mvf';
    import BaseMetaData from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/base-metadata-object';
    import type { MapDataInternal } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    /**
        * A class representing image link data within the map.
        */
    class ImageMetaData extends BaseMetaData {
            #private;
            /**
                * @internal
                */
            static readonly __type = "image";
            /**
                * Checks if the provided instance is of type Image.
                *
                * @param instance The instance to check.
                * @returns {boolean} True if the instance is a Image, false otherwise.
                */
            static is(instance: object): instance is ImageMetaData;
            /**
                * @internal
                */
            constructor(options: {
                    mvfData: MVFImage;
                    mapData: MapDataInternal;
            });
            /**
                * Gets the url of the image.
                *
                * @returns {string | undefined} The url of the image.
                */
            get url(): string | undefined;
            /**
                * Gets the alt text of the image.
                *
                * @returns {string | undefined } The alt text of the image.
                * @deprecated Use {@link altText} instead.
                */
            get name(): string | undefined;
            /**
                * Gets the alt text of the image.
                *
                * @returns {string | undefined } The alt text of the image.
                */
            get altText(): string | undefined;
            /**
            /**
                * Serializes the image data to JSON.
                *
                * @returns An object representing the image.
                */
            toJSON(): {
                    id: string;
                    url: string | undefined;
                    name: string | undefined;
            };
            /**
                * Cleans up resources used by the instance.
                *
                * @internal
                */
            destroy(): void;
    }
    export default ImageMetaData;
}

declare module '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/floor-stack' {
    import type { FloorStack as MVFFloorStack } from '@mappedin/mvf';
    import type { MapDataInternal, Floor, Facade } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    import BaseMapData from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/base-object';
    /**
        * A class representing floor stack data within the map.
        *
        * FloorStacks are used to represent a group of floors that are part of a single entity.
        */
    class FloorStack extends BaseMapData {
            #private;
            /**
                * @internal
                */
            static readonly __type = "floor-stack";
            /**
                * @internal
                */
            readonly __type = "floor-stack";
            /**
                * Checks if the provided instance is of type FloorStack.
                *
                * @param instance The instance to check.
                * @returns {boolean} True if the instance is a FloorStack, false otherwise.
                */
            static is(instance: object): instance is FloorStack;
            /**
                * @internal
                */
            constructor(data: MapDataInternal, options: {
                    mvfData: MVFFloorStack;
                    facadeId?: string;
            });
            /**
                * Gets the type of FloorStack.
                */
            get type(): MVFFloorStack['type'];
            /**
                * Gets the name of the FloorStack.
                *
                * @returns {string} The name of the FloorStack.
                */
            get name(): string;
            /**
                * Gets the short name of the FloorStack.
                *
                * @returns {string} The short name of the FloorStack.
                */
            get shortName(): string;
            /**
                * Gets the externalId of FloorStack
                */
            get externalId(): string;
            /**
                * Gets the floors ({@link Floor}) included in this FloorStack.
                *
                * @returns {Floor[]} An array of Floor objects in this FloorStack.
                */
            get floors(): [Floor, ...Floor[]];
            /**
                * Get the default floor for this floor stack
                */
            get defaultFloor(): Floor;
            /**
                * Gets the facade ({@link Facade}) representing this floor stack, if it exists.
                */
            get facade(): Facade | undefined;
            /**
                * Serializes the FloorStack data to JSON.
                *
                * @returns An object representing the FloorStack.
                */
            toJSON(): {
                    id: string;
                    name: string;
                    shortName: string;
                    type: "Building" | "Outdoor" | undefined;
                    floors: string[];
            };
            /**
                * Cleans up resources used by the instance.
                *
                * @internal
                */
            destroy(): void;
    }
    export default FloorStack;
}

declare module '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/facade' {
    import type { Space, MapDataInternal } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    import { Coordinate } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    import BaseMapData from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/base-object';
    import type { Facade as MVFFacade } from '@mappedin/mvf';
    import type { IAnchorable, IFocusable } from '@mappedin/mappedin-js/mappedin-js/src/types';
    /**
        * A Facade is a collection of spaces that make up the exterior representation of a Floor Stack ({@link FloorStack}).
        */
    class Facade extends BaseMapData implements IFocusable, IAnchorable {
            #private;
            static readonly __type = "facade";
            readonly __type = "facade";
            /**
                * Checks if the provided instance is of type Floor.
                *
                * @param instance The instance to check.
                * @returns {boolean} True if the instance is a Floor, false otherwise.
                */
            static is(instance: object): instance is Facade;
            /** @internal */
            constructor(data: MapDataInternal, options: {
                    mvfData: MVFFacade;
                    floorStackId: string;
            });
            /**
                * Gets the floor stack that this Facade represents.
                */
            get floorStack(): import("./floor-stack").default;
            /**
                * Gets the collection of spaces that make up this Facade.
                */
            get spaces(): Space[];
            /**
                * Gets the center {@link Coordinate} of the Facade.
                */
            get center(): Coordinate;
            /** @internal */
            get focusTarget(): Space[];
            /** @internal */
            get anchorTarget(): Coordinate;
    }
    export default Facade;
}

declare module '@mappedin/mappedin-js/mappedin-js/src/utils/data-creation' {
    import type { AnnotationCollection, EntranceCollection, FeatureCollection, Connection as MVFConnection, EnterpriseCategory as MVFEnterpriseCategory, EnterpriseCategoryId as MVFEnterpriseCategoryId, EnterpriseLocation as MVFEnterpriseLocation, EnterpriseLocationId as MVFEnterpriseLocationId, EnterpriseVenue as MVFEnterpriseVenue, FloorProperties as MVFFloor, FloorStack as MVFFloorStack, NodeCollection, ObstructionCollection, ParsedMVF, Point, SpaceCollection, SpaceProperties, AreaCollection, AreaId, EnterpriseLocationInstance, SpaceId } from '@mappedin/mvf';
    import { Annotation, Area, Connection, Door, EnterpriseCategory, EnterpriseLocation, Facade, Floor, FloorStack, MapObject, Node, PointOfInterest, Space, LocationCategory, LocationProfile, type MapDataInternal } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    export type MapDataRecords = {
            spacesById: Record<string, Space>;
            nodesById: Record<string, Node>;
            objectsById: Record<string, MapObject>;
            floorsById: Record<string, Floor>;
            floorStacksById: Record<string, FloorStack>;
            facadesById: Record<string, Facade>;
            facadesBySpaceId: Record<string, Facade>;
            connectionsById: Record<string, Connection>;
            doorsById: Record<string, Door>;
            doorsByNodeId: Record<string, Door>;
            poisById: Record<string, PointOfInterest>;
            annotationsById: Record<string, Annotation>;
            areasById: Record<AreaId, Area>;
            locationProfilesById: Record<string, LocationProfile>;
            locationCategoriesById: Record<string, LocationCategory>;
            locationProfilesByCategoryId: Record<string, LocationProfile[]>;
            locationCategoriesByParentId: Record<string, LocationCategory[]>;
            spacesByExternalId: Record<string, Space[]>;
            nodesByExternalId: Record<string, Node[]>;
            poisByExternalId: Record<string, PointOfInterest[]>;
            doorsByExternalId: Record<string, Door[]>;
            floorStacksByExternalId: Record<string, FloorStack[]>;
            floorsByExternalId: Record<string, Floor[]>;
            objectsByExternalId: Record<string, MapObject[]>;
            areasByExternalId: Record<string, Area[]>;
            locationProfilesByExternalId: Record<string, LocationProfile[]>;
            spaceIdsByDestinationNodeId: Record<string, string[]>;
            objectEntranceNodeIdsByObstructionId: Record<string, string[]>;
            obstructionIdByEntranceId: Record<string, string>;
            connectionIdsByLatLon: Record<string, string[]>;
            mvfConnectionIdsByLatLon: Record<string, string[]>;
            locationProfilesByAttachedFeatureId: Record<string, LocationProfile[]>;
            mvfSpacesById: Record<string, SpaceCollection['features'][number]>;
            mvfNodesById: Record<string, NodeCollection['features'][number]>;
            mvfObstructionById: Record<string, ObstructionCollection['features'][number]>;
            mvfFloorsById: Record<string, MVFFloor>;
            mvfFloorStacksById: Record<string, MVFFloorStack>;
            mvfConnectionsById: Record<string, MVFConnection>;
            mvfConnectionsByNodeId: Record<string, MVFConnection>;
            mvfEntrancesById: Record<string, EntranceCollection['features'][number]>;
            mvfAnnotationsById: Record<string, AnnotationCollection['features'][number]>;
            mvfNodesByFloorId: {
                    [floorId: string]: NodeCollection['features'][number][];
            };
            mvfSpacesByFloorId: {
                    [floorId: string]: SpaceCollection['features'][number][];
            };
            mvfPoisByFloorId: {
                    [floorId: string]: FeatureCollection<Point, SpaceProperties>['features'][number][];
            };
            mvfEntrancesByFloorId: {
                    [floorId: string]: EntranceCollection['features'][number][];
            };
            mvfAnnotationsByFloorId: {
                    [floorId: string]: AnnotationCollection['features'][number][];
            };
            mvfAreasById: Record<AreaId, AreaCollection['features'][number]>;
    };
    export type EnterpriseMapDataRecords = {
            connectionsByExternalId: Record<string, Connection[]>;
            locationsByExternalId: Record<string, EnterpriseLocation[]>;
            categoriesByExternalId: Record<string, EnterpriseCategory[]>;
            locationsById: Record<MVFEnterpriseLocationId, EnterpriseLocation>;
            categoriesById: Record<MVFEnterpriseCategoryId, EnterpriseCategory>;
            locationIdsByNodeId: Record<string, MVFEnterpriseLocationId[]>;
            spaceIdsByNodeId: Record<string, SpaceId[]>;
            locationInstancesById: Record<string, EnterpriseLocationInstance>;
            venue: MVFEnterpriseVenue;
            mvfCategoriesById: Record<string, MVFEnterpriseCategory>;
            mvfLocationsById: Record<string, MVFEnterpriseLocation>;
            mvfLocationsBySpaceId: Record<string, MVFEnterpriseLocation[]>;
    };
    export const processMVFLocationProfilesAndCategories: (mvf: ParsedMVF, data: MapDataInternal) => {
            locationCategoriesByParentId: Record<string, LocationCategory[]>;
            locationProfilesById: Record<string, LocationProfile>;
            locationCategoriesById: Record<string, LocationCategory>;
            locationProfilesByExternalId: Record<string, LocationProfile[]>;
            locationProfilesByCategoryId: Record<string, LocationProfile[]>;
            locationProfilesByAttachedFeatureId: Record<string, LocationProfile[]>;
    };
    export const processMVFSpaces: (mvf: ParsedMVF, mvfConnectionsByNodeId: MapDataRecords["mvfConnectionsByNodeId"], data: MapDataInternal) => Pick<MapDataRecords, "spacesById" | "spacesByExternalId" | "spaceIdsByDestinationNodeId" | "poisById" | "poisByExternalId" | "mvfSpacesById" | "objectEntranceNodeIdsByObstructionId" | "connectionsById" | "connectionIdsByLatLon" | "mvfSpacesByFloorId" | "mvfPoisByFloorId">;
    export const processMVFNodes: (mvf: ParsedMVF, data: MapDataInternal) => Pick<MapDataRecords, "nodesById" | "nodesByExternalId" | "mvfNodesById" | "mvfNodesByFloorId">;
    export const processMVFObstructions: (mvf: ParsedMVF, data: MapDataInternal) => Pick<MapDataRecords, "objectsById" | "objectsByExternalId" | "mvfObstructionById" | "obstructionIdByEntranceId">;
    export const processMVFFloors: (mvf: ParsedMVF, data: MapDataInternal) => Pick<MapDataRecords, "floorsById" | "floorsByExternalId" | "mvfFloorsById">;
    export const processMVFFloorStacks: (mvf: ParsedMVF, data: MapDataInternal) => Pick<MapDataRecords, "floorStacksById" | "floorStacksByExternalId" | "mvfFloorStacksById" | "facadesById" | "facadesBySpaceId">;
    export const processMVFConnections: (mvf: ParsedMVF, mvfNodesById?: MapDataRecords["mvfNodesById"]) => Pick<MapDataRecords, "mvfConnectionsById" | "mvfConnectionsByNodeId" | "mvfConnectionIdsByLatLon">;
    export const processMVFEntrances: (mvf: ParsedMVF, data: MapDataInternal) => Pick<MapDataRecords, "doorsById" | "doorsByExternalId" | "doorsByNodeId" | "mvfEntrancesById" | "mvfEntrancesByFloorId">;
    export const processMVFEnterpriseTextures: (mvf: ParsedMVF, spacesById: MapDataRecords["mvfSpacesById"], obstructionsById: MapDataRecords["mvfObstructionById"]) => void;
    export const processMVFAnnotations: (mvf: ParsedMVF, data: MapDataInternal) => Pick<MapDataRecords, "annotationsById" | "mvfAnnotationsById" | "mvfAnnotationsByFloorId">;
    export const processMVFAreas: (mvf: ParsedMVF, data: MapDataInternal) => Pick<MapDataRecords, "areasById" | "areasByExternalId" | "mvfAreasById">;
    /**
        * @internal
        */
    export const createEnterpriseDataFromMVF: (mvf: ParsedMVF, data: MapDataInternal) => EnterpriseMapDataRecords;
    /**
        * @internal
        */
    export const createDataFromMVF: (mvf: ParsedMVF, data: MapDataInternal) => MapDataRecords;
}

declare module '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/location' {
    import type { EnterpriseLocation as MVFEnterpriseLocation, LocationState, OperationHours, SiblingGroup } from '@mappedin/mvf';
    import type { Coordinate, EnterpriseCategory, MapDataInternal, Space } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    import type Node from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/node';
    import BaseMetaData from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/base-metadata-object';
    import type { IFocusable } from '@mappedin/mappedin-js/mappedin-js/src/types';
    /**
        * An EnterpriseLocation contains metadata about a location, such as its name, description, logo, phone number, social medial links, hours of operation and more.
        * They can be accessed using the {@link MapData.getByType} method as shown below.
        *
        * ```typescript
        * const allLocations = mapData.getByType('enterprise-location');
        * ```
        *
        * Refer to the [EnterpriseLocation Guide](https://developer.mappedin.com/web-sdk/enterprise-data#enterprise-locations) for more information and interactive examples.
        */
    class EnterpriseLocation extends BaseMetaData implements Omit<MVFEnterpriseLocation, 'polygons' | 'nodes' | 'links' | 'spaces' | 'categories'>, IFocusable {
            #private;
            /**
                * @internal
                */
            static readonly __type = "enterprise-location";
            /**
                * @internal
                */
            readonly __type = "enterprise-location";
            /**
                * The description of the location.
                */
            description?: string | undefined;
            /**
                * The name of the location.
                */
            name: string;
            /**
                * The amenity of the location.
                */
            amenity?: string | undefined;
            /**
                * The external ID of the location.
                */
            externalId: string;
            /**
                * Extra properties of the location.
                */
            extra?: Record<string, unknown> | undefined;
            /**
                * The gallery of the location.
                */
            gallery?: {
                    caption?: string | null;
                    image: string;
                    embeddedUrl?: string | null;
            }[] | undefined;
            /**
                * Specific instances of this location with different properties.
                * Typically, there will be at least one node or polygon defined,
                * plus one or more other properties that are different from the parent.
                * The remaining properties will be the same as the parent.
    
                * For example, suppose there is a location like this:
                *
                * ```json
                * {
                *   "id": "location-id-1",
                *   "name": "Location 1",
                *   "nodes": ["node-1", "node-2"],
                *   "polygons": ["polygon-1", "polygon-2"],
                *   "externalId": "externalId-1",
                *   "description": "Description 1",
                * }
                * ```
                *
                * (Note that for clarity, this example puts strings in for nodes and polygons, but in practice they would be objects.)
                *
                * Then suppose it had an `instances` array that contained an object that looked like this:
                *
                * ```json
                * {
                *   "id": "instance-id-1",
                *   "name": "Location 1 - A",
                *   "nodes": ["node-1"],
                *   "polygons": ["polygon-1"],
                *   "externalId": "externalId-1-A",
                *   "description": "Description 1",
                * }
                * ```
                * This says "Location 1" is the parent location, and "Location 1 - A" is an instance of it. The instance has a different name, and a different external ID, and it only applies to node `node-1` and polygon `polygon-1`.
                * The ID will always be different, but other properties (like the description) are the same as the parent.
                *
                * Example use cases:
                * - A Mall may have a location with two nodes and one polygon. It may then have an instance with one of the nodes, and operating hours
                * that are different from the parent. This indicates that this instance is an entrance for the location that is accessible at different times, perhaps for an interior mall entrance, when the main location (and other, exterior entrance) is open later than the rest of the mall.
                * - An airport may have a location with several polygons and nodes, and an instance for each node (and corresponding polygon, if any) with a different siblingGroup. The location in the sibling group may be the airport terminal, or airside vs landside.
                * This would allow an application to show the location once in a search result, but offer UX to select the instance that is in the right terminal.
                *
                * Note: Instances are actual EnterpriseLocations. This means they have all the properties of a normal EnterpriseLocation, including an `instances` property, that will always be undefined. They also do NOT have a parent property, or any other explicit reference to the parent location. These instances are
                * only referenced from their parent location, and will not show up in other places in the map data. However, they should otherwise behave like normal EnterpriseLocations, being targetable for things like navigation and focus.
                */
            instances?: EnterpriseLocation[] | undefined;
            /**
                * A URL to the logo of the location.
                */
            logo?: string | undefined;
            /**
                * The operation hours of the location.
                */
            operationHours?: OperationHours[] | undefined;
            /**
                * The phone number of the location.
                */
            phone?: {
                    number: string;
                    extension?: string;
            } | undefined;
            /**
                * A URL to the picture of the location.
                */
            picture?: string | undefined;
            /**
                * The short name of the location.
                */
            shortName?: string | undefined;
            /**
                * Whether to show the floating label when an image is present.
                */
            showFloatingLabelWhenImagePresent?: boolean | undefined;
            /**
                * Whether to show the logo.
                */
            showLogo?: boolean | undefined;
            /**
                * The sibling groups of the location.
                */
            siblingGroups?: SiblingGroup[] | undefined;
            /**
                * The social media links of the location.
                */
            social?: {
                    facebook?: string;
                    instagram?: string;
                    twitter?: string;
                    website?: string;
            } | undefined;
            /**
                * The sort order of the location.
                */
            sortOrder: number;
            /**
                * The {@link LocationState}s of the location.
                */
            states?: LocationState[] | undefined;
            /**
                * The tags of the location.
                */
            tags?: string[] | undefined;
            /**
                * The type of the location.
                */
            type: string;
            /**
                * Checks if the provided instance is of type EnterpriseLocation.
                *
                * @param instance The instance to check.
                * @returns {boolean} True if the instance is a EnterpriseLocation, false otherwise.
                */
            static is(instance: object): instance is EnterpriseLocation;
            /**
                * @internal
                */
            constructor(data: MapDataInternal, options: {
                    mvfData: MVFEnterpriseLocation;
                    categoryIds: string[];
                    locationInstances?: EnterpriseLocation[];
                    parentId?: string;
            });
            /** @internal */
            get focusTarget(): Space[];
            get categories(): EnterpriseCategory[];
            get coordinates(): Coordinate[];
            get nodes(): Node[];
            get spaces(): Space[];
            /**
                * Serializes the EnterpriseLocation data to JSON.
                *
                * @returns An object representing the EnterpriseLocation.
                */
            toJSON(): {
                    id: string;
                    name: string;
            };
            /**
                * Cleans up resources used by the instance.
                *
                * @internal
                */
            destroy(): void;
    }
    export default EnterpriseLocation;
}

declare module '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/category' {
    import type { EnterpriseCategory as MVFEnterpriseCategory } from '@mappedin/mvf';
    import type { MapDataInternal, EnterpriseLocation } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    import BaseMetaData from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/base-metadata-object';
    /**
        * An EnterpriseCategory groups one or more EnterpriseLocation. These allow similar locations to be sorted in a logical fashion.
        * For example a mall may group locations into Food Court, Footwear and Women's Fashion. They can be accessed using the {@link MapData.getByType} method as shown below.
        *
        * ```typescript
        * const categories = mapData.getByType('enterprise-category');
        * ```
        *
        * Refer to the [EnterpriseCategory Guide](https://developer.mappedin.com/web-sdk/enterprise-data#enterprise-categories) for more information and interactive examples.
        */
    class EnterpriseCategory extends BaseMetaData implements Omit<MVFEnterpriseCategory, 'children' | 'locations'> {
            #private;
            /**
                * @internal
                */
            static readonly __type = "enterprise-category";
            /**
                * @internal
                */
            readonly __type = "enterprise-category";
            /**
                * The name of the category.
                */
            name: string;
            /**
                * The color of the category.
                */
            color?: string | undefined;
            /**
                * The external ID of the category.
                */
            externalId: string;
            /**
                * Extra properties of the category.
                */
            extra?: Record<string, unknown> | undefined;
            /**
                * A URL to the icon of the category.
                */
            icon?: string | undefined;
            /**
                * The icon from the default list of icons.
                */
            iconFromDefaultList?: string | null | undefined;
            /**
                * The sort order of the category.
                */
            sortOrder: number;
            /**
                * A URL to the picture of the category.
                */
            picture?: string | undefined;
            /**
                * Checks if the provided instance is of type EnterpriseCategory.
                *
                * @param instance The instance to check.
                * @returns {boolean} True if the instance is a EnterpriseCategory, false otherwise.
                */
            static is(instance: object): instance is EnterpriseCategory;
            /**
                * @internal
                */
            constructor(data: MapDataInternal, options: {
                    mvfData: MVFEnterpriseCategory;
            });
            /**
                * The child categories of the category.
                */
            get children(): EnterpriseCategory[];
            /**
                * The {@link EnterpriseLocation}s within this category.
                */
            get locations(): EnterpriseLocation[];
            /**
                * Serializes the EnterpriseCategory data to JSON.
                *
                * @returns An object representing the EnterpriseCategory.
                */
            toJSON(): {
                    id: string;
                    name: string;
            };
            /**
                * Cleans up resources used by the instance.
                *
                * @internal
                */
            destroy(): void;
    }
    export default EnterpriseCategory;
}

declare module '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/venue' {
    import type { EnterpriseVenue as MVFEnterpriseVenue, Language } from '@mappedin/mvf';
    import type { Hyperlink, MapDataInternal } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    import BaseMetaData from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/base-metadata-object';
    /**
        * The EnterpriseVenue class holds metadata bout the map, which includes the map name, supported languages, default language, top locations and more.
        * It can be accessed using the {@link MapData.getByType} method as shown below.
        *
        * ```typescript
        * const venue = mapData.getByType('enterprise-venue');
        * ```
        *
        * Refer to the [EnterpriseVenue Guide](https://developer.mappedin.com/web-sdk/enterprise-data#enterprise-venue) for more information.
        */
    class EnterpriseVenue extends BaseMetaData implements MVFEnterpriseVenue {
            #private;
            /**
                * @internal
                */
            static readonly __type = "enterprise-venue";
            /**
                * @internal
                */
            readonly __type = "enterprise-venue";
            /**
                * The country code of the venue.
                */
            countrycode?: string | undefined;
            /**
                * The external ID of the venue.
                */
            externalId: string;
            /**
                * The default language of the venue.
                */
            defaultLanguage: Language;
            /**
                * The default map of the venue.
                */
            defaultMap?: string | undefined;
            /**
                * Extra properties of the venue.
                */
            extra?: Record<string, unknown> | undefined;
            /**
                * A URL to the icon of the venue.
                */
            icon?: string | undefined;
            /**
                * The languages supported by the venue.
                */
            languages: Language[];
            /**
                * The links of the venue.
                */
            links: Hyperlink[];
            /**
                * A URL to the logo of the venue.
                */
            logo?: string | undefined;
            /**
                * A URL to a web page with [Mappedin Web](https://developer.mappedin.com/docs/enterprise-apps/mappedin-web-v2) for this venue.
                */
            mappedinWebUrl?: string | undefined;
            /**
                * The slug of the venue.
                */
            slug: string;
            /**
                * The top locations of the venue.
                */
            topLocations?: string[] | undefined;
            /**
                * The timezone ID of the venue.
                */
            tzid?: string | undefined;
            /**
                * Checks if the provided instance is of type EnterpriseVenue.
                *
                * @param instance The instance to check.
                * @returns {boolean} True if the instance is a EnterpriseVenue, false otherwise.
                */
            static is(instance: object): instance is EnterpriseVenue;
            /**
                * @internal
                */
            constructor(_data: MapDataInternal, options: {
                    mvfData: MVFEnterpriseVenue;
            });
            /**
                * Gets the name of the EnterpriseVenue.
                *
                * @returns {string} The name of the EnterpriseVenue.
                */
            get name(): string;
            /**
                * Serializes the EnterpriseVenue data to JSON.
                *
                * @returns An object representing the EnterpriseVenue.
                */
            toJSON(): {
                    id: string;
                    name: string;
            };
            /**
                * Cleans up resources used by the instance.
                *
                * @internal
                */
            destroy(): void;
    }
    export default EnterpriseVenue;
}

declare module '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/location-profile' {
    import type { LocationId, LocationSocial, Location as MVFLocation } from '@mappedin/mvf';
    import BaseMetaData from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/base-metadata-object';
    import type { Annotation, Connection, Door, LocationCategory, MapDataInternal, Space, MapObject, PointOfInterest, Area } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    import type { TFocusTarget, TNavigationTarget, IFocusable, INavigatable } from '@mappedin/mappedin-js/mappedin-js/src/types';
    import { OpeningHours } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/opening-hours';
    import Hyperlink from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/hyperlink';
    import ImageMetaData from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/image';
    type LocationData = Omit<MVFLocation, 'categories' | 'spaces' | 'obstructions' | 'entrances' | 'shapes' | 'connections' | 'annotations' | 'areas' | 'openingHoursSpecification' | 'links' | 'pictures' | 'website' | 'icon'> & {
            links: Hyperlink[];
            images: ImageMetaData[];
            icon?: ImageMetaData;
    };
    class LocationProfile extends BaseMetaData implements LocationData, IFocusable, INavigatable {
            #private;
            /**
                * Checks if the provided instance is of type EnterpriseLocation.
                *
                * @param instance The instance to check.
                * @returns {boolean} True if the instance is a EnterpriseLocation, false otherwise.
                */
            static is(instance: object): instance is LocationProfile;
            /**
                * @internal
                */
            static readonly __type = "location-profile";
            /**
                * @internal
                */
            readonly __type = "location-profile";
            id: LocationId;
            name: string;
            externalId?: string;
            description?: string;
            /**
                * The location's logo
                *
                * @format uri
                */
            logo?: string;
            phone?: string;
            /**
                * The location's social media links.
                */
            social: LocationSocial[];
            /**
                * The location's pictures
                */
            images: ImageMetaData[];
            /**
                * Web links for the location
                */
            links: Hyperlink[];
            /**
                * The location's website
                */
            website?: Hyperlink;
            /**
                * The location's icon to display. Will be either a logo, category, or image
                *
                * @format uri
                */
            icon?: ImageMetaData;
            constructor(data: MapDataInternal, options: {
                    mvfData: MVFLocation;
            });
            /**
                * Gets the {@link Space}s associated with the location.
                *
                * @returns {Space[]} The spaces array.
                */
            get spaces(): Space[];
            /**
                * Gets the {@link PointOfInterest}s associated with the location.
                *
                * @returns {PointOfInterest[]} The points of interest array.
                */
            get points(): PointOfInterest[];
            /**
                * Gets the {@link Door}s associated with the location.
                *
                * @returns {Door[]} The doors array.
                */
            get doors(): Door[];
            /**
                * Gets the {@link Connection}s associated with the location.
                *
                * @returns {Connection[]} The connections array.
                */
            get connections(): Connection[];
            /**
                * Gets the {@link Annotation}s associated with the location.
                *
                * @returns {Annotation[]} The annotations array.
                */
            get annotations(): Annotation[];
            /**
                * Gets the {@link LocationCategory}s associated with the location.
                *
                * @returns {LocationCategory[]} The location categories array.
                */
            get categories(): LocationCategory[];
            /**
                * Gets the {@link MapObject}s associated with the location.
                *
                * @returns {MapObject[]} The map objects array.
                */
            get mapObjects(): MapObject[];
            /**
                * Gets the {@link Area}s associated with the location.
                *
                * @returns {Area[]} The areas array.
                */
            get areas(): Area[];
            /** @internal */
            get focusTarget(): TFocusTarget[];
            /**
                * Gets the {@link OpeningHours} associated with the location.
                *
                * @returns {OpeningHours} The opening hours.
                */
            get openingHours(): OpeningHours;
            /**
                * @internal
                */
            get navigationTarget(): TNavigationTarget[];
            toJSON(): {
                    id: string;
                    name: string;
            };
    }
    export default LocationProfile;
}

declare module '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/location-category' {
    import type { CategoryId, Category as MVFCategory } from '@mappedin/mvf';
    import BaseMetaData from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/base-metadata-object';
    import type { LocationProfile, MapDataInternal } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    class LocationCategory extends BaseMetaData implements Omit<MVFCategory, 'parent'> {
            #private;
            /**
                * Checks if the provided instance is of type EnterpriseLocation.
                *
                * @param instance The instance to check.
                * @returns {boolean} True if the instance is a EnterpriseLocation, false otherwise.
                */
            static is(instance: object): instance is LocationCategory;
            /**
                * @internal
                */
            static readonly __type = "location-category";
            /**
                * @internal
                */
            readonly __type = "location-category";
            id: CategoryId;
            name: string;
            /**
                * The category's icon
                *
                * @format uri
                */
            icon: string;
            constructor(data: MapDataInternal, options: {
                    mvfData: MVFCategory;
            });
            /**
                * Gets the parent {@link LocationCategory}.
                *
                * @returns {LocationCategory | undefined} The parent location category.
                */
            get parent(): LocationCategory | undefined;
            /**
                * Gets the children {@link LocationCategory}s.
                */
            get children(): LocationCategory[];
            /**
                * Gets the {@link LocationProfile}s that are associated with this category.
                */
            get locationProfiles(): LocationProfile[];
            toJSON(): {
                    id: string;
                    name: string;
            };
    }
    export default LocationCategory;
}

declare module '@mappedin/mappedin-js/mappedin-js/src/api-geojson/shapes' {
    import type { GeojsonApiMapObject } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/map-object';
    import { Shape } from '@mappedin/mappedin-js/mappedin-js/src/map-view-objects';
    import type { FeatureCollection, LineString, MultiPolygon, Polygon } from 'geojson';
    import type { LineStyle, PaintStyle } from '@mappedin/core-sdk';
    import type { Floor } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    /**
        * The Shapes class draws 3 dimensional shapes on top of a map. The shapes are created using GeoJSON geometry, which could be a {@link Polygon}, {@link MultiPolygon} (array of polygons) or a {@link LineString}.
        *
        * This class is accessed using {@link MapView.Shapes}.
        *
        * Refer to the [Shapes Guide](https://developer.mappedin.com/web-sdk/shapes) for more information and interactive examples.
        */
    export class Shapes {
            #private;
            /**
                * @internal
                */
            get currentMap(): GeojsonApiMapObject | undefined;
            /**
                * @internal
                */
            constructor({ currentMapGetter }: {
                    currentMapGetter: CurrentMapGetter;
            });
            /**
                * @internal
                */
            getById(id: string): Shape | undefined;
            /**
                * Adds a custom GeoJSON geometry ({@link Shape}) to the map.
                *
                * @param geometry a valid GeoJSON feature collection
                * @param style
                * @param floor Floor to add the geometry to
                * @returns {Shape | undefined} The created shapes, or undefined if creation failed.
                * @example
                *
                * map.Shapes.add(polygons, { color: 'red' }, mapView.currentFloor);
                */
            add<T extends FeatureCollection<Polygon | MultiPolygon | LineString, any>>(geometry: T, style: T extends FeatureCollection<LineString, any> ? LineStyle : PaintStyle, floor?: Floor): Shape;
            /**
                * Removes a specific shape ({@link Shape}) from the map.
                * @param shape The shape to be removed.
                * @example
                * map.Shapes.remove(geo);
                */
            remove(shape: Shape): void;
            /**
                * Removes all Shapes ({@link Shape}) from the map.
                *
                * @example
                * map.Shapes.removeAll();
                */
            removeAll(): string[];
    }
    type CurrentMapGetter = () => GeojsonApiMapObject | undefined;
    export {};
}

declare module '@mappedin/mappedin-js/mappedin-js/src/api-geojson/inspector/inspector' {
    import type MapData from '@mappedin/mappedin-js/mappedin-js/src/map-data';
    import type { MapView } from '@mappedin/mappedin-js/mappedin-js/src/map-view';
    import type { GeoJsonApi } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/api';
    export class Inspector {
        storeStateToLocalStorageEnabled: boolean;
        constructor(mv: MapView, api: GeoJsonApi);
        setMapData(data: MapData): void;
        enable(options?: InspectorOption): Promise<void>;
        get enabled(): boolean;
    }
    export type InspectorState = {
        camera: {
            focusOnClick: boolean;
            padding: [number, number, number, number];
        };
    };
    export type InspectorOption = Partial<InspectorState>;
}

declare module '@mappedin/mappedin-js/mappedin-js/src/map-view-objects/path' {
    import { type Coordinate } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    import type { IFocusable } from '@mappedin/mappedin-js/mappedin-js/src/types';
    /**
        * @experimental
        *
        * A segment of a complete path. This can be a continuous portion of the path on a single floor, or
        * the transition of a path between two floors, or a transition between indoors and outdoors.
        */
    export class PathSegment implements IFocusable {
            readonly id: string;
            readonly coordinates: Coordinate[];
            /**
                * @internal
                */
            static readonly __type = "PathSegment";
            /**
                * @internal
                */
            readonly __type = "PathSegment";
            /**
                * Checks if the provided instance is a PathSegment.
                */
            static is(instance: object): instance is PathSegment;
            constructor(id: string, coordinates: Coordinate[]);
            /** @internal */
            get focusTarget(): Coordinate[];
    }
    /**
        * Class representing a path on the {@link MapView}.
        *
        * Paths are used to indicate a route on the map and can be added and removed using {@link Paths.add} and {@link Paths.remove}.
        */
    export class Path implements IFocusable {
            /**
                * The path's id
                */
            id: string;
            /**
                * The promise that resolves when the current path animation is complete.
                */
            animation: Promise<void>;
            /**
                * The coordinates of the path.
                */
            coordinates: Coordinate[];
            /**
                * @experimental
                *
                * The segments of the path.
                */
            segments: PathSegment[];
            /**
                * @internal
                */
            static readonly __type = "Path";
            /**
                * @internal
                */
            readonly __type = "Path";
            /**
                * Checks if the provided instance is a Path.
                *
                * @param instance The instance to check.
                * @returns {boolean} True if the instance is a Path, false otherwise.
                */
            static is(instance: object): instance is Path;
            /** @internal */
            get focusTarget(): Coordinate[];
            /**
                * @internal
                */
            constructor(id: string, drawAnimation: Promise<void>, coordinates: Coordinate[], segments: {
                    id: string | number;
                    coordinates: Coordinate[];
            }[]);
    }
}

declare module '@mappedin/mappedin-js/mappedin-js/src/api-geojson/types' {
    import type { GeojsonApiMapObject } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/map-object';
    export type CurrentMapGetter = () => GeojsonApiMapObject | undefined;
}

declare module '@mappedin/mappedin-js/geojson/src/components/marker' {
    import '../styles/marker.scss';
    import { Vector2 } from 'three';
    import type { Entity2DHTMLDivElement, EntityId, Position } from '@mappedin/mappedin-js/geojson/src/types';
    import type { GroupContainerState } from '@mappedin/mappedin-js/geojson/src/entities/group-container';
    import type { CollisionRankingTier } from '@mappedin/mappedin-js/geojson/src/utils/collision-ranking-tier';
    import { z } from 'zod';
    import { type PackedBBoxes } from '@mappedin/mappedin-js/geojson/src/systems/collisions/system';
    /**
        * State reprsenting a Marker
        */
    export type MarkerState = {
            readonly id: string | number;
            readonly type: 'marker';
            /**
                * The parent container of the marker
                */
            readonly parent: EntityId<GroupContainerState> | string | number;
            /**
                * The position of the marker in [lon, lat]
                */
            readonly position: Position;
            /**
                * Whether the marker is enabled
                */
            enabled: boolean;
            /**
                * Whether the marker is visible IF is is enabled
                * this can be used to have more granular control of whether the label shows up,
                * for example, if someone implements a layer system that shows/hides
                */
            visible: boolean;
            /**
                * HTML content of the marker as text
                */
            contentHTML?: string;
            /**
                * Pointer to the HTML element of the marker in the DOM tree
                */
            element: HTMLElement;
            /**
                * The initial rank of the marker, which can be used to reset the rank of the marker to its initial value.
                */
            initialRank: CollisionRankingTier | number;
            options?: {
                    /**
                        * The rank of the marker, which determines its visibility in relation to other colliders.
                        */
                    rank?: CollisionRankingTier | number;
                    /**
                        * Whether the Marker should be clickable via the SDK's internal click event system.
                        *
                        * @example
                        * ```javascript
                        * 	renderer.on('click', ({ markers }) => {});
                        * ```
                        */
                    interactive?: boolean | 'pointer-events-auto';
                    /**
                        * The z-index of the marker. Can be used used in conjunction with rank: 'always-visible' to make certain markers appear over others
                        */
                    zIndex?: number;
                    /**
                        * The vertical position of the marker relative to the floor.
                        */
                    verticalOffset?: number;
            };
            /**
                * Anchor point for the marker. This will determine the position of the marker relative to the position. A list will place the marker in the first empty placement.
                */
            anchor: MarkerAnchor | MarkerAnchor[];
            /**
                * Dynamic resize of the marker. If set to true, the marker will resize based on the content.
                */
            dynamicResize: boolean;
    };
    export const addMarkerOptionsSchema: z.ZodObject<{
            rank: z.ZodOptional<z.ZodUnion<[z.ZodEnum<["low", "medium", "high", "always-visible"]>, z.ZodNumber]>>;
            interactive: z.ZodOptional<z.ZodUnion<[z.ZodBoolean, z.ZodLiteral<"pointer-events-auto">]>>;
            id: z.ZodOptional<z.ZodString>;
            anchor: z.ZodOptional<z.ZodUnion<[z.ZodEnum<["top", "bottom", "left", "right", "center", "top-left", "top-right", "bottom-left", "bottom-right"]>, z.ZodArray<z.ZodEnum<["top", "bottom", "left", "right", "center", "top-left", "top-right", "bottom-left", "bottom-right"]>, "many">]>>;
            dynamicResize: z.ZodOptional<z.ZodBoolean>;
            zIndex: z.ZodOptional<z.ZodNumber>;
    }, "strip", z.ZodTypeAny, {
            anchor?: "center" | "left" | "right" | "top" | "bottom" | "top-left" | "top-right" | "bottom-left" | "bottom-right" | ("center" | "left" | "right" | "top" | "bottom" | "top-left" | "top-right" | "bottom-left" | "bottom-right")[] | undefined;
            id?: string | undefined;
            interactive?: boolean | "pointer-events-auto" | undefined;
            dynamicResize?: boolean | undefined;
            zIndex?: number | undefined;
            rank?: number | "low" | "medium" | "high" | "always-visible" | undefined;
    }, {
            anchor?: "center" | "left" | "right" | "top" | "bottom" | "top-left" | "top-right" | "bottom-left" | "bottom-right" | ("center" | "left" | "right" | "top" | "bottom" | "top-left" | "top-right" | "bottom-left" | "bottom-right")[] | undefined;
            id?: string | undefined;
            interactive?: boolean | "pointer-events-auto" | undefined;
            dynamicResize?: boolean | undefined;
            zIndex?: number | undefined;
            rank?: number | "low" | "medium" | "high" | "always-visible" | undefined;
    }>;
    export function validateMarker(coordinate: Position, contentHTML: string, options: AddMarkerOptions): void;
    export type MarkerAnchor = 'top' | 'bottom' | 'left' | 'right' | 'center' | 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';
    /**
        * Options for creating a new Marker
        */
    export type AddMarkerOptions = {
            /**
                * Optional. Determines the collision ranking tier of the marker, which influences its visibility in relation to other colliders.
                * For the possible values ('low', 'medium', 'high', 'always-visible') and their impact on label visibility.
                *
                * See {@link CollisionRankingTier}.
                */
            rank?: CollisionRankingTier;
            /**
                * Whether the Label should be clickable.
                * If `true` the marker will be registered in the SDK interaction events.
                * If `'pointer-events-auto'` the marker will receive browser pointer events.
                * @default false
                */
            interactive?: boolean | 'pointer-events-auto';
            /**
                * @internal
                */
            id?: string;
            /**
                * Anchor point for the marker. This will determine the position of the marker relative to the position. A list will place the marker in the first empty placement.
                */
            anchor?: MarkerAnchor | MarkerAnchor[];
            /**
                * Dynamic resize of the marker. If set to true, the marker will resize based on the content.
                */
            dynamicResize?: boolean;
            /**
                * @internal
                */
            occluderId?: number;
            /**
                * The z-index of the marker. Can be used used in conjunction with rank: 'always-visible' to make certain markers appear over others
                */
            zIndex?: number;
            /**
                * The vertical position of the marker relative to the floor.
                */
            verticalOffset?: number;
    };
    export class MarkerComponent {
            id: string | number;
            readonly type = "marker";
            static testId: number;
            rank: number;
            initialRank: number;
            activeAnchor: MarkerAnchor;
            pointerEvents: 'auto' | 'none';
            options: Required<Omit<AddMarkerOptions, 'zIndex'>> & {
                    zIndex?: number;
            };
            projection: Vector2;
            enabled: boolean;
            /**
                * Whether the marker can be shown, which is decided by the collision engine
                */
            canShow: boolean;
            visible: boolean;
            isOccluded: boolean;
            offscreen: boolean;
            strategyIndex: number;
            activeBoundingBox: {
                    x: number;
                    y: number;
                    w: number;
                    h: number;
            };
            containerEl: Entity2DHTMLDivElement;
            contentEl: HTMLDivElement | null;
            contentHtml: string;
            style: {
                    top: string;
                    left: string;
            };
            dirty: boolean;
            /** Flag used in 2d-projection system to determine if the parent has changed */
            parentDirty: boolean;
            collisionDirty: boolean;
            visibilityNeedsUpdate: 'show' | 'hide' | false;
            constructor(contentHtml: string, options?: AddMarkerOptions);
            updateDimensions(width?: number, height?: number): void;
            animation: Animation | null;
            currentStrategyIndex: number;
            onStrategySelected: (strategyIndex: number, force?: boolean) => void;
            get strategies(): {
                    name: MarkerAnchor;
                    getBoundingBox: () => number[];
            }[];
            toPackedMessage(isPanning?: boolean): {
                    x: number;
                    y: number;
                    enabled: boolean;
                    rank: number;
                    bboxes: PackedBBoxes;
                    lockedToStrategyIndex: number;
                    shouldCollideWithScreenEdges: boolean;
            };
            destroy(): void;
    }
}

declare module '@mappedin/mappedin-js/geojson/src/components/path' {
    import { Vector3 } from 'three';
    import type { BufferGeometry, LineSegments } from 'three';
    import type { EntityId, Position } from '@mappedin/mappedin-js/geojson/src/types';
    import type { PathMaterial, PatMeshContainer } from '@mappedin/mappedin-js/geojson/src/entities/geometry3d';
    import type { FeatureCollection, Point } from 'geojson';
    import type { GroupContainerState } from '@mappedin/mappedin-js/geojson/src/entities/group-container';
    import { z } from 'zod';
    export type PathProperties = {
            /**
                * The parentId of the point. The point will be anchored to the altitude of this parent group container.
                */
            parentId?: EntityId<GroupContainerState> | string | null;
    };
    /**
        * Updatable path state
        * @interface
        */
    export type PathUpdateState = Omit<Partial<PathState>, 'id' | 'type'>;
    /**
        * State representing a Path
        */
    export type PathState = {
            readonly id: string | number;
            readonly type: 'path';
            /**
                * The position of the path in [lon, lat]
                */
            readonly position: Position;
            /**
                * The altitude of the geometry, in meters
                */
            altitude?: number;
            /**
                * Whether the path is visible.
                */
            visible: boolean;
            /**
                * Whether the path is interactive, which means it can be hovered over and clicked on.
                *
                * @example
                * ```javascript
                * 	renderer.on('click', ({ geometry }) => {});
                * ```
                */
            interactive?: boolean;
            /**
                * The fraction of the path that has been drawn. This can be used to animate the drawing of the path.
                * Note: use values between 0 and 1.
                */
            completeFraction: number;
            /**
                * The color of the path.
                */
            color: string;
            /**
                * The accent color of the path. When arrows are visible, it is applied to them
                */
            accentColor: string;
            /**
                * Display Arrows on Path to indicate direction
                */
            displayArrowsOnPath: boolean;
            /**
                * Arrows on path should animate to indicate direction
                */
            animateArrowsOnPath: boolean;
            /**
                * The radius of the path when zoomed in
                */
            nearRadius: number;
            /**
                * The zoom level at which the near radius is applied
                */
            nearZoomLevel?: number;
            /**
                * The radius of the path when zoomed out
                */
            farRadius: number;
            /**
                * The zoom level at which the far radius is applied
                */
            farZoomLevel?: number;
    };
    export type AddPathOptions = {
            /**
                * Whether the Path should be clickable.
                * @default false
                */
            interactive?: boolean;
            /**
                * @internal
                */
            id?: string | number;
            /**
                * The radius of the path when zoomed in
                */
            nearRadius?: number;
            /**
                * The zoom level at which the near radius is applied
                */
            nearZoomLevel?: number;
            /**
                * The radius of the path when zoomed out
                */
            farRadius?: number;
            /**
                * The zoom level at which the far radius is applied
                */
            farZoomLevel?: number;
            /**
                * The color of the path.
                */
            color?: string;
            /**
                * The accent color of the path. When arrows are visible, it is applied to them
                */
            accentColor?: string;
            /**
                * Display Arrows on Path to indicate direction
                */
            displayArrowsOnPath?: boolean;
            /**
                * Arrows on path should animate to indicate direction
                */
            animateArrowsOnPath?: boolean;
    };
    export const addPathOptionsSchema: z.ZodObject<{
            interactive: z.ZodOptional<z.ZodBoolean>;
            id: z.ZodOptional<z.ZodString>;
            nearRadius: z.ZodOptional<z.ZodNumber>;
            farRadius: z.ZodOptional<z.ZodNumber>;
            accentColor: z.ZodOptional<z.ZodString>;
            displayArrowsOnPath: z.ZodOptional<z.ZodBoolean>;
            animateArrowsOnPath: z.ZodOptional<z.ZodBoolean>;
            nearZoomLevel: z.ZodOptional<z.ZodNumber>;
            farZoomLevel: z.ZodOptional<z.ZodNumber>;
    }, "strip", z.ZodTypeAny, {
            id?: string | undefined;
            interactive?: boolean | undefined;
            accentColor?: string | undefined;
            displayArrowsOnPath?: boolean | undefined;
            animateArrowsOnPath?: boolean | undefined;
            nearRadius?: number | undefined;
            nearZoomLevel?: number | undefined;
            farRadius?: number | undefined;
            farZoomLevel?: number | undefined;
    }, {
            id?: string | undefined;
            interactive?: boolean | undefined;
            accentColor?: string | undefined;
            displayArrowsOnPath?: boolean | undefined;
            animateArrowsOnPath?: boolean | undefined;
            nearRadius?: number | undefined;
            nearZoomLevel?: number | undefined;
            farRadius?: number | undefined;
            farZoomLevel?: number | undefined;
    }>;
    export const featureSchema: z.ZodObject<{
            type: z.ZodEnum<["Feature"]>;
            geometry: z.ZodObject<{
                    type: z.ZodEnum<["Point"]>;
                    coordinates: z.ZodArray<z.ZodNumber, "many">;
            }, "strip", z.ZodTypeAny, {
                    type: "Point";
                    coordinates: number[];
            }, {
                    type: "Point";
                    coordinates: number[];
            }>;
            properties: z.ZodObject<{
                    parentId: z.ZodOptional<z.ZodAny>;
            }, "strip", z.ZodTypeAny, {
                    parentId?: any;
            }, {
                    parentId?: any;
            }>;
    }, "strip", z.ZodTypeAny, {
            type: "Feature";
            geometry: {
                    type: "Point";
                    coordinates: number[];
            };
            properties: {
                    parentId?: any;
            };
    }, {
            type: "Feature";
            geometry: {
                    type: "Point";
                    coordinates: number[];
            };
            properties: {
                    parentId?: any;
            };
    }>;
    export function validatePath(geometry: FeatureCollection<Point, PathProperties>, options: AddPathOptions): void;
    export class PathComponent {
            #private;
            readonly type = "path";
            mesh: PatMeshContainer;
            material?: PathMaterial;
            geometry?: BufferGeometry;
            outline?: LineSegments;
            feature: FeatureCollection<Point, PathProperties>;
            options: AddPathOptions;
            nearRadius: number;
            farRadius: number;
            nearZoomLevel?: number;
            farZoomLevel?: number;
            nearZoomAltitude?: number;
            farZoomAltitude?: number;
            accentColor: string;
            completeFraction: number;
            altitudeAdjustment: number;
            displayArrowsOnPath: boolean;
            animateArrowsOnPath: boolean;
            /**
                * If the path is vertical it will be rebuilt whenever altitudeDirty = true. This will be set during the first render of the path.
                */
            isVertical: boolean;
            dirty: boolean;
            materialDirty: boolean;
            constructor(feature: FeatureCollection<Point, PathProperties>, options?: AddPathOptions);
            setColor(): void;
            setOpacity(): void;
            set visible(visible: boolean);
            get visible(): boolean;
            position: Vector3;
            get altitude(): number;
            set altitude(value: number);
            set complete(value: number);
    }
}

declare module '@mappedin/mappedin-js/geojson/src/components/label' {
    import { Vector2 } from 'three';
    import type { TDrawFn } from '@packages/internal/shave-text/shave-text';
    import type { EntityId, Position } from '@mappedin/mappedin-js/geojson/src/types';
    import type { GroupContainerState } from '@mappedin/mappedin-js/geojson/src/entities/group-container';
    import type { RendererState } from '@mappedin/mappedin-js/geojson/src/renderer';
    import type { CollisionRankingTier, GeometryState } from '@mappedin/mappedin-js/geojson/src';
    import { z } from 'zod';
    import type { PackedBBoxes } from '@mappedin/mappedin-js/geojson/src/systems/collisions/system';
    export const addLabelOptionsSchema: z.ZodObject<{
            rank: z.ZodOptional<z.ZodUnion<[z.ZodEnum<["low", "medium", "high", "always-visible"]>, z.ZodNumber]>>;
            interactive: z.ZodOptional<z.ZodBoolean>;
            appearance: z.ZodOptional<z.ZodObject<{
                    margin: z.ZodOptional<z.ZodNumber>;
                    text: z.ZodOptional<z.ZodObject<{
                            numLines: z.ZodOptional<z.ZodNumber>;
                            lineHeight: z.ZodOptional<z.ZodNumber>;
                            size: z.ZodOptional<z.ZodNumber>;
                            maxWidth: z.ZodOptional<z.ZodNumber>;
                            foregroundColor: z.ZodOptional<z.ZodString>;
                            backgroundColor: z.ZodOptional<z.ZodString>;
                    }, "strip", z.ZodTypeAny, {
                            size?: number | undefined;
                            maxWidth?: number | undefined;
                            lineHeight?: number | undefined;
                            backgroundColor?: string | undefined;
                            numLines?: number | undefined;
                            foregroundColor?: string | undefined;
                    }, {
                            size?: number | undefined;
                            maxWidth?: number | undefined;
                            lineHeight?: number | undefined;
                            backgroundColor?: string | undefined;
                            numLines?: number | undefined;
                            foregroundColor?: string | undefined;
                    }>>;
                    marker: z.ZodOptional<z.ZodObject<{
                            size: z.ZodOptional<z.ZodNumber>;
                            foregroundColor: z.ZodOptional<z.ZodObject<{
                                    active: z.ZodOptional<z.ZodString>;
                                    inactive: z.ZodOptional<z.ZodString>;
                            }, "strip", z.ZodTypeAny, {
                                    active?: string | undefined;
                                    inactive?: string | undefined;
                            }, {
                                    active?: string | undefined;
                                    inactive?: string | undefined;
                            }>>;
                            backgroundColor: z.ZodOptional<z.ZodObject<{
                                    active: z.ZodOptional<z.ZodString>;
                                    inactive: z.ZodOptional<z.ZodString>;
                            }, "strip", z.ZodTypeAny, {
                                    active?: string | undefined;
                                    inactive?: string | undefined;
                            }, {
                                    active?: string | undefined;
                                    inactive?: string | undefined;
                            }>>;
                    }, "strip", z.ZodTypeAny, {
                            size?: number | undefined;
                            backgroundColor?: {
                                    active?: string | undefined;
                                    inactive?: string | undefined;
                            } | undefined;
                            foregroundColor?: {
                                    active?: string | undefined;
                                    inactive?: string | undefined;
                            } | undefined;
                    }, {
                            size?: number | undefined;
                            backgroundColor?: {
                                    active?: string | undefined;
                                    inactive?: string | undefined;
                            } | undefined;
                            foregroundColor?: {
                                    active?: string | undefined;
                                    inactive?: string | undefined;
                            } | undefined;
                    }>>;
            }, "strip", z.ZodTypeAny, {
                    text?: {
                            size?: number | undefined;
                            maxWidth?: number | undefined;
                            lineHeight?: number | undefined;
                            backgroundColor?: string | undefined;
                            numLines?: number | undefined;
                            foregroundColor?: string | undefined;
                    } | undefined;
                    margin?: number | undefined;
                    marker?: {
                            size?: number | undefined;
                            backgroundColor?: {
                                    active?: string | undefined;
                                    inactive?: string | undefined;
                            } | undefined;
                            foregroundColor?: {
                                    active?: string | undefined;
                                    inactive?: string | undefined;
                            } | undefined;
                    } | undefined;
            }, {
                    text?: {
                            size?: number | undefined;
                            maxWidth?: number | undefined;
                            lineHeight?: number | undefined;
                            backgroundColor?: string | undefined;
                            numLines?: number | undefined;
                            foregroundColor?: string | undefined;
                    } | undefined;
                    margin?: number | undefined;
                    marker?: {
                            size?: number | undefined;
                            backgroundColor?: {
                                    active?: string | undefined;
                                    inactive?: string | undefined;
                            } | undefined;
                            foregroundColor?: {
                                    active?: string | undefined;
                                    inactive?: string | undefined;
                            } | undefined;
                    } | undefined;
            }>>;
    }, "strip", z.ZodTypeAny, {
            interactive?: boolean | undefined;
            rank?: number | "low" | "medium" | "high" | "always-visible" | undefined;
            appearance?: {
                    text?: {
                            size?: number | undefined;
                            maxWidth?: number | undefined;
                            lineHeight?: number | undefined;
                            backgroundColor?: string | undefined;
                            numLines?: number | undefined;
                            foregroundColor?: string | undefined;
                    } | undefined;
                    margin?: number | undefined;
                    marker?: {
                            size?: number | undefined;
                            backgroundColor?: {
                                    active?: string | undefined;
                                    inactive?: string | undefined;
                            } | undefined;
                            foregroundColor?: {
                                    active?: string | undefined;
                                    inactive?: string | undefined;
                            } | undefined;
                    } | undefined;
            } | undefined;
    }, {
            interactive?: boolean | undefined;
            rank?: number | "low" | "medium" | "high" | "always-visible" | undefined;
            appearance?: {
                    text?: {
                            size?: number | undefined;
                            maxWidth?: number | undefined;
                            lineHeight?: number | undefined;
                            backgroundColor?: string | undefined;
                            numLines?: number | undefined;
                            foregroundColor?: string | undefined;
                    } | undefined;
                    margin?: number | undefined;
                    marker?: {
                            size?: number | undefined;
                            backgroundColor?: {
                                    active?: string | undefined;
                                    inactive?: string | undefined;
                            } | undefined;
                            foregroundColor?: {
                                    active?: string | undefined;
                                    inactive?: string | undefined;
                            } | undefined;
                    } | undefined;
            } | undefined;
    }>;
    export function validateLabel(coordinate: Position | EntityId<GeometryState>, text: string, options: AddLabelOptions): void;
    export const labelThemes: {
            lightOnDark: {
                    text: {
                            foregroundColor: string;
                            backgroundColor: string;
                            numLines: number;
                            lineHeight: number;
                            size: number;
                            maxWidth: number;
                    };
                    marker: {
                            foregroundColor: {
                                    active: string;
                                    inactive: undefined;
                            };
                            backgroundColor: {
                                    active: string;
                                    inactive: undefined;
                            };
                            size: number;
                    };
                    margin: number;
            };
            darkOnLight: {
                    text: {
                            foregroundColor: string;
                            backgroundColor: string;
                            numLines: number;
                            lineHeight: number;
                            size: number;
                            maxWidth: number;
                    };
                    marker: {
                            foregroundColor: {
                                    active: string;
                                    inactive: undefined;
                            };
                            backgroundColor: {
                                    active: string;
                                    inactive: undefined;
                            };
                            size: number;
                    };
                    margin: number;
            };
    };
    export const COLLIDER_STRATEGY_LOW_PRIORITY = "LOW_PRIORITY";
    /**
        * Control how a Label looks
        */
    export type LabelAppearance = {
            /**
                * Margin around the label and marker in pixels. This will affect label density. Minimum is 6px.
                * @default 6
                */
            margin?: number;
            text?: {
                    /**
                        * Number of lines to display when text spans multiple lines.
                        */
                    numLines?: number;
                    /**
                        * Text size in pixels
                        */
                    size?: number;
                    /**
                        * Maxiumum width of text in pixels.
                        */
                    maxWidth?: number;
                    /**
                        * Line height sets the height of a line box. It's commonly used to set the distance between lines of text.
                        *
                        * @default 1.2
                        */
                    lineHeight?: number;
                    /**
                        * Text foreground color. Color can be set using CSS colors names `DarkGoldenRod`, as Hex strings `#0000FF` or the rgb values `rgb(255,0,0)`.
                        */
                    foregroundColor?: string;
                    /**
                        * Text background color. Color can be set using CSS colors names `DarkGoldenRod`, as Hex strings `#0000FF` or the rgb values `rgb(255,0,0)`.
                        */
                    backgroundColor?: string;
            };
            marker?: {
                    foregroundColor?: {
                            /**
                                * Foreground color of the marker when it is active. Color can be set using CSS colors names `DarkGoldenRod`, as Hex strings `#0000FF` or the rgb values `rgb(255,0,0)`.
                                */
                            active?: string;
                            /**
                                * Foreground color of the marker when it is inactive (grayed out due to being outranked by other labels around). Color can be set using CSS colors names `DarkGoldenRod`, as Hex strings `#0000FF` or the rgb values `rgb(255,0,0)`.
                                */
                            inactive?: string;
                    };
                    backgroundColor?: {
                            /**
                                * Background color of the marker when it is active. Color can be set using CSS colors names `DarkGoldenRod`, as Hex strings `#0000FF` or the rgb values `rgb(255,0,0)`.
                                */
                            active?: string;
                            /**
                                * Background color of the marker when it is inactive (grayed out due to being outranked by other labels around). Color can be set using CSS colors names `DarkGoldenRod`, as Hex strings `#0000FF` or the rgb values `rgb(255,0,0)`.
                                */
                            inactive?: string;
                    };
                    /**
                        * Size of bounding box of the icon
                        * @default 20
                        */
                    iconSize?: number;
                    /**
                        * Icon to be placed inside the Floating Label marker. Supports SVG or a URL to png or jpeg.
                        * @example
                        * ```ts
                        * // SVG
                        * mapView.FloatingLabels.add(polygon, "Label", {
                        * 	appearance: {
                        * 		marker: {
                        * 			icon: `<svg>...</svg>`,
                        * 		},
                        * 	},
                        * });
                        * ```
                        *
                        * @example
                        * ```ts
                        * // Image URL
                        * mapView.FloatingLabels.add(polygon, "Label", {
                        * 	appearance: {
                        * 		marker: {
                        * 			icon: 'https://example.com/icon.png',
                        * 		},
                        * 	},
                        * });
                        * ```
                        */
                    icon?: string;
                    /**
                        * Padding between the icon and the marker's border in pixels.
                        * @default 2
                        */
                    iconPadding?: number;
                    /**
                        * How the icon should fit inside the marker.
                        *  - `fill` will stretch the icon to fill the marker.
                        *  - `cover` will maintain aspect ratio and fill the marker.
                        *  - `contain` will maintain aspect ratio and fit the icon inside the marker.
                        * @default 'cover'
                        */
                    iconFit?: 'contain' | 'fill' | 'cover';
                    /**
                        * Whether the icon should overflow the circle of the marker.
                        * @default 'hidden'
                        */
                    iconOverflow?: 'visible' | 'hidden';
                    /**
                        * Defines the zoom level at which the icon becomes visible.
                        * Infinity ensures the icon is never visible.
                        * -Infinity ensures the icon is always visible.
                        * @default -Infinity
                        */
                    iconVisibleAtZoomLevel?: number;
            };
    };
    /**
        * Options for creating a new Label
        */
    export type AddLabelOptions = {
            /**
                * Optional. Determines the collision ranking tier of the label, which influences its visibility in relation to other colliders.
                * For the possible values ('low', 'medium', 'high', 'always-visible') and their impact on label visibility.
                *
                * See {@link CollisionRankingTier}.
                */
            rank?: CollisionRankingTier;
            /**
                * Customize the appearance of the Label and its pin
                */
            appearance?: LabelAppearance;
            /**
                * Whether the Label should be clickable.
                * @default false
                */
            interactive?: boolean;
            /**
                * @internal
                */
            id?: string;
            /**
                * @internal
                */
            occluderId?: number;
            /**
                * The vertical position of the label relative to the floor.
                */
            verticalOffset?: number;
    };
    type TStyle = {
            top?: number;
            left?: number;
            textLabelVisible?: boolean;
            pinVisibility: PINVISIBILITY;
            textAlign?: TEXTALIGN;
            cachedSymbol?: HTMLCanvasElement;
    };
    type LabelAppearanceFillenIn = {
            margin: number;
            text: {
                    numLines: number;
                    lineHeight: number;
                    size: number;
                    maxWidth: number;
                    foregroundColor: string;
                    backgroundColor: string;
            };
            marker: {
                    foregroundColor: {
                            active: string;
                            inactive: string;
                    };
                    backgroundColor: {
                            active: string;
                            inactive: string;
                    };
                    iconSize?: number;
                    iconPadding: number;
                    iconFit: 'fill' | 'contain' | 'cover';
                    iconOverflow: 'visible' | 'hidden';
                    icon?: string;
                    iconVisibleAtZoomLevel?: number;
            };
    };
    export type LabelOptions = {
            id?: string;
            shortText?: string;
            text?: string;
            rank?: number;
            /**
                * Customize the appearance of the Smart Label and its marker
                */
            appearance?: LabelAppearance;
            createDespiteImage?: boolean;
            interactive?: boolean;
    };
    enum PINVISIBILITY {
            OPAQUE = 1,
            SEMI_TRANSPARENT = 0.5
    }
    enum TEXTALIGN {
            LEFT = "left",
            CENTER = "center",
            RIGHT = "right"
    }
    /**
        * State reprsenting a Label
        */
    export type LabelState = {
            readonly id: string | number;
            readonly type: 'label';
            /**
                * The position of the label in [lon, lat]
                */
            readonly position: Position;
            /**
                * The parent container of the label
                */
            readonly parent: EntityId<GroupContainerState>;
            /**
                * Whether the label is enabled
                */
            enabled: boolean;
            /**
                * Whether the label is visible IF is is enabled
                * this can be used to have more granular control of whether the label shows up,
                * for example, if someone implements a layer system that shows/hides,
                */
            visible: boolean;
            /**
                * Text content of the label
                */
            text: string;
            /**
                * The initial rank of the label, which can be used to reset the rank of the label to its initial value.
                */
            initialRank: CollisionRankingTier;
            /**
                * Options for the label
                */
            options: Omit<AddLabelOptions, 'id'>;
            /**
                * vertical offset of the model in meters off the floor
                */
            verticalOffset: number;
    };
    export class LabelComponent {
            lines: number;
            id: string;
            rank: number;
            readonly type = "label";
            initialRank: number;
            contextConfigured: boolean;
            fillText: TDrawFn | undefined;
            newStyle: TStyle;
            static testId: number;
            opacity: number;
            visibilityNeedsUpdate: 'show' | 'hide' | false;
            text: string;
            style: TStyle;
            projection: Vector2;
            labelCacheId?: string;
            _cache: {};
            appearance: LabelAppearanceFillenIn;
            options: LabelOptions;
            /**
                * Whether the anchored parent is visible.
                */
            visible: boolean;
            enabled: boolean;
            isOccluded: boolean;
            offscreen: boolean;
            /**
                * Whether the label can be shown, which is decided by the collision engine
                */
            canShow: boolean;
            activeBoundingBox: {
                    x: number;
                    y: number;
                    w: number;
                    h: number;
            };
            dimensions: {
                    width: number;
                    height: number;
            };
            currentStrategyIndex: number;
            totalMarkerSize: number;
            dirty: boolean;
            /** Flag used in 2d-projection system to determine if the parent has changed */
            parentDirty: boolean;
            collisionDirty: boolean;
            lastTextAlign: any;
            imageHash?: number;
            markerSize: number;
            iconVisible: boolean;
            dp: (v?: number) => number;
            setEntity(): void;
            constructor(text: string, options: AddLabelOptions, state: RendererState);
            calculateMarkerSize(): void;
            get lowPriorityStrategyIndex(): 3 | -1;
            get strategies(): any[];
            animate: boolean;
            onStrategySelected: (strategyIndex: any) => void;
            updatePosition(): void;
            disable(): void;
            toPackedMessage(isPanning?: boolean): {
                    x: number;
                    y: number;
                    enabled: boolean;
                    rank: number;
                    bboxes: PackedBBoxes;
                    shouldCollideWithScreenEdges: boolean;
                    lockedToStrategyIndex: number;
            };
            destroy(): void;
    }
    export default LabelComponent;
}

declare module '@mappedin/mappedin-js/geojson/src/entities/group-container' {
    import { Object3D } from 'three';
    import type { GeometryGroupState } from '@mappedin/mappedin-js/geojson/src/entities/geometry-group';
    import { GeometryGroupObject3D } from '@mappedin/mappedin-js/geojson/src/entities/geometry-group';
    import { Geometry2D } from '@mappedin/mappedin-js/geojson/src/entities/geometry2d';
    import type { StackComponent } from '@mappedin/mappedin-js/geojson/src/components/stack';
    import type { MarkerState } from '@mappedin/mappedin-js/geojson/src/components/marker';
    import type { LabelState } from '@mappedin/mappedin-js/geojson/src/components/label';
    import type { Geometry3DTypes } from '@mappedin/mappedin-js/geojson/src/entities/geometry3d';
    import { Geometry3D } from '@mappedin/mappedin-js/geojson/src/entities/geometry3d';
    import type { PathState } from '@mappedin/mappedin-js/geojson/src/components/path';
    import type { InteractionComponent } from '@mappedin/mappedin-js/geojson/src/components/interaction';
    import type { BatchedText } from '@mappedin/mappedin-js/geojson/src/services/text3d/text3d';
    import type { EntityTypes } from '@mappedin/mappedin-js/geojson/src/renderer';
    import type { Feature, MultiPolygon, Polygon } from 'geojson';
    export enum GroupContainerComponents {
            Stack = 0,
            Interaction = 1
    }
    /**
        * State representing a Group Container, which is a container for other Group Containers, Geometry Groups, Labels, Markers and Paths.
        */
    export type GroupContainerState = {
            readonly id: string | number;
            readonly type: 'group-container';
            /**
                * The states of the children of the group container
                */
            readonly children: (PathState | MarkerState | LabelState | GroupContainerState | GeometryGroupState)[];
            /**
                * Whether the group container is visible
                */
            visible: boolean;
            /**
                * The altitude of the group container above the ground in meters
                */
            altitude: number;
            interactive: boolean;
            /**
                * The opacity of the group container, which sets the opacity of all its children
                */
            opacity: number;
    };
    export class GroupContainerObject3D extends Object3D {
            childrenIds: Set<string | number>;
            children: (GroupContainerObject3D | GeometryGroupObject3D | BatchedText | Geometry2D['object3d'] | NonNullable<Geometry3D['object3d']>)[];
            readonly type: "group-container";
            userData: {
                    entityId: string | number;
                    entities2D: Set<string | number>;
                    dirty: boolean;
                    occluderDirty: boolean;
                    occluderId?: number;
                    occluderFeature?: Feature<Polygon | MultiPolygon, any>;
                    opacity: number;
                    /** The effective opacity of the entity after all parent containers have been considered. */
                    computedOpacity: number;
            };
            components: [StackComponent?, InteractionComponent?];
            constructor(id: string);
            addOccluderFeature(feature: Feature<Polygon | MultiPolygon, any>, occluderId: number): void;
            addEntity(entityGroupOrContainer: GroupContainerObject3D | GeometryGroupObject3D | Geometry2D | Geometry3DTypes): void;
            removeEntity(entityGroupOrContainer: EntityTypes): void;
            setVisible(visible: boolean): void;
            setAltitude(altitude: number): void;
            get altitude(): number;
            setOpacity(opacity: number): void;
            get opacity(): number;
    }
}

declare module '@mappedin/mappedin-js/geojson/src/entities/geometry-group' {
    import type { LineStyle, PaintStyle, Shading } from '@mappedin/mappedin-js/geojson/src/types';
    import { Object3D } from 'three';
    import { type GeometryState } from '@mappedin/mappedin-js/geojson/src/components/mesh';
    import type { ModelState } from '@mappedin/mappedin-js/geojson/src/components/model';
    import { GeometryGroupStyleComponent } from '@mappedin/mappedin-js/geojson/src/components/geometry-group-style';
    export enum GeometryGroupComponents {
            GeometryGroupStyle = 0
    }
    /**
        * State representing a Geometry Group, which is a container for Geometries and Models.
        */
    export type GeometryGroupState = {
            readonly id: string | number;
            readonly type: 'geometry-group';
            /**
                * The states of the children of the geometry group
                */
            readonly children: (GeometryState | ModelState)[];
            /**
                * Whether the geometry group is visible
                */
            visible: boolean;
            /**
                * Whether the geometry group is interactive, which means it can be hovered over and clicked on.
                * This will affect all children of the geometry group and override their interactive state.
                *
                * @example
                * ```javascript
                * 	renderer.on('click', ({ geometry }) => {});
                * ```
                */
            interactive: boolean;
            /**
                * The opacity of the geometry group. This will affect all children of the geometry group and override their opacity.
                */
            opacity: number;
            /**
                * The initial color of the geometry and its children. This is used to reset the color of the geometry to its initial value.
                */
            initialColor: string;
            /**
                * The color of the geometry and its children. Updating this will affect any children whose color was not updated after generation
                */
            color: string;
            /**
                * The initial top color of the geometry and its children. This is used to reset the top color of the geometry to its initial value.
                */
            initialTopColor?: string;
            /**
                * The top color of the geometry and its children. Updating this will affect any children whose top color was not updated after generation
                */
            topColor?: string;
            /**
                * The shading of the geometry and its children. Updating this will affect all children of the geometry group.
                */
            shading?: Shading;
            /**
                * Whether the geometry and its children are outlined. This will affect all children of the geometry group and override their outline state.
                */
            outline?: boolean;
            /**
                * The texture URL of the geometry
                */
            texture?: string;
            /**
                * The top texture URL of the geometry
                */
            topTexture?: string;
            /**
                * altitude of the geometry group
                */
            altitude?: number;
            /**
                * height of the geometry group
                */
            height?: number;
    };
    export type ChildUpdatable<T> = T extends LineStyle ? Partial<Pick<LineStyle, 'color' | 'opacity' | 'visible'>> : Partial<Pick<PaintStyle, 'color' | 'opacity' | 'visible'>>;
    export class GeometryGroupObject3D extends Object3D {
            visible: boolean;
            readonly type: "geometry-group";
            components: [GeometryGroupStyleComponent];
            userData: {
                    entityId: string | number;
                    entities3D: Set<string | number>;
                    modelURL?: string;
                    opacity: number;
                    dirty: boolean;
                    outlineDirty: boolean;
                    shadingDirty: boolean;
            };
            setVisible(visible: boolean): void;
            getOpacity(): number;
            setOpacity(opacity: number): void;
            removeEntity(): void;
            constructor(id: string, style?: GeometryGroupStyleComponent);
            /**
                * Get first child entity of a group if it's a batched mesh
                * We use this logic a lot for getting the material of the group. since group does not have material and batched mesh does
                */
            getfirstChildEntityId(): string | number | undefined;
            setAltitude(altitude: number): void;
            get altitude(): number;
    }
}

declare module '@mappedin/mappedin-js/geojson/src/types/geometry' {
    export type Position = [lon: number, lat: number] | [lon: number, lat: number, alt: number];
}

declare module '@mappedin/mappedin-js/geojson/src/types' {
    import type { Camera } from 'three';
    import { Mesh, Object3D, InstancedMesh } from 'three';
    import type { Geometry2D } from '@mappedin/mappedin-js/geojson/src/entities/geometry2d';
    import type { Position } from '@mappedin/mappedin-js/geojson/src/types/geometry';
    import type { GeometryState } from '@mappedin/mappedin-js/geojson/src/components/mesh';
    import type { GeometryGroupObject3D, GeometryGroupState } from '@mappedin/mappedin-js/geojson/src/entities/geometry-group';
    import type { GroupContainerObject3D, GroupContainerState } from '@mappedin/mappedin-js/geojson/src/entities/group-container';
    import type { PathState } from '@mappedin/mappedin-js/geojson/src/components/path';
    import type { ModelState } from '@mappedin/mappedin-js/geojson/src/components/model';
    import type { LabelState } from '@mappedin/mappedin-js/geojson/src/components/label';
    import type { MarkerState } from '@mappedin/mappedin-js/geojson/src/components/marker';
    import type { ImageState } from '@mappedin/mappedin-js/geojson/src/components/image';
    import type { ShapeState } from '@mappedin/mappedin-js/geojson/src/components/custom';
    import type { Group as TweenGroup } from '@tweenjs/tween.js';
    import type { MaterialSide } from '@mappedin/mappedin-js/geojson/src/components/styles';
    import type { Geometry3DTypes } from '@mappedin/mappedin-js/geojson/src/entities/geometry3d';
    import type { Text3DState } from '@mappedin/mappedin-js/geojson/src/components/text3d';
    /**
        * The state of an entity, which can be a geometry, geometry group, group container, path, model, label, or marker.
        */
    export type EntityState = GeometryState | GeometryGroupState | GroupContainerState | PathState | ModelState | LabelState | MarkerState | ImageState | Text3DState | ShapeState;
    /**
        * A wrapper object that contains the ID and type of an entity. This is returned when adding entities to the scene, and can be used
        * to `getState` and `setState` of the entity.
        */
    export type EntityId<T extends EntityState> = {
            id: T['id'];
            type: T['type'];
    };
    export class EntityInstancedMesh extends InstancedMesh {
            userData: {
                    entities: {
                            [key: number]: string;
                    };
            };
    }
    export class EntityMesh<T> extends Mesh<any> {
            userData: {
                    entity: T;
            };
    }
    export class EntityObject3D<T> extends Object3D {
            userData: {
                    entity: T;
            };
    }
    export type Entity2DHTMLDivElement = HTMLDivElement & {
            userData: {
                    entityId: Geometry2D['id'];
            };
    };
    export type Entity2DHTMLDivElementContainer = HTMLDivElement & {
            children: HTMLCollectionOf<HTMLElement & {
                    userData: {
                            entityId: Geometry2D['id'];
                    };
            }>;
    };
    export type PaintStyle = {
            color: string;
            topColor?: string;
            height?: number;
            altitude?: number;
            opacity?: number;
            visible?: boolean;
            topTexture?: string;
            texture?: string;
            shading?: Shading;
            outline?: boolean;
            showImage?: boolean;
            flipImageToFaceCamera?: boolean;
            side?: MaterialSide;
    };
    export type Shading = {
            start?: number;
            end?: number;
            intensity?: number;
    };
    export type LineStyle = {
            color: string;
            topColor?: string;
            width: number;
            opacity?: number;
            height?: number;
            altitude?: number;
            visible?: boolean;
            cap?: 'round' | 'square' | 'butt';
            join?: 'round' | 'bevel' | 'miter';
            shading?: Shading;
            outline?: boolean;
            side?: MaterialSide;
    };
    export type Layer = {
            id: string;
            type: string;
            paint: {
                    'fill-extrusion-color': string;
                    'fill-extrusion-height': number;
                    'fill-extrusion-base': number;
                    'fill-extrusion-opacity': number | ['interpolate', [easing: 'linear'], [prop: 'zoom'], number, number, number, number];
                    'fill-extrusion-outline': boolean;
            };
            source: string;
    };
    export type PolygonImage = {
            width: number;
            height: number;
            verticalOffset?: number;
            rotation?: number;
    };
    export type PolygonSource = {
            features: {
                    type: 'Feature';
                    properties: {
                            level: number;
                            name: string;
                            height: number;
                            base_height: number;
                            color: string;
                    };
                    geometry: {
                            coordinates: [[number][]];
                            type: 'Polygon';
                    };
                    id: string;
            }[];
            type: 'FeatureCollection';
    };
    export * from '@mappedin/mappedin-js/geojson/src/types/geometry';
    export * from '@mappedin/mappedin-js/geojson/src/types/options';
    export type ModelProperties = {
            rotation?: [number, number, number];
            scale?: [number, number, number];
            interactive?: boolean;
            id?: string | number;
            verticalOffset?: number;
    };
    export type ModelGroupStyle = {
            url: string;
            color?: string;
            opacity?: number;
            /**
                * traverse the scene and update the materials by name
                */
            material?: {
                    [name: string]: {
                            color: string;
                    };
            };
    };
    export type InsetPadding = {
            top: number;
            left: number;
            bottom: number;
            right: number;
            /**
                * The type of padding to use. If 'portion', the padding will be a portion of the canvas size. If 'pixel', the padding will be in pixels.
                * @defaultValue 'pixel'
                */
            type: 'pixel' | 'portion';
    };
    /**
        * An option for setting the inset padding of the camera.
        * @interface
        */
    export type InsetPaddingOption = Omit<InsetPadding, 'type'> & {
            /**
                * The type of padding to use. If 'portion', the padding will be a portion of the canvas size. If 'pixel', the padding will be in pixels.
                * @defaultValue 'pixel'
                */
            type?: InsetPadding['type'];
    };
    /**
        * Result of a user click event.
        */
    export type ClickPayload = {
            /**
                * The coordinate of the interaction.
                */
            coordinate: Position;
            /**
                * An array of path IDs which the user interaction passed through. Will be empty if no paths were interacted with.
                */
            paths: (string | number)[] | [];
            /**
                * An array of marker IDs which the user interaction passed through. Will be empty if no markers were interacted with.
                */
            markers: (string | number)[] | [];
            /**
                * An array of 3D models IDs which the user interaction passed through. Will be empty if no models were interacted with.
                */
            models: [string | number] | [];
            /**
                * An array of label IDs which the user interaction passed through. Will be empty if no labels were interacted with.
                */
            labels: (string | number)[] | [];
            /**
                * An array of geometry IDs which the user interaction passed through. Will be empty if no geometry was interacted with.
                */
            geometry: (string | number)[] | [];
            /**
                * Details about the pointer event which triggered the interaction.
                */
            pointerEvent: {
                    /**
                        * The button which was clicked. 0 is the left mouse button and 2 is the right mouse button.
                        * On touch devices a tap will have a button of 0.
                        *
                        * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button
                        */
                    button: number;
            };
            /**
                * An array of group container IDs which the user interaction passed through. Will be empty if no group containers were interacted with.
                */
            containers: (string | number)[] | [];
    };
    /**
        * Result of a user hover event.
        */
    export type HoverPayload = Omit<ClickPayload, 'pointerEvent'>;
    /**
        * The result of a camera change event.
        */
    export type CameraPayload = {
            /**
                * The camera's current center in [longitude, latitude].
                */
            center: Position;
            /**
                * The camera's current bearing in degrees from north.
                */
            bearing: number;
            /**
                * The camera's current pitch in degrees.
                */
            pitch: number;
            /**
                * The camera's current zoom level in mercator zoom level units
                */
            zoomLevel: number;
            /**
                * The camera's current elevation in meters from the ground.
                */
            elevation: number;
    };
    /**
        * The events which can be subscribed to on the renderer.
        */
    export type MapEvent = {
            /**
                * Fired when the user hovers over an interactive entity on the map.
                */
            hover: HoverPayload;
            /**
                * Fired when the user clicks on an interactive entity on the map.
                */
            click: ClickPayload;
            /**
                * Fired when the camera moves, either by user interaction or programmatic change.
                */
            'camera-change': CameraPayload;
            /**
                * If outdoor view is enabled, this is fired when the renderer has loaded the outdoor view.
                */
            'outdoor-view-loaded': undefined;
            /**
                * If outdoor view is enabled, this is fired when the style first loads or changes.
                */
            'outdoor-style-loaded': undefined;
            /**
                * Fired when the user starts interacting with the map.
                */
            'user-interaction-start': undefined;
            /**
                * Fired when the user stops interacting with the map.
                */
            'user-interaction-end': undefined;
            /**
                * Fired when a geometry is in focus, meaning it occupies the area closest to the center of the screen. Is an array of geometry IDs sorted by most likely to be in focus.
                * Geometries can be added to the focus listener via `mapView.setState(.., { focusable: true })`.
                */
            'geometry-in-focus': string[];
            /**
                * Fired before the scene is rendered. Use this to modify the scene before it is rendered.
                */
            'pre-render': undefined;
            /**
                * Fired when the synchronous tasks of the scene render are complete.
                */
            'post-render': undefined;
            resize: undefined;
    };
    /**
        * The payload of an event. See also {@link MapEvent}.
        */
    export type MapEventPayload<EventName extends keyof MapEvent> = MapEvent[EventName] extends {
            data: null;
    } ? MapEvent[EventName]['data'] : MapEvent[EventName];
    /**
        * All entities in 3D
        */
    export type All3DTypes = Geometry3DTypes | GeometryGroupObject3D | GroupContainerObject3D;
    export type RendererState = {
            geometry3DMap: Map<string | number, All3DTypes>;
            geometry2DMap: Map<string | number, Geometry2D>;
            geometry2DIdsInScene: Set<Geometry2D['id']>;
            geometry3DIdsInScene: Set<All3DTypes['id']>;
            entityScene: GroupContainerObject3D;
            hoverColor: string;
            text3dHoverColor: string;
            center?: Position;
            insetsPadding: InsetPadding;
            shouldMeasureCanvas: boolean;
            /**
                * Current clamped pixel ratio of the renderer, based on maplibre's clamping logic (when in interleaved mode)
                */
            pixelRatio: number;
            canvasWidth: number;
            canvasHeight: number;
            /** Global group for all tweens */
            tweenGroup: TweenGroup;
            cameraObject: Camera;
            naturalBearing: number;
            containerOffset: [number, number];
    };
    /**
        * All of the entities in the scene
        */
    export type EntityTypes = Geometry3DTypes | Geometry2D | GeometryGroupObject3D | GroupContainerObject3D;
    /** @internal */
    export type TransformImageRequest = (url: string) => Promise<{
            url: string;
    }>;
    /**
        * The mode to use for auto image placement.
        * - `default` will currently not rotate the image, but in the future it may be settable per-image, in which case this mode will use that setting.
        * - `none` will not rotate the image.
        * - `nearest 90` may rotate the image 90 degrees to fit the polygon better.
        * - `initial bearing` will rotate the images to face the initial bearing of the map view, then try to fit them to their polygon.
        *
        * @internal
        */
    export type ImagePlacementMode = 'default' | 'none' | 'fit-nearest-90' | 'fit-initial-bearing';
    /**
        * Options for configuring how images are automatically placed on polygons.
        *
        * @internal
        */
    export type ImagePlacementOptions = {
            /**
                * The mode to use for auto image placement. See {@link ImagePlacementMode} for more information.
                * @defaultValue 'default'
                */
            mode?: ImagePlacementMode;
            /**
                * Scale factor applied to the resulting rectangle dimensions.
                * Values less than 1 create a safety margin inside the polygon.
                * @defaultValue 0.9
                */
            scaleFactor?: number;
            /**
                * Controls the balance between optimizing for rectangle area vs. proximity to center.
                * Higher values prioritize center alignment over size.
                * @defaultValue 0.5
                */
            centerPriority?: number;
            /**
                * Resolution of the grid used for finding the rectangle.
                * Higher values provide more precise results but require more computation.
                * @defaultValue 100
                */
            resolution?: number;
            /**
                * Threshold ratio for determining when to fall back to the original rectangle.
                * If the calculated rectangle is smaller than this ratio of the original,
                * the original rectangle will be returned instead.
                * @defaultValue 0.5
                */
            minimumSizeRatio?: number;
    };
}

declare module '@mappedin/mappedin-js/geojson/src/components/mesh' {
    import type { Texture, BufferGeometry, LineSegments, Mesh } from 'three';
    import { BatchedMesh, Color, Vector3 } from 'three';
    import type { BatchedStandardMaterial } from '@mappedin/mappedin-js/geojson/src/systems/mesh-creation-and-optimization/batched-material';
    import type { EntityId, Position } from '@mappedin/mappedin-js/geojson/src/types';
    import type { Feature, LineString, MultiLineString, MultiPolygon, Polygon, Position as GeoJsonPosition } from 'geojson';
    import type { BBox } from '@turf/turf';
    import { type ImageProperties } from '@mappedin/mappedin-js/geojson/src/components/image';
    import { type BaseTextAreaProperties, type EnterpriseTexture } from '@mappedin/mvf';
    import type { Text } from 'troika-three-text';
    import type { GeometryGroupState } from '@mappedin/mappedin-js/geojson/src/entities/geometry-group';
    export class EntityBatchedMesh extends BatchedMesh {
            type: "entityBatchedMesh";
            userData: {
                    entities: {
                            [key: number]: string | number;
                    };
                    detached?: boolean;
            };
    }
    export type MeshComponentProperties = {
            id: string;
            image?: ImageProperties & {
                    position: GeoJsonPosition;
                    path: string;
            };
            textArea?: BaseTextAreaProperties & {
                    position: GeoJsonPosition;
            };
            textures?: EnterpriseTexture[];
    };
    /**
        * State representing a Geometry
        */
    export type GeometryState = {
            readonly id: string | number;
            readonly type: 'geometry';
            /**
                * The position of the geometry in [lon, lat]
                */
            readonly position: Position;
            /**
                * The parent group of the geometry
                */
            readonly parent: EntityId<GeometryGroupState>;
            /**
                * Whether the geometry is visible. This is independent of the visibility of the children, but will affect the visibility of the children if set to false.
                */
            visible: boolean;
            /**
                * The initial color of the geometry. This is used to reset the color of the geometry to its initial value.
                */
            initialColor: string;
            /**
                * The color of the geometry
                */
            color: string;
            /**
                * The initial top color of the geometry. This is used to reset the top color of the geometry to its initial value.
                */
            initialTopColor?: string;
            /**
                * The color of geometry faces that are facing up
                */
            topColor?: string;
            /**
                * The color of the geometry when hovered over with a mouse
                */
            hoverColor?: string;
            /**
                * Whether the geometry is interactive, which means it can be hovered over and clicked on.
                *
                * @example
                * ```javascript
                * 	renderer.on('click', ({ geometry }) => {});
                * ```
                */
            interactive: boolean;
            /**
                * Whether the geometry is outlined with a 30% darkened color. This effect adds lines around the geometry to make it stand out.
                */
            outline: boolean;
            /**
                * Show geometry image if present
                */
            showImage: boolean;
            /**
                * Attempt to keep the image facing the camera as much as possible
                */
            flipImageToFaceCamera: boolean;
            /**
                * Whether the geometry should emit an event when focused on by the center of the camera
                */
            focusable: boolean;
            /**
                * The opacity of the geometry
                */
            opacity: number;
            /**
                * The height of the geometry
                */
            height: number;
            /**
                * The texture URL of the geometry
                */
            texture?: string;
            /**
                * The top texture URL of the geometry
                */
            topTexture?: string;
            /**
                * Whether the geometry is currently in hover state or not
                */
            hovered: boolean;
            /**
                * The render order of the geometry
                */
            renderOrder?: number;
    };
    export class MeshComponent {
            #private;
            mesh?: EntityBatchedMesh;
            focusMesh?: Mesh;
            outline?: LineSegments;
            imageMesh?: Mesh;
            /**
                * holds a pointer to space label text if the polygon has label active.
                */
            textMesh?: Text;
            textEntityId?: string;
            readonly type = "geometry";
            dirty: boolean;
            detached: boolean;
            instanceIndex: number;
            geometry?: BufferGeometry;
            material?: BatchedStandardMaterial;
            feature: Feature<Polygon | LineString | MultiPolygon | MultiLineString, MeshComponentProperties>;
            currentHeight: number;
            constructor(feature: Feature<Polygon | LineString | MultiPolygon | MultiLineString, MeshComponentProperties>);
            get visible(): boolean;
            set visible(visible: boolean);
            get renderOrder(): number;
            set renderOrder(value: number);
            focusable: boolean;
            color: Color;
            topColor: Color;
            setColor(color: string, topColor: string): void;
            getColor(): {
                    color: Color;
                    topColor: Color;
            } | undefined;
            position: Vector3;
            get altitude(): number;
            set altitude(value: number);
            get opacity(): number;
            set opacity(value: number);
            get texture(): string;
            set texture(texture: Texture);
            get textureInstance(): Texture | undefined;
            set topTexture(texture: Texture);
            get topTexture(): string;
            get topTextureInstance(): Texture | undefined;
            set blendTexture(value: boolean);
            get featureBbox(): BBox;
            texturesVisible: boolean;
            showTextures(): void;
            hideTextures(): void;
            removeSideTexture(): void;
            removeTopTexture(): void;
    }
}

declare module '@mappedin/mappedin-js/geojson/src/components/custom' {
    import { Color, type Object3D, type LineSegments } from 'three';
    import type { EntityId, Position } from '@mappedin/mappedin-js/geojson/src/types';
    import type { Feature, Point } from 'geojson';
    import { Geometry3DObject3D } from '@mappedin/mappedin-js/geojson/src/entities/geometry3d';
    import type { GroupContainerState } from '@mappedin/mappedin-js/geojson/src/entities/group-container';
    /**
        * Represents the state of a custom shape.
        */
    export type ShapeState = {
            /**
                * The unique identifier of the shape.
                */
            readonly id: string;
            /**
                * The type of the shape, which is always 'custom-geometry'.
                */
            readonly type: 'custom-geometry';
            /**
                * The position of the geometry in [longitude, latitude].
                */
            readonly position: Position;
            /**
                * Whether the geometry is visible.
                */
            visible?: boolean;
            /**
                * The altitude of the geometry, in meters.
                */
            altitude?: number;
            /**
                * The color of the shape.
                */
            color: string;
            /**
                * The opacity of the shape.
                */
            opacity: number;
            /**
                * The parent container of the geometry.
                */
            readonly parent: EntityId<GroupContainerState> | string | number;
    };
    export type CustomGeometryBuilder = {
            /**
                * A setup function that is called once when the geometry is created
                */
            setup: (object: Object3D) => void;
            /**
                *  An update function that is called every render frame.
                *
                *  Note: do not create new objects in this function, and only update the object's children
                *  Note 2: calling `render` or `setState` in this method will result in a render loop, so avoid if possible
                */
            update: (object: Object3D) => void;
    };
    export class CustomGeometryComponent {
            #private;
            mesh: Geometry3DObject3D;
            readonly type = "custom-geometry";
            dirty: boolean;
            feature: Feature<Point>;
            builder: CustomGeometryBuilder;
            outline?: LineSegments;
            constructor(feature: Feature<Point>, builder: CustomGeometryBuilder);
            get visible(): boolean;
            set visible(value: boolean);
            set opacity(_v: number);
            get opacity(): number;
            color: Color;
            setColor(): void;
            get position(): import("three").Vector3;
            get altitude(): number;
            set altitude(value: number);
            get renderOrder(): number;
            set renderOrder(_: number);
    }
}

declare module '@mappedin/mappedin-js/geojson/src/components/model' {
    import type { Group, LineSegments, Object3D } from 'three';
    import { Color, Vector3 } from 'three';
    import type { BatchedStandardMaterial } from '@mappedin/mappedin-js/geojson/src/systems/mesh-creation-and-optimization/batched-material';
    import type { Position, EntityId, ModelProperties, ModelGroupStyle } from '@mappedin/mappedin-js/geojson/src/types';
    import type { Feature, FeatureCollection, Point } from 'geojson';
    import type { Geometry3DObject3D } from '@mappedin/mappedin-js/geojson/src/entities/geometry3d';
    import type { GeometryGroupState } from '@mappedin/mappedin-js/geojson/src/entities/geometry-group';
    import { z } from 'zod';
    import type { ModelStyle } from '@mappedin/mappedin-js/geojson/src/components/styles';
    /**
        * State representing a Model, typically loaded via a URL
        */
    export type ModelState = {
            readonly id: string;
            readonly type: 'model';
            /**
                * The parent container of the marker
                */
            readonly parent?: EntityId<GeometryGroupState> | string | number;
            /**
                * The position of the model in [lon, lat]
                */
            readonly position: Position;
            /**
                * Whether the model is interactive, which means it can be hovered over and clicked on.
                *
                * @example
                * ```javascript
                * 	renderer.on('click', ({ geometry }) => {});
                * ```
                */
            interactive: boolean;
    } & Partial<Omit<ModelStyle, 'rotation' | 'scale'>> & Pick<ModelStyle, 'rotation' | 'scale'>;
    /**
        * initialize model state
        * @interface
        */
    export type InitializeModelState = Omit<Partial<ModelState>, 'id' | 'type' | 'parent' | 'position'>;
    /**
        * updatable model state
        * @interface
        */
    export type UpdateModelState = Omit<InitializeModelState, 'url'> & {
            position?: Position;
    };
    export const modelPropertiesSchema: z.ZodObject<{
            rotation: z.ZodOptional<z.ZodArray<z.ZodNumber, "many">>;
            altitude: z.ZodOptional<z.ZodNumber>;
            scale: z.ZodOptional<z.ZodArray<z.ZodNumber, "many">>;
            interactive: z.ZodOptional<z.ZodBoolean>;
            verticalOffset: z.ZodOptional<z.ZodNumber>;
            id: z.ZodOptional<z.ZodUnion<[z.ZodNumber, z.ZodString]>>;
    }, "strip", z.ZodTypeAny, {
            altitude?: number | undefined;
            verticalOffset?: number | undefined;
            rotation?: number[] | undefined;
            scale?: number[] | undefined;
            id?: string | number | undefined;
            interactive?: boolean | undefined;
    }, {
            altitude?: number | undefined;
            verticalOffset?: number | undefined;
            rotation?: number[] | undefined;
            scale?: number[] | undefined;
            id?: string | number | undefined;
            interactive?: boolean | undefined;
    }>;
    export const featureSchema: z.ZodObject<{
            type: z.ZodEnum<["Feature"]>;
            geometry: z.ZodObject<{
                    type: z.ZodEnum<["Point"]>;
                    coordinates: z.ZodArray<z.ZodNumber, "many">;
            }, "strip", z.ZodTypeAny, {
                    type: "Point";
                    coordinates: number[];
            }, {
                    type: "Point";
                    coordinates: number[];
            }>;
            properties: z.ZodObject<{
                    rotation: z.ZodOptional<z.ZodArray<z.ZodNumber, "many">>;
                    altitude: z.ZodOptional<z.ZodNumber>;
                    scale: z.ZodOptional<z.ZodArray<z.ZodNumber, "many">>;
                    interactive: z.ZodOptional<z.ZodBoolean>;
                    verticalOffset: z.ZodOptional<z.ZodNumber>;
                    id: z.ZodOptional<z.ZodUnion<[z.ZodNumber, z.ZodString]>>;
            }, "strip", z.ZodTypeAny, {
                    altitude?: number | undefined;
                    verticalOffset?: number | undefined;
                    rotation?: number[] | undefined;
                    scale?: number[] | undefined;
                    id?: string | number | undefined;
                    interactive?: boolean | undefined;
            }, {
                    altitude?: number | undefined;
                    verticalOffset?: number | undefined;
                    rotation?: number[] | undefined;
                    scale?: number[] | undefined;
                    id?: string | number | undefined;
                    interactive?: boolean | undefined;
            }>;
    }, "strip", z.ZodTypeAny, {
            type: "Feature";
            geometry: {
                    type: "Point";
                    coordinates: number[];
            };
            properties: {
                    altitude?: number | undefined;
                    verticalOffset?: number | undefined;
                    rotation?: number[] | undefined;
                    scale?: number[] | undefined;
                    id?: string | number | undefined;
                    interactive?: boolean | undefined;
            };
    }, {
            type: "Feature";
            geometry: {
                    type: "Point";
                    coordinates: number[];
            };
            properties: {
                    altitude?: number | undefined;
                    verticalOffset?: number | undefined;
                    rotation?: number[] | undefined;
                    scale?: number[] | undefined;
                    id?: string | number | undefined;
                    interactive?: boolean | undefined;
            };
    }>;
    export const addModelFeatureSchema: z.ZodObject<{
            type: z.ZodEnum<["FeatureCollection"]>;
            features: z.ZodArray<z.ZodObject<{
                    type: z.ZodEnum<["Feature"]>;
                    geometry: z.ZodObject<{
                            type: z.ZodEnum<["Point"]>;
                            coordinates: z.ZodArray<z.ZodNumber, "many">;
                    }, "strip", z.ZodTypeAny, {
                            type: "Point";
                            coordinates: number[];
                    }, {
                            type: "Point";
                            coordinates: number[];
                    }>;
                    properties: z.ZodObject<{
                            rotation: z.ZodOptional<z.ZodArray<z.ZodNumber, "many">>;
                            altitude: z.ZodOptional<z.ZodNumber>;
                            scale: z.ZodOptional<z.ZodArray<z.ZodNumber, "many">>;
                            interactive: z.ZodOptional<z.ZodBoolean>;
                            verticalOffset: z.ZodOptional<z.ZodNumber>;
                            id: z.ZodOptional<z.ZodUnion<[z.ZodNumber, z.ZodString]>>;
                    }, "strip", z.ZodTypeAny, {
                            altitude?: number | undefined;
                            verticalOffset?: number | undefined;
                            rotation?: number[] | undefined;
                            scale?: number[] | undefined;
                            id?: string | number | undefined;
                            interactive?: boolean | undefined;
                    }, {
                            altitude?: number | undefined;
                            verticalOffset?: number | undefined;
                            rotation?: number[] | undefined;
                            scale?: number[] | undefined;
                            id?: string | number | undefined;
                            interactive?: boolean | undefined;
                    }>;
            }, "strip", z.ZodTypeAny, {
                    type: "Feature";
                    geometry: {
                            type: "Point";
                            coordinates: number[];
                    };
                    properties: {
                            altitude?: number | undefined;
                            verticalOffset?: number | undefined;
                            rotation?: number[] | undefined;
                            scale?: number[] | undefined;
                            id?: string | number | undefined;
                            interactive?: boolean | undefined;
                    };
            }, {
                    type: "Feature";
                    geometry: {
                            type: "Point";
                            coordinates: number[];
                    };
                    properties: {
                            altitude?: number | undefined;
                            verticalOffset?: number | undefined;
                            rotation?: number[] | undefined;
                            scale?: number[] | undefined;
                            id?: string | number | undefined;
                            interactive?: boolean | undefined;
                    };
            }>, "many">;
    }, "strip", z.ZodTypeAny, {
            type: "FeatureCollection";
            features: {
                    type: "Feature";
                    geometry: {
                            type: "Point";
                            coordinates: number[];
                    };
                    properties: {
                            altitude?: number | undefined;
                            verticalOffset?: number | undefined;
                            rotation?: number[] | undefined;
                            scale?: number[] | undefined;
                            id?: string | number | undefined;
                            interactive?: boolean | undefined;
                    };
            }[];
    }, {
            type: "FeatureCollection";
            features: {
                    type: "Feature";
                    geometry: {
                            type: "Point";
                            coordinates: number[];
                    };
                    properties: {
                            altitude?: number | undefined;
                            verticalOffset?: number | undefined;
                            rotation?: number[] | undefined;
                            scale?: number[] | undefined;
                            id?: string | number | undefined;
                            interactive?: boolean | undefined;
                    };
            }[];
    }>;
    export const modelGroupStyleSchema: z.ZodObject<{
            url: z.ZodString;
            color: z.ZodOptional<z.ZodString>;
            opacity: z.ZodOptional<z.ZodNumber>;
            material: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodObject<{
                    color: z.ZodString;
            }, "strip", z.ZodTypeAny, {
                    color: string;
            }, {
                    color: string;
            }>>>;
    }, "strip", z.ZodTypeAny, {
            url: string;
            color?: string | undefined;
            opacity?: number | undefined;
            material?: Record<string, {
                    color: string;
            }> | undefined;
    }, {
            url: string;
            color?: string | undefined;
            opacity?: number | undefined;
            material?: Record<string, {
                    color: string;
            }> | undefined;
    }>;
    export function validateModelGroup(id: string | number, geometry: FeatureCollection<Point, ModelProperties>, style: Partial<ModelGroupStyle>): void;
    export class ModelComponent {
            #private;
            mesh?: Geometry3DObject3D | Group;
            readonly type = "model";
            positionDirty: boolean;
            outline?: LineSegments;
            geometry?: Object3D;
            material?: BatchedStandardMaterial;
            feature: Feature<Point, ModelProperties>;
            instanceIndex?: number;
            constructor(feature: Feature<Point, ModelProperties>);
            visible: boolean;
            setOpacity(): void;
            color: Color;
            setColor(): void;
            position: Vector3;
            get altitude(): number;
            set altitude(value: number);
            getRotation(): number[] | undefined;
            setRotation(value: [number, number, number]): void;
            getScale(): number[] | undefined;
            setScale(value: [number, number, number]): void;
            get opacity(): number;
            set opacity(value: number);
    }
}

declare module '@mappedin/mappedin-js/geojson/src/renderer' {
    import './utils/object-this-polyfill';
    import { PerspectiveCamera, Scene, Vector3, Raycaster, Camera as ThreeCamera } from 'three';
    import type { GroupContainerState } from '@mappedin/mappedin-js/geojson/src/entities/group-container';
    import { GroupContainerObject3D } from '@mappedin/mappedin-js/geojson/src/entities/group-container';
    import { PubSub } from '@mappedin/mappedin-js/packages/common/pubsub';
    import { Renderer } from '@mappedin/mappedin-js/geojson/src/services/renderer';
    import { CollisionSystem } from '@mappedin/mappedin-js/geojson/src/systems/collisions/system';
    import { InteractionSystem } from '@mappedin/mappedin-js/geojson/src/systems/interactions';
    import type { AddMarkerOptions, MarkerState } from '@mappedin/mappedin-js/geojson/src/components/marker';
    import type { GLTFExportOptions } from '@mappedin/mappedin-js/geojson/src/systems/exporter';
    import { ExporterSystem } from '@mappedin/mappedin-js/geojson/src/systems/exporter';
    import type { AddLabelOptions, LabelState } from '@mappedin/mappedin-js/geojson/src/components/label';
    import type { LineStyle, PaintStyle, RendererCoreOptions, Position, ModelProperties, EntityState, EntityId, MapEvent, MapEventPayload, RendererState, EntityTypes, EnvMapOptions } from '@mappedin/mappedin-js/geojson/src/types';
    import { MeshCreationAndOptimizationSystem } from '@mappedin/mappedin-js/geojson/src/systems/mesh-creation-and-optimization/system';
    import { DOMVisibilitySystem } from '@mappedin/mappedin-js/geojson/src/systems/dom-visiblity/system';
    import { TwoDProjectionSystem } from '@mappedin/mappedin-js/geojson/src/systems/2d-projection/system';
    import { TwoDDrawSystem } from '@mappedin/mappedin-js/geojson/src/systems/2d-draw/system';
    import { DrawSystem } from '@mappedin/mappedin-js/geojson/src/systems/draw/system';
    import { TwoDVisibilitySystem } from '@mappedin/mappedin-js/geojson/src/systems/2d-visibility/system';
    import { RenderSystem } from '@mappedin/mappedin-js/geojson/src/systems/render/system';
    import type { Position as GeoJsonPosition, FeatureCollection, LineString, MultiPolygon, Polygon, Point, Feature, BBox } from 'geojson';
    import type { AddPathOptions, PathProperties, PathState, PathUpdateState } from '@mappedin/mappedin-js/geojson/src/components/path';
    import { StackSystem } from '@mappedin/mappedin-js/geojson/src/systems/stack/system';
    import { CameraSystem } from '@mappedin/mappedin-js/geojson/src/systems/camera';
    import { DOMDrawSystem } from '@mappedin/mappedin-js/geojson/src/systems/dom-draw/system';
    import { type Map as MapLibreMap } from '@mappedin/mappedin-js/packages/outdoor-context-v4';
    import type { GeometryState } from '@mappedin/mappedin-js/geojson/src/components/mesh';
    import type { InitializeModelState, ModelState, UpdateModelState } from '@mappedin/mappedin-js/geojson/src/components/model';
    import type { GeometryGroupState } from '@mappedin/mappedin-js/geojson/src/entities/geometry-group';
    import { DOMResizeSystem } from '@mappedin/mappedin-js/geojson/src/systems/dom-resize/system';
    import { Camera } from '@mappedin/mappedin-js/geojson/src/camera';
    import { type WatermarkUpdateOptions, WatermarkSystem } from '@mappedin/mappedin-js/geojson/src/systems/watermark/system';
    import { PanBoundsSystem } from '@mappedin/mappedin-js/geojson/src/systems/pan-bounds/system';
    import { HTMLControlsSystem } from '@mappedin/mappedin-js/geojson/src/systems/html-controls/system';
    import { type CustomGeometryBuilder, type ShapeState } from '@mappedin/mappedin-js/geojson/src/components/custom';
    import { CustomGeometrySystem } from '@mappedin/mappedin-js/geojson/src/systems/custom-geometry/system';
    import { OutlineInterpolationSystem } from '@mappedin/mappedin-js/geojson/src/systems/outline-interpolation/system';
    import { ImageSystem } from '@mappedin/mappedin-js/geojson/src/systems/image/system';
    import { GeometryInFocusSystem } from '@mappedin/mappedin-js/geojson/src/systems/geometry-in-focus/system';
    import { OutdoorLayers } from '@mappedin/mappedin-js/geojson/src/systems/outdoor-layers/system';
    import { PathSystem } from '@mappedin/mappedin-js/geojson/src/systems/path';
    import { type ImageProperties, type ImageState, type ImageStyle } from '@mappedin/mappedin-js/geojson/src/components/image';
    import type { AddText3DOptions, Text3DState, UpdatableText3DState } from '@mappedin/mappedin-js/geojson/src/components/text3d';
    import { MeshDetachmentSystem } from '@mappedin/mappedin-js/geojson/src/systems/mesh-detachment/system';
    import { MeshModificationSystem } from '@mappedin/mappedin-js/geojson/src/systems/mesh-modification/system';
    import { Text3DSystem } from '@mappedin/mappedin-js/geojson/src/systems/text3d/system';
    import { Group as TweenGroup } from '@tweenjs/tween.js';
    import { Debug } from '@mappedin/mappedin-js/geojson/src/utils/debug';
    import { Occlusion2DSystem } from '@mappedin/mappedin-js/geojson/src/systems/2d-occlusion/system';
    import type { FloatingFloorTextProperties } from '@mappedin/mvf';
    export type * from '@mappedin/mappedin-js/geojson/src/types';
    export const raycaster: Raycaster;
    /**
        * Some preset orderings for updates.
        */
    export const UPDATE_ORDERING: {
            BEFORE_CAMERA: number;
            CAMERA: number;
            AFTER_CAMERA: number;
            RENDER: number;
            AFTER_RENDER: number;
            AFTER_ALL_UPDATES: number;
    };
    export const DEFAULT_PITCH: number, DEFAULT_BEARING: number, DEFAULT_ZOOM_LEVEL: number, DEFAULT_MIN_ZOOM_LEVEL: number, DEFAULT_MAX_ZOOM_LEVEL: number;
    export type Systems = {
            cameraSystem: CameraSystem;
            panBoundsSystem: PanBoundsSystem;
            collisionSystem: CollisionSystem;
            interactionSystem: InteractionSystem;
            meshOptimizationSystem: MeshCreationAndOptimizationSystem;
            domVisiblitySystem: DOMVisibilitySystem;
            domMutationSystem: DOMResizeSystem;
            domDrawSystem: DOMDrawSystem;
            twoDProjectionSystem: TwoDProjectionSystem;
            twoDDrawSystem: TwoDDrawSystem;
            drawSystem: DrawSystem;
            twoDVisiblitySystem: TwoDVisibilitySystem;
            renderSystem: RenderSystem;
            stackSystem: StackSystem;
            watermarkSystem: WatermarkSystem;
            htmlControlsSystem: HTMLControlsSystem;
            exporterSystem: ExporterSystem;
            customGeometrySystem: CustomGeometrySystem;
            outlineInterpolationSystem: OutlineInterpolationSystem;
            outdoorLayersSystem: OutdoorLayers;
            pathSystem: PathSystem;
            imageSystem: ImageSystem;
            geometryInFocusSystem: GeometryInFocusSystem;
            meshDetachmentSystem: MeshDetachmentSystem;
            meshModificationSystem: MeshModificationSystem;
            text3DSystem: Text3DSystem;
            occlusion2DSystem: Occlusion2DSystem;
    };
    export type MapViewState = {
            readonly type: 'map-view';
            hoverColor: string;
            text3dHoverColor: string;
    };
    class Core extends PubSub<MapEvent> {
            #private;
            options: Omit<RendererCoreOptions, 'outdoorView'>;
            container: HTMLElement;
            Debug: Debug;
            /**
                * The view camera is used for projecting both the outdoor map and our scene
                */
            get viewCamera(): ThreeCamera;
            get canvasWidth(): number;
            get canvasHeight(): number;
            rendererDomElement: HTMLCanvasElement;
            /**
                * Returns pixel ratio of the renderer
                */
            get resolutionScale(): number;
            get aspect(): number;
            camera: Camera;
            map: MapLibreMap | undefined;
            /**
                * Returns the mode the Renderer is in.
                */
            get mode(): "standalone" | "outdoors-interleaved" | "outdoors-overlay" | undefined;
            /**
                * @internal
                */
            constructor(container: HTMLElement, options?: RendererCoreOptions);
            /**
                * Add a container that can hold other containers, geometry groups, markers, labels and paths. Use this to group entities together.
                */
            addGroupContainer(id: string, options?: {
                    visible?: boolean;
                    altitude?: number;
                    interactive?: boolean;
            }, parent?: EntityId<GroupContainerState> | string | number | null): EntityId<GroupContainerState>;
            addStackContainer(id: string, style?: {
                    visible?: true;
            }, parent?: EntityId<GroupContainerState> | string | null): {
                    id: string;
                    type: string;
            };
            getParentContainer: (parent?: EntityId<GroupContainerState> | EntityId<GeometryState> | string | number | null, defaultToScene?: boolean) => GroupContainerObject3D | undefined;
            /**
                * Add a custom THREE.js entity to the map. The geometry is placed at the GeoJSON coordinate and includes a `setup` and `update` methods.
                * Setup is called when the first time the geometry visible, and update is called every render frame.
                */
            addCustomGeometry(id: string, feature: Feature<Point>, builder: CustomGeometryBuilder, style?: {
                    visible?: boolean;
                    altitude?: number;
                    interactive?: boolean;
            }, parent?: EntityId<GroupContainerState> | string | number | null): EntityId<ShapeState>;
            /**
                * Add a geometry group from GeoJSON data
                */
            addGeometryGroup<T extends FeatureCollection<Polygon | MultiPolygon | LineString, any>>(id: string, geometry: T, style?: T extends FeatureCollection<LineString, any> ? LineStyle : PaintStyle, parent?: EntityId<GroupContainerState> | string | number | null): EntityId<GeometryGroupState>;
            addOccluder<T extends Feature<Polygon | MultiPolygon, any>>(feature: T, parent?: EntityId<GroupContainerState> | string | number | null): number;
            addImage(id: string, geometry: Feature<Point, ImageProperties>, style: ImageStyle, parent?: EntityId<GroupContainerState> | string | null): EntityId<ImageState> | undefined;
            /**
                * Add a group of models from GeoJSON data. These will be instanced automatically for better performance.
                */
            addModelGroup(id: string, geometry: FeatureCollection<Point, ModelProperties>, style: Partial<InitializeModelState>, { parent, onComplete: onAdd, }?: {
                    parent?: EntityId<GroupContainerState> | string | null;
                    onComplete?: () => void;
            }): EntityId<GeometryGroupState> | undefined;
            /**
                * Add an HTML Marker at a GeoJSON coordinate.
                */
            addMarker2D(coordinate: Position, contentHTML: string, options?: AddMarkerOptions, parent?: EntityId<GroupContainerState> | string | number | null): EntityId<MarkerState> | undefined;
            addText3D(id: string, geometry: Feature<Point, FloatingFloorTextProperties>, options: AddText3DOptions, parent?: EntityId<GroupContainerState> | string | null): EntityId<Text3DState>;
            /**
                * Labels an existing 3D geometry with a text area.
                *
                * @param meshGeometryId - The ID of the target 3D geometry to label.
                * @param content - The text content to display.
                * @param options - Additional options for adding the text label, including:
                *   - parentId: Optional ID of the parent container.
                *   - appearance: Optional appearance settings for the text label.
                *
                * @returns An object containing the ID and type of the created or existing text label, or undefined if labeling failed. If geometry is already labeld, the same text id will be returned
                *
                * @example
                * ```typescript
                * const label = renderer.labelText3D('geometry123', 'Hello World', { parentId: 'parent456', appearance: { color: 'red' } });
                * if (label) {
                *   console.log(`Label created with ID: ${label.id}`);
                * }
                *
                */
            labelText3D(meshGeometryId: string, content: string, options?: AddText3DOptions & {
                    parentId?: string;
            }): EntityId<Text3DState> | undefined;
            /**
                * Add a 2D label at a GeoJSON coordinate.
                */
            addLabel2D(coordinate: Position, text: string, options?: AddLabelOptions, parent?: EntityId<GroupContainerState> | string | null): EntityId<LabelState> | undefined;
            /**
                * Add a Path along a set of GeoJSON coordinates that can be animated.
                */
            addPath(geometry: FeatureCollection<Point, PathProperties>, options?: AddPathOptions, parent?: EntityId<GroupContainerState> | string | null): EntityId<PathState> | undefined;
            /**
                * Updates the watermark on the map.
                *
                * @param options {WatermarkUpdateOptions}
                */
            updateWatermark(options: WatermarkUpdateOptions): void;
            /**
                * Remove an entity from the renderer and release associated resources.
                */
            remove(object: string | number): void;
            remove(object: EntityTypes): void;
            /**
                * Show collision boxes for 2D entities for debugging
                */
            showCollisionBoxes: () => void;
            /**
                * Hide collision boxes for 2D entities for debugging
                */
            hideCollisionBoxes: () => void;
            /**
                * Recursively get the state for the whole scene. Can be an expensive operation.
                */
            getScene(): GroupContainerState;
            getThreeScene(): Scene | undefined;
            getThreeCamera(): PerspectiveCamera;
            setEnvironment(update: EnvMapOptions): Promise<void>;
            getEnvironment(): EnvMapOptions;
            /**
                * Get the current scene as a GLB file
                */
            getCurrentSceneGLTF(options: GLTFExportOptions): Promise<Blob>;
            /**
                * Gets the bounding area (4 corners) in lon,lat of a geometry, geomrtry group, or group container. This can be used with Camera to focus on an entity
                */
            getBoundingArea(geometryOrGeometryId?: string | number | EntityId<EntityState>): Position[] | undefined;
            /**
                * Get the current state of the map view, or any entity that was added, regardless of whether it is visible in the scene
                */
            getState(): MapViewState;
            getState<T extends EntityId<EntityState>>(geometryOrGeometryId: T): T extends EntityId<LabelState> ? LabelState : T extends EntityId<GeometryState> ? GeometryState : T extends EntityId<MarkerState> ? MarkerState : T extends EntityId<GeometryGroupState> ? GeometryGroupState : T extends EntityId<GroupContainerState> ? GroupContainerState : T extends EntityId<ModelState> ? ModelState : T extends EntityId<PathState> ? PathState : T extends EntityId<ShapeState> ? ShapeState : T extends EntityId<ImageState> ? ImageState : T extends EntityId<Text3DState> ? Text3DState : EntityState;
            getState(geometryOrGeometryId?: Record<string | number, any> | string | number): EntityState;
            getState<T extends EntityState>(geometryOrGeometryId: T['id']): T extends LabelState ? LabelState : T extends GeometryState ? GeometryState : T extends MarkerState ? MarkerState : T extends GeometryGroupState ? GeometryGroupState : T extends GroupContainerState ? GroupContainerState : T extends ModelState ? ModelState : T extends PathState ? PathState : T extends ShapeState ? ShapeState : T extends ImageState ? ImageState : EntityState;
            /**
                * Set the state of the map view or any entity that was added, regardless of whether it is visible in the scene.
                */
            setState(object: Partial<Omit<MapViewState, 'type'>>): void;
            setState<T extends EntityId<LabelState>>(object: T | T['id'], state: Partial<LabelState>): void;
            setState<T extends EntityId<MarkerState>>(object: T | T['id'], state: Partial<MarkerState>): void;
            setState<T extends EntityId<GeometryGroupState>>(object: T | T['id'], state: Partial<GeometryGroupState>): void;
            setState<T extends EntityId<GroupContainerState>>(object: T | T['id'], state: Partial<GroupContainerState>): void;
            setState<T extends EntityId<GeometryState>>(object: T | T['id'], state: Partial<GeometryState>): void;
            setState<T extends EntityId<ShapeState>>(object: T | T['id'], state: Partial<ShapeState>): void;
            setState<T extends EntityId<PathState>>(object: T | T['id'], state: PathUpdateState): void;
            setState<T extends EntityId<ModelState>>(object: T | T['id'], state: Partial<UpdateModelState>): void;
            setState<T extends EntityId<ImageState>>(object: T | T['id'], state: Partial<ImageState>): void;
            setState<T extends EntityId<Text3DState>>(object: T | T['id'], state: Partial<UpdatableText3DState>): void;
            setState<T extends EntityId<PathState>>(object: T | T['id'], state: Partial<PathState>): void;
            setState<T extends EntityState>(object: T | T['id'], state: Partial<T>): void;
            /**
                * Project a screen coordinate to a geographic coordinate
                */
            projectScreenXYToCoordinate: (x: number, y: number, useWorldPlane?: boolean) => {
                    coordinate: Position;
                    groupContainers: GroupContainerObject3D[] | undefined;
            } | undefined;
            /**
                * Project a geographic coordinate to a screen coordinate
                */
            projectCoordinateToScreenXY: (coordinate: Position) => {
                    x: number;
                    y: number;
            };
            /**
                * Convert a GeoJSON position to a 3D map position.
                *
                * @param position - The GeoJSON position to convert.
                * @param vector - Optional vector to copy the result into instead of creating a new vector.
                * @returns The converted 3D map position.
                */
            convertTo3DMapPosition(position: GeoJsonPosition, vector?: Vector3): Vector3;
            /**
                * Convert latitude and longitude to a 3D map position.
                *
                * @param latitude - The latitude to convert.
                * @param longitude - The longitude to convert.
                * @param altitude - Optional altitude to include in the conversion. Defaults to 0.
                * @param vector - Optional vector to copy the result into instead of creating a new vector.
                * @returns The converted 3D map position.
                */
            convertTo3DMapPosition(latitude: number, longitude: number, altitude?: number, vector?: Vector3): Vector3;
            /**
                * @internal
                */
            convert3DMapPositionToCoordinate: (v: Vector3) => Position;
            /**
                * Sets the background color of the renderer. Only applies to "standalone mode"
                */
            setBackgroundColor: (color: string, alpha: number) => void;
            /**
                * Returns  the background color of the renderer. Only applies to "standalone mode"
                */
            get backgroundColor(): string;
            /**
                * Returns  the background alpha of the renderer. Only applies to "standalone mode"
                */
            get backgroundAlpha(): number;
            /**
                * internal
                */
            getThreeRenderer(): Renderer;
            /**
                * Returns the current scale of the map in metres per pixel.
                */
            getMetresPerPixel: () => number | undefined;
            /**
                * @internal
                * Filters out layers at a certain point on the outdoor map. This can be used to hide the outdoor building footprint underneath the 3D geometry.
                * @param point The lat lon point to filter layers under.
                * @param layers The layers to filter out.
                */
            hideOutdoorLayersUnderPoint: (point: Position, layers: string[]) => void;
            /**
                * Filters out layers at a certain point on the outdoor map. This can be used to hide the outdoor building footprint underneath the 3D geometry.
                * @param bbox The bounding box to filter layers under.
                * @param polygons The polygons to filter layers under.
                * @param layers The layers to filter out.
                */
            hideOutdoorLayersIntersectingPolygons: (bbox: BBox, polygons: GeoJSON.Feature<GeoJSON.Polygon | GeoJSON.MultiPolygon, any>[], layers: string[]) => void;
            /**
                * Get the center of a geometry or bounding box.
                * @param geometryOrBoundingBox Geometry, geometry id, or bounding box to get the center of.
                */
            getCenter(geometryOrBoundingBox: string | number | EntityId<EntityState> | Position[]): [number, number] | undefined;
            /**
                * Checks if the given entity is within the current camera's view frustum.
                * This method is useful for determining if an entity is visible on the screen.
                *
                * @param target - The entity to check. This can be an object with `id` and `type` properties,
                *                 a string representing the entity's ID, or an entity state object.
                * @returns - Returns `true` if the entity is within the camera's view, otherwise `false`.
                */
            isInView(target: {
                    id: EntityState['id'];
                    type: EntityState['type'];
            } | string | EntityState): boolean;
            /**
                * Perform a render of the scene. This is called internally when something changes, but can be called when adding external models
                * The render happens in an animation frame, not matter how frequently it is called
                * @method render
                */
            render: () => Promise<any> | undefined;
            /**
                * Perform a synchronous render of the scene. This bypasses the animation frame and renders immediately.
                *
                * Note: Only use this if you have an animation frame setup elsewhere
                */
            renderSync: () => Promise<any> | undefined;
            /**
                * @internal for testing
                */
            getSystems(): Systems;
            /**
                * @internal for testing
                */
            getInternalState(): RendererState;
            getTweenGroup(): TweenGroup;
            /**
                * Subscribe a function to an event.
                *
                * @param eventName An event name which, when fired, will call the provided
                * function.
                * @param fn A callback that gets called when the corresponding event is fired. The
                * callback will get passed an argument with a type that's one of event payloads.
                * @example
                * // Subscribe to the 'click' event
                * const handler = (event) => {
                *  const { coordinate } = event;
                *  const { latitude, longitude } = coordinate;
                * 	console.log(`Map was clicked at ${latitude}, ${longitude}`);
                * };
                * map.on('click', handler);
                */
            on: <EventName extends keyof MapEvent>(eventName: EventName, fn: (payload: MapEventPayload<EventName>) => void) => void;
            /**
                * Unsubscribe a function previously subscribed with {@link on}
                *
                * @param eventName An event name to which the provided function was previously
                * subscribed.
                * @param fn A function that was previously passed to {@link on}. The function must
                * have the same reference as the function that was subscribed.
                * @example
                * // Unsubscribe from the 'click' event
                * const handler = (event) => {
                * 	console.log('Map was clicked', event);
                * };
                * map.off('click', handler);
                */
            off: <EventName extends keyof MapEvent>(eventName: EventName, fn: (payload: MapEventPayload<EventName>) => void) => void;
            /**
                * @hidden
                * Returns the current cursor decided by Mappedin. This is useful when integrating with other overlays to show the correct user interaction.
                */
            getCursor: () => "grabbing" | "grab" | "pointer";
            /**
                * Destroys instance and frees resources
                */
            destroy: () => void;
    }
    export default Core;
}

declare module '@mappedin/mappedin-js/geojson/src/camera' {
    import { Vector3 } from 'three';
    import type { RendererCore } from '@mappedin/mappedin-js/geojson/src';
    import type { Position as GeoJSONPosition } from 'geojson';
    import type { InsetPadding, Position, All3DTypes } from '@mappedin/mappedin-js/geojson/src/types';
    import type { InsetPaddingOption, RendererState, Systems } from '@mappedin/mappedin-js/geojson/src/renderer';
    import { type LngLatBoundsLike } from '@packages/internal/outdoor-context-v4';
    export type EasingCurve = 'ease-in' | 'ease-out' | 'ease-in-out' | 'linear';
    export type AnimationOptions = {
            duration?: number;
            easing?: EasingCurve;
    };
    export type AnimateElevationOptions = AnimationOptions & {
            interruptible?: boolean;
    };
    export type FocusOnOptions = AnimationOptions & {
            bearing?: number;
            pitch?: number;
            padding?: InsetPaddingOption;
            minZoomLevel?: number;
            maxZoomLevel?: number;
            interruptible?: boolean;
            verticalPadding?: number;
    };
    export type AnimateToOptions = AnimationOptions & {
            center?: Position;
            zoomLevel?: number;
            bearing?: number;
            pitch?: number;
            elevation?: number;
            interruptible?: boolean;
    };
    export const ANIMATION_TWEENS: {
            linear: (amount: number) => number;
            'ease-in': (amount: number) => number;
            'ease-out': (amount: number) => number;
            'ease-in-out': (amount: number) => number;
    };
    export class Camera {
            #private;
            /**
                * @internal
                */
            constructor(core: RendererCore, systems: Systems, state: RendererState);
            /**
                * The camera's current center in [longitude, latitude] degrees.
                */
            get center(): Position;
            /**
                * @param center The center in [longitude, latitude] degrees.
                */
            setCenter(center: Position): void;
            /**
                * Current camera zoom in mercator zoom level units.
                */
            get zoomLevel(): number;
            /**
                * Set the camera's zoom level in mercator zoom level units.
                */
            setZoomLevel(zoomLevel: number): void;
            /**
                * Whether the camera is animating.
                */
            get isAnimating(): boolean;
            /**
                * Cancel the last animation.
                */
            cancelAnimation(): void;
            /**
                * How far the camera can zoom in towards the ground
                */
            get maxZoomLevel(): number;
            /**
                * How far the camera can zoom out away from the ground
                */
            get minZoomLevel(): number;
            /**
                * Toggle the mode of the camera to automatically set the minimum zoom level based on the size of the scene.
                * It will be automatically disabled when the minimum zoom level is set manually.
                * @param value The new value for the auto min zoom level mode.
                */
            setAutoMinZoomLevel(value: boolean): void;
            /**
                * The mode of the camera to automatically set the minimum zoom level based on the size of the scene.
                */
            get autoMinZoomLevel(): boolean;
            /**
                * How far out the camera can zoom
                *
                * @param zoomLevel  The minimum zoom level in mercator zoom level units.
                * @default 0
                */
            setMinZoomLevel(zoomLevel: number, disableAutoMinZoomLevel?: boolean): void;
            /**
                * How far in the camera can zoom
                *
                * @param zoomLevel The maximum zoom level in mercator zoom level units.
                * @default Infinity
                */
            setMaxZoomLevel(zoomLevel: number): void;
            /**
                * The maximum pitch in degrees.
                */
            get maxPitch(): number;
            /**
                * The minimum pitch in degrees.
                */
            get minPitch(): number;
            /**
                * @param pitch The minimum pitch in degrees.
                */
            setMinPitch(pitch: number): void;
            /**
                * @param pitch The maximum pitch in degrees.
                */
            setMaxPitch(pitch: number): void;
            /**
                * The camera's current clockwise rotation in degrees from north.
                */
            get bearing(): number;
            /**
                * @param bearing The bearing in degrees from north.
                */
            setBearing(bearing: number): void;
            /**
                * The camera's current pitch in degrees.
                */
            get pitch(): number;
            /**
                *
                * @param pitch The pitch in degrees.
                */
            setPitch(pitch: number): void;
            /**
                * The camera's current elevation in meters from the ground.
                */
            get elevation(): number;
            /**
                * @param elevation The elevation in meters.
                */
            setElevation(elevation: number): void;
            /**
                * Animate the camera's elevation to a new value.
                * @param elevation The new elevation in meters.
                * @param options The animation options.
                */
            animateElevation(elevation: number, options?: AnimateElevationOptions): Promise<void>;
            /**
                * The padding around the edges of the map when focusing on a set of coordinates.
                */
            get insetsPadding(): InsetPadding;
            /**
                * The camera's current pan mode.
                */
            get panMode(): "default" | "elevation";
            /**
                * Set the camera's pan mode. 'elevation' moves the camera up and down, while 'default' allows the camera to pan along the ground.
                */
            setPanMode(panMode: 'default' | 'elevation'): void;
            /**
                *
                * @param padding The padding around the edges of the map when focusing on a set of coordinates (in screen pixels).
                */
            setInsetPadding(padding: InsetPadding): void;
            animateTo(options: AnimateToOptions): Promise<void>;
            getCameraFrameForCoordinates(coordinates: (GeoJSONPosition | Position | string)[], options?: FocusOnOptions): {
                    center: Position;
                    zoomLevel: number;
            };
            /**
                *  Focuses the camera on a set of coordinates, with optional animation
                *
                * @param target list of [longitude, latitude, altitude?] points
                * @param options {FocusOnOptions}
                * @returns Promise<void>
                */
            focusOn(target: (GeoJSONPosition | Position | string)[], options?: FocusOnOptions): Promise<void>;
    }
    export function processTargets(targets: (GeoJSONPosition | Position | string)[], core: RendererCore, geometry3DMap: Map<string | number, All3DTypes>): {
            pointCloud: Vector3[];
            geoBounds: LngLatBoundsLike;
            firstPosition: (Position | GeoJSONPosition) | null;
    };
}

declare module '@mappedin/mappedin-js/geojson/examples/src/utils/scene-graph-visualizer' {
    import type Core from '@mappedin/mappedin-js/geojson/src/renderer';
    export function mountSceneGraphVisualizer(mv: Core, gui: any): void;
}

declare module '@mappedin/mappedin-js/geojson/src/utils/collision-ranking-tier' {
    /**
        * Defines the priority levels for collider collision handling, allowing customization of collider visibility in congested areas.
        *
        * | Value  | Description                                                                                                                             |
        * |--------|-----------------------------------------------------------------------------------------------------------------------------------------|
        * | medium | Colliders with this ranking have a standard visibility priority and may be hidden in favor of higher-ranked colliders in crowded areas. |
        * | high   | These colliders are given higher visibility priority than 'medium' priority.                                                            |
        * | always-visible | Colliders with this ranking will not be hidden, ensuring their constant visibility regardless of crowding. |
        *
        * Use this type to fine-tune the visibility of colliders, enhancing map readability and user experience by prioritizing important information.
        */
    export type CollisionRankingTier = 'low' | 'medium' | 'high' | 'always-visible' | number;
    export const LOW_RANK_INDEX = 2;
    export const MEDIUM_RANK_INDEX = 3;
    export const HIGH_RANK_INDEX = 4;
    export const ALWAYS_VISIBLE_RANK_INDEX = 5;
    /**
        * @param tier CollisionRankingTier as a string or number
        * @returns The number representation of the tier, clamped to the valid range
        */
    export function convertCollisionRankingTierToNumber(tier: CollisionRankingTier): number;
    /**
        * @param rank Rank as a number
        * @returns The CollisionRankingTier representation of the rank, clamped to the valid range
        */
    export function convertNumberToCollisionRankingTier(rank: number): CollisionRankingTier;
}

declare module '@mappedin/mappedin-js/geojson/src/components/text3d' {
    import type { Position } from '@mappedin/mappedin-js/geojson/src/types';
    import { z } from 'zod';
    import type { Feature, Point } from 'geojson';
    import { Geometry3DObject3D } from '@mappedin/mappedin-js/geojson/src/entities/geometry3d';
    import type { BatchedText, Text } from '@mappedin/mappedin-js/geojson/src/services/text3d/text3d';
    import type { Text3DStyle } from '@mappedin/mappedin-js/geojson/src/components/styles';
    import type { MeshComponentProperties } from '@mappedin/mappedin-js/geojson/src/components/mesh';
    import type { GroupContainerObject3D } from '@mappedin/mappedin-js/geojson/src/entities/group-container';
    import { type FloorTextCommonProperties } from '@mappedin/mvf';
    /**
        * State representing an Text3D
        */
    export type Text3DState = {
            readonly id: string | number;
            readonly type: 'text3d';
            /**
                * The position of the Text3D in [lon, lat, altitude]
                */
            readonly position: Position;
            /**
                * Whether the Text3D is visible
                */
            visible: boolean;
            /**
                * Attempt to keep the Text3D facing the camera as much as possible
                */
            flipToFaceCamera: boolean;
            /**
                * Content of the text3d
                */
            content: string;
    } & Text3DStyle;
    export const text3DStateSchema: z.ZodObject<{
            visible: z.ZodBoolean;
            color: z.ZodString;
            flipToFaceCamera: z.ZodBoolean;
            font: z.ZodOptional<z.ZodString>;
            fontSize: z.ZodNumber;
            margin: z.ZodUnion<[z.ZodNumber, z.ZodTuple<[z.ZodNumber, z.ZodNumber, z.ZodNumber, z.ZodNumber], null>]>;
            outlineColor: z.ZodString;
            outlineOpacity: z.ZodNumber;
            outlineBlur: z.ZodUnion<[z.ZodNumber, z.ZodString]>;
            outlineWidth: z.ZodNumber;
            outlineOffsetX: z.ZodNumber;
            outlineOffsetY: z.ZodNumber;
            strokeWidth: z.ZodNumber;
            maxWidth: z.ZodOptional<z.ZodNumber>;
            maxHeight: z.ZodOptional<z.ZodNumber>;
            strokeOpacity: z.ZodNumber;
            strokeColor: z.ZodString;
            fillOpacity: z.ZodNumber;
            hoverColor: z.ZodOptional<z.ZodString>;
            id: z.ZodUnion<[z.ZodString, z.ZodNumber]>;
            type: z.ZodLiteral<"text3d">;
            position: z.ZodTuple<[z.ZodNumber, z.ZodNumber, z.ZodNumber], null>;
            content: z.ZodString;
    }, "strip", z.ZodTypeAny, {
            type: "text3d";
            visible: boolean;
            color: string;
            flipToFaceCamera: boolean;
            fontSize: number;
            margin: number | [number, number, number, number];
            outlineColor: string;
            outlineOpacity: number;
            outlineBlur: string | number;
            outlineWidth: number;
            outlineOffsetX: number;
            outlineOffsetY: number;
            strokeWidth: number;
            strokeOpacity: number;
            strokeColor: string;
            fillOpacity: number;
            id: string | number;
            position: [number, number, number];
            content: string;
            maxWidth?: number | undefined;
            font?: string | undefined;
            maxHeight?: number | undefined;
            hoverColor?: string | undefined;
    }, {
            type: "text3d";
            visible: boolean;
            color: string;
            flipToFaceCamera: boolean;
            fontSize: number;
            margin: number | [number, number, number, number];
            outlineColor: string;
            outlineOpacity: number;
            outlineBlur: string | number;
            outlineWidth: number;
            outlineOffsetX: number;
            outlineOffsetY: number;
            strokeWidth: number;
            strokeOpacity: number;
            strokeColor: string;
            fillOpacity: number;
            id: string | number;
            position: [number, number, number];
            content: string;
            maxWidth?: number | undefined;
            font?: string | undefined;
            maxHeight?: number | undefined;
            hoverColor?: string | undefined;
    }>;
    /**
        * @interface
        */
    export type InitializeText3DState = Partial<Omit<Text3DState, 'id' | 'type'>>;
    export const initializeText3DStateSchema: z.ZodObject<Omit<{
            visible: z.ZodOptional<z.ZodBoolean>;
            color: z.ZodOptional<z.ZodString>;
            flipToFaceCamera: z.ZodOptional<z.ZodBoolean>;
            font: z.ZodOptional<z.ZodOptional<z.ZodString>>;
            fontSize: z.ZodOptional<z.ZodNumber>;
            margin: z.ZodOptional<z.ZodUnion<[z.ZodNumber, z.ZodTuple<[z.ZodNumber, z.ZodNumber, z.ZodNumber, z.ZodNumber], null>]>>;
            outlineColor: z.ZodOptional<z.ZodString>;
            outlineOpacity: z.ZodOptional<z.ZodNumber>;
            outlineBlur: z.ZodOptional<z.ZodUnion<[z.ZodNumber, z.ZodString]>>;
            outlineWidth: z.ZodOptional<z.ZodNumber>;
            outlineOffsetX: z.ZodOptional<z.ZodNumber>;
            outlineOffsetY: z.ZodOptional<z.ZodNumber>;
            strokeWidth: z.ZodOptional<z.ZodNumber>;
            maxWidth: z.ZodOptional<z.ZodOptional<z.ZodNumber>>;
            maxHeight: z.ZodOptional<z.ZodOptional<z.ZodNumber>>;
            strokeOpacity: z.ZodOptional<z.ZodNumber>;
            strokeColor: z.ZodOptional<z.ZodString>;
            fillOpacity: z.ZodOptional<z.ZodNumber>;
            hoverColor: z.ZodOptional<z.ZodOptional<z.ZodString>>;
            id: z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>;
            type: z.ZodOptional<z.ZodLiteral<"text3d">>;
            position: z.ZodOptional<z.ZodTuple<[z.ZodNumber, z.ZodNumber, z.ZodNumber], null>>;
            content: z.ZodOptional<z.ZodString>;
    }, "type" | "id">, "strict", z.ZodTypeAny, {
            maxWidth?: number | undefined;
            visible?: boolean | undefined;
            color?: string | undefined;
            flipToFaceCamera?: boolean | undefined;
            font?: string | undefined;
            fontSize?: number | undefined;
            margin?: number | [number, number, number, number] | undefined;
            outlineColor?: string | undefined;
            outlineOpacity?: number | undefined;
            outlineBlur?: string | number | undefined;
            outlineWidth?: number | undefined;
            outlineOffsetX?: number | undefined;
            outlineOffsetY?: number | undefined;
            strokeWidth?: number | undefined;
            maxHeight?: number | undefined;
            strokeOpacity?: number | undefined;
            strokeColor?: string | undefined;
            fillOpacity?: number | undefined;
            hoverColor?: string | undefined;
            position?: [number, number, number] | undefined;
            content?: string | undefined;
    }, {
            maxWidth?: number | undefined;
            visible?: boolean | undefined;
            color?: string | undefined;
            flipToFaceCamera?: boolean | undefined;
            font?: string | undefined;
            fontSize?: number | undefined;
            margin?: number | [number, number, number, number] | undefined;
            outlineColor?: string | undefined;
            outlineOpacity?: number | undefined;
            outlineBlur?: string | number | undefined;
            outlineWidth?: number | undefined;
            outlineOffsetX?: number | undefined;
            outlineOffsetY?: number | undefined;
            strokeWidth?: number | undefined;
            maxHeight?: number | undefined;
            strokeOpacity?: number | undefined;
            strokeColor?: string | undefined;
            fillOpacity?: number | undefined;
            hoverColor?: string | undefined;
            position?: [number, number, number] | undefined;
            content?: string | undefined;
    }>;
    /**
        * At this moment updating text margin is not supported
        * Margin and content update are not handled at the moment.
        * @interface
        */
    export type UpdatableText3DState = Omit<InitializeText3DState, 'margin' | 'position' | 'content'>;
    export const updateText3DStateSchema: z.ZodObject<Omit<Omit<{
            visible: z.ZodOptional<z.ZodBoolean>;
            color: z.ZodOptional<z.ZodString>;
            flipToFaceCamera: z.ZodOptional<z.ZodBoolean>;
            font: z.ZodOptional<z.ZodOptional<z.ZodString>>;
            fontSize: z.ZodOptional<z.ZodNumber>;
            margin: z.ZodOptional<z.ZodUnion<[z.ZodNumber, z.ZodTuple<[z.ZodNumber, z.ZodNumber, z.ZodNumber, z.ZodNumber], null>]>>;
            outlineColor: z.ZodOptional<z.ZodString>;
            outlineOpacity: z.ZodOptional<z.ZodNumber>;
            outlineBlur: z.ZodOptional<z.ZodUnion<[z.ZodNumber, z.ZodString]>>;
            outlineWidth: z.ZodOptional<z.ZodNumber>;
            outlineOffsetX: z.ZodOptional<z.ZodNumber>;
            outlineOffsetY: z.ZodOptional<z.ZodNumber>;
            strokeWidth: z.ZodOptional<z.ZodNumber>;
            maxWidth: z.ZodOptional<z.ZodOptional<z.ZodNumber>>;
            maxHeight: z.ZodOptional<z.ZodOptional<z.ZodNumber>>;
            strokeOpacity: z.ZodOptional<z.ZodNumber>;
            strokeColor: z.ZodOptional<z.ZodString>;
            fillOpacity: z.ZodOptional<z.ZodNumber>;
            hoverColor: z.ZodOptional<z.ZodOptional<z.ZodString>>;
            id: z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>;
            type: z.ZodOptional<z.ZodLiteral<"text3d">>;
            position: z.ZodOptional<z.ZodTuple<[z.ZodNumber, z.ZodNumber, z.ZodNumber], null>>;
            content: z.ZodOptional<z.ZodString>;
    }, "type" | "id">, "maxWidth" | "margin" | "maxHeight" | "position" | "content">, "strict", z.ZodTypeAny, {
            visible?: boolean | undefined;
            color?: string | undefined;
            flipToFaceCamera?: boolean | undefined;
            font?: string | undefined;
            fontSize?: number | undefined;
            outlineColor?: string | undefined;
            outlineOpacity?: number | undefined;
            outlineBlur?: string | number | undefined;
            outlineWidth?: number | undefined;
            outlineOffsetX?: number | undefined;
            outlineOffsetY?: number | undefined;
            strokeWidth?: number | undefined;
            strokeOpacity?: number | undefined;
            strokeColor?: string | undefined;
            fillOpacity?: number | undefined;
            hoverColor?: string | undefined;
    }, {
            visible?: boolean | undefined;
            color?: string | undefined;
            flipToFaceCamera?: boolean | undefined;
            font?: string | undefined;
            fontSize?: number | undefined;
            outlineColor?: string | undefined;
            outlineOpacity?: number | undefined;
            outlineBlur?: string | number | undefined;
            outlineWidth?: number | undefined;
            outlineOffsetX?: number | undefined;
            outlineOffsetY?: number | undefined;
            strokeWidth?: number | undefined;
            strokeOpacity?: number | undefined;
            strokeColor?: string | undefined;
            fillOpacity?: number | undefined;
            hoverColor?: string | undefined;
    }>;
    export type Text3DProperties = {
            id: string;
            content: string;
            textArea?: MeshComponentProperties['textArea'];
    };
    export type AddText3DOptions = {
            appearance?: Partial<InitializeText3DState>;
    };
    export const addText3DOptionsSchema: z.ZodObject<{
            appearance: z.ZodOptional<z.ZodObject<Omit<{
                    visible: z.ZodOptional<z.ZodBoolean>;
                    color: z.ZodOptional<z.ZodString>;
                    flipToFaceCamera: z.ZodOptional<z.ZodBoolean>;
                    font: z.ZodOptional<z.ZodOptional<z.ZodString>>;
                    fontSize: z.ZodOptional<z.ZodNumber>;
                    margin: z.ZodOptional<z.ZodUnion<[z.ZodNumber, z.ZodTuple<[z.ZodNumber, z.ZodNumber, z.ZodNumber, z.ZodNumber], null>]>>;
                    outlineColor: z.ZodOptional<z.ZodString>;
                    outlineOpacity: z.ZodOptional<z.ZodNumber>;
                    outlineBlur: z.ZodOptional<z.ZodUnion<[z.ZodNumber, z.ZodString]>>;
                    outlineWidth: z.ZodOptional<z.ZodNumber>;
                    outlineOffsetX: z.ZodOptional<z.ZodNumber>;
                    outlineOffsetY: z.ZodOptional<z.ZodNumber>;
                    strokeWidth: z.ZodOptional<z.ZodNumber>;
                    maxWidth: z.ZodOptional<z.ZodOptional<z.ZodNumber>>;
                    maxHeight: z.ZodOptional<z.ZodOptional<z.ZodNumber>>;
                    strokeOpacity: z.ZodOptional<z.ZodNumber>;
                    strokeColor: z.ZodOptional<z.ZodString>;
                    fillOpacity: z.ZodOptional<z.ZodNumber>;
                    hoverColor: z.ZodOptional<z.ZodOptional<z.ZodString>>;
                    id: z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>;
                    type: z.ZodOptional<z.ZodLiteral<"text3d">>;
                    position: z.ZodOptional<z.ZodTuple<[z.ZodNumber, z.ZodNumber, z.ZodNumber], null>>;
                    content: z.ZodOptional<z.ZodString>;
            }, "type" | "id">, "strict", z.ZodTypeAny, {
                    maxWidth?: number | undefined;
                    visible?: boolean | undefined;
                    color?: string | undefined;
                    flipToFaceCamera?: boolean | undefined;
                    font?: string | undefined;
                    fontSize?: number | undefined;
                    margin?: number | [number, number, number, number] | undefined;
                    outlineColor?: string | undefined;
                    outlineOpacity?: number | undefined;
                    outlineBlur?: string | number | undefined;
                    outlineWidth?: number | undefined;
                    outlineOffsetX?: number | undefined;
                    outlineOffsetY?: number | undefined;
                    strokeWidth?: number | undefined;
                    maxHeight?: number | undefined;
                    strokeOpacity?: number | undefined;
                    strokeColor?: string | undefined;
                    fillOpacity?: number | undefined;
                    hoverColor?: string | undefined;
                    position?: [number, number, number] | undefined;
                    content?: string | undefined;
            }, {
                    maxWidth?: number | undefined;
                    visible?: boolean | undefined;
                    color?: string | undefined;
                    flipToFaceCamera?: boolean | undefined;
                    font?: string | undefined;
                    fontSize?: number | undefined;
                    margin?: number | [number, number, number, number] | undefined;
                    outlineColor?: string | undefined;
                    outlineOpacity?: number | undefined;
                    outlineBlur?: string | number | undefined;
                    outlineWidth?: number | undefined;
                    outlineOffsetX?: number | undefined;
                    outlineOffsetY?: number | undefined;
                    strokeWidth?: number | undefined;
                    maxHeight?: number | undefined;
                    strokeOpacity?: number | undefined;
                    strokeColor?: string | undefined;
                    fillOpacity?: number | undefined;
                    hoverColor?: string | undefined;
                    position?: [number, number, number] | undefined;
                    content?: string | undefined;
            }>>;
            parentId: z.ZodOptional<z.ZodString>;
    }, "strict", z.ZodTypeAny, {
            parentId?: string | undefined;
            appearance?: {
                    maxWidth?: number | undefined;
                    visible?: boolean | undefined;
                    color?: string | undefined;
                    flipToFaceCamera?: boolean | undefined;
                    font?: string | undefined;
                    fontSize?: number | undefined;
                    margin?: number | [number, number, number, number] | undefined;
                    outlineColor?: string | undefined;
                    outlineOpacity?: number | undefined;
                    outlineBlur?: string | number | undefined;
                    outlineWidth?: number | undefined;
                    outlineOffsetX?: number | undefined;
                    outlineOffsetY?: number | undefined;
                    strokeWidth?: number | undefined;
                    maxHeight?: number | undefined;
                    strokeOpacity?: number | undefined;
                    strokeColor?: string | undefined;
                    fillOpacity?: number | undefined;
                    hoverColor?: string | undefined;
                    position?: [number, number, number] | undefined;
                    content?: string | undefined;
            } | undefined;
    }, {
            parentId?: string | undefined;
            appearance?: {
                    maxWidth?: number | undefined;
                    visible?: boolean | undefined;
                    color?: string | undefined;
                    flipToFaceCamera?: boolean | undefined;
                    font?: string | undefined;
                    fontSize?: number | undefined;
                    margin?: number | [number, number, number, number] | undefined;
                    outlineColor?: string | undefined;
                    outlineOpacity?: number | undefined;
                    outlineBlur?: string | number | undefined;
                    outlineWidth?: number | undefined;
                    outlineOffsetX?: number | undefined;
                    outlineOffsetY?: number | undefined;
                    strokeWidth?: number | undefined;
                    maxHeight?: number | undefined;
                    strokeOpacity?: number | undefined;
                    strokeColor?: string | undefined;
                    fillOpacity?: number | undefined;
                    hoverColor?: string | undefined;
                    position?: [number, number, number] | undefined;
                    content?: string | undefined;
            } | undefined;
    }>;
    export class Text3DComponent {
            mesh: Geometry3DObject3D;
            textMesh?: Text;
            readonly type = "text3d";
            feature: Feature<Point, Text3DProperties | (FloorTextCommonProperties & {
                    verticalOffset: number;
            })>;
            constructor(feature: Feature<Point, Text3DProperties | (FloorTextCommonProperties & {
                    verticalOffset: number;
            })>);
            get visible(): boolean;
            set visible(visible: boolean);
            parent?: GroupContainerObject3D;
            batchedText?: BatchedText;
            /**
                * if this Text3DComponent is a polygon label, populate this id with the polygon entity id
                * This id is used to prevent drawing text for the same polygon.
                */
            polygonEntityId?: string;
    }
}

declare module '@mappedin/mappedin-js/geojson/src/entities/utils' {
    import type { CollisionRankingTier, GeometryState, LabelState, ModelState, RendererCore } from '@mappedin/mappedin-js/geojson/src';
    import { type MarkerState } from '@mappedin/mappedin-js/geojson/src/components/marker';
    import type { PathUpdateState } from '@mappedin/mappedin-js/geojson/src/components/path';
    import type { EntityTypes, All3DTypes, Position, RendererState } from '@mappedin/mappedin-js/geojson/src/renderer';
    import type { KeysOfUnion } from '@mappedin/mappedin-js/geojson/src/utils';
    import { GeometryGroupObject3D, type GeometryGroupState } from '@mappedin/mappedin-js/geojson/src/entities/geometry-group';
    import { GroupContainerObject3D } from '@mappedin/mappedin-js/geojson/src/entities/group-container';
    import { Geometry3D, Geometry3DObject3D } from '@mappedin/mappedin-js/geojson/src/entities/geometry3d';
    import type { ModelGeometry3D, Geometry3DTypes, TextGeometry3D } from '@mappedin/mappedin-js/geojson/src/entities/geometry3d';
    import { Geometry2D, Geometry2DObject3D } from '@mappedin/mappedin-js/geojson/src/entities/geometry2d';
    import type { StyleComponent } from '@mappedin/mappedin-js/geojson/src/components/styles/style';
    import type { GeometryGroupStyleComponent } from '@mappedin/mappedin-js/geojson/src/components/geometry-group-style';
    import { type Text3DState, type UpdatableText3DState } from '@mappedin/mappedin-js/geojson/src/components/text3d';
    export function updateInteractivity(entity: All3DTypes | Geometry2D, update: boolean | undefined, state: RendererState): boolean;
    export function updateGroupColor(entity: GeometryGroupObject3D, state: RendererState, update: Partial<Pick<GeometryGroupState, 'color' | 'topColor'>>): boolean | undefined;
    export function updateGroupShading(entity: GeometryGroupObject3D, update?: GeometryGroupState['shading']): boolean;
    export function updateImageProps(entity: Geometry3D | Geometry2D | GeometryGroupObject3D | GroupContainerObject3D, update?: Partial<GeometryState>): void;
    export function updateHeight(entity: Geometry3D | GeometryGroupObject3D, state: RendererState, update?: number): boolean;
    export function updateColor(entity: Geometry3DTypes | Geometry2D | GeometryGroupObject3D | GroupContainerObject3D, update?: Partial<GeometryState>): void;
    export function updatePosition(entity: EntityTypes, update: Position | undefined, convertTo3DMapPosition: RendererCore['convertTo3DMapPosition']): void;
    export function updateParent(entity: EntityTypes, update: GroupContainerObject3D | undefined): boolean;
    export function updateEnabled(entity: Geometry3D | Geometry2D | GeometryGroupObject3D | GroupContainerObject3D, update: boolean | undefined): void;
    export function updateMarker(entity: Geometry3D | Geometry2D | GeometryGroupObject3D | GroupContainerObject3D, update: Partial<MarkerState> | undefined, state: RendererState): boolean;
    export function updateRank(entity: Geometry3D | Geometry2D | GeometryGroupObject3D | GroupContainerObject3D, update: CollisionRankingTier | undefined): boolean;
    export function updateLabel(entity: Geometry3D | Geometry2D | GeometryGroupObject3D | GroupContainerObject3D, update: Partial<LabelState> | undefined, state: RendererState): void;
    export function updateHoverColor(entity: Geometry3D | Geometry2D | GeometryGroupObject3D | GroupContainerObject3D, update?: string): void;
    /** Sets a geometry to be in hovered state, until manually unset or the user interacts with it. */
    export function updateHovered(entity: Geometry3D, update?: boolean): boolean;
    export function updateFlipImageToFaceCamera(entity: EntityTypes, update?: boolean): void;
    export function updateVisibility(entity: EntityTypes, state: RendererState, update?: boolean): boolean;
    export function updateOpacity(entity: Geometry3D | Geometry2D | GeometryGroupObject3D | GroupContainerObject3D, state: RendererState, update?: number): boolean;
    export function updateGroupTexture(entity: Geometry3D | Geometry2D | GeometryGroupObject3D | GroupContainerObject3D, update?: Pick<GeometryGroupStyleComponent, 'texture' | 'topTexture'>): void;
    export function updateIndividualGeometryTexture(entity: Geometry3D, update?: Pick<StyleComponent, 'texture' | 'topTexture'>): boolean;
    export function updateIndividualGeometryOpacity(entity: Geometry3D, update?: number): boolean;
    export function updateAltitude(entity: EntityTypes, update?: number): boolean;
    export function updateOutline(entity: All3DTypes, update?: boolean): boolean;
    export function updateFocusable(entity: Geometry3D, update?: boolean): boolean;
    export function updateIndividualGeometryRenderOrder(entity: Geometry3D, update?: number): boolean;
    export function handlePathUpdate(geometry: Geometry3DTypes, state: RendererState, update: PathUpdateState): void;
    export function pickPathOptions(update: PathUpdateState): Partial<PathUpdateState>;
    export function getEntityId(entityOrEntityId: Geometry2D | Geometry3DTypes | Geometry2DObject3D | Geometry3DObject3D | GeometryGroupObject3D | GroupContainerObject3D | string | number): any;
    export function assetGeometryIsText3D(geometry: Geometry3DTypes): asserts geometry is TextGeometry3D;
    /**
        * @internal
        */
    export const TEXT3D_STYLE_UPDATE_PROPS: KeysOfUnion<UpdatableText3DState>[];
    /**
        * Handle state update of the text3d geometry.
        */
    export function handleText3DUpdate(geometry: TextGeometry3D, state: RendererState, update: Partial<Text3DState>): void;
    /**
        * @internal
        */
    export const MODEL_UPATE_PROPS: KeysOfUnion<ModelState>[];
    export function handleModelStyleUpdate(geometry: ModelGeometry3D, update: Partial<ModelState>): void;
}

declare module '@mappedin/mappedin-js/packages/geojson-navigator' {
    export * from '@mappedin/mappedin-js/packages/geojson-navigator/src';
}

declare module '@mappedin/mappedin-js/geojson/src/utils' {
    import type { Object3D, Camera as THREECamera } from 'three';
    import { MercatorCoordinate } from '@mappedin/mappedin-js/packages/outdoor-context-v4';
    import type { CustomLayerInterface } from '@mappedin/mappedin-js/packages/outdoor-context-v4';
    import { GroupContainerObject3D } from '@mappedin/mappedin-js/geojson/src/entities/group-container';
    import type { Geometry2D } from '@mappedin/mappedin-js/geojson/src/entities/geometry2d';
    import type { Geometry3DTypes } from '@mappedin/mappedin-js/geojson/src/entities/geometry3d';
    import type { Position, RendererState } from '@mappedin/mappedin-js/geojson/src/renderer';
    import type { Camera } from '@mappedin/mappedin-js/geojson/src/camera';
    import { GeometryGroupObject3D } from '@mappedin/mappedin-js/geojson/src/entities/geometry-group';
    export { isFiniteBox } from '@packages/internal/common';
    export function cartesianToGeographic(centerLat: number, centerLon: number, x: number, y: number): {
        lat: number;
        lon: number;
    };
    export function geographicToCartesian(centerLat: number, centerLon: number, targetLat: number, targetLon: number): {
        x: number;
        y: number;
    };
    export const populateGeometry3DIdsInScene: (tree: GroupContainerObject3D["children"][0] | Object3D, entities: RendererState["geometry3DIdsInScene"]) => Set<string | number>;
    export const populateGeometry2DIdsInScene: (tree: any, entities: Set<Geometry2D["id"]>) => Set<string | number>;
    export function convertMapLibreStylePaintProps(paint: any): {
        color: any;
        height: any;
        altitude: any;
        opacity: any;
        outline: any;
    };
    export function convertMapLibreLineStylePaintProps(paint: any): {
        color: any;
        join: any;
        opacity: any;
        width: any;
        cap: any;
    };
    export function mergeObjects<T extends Record<string, any>>(obj1: T, obj2: T): T;
    export function createCustomLayer(modelAsMercatorCoordinate: MercatorCoordinate, viewCamera: THREECamera, camera: Camera, onRender: () => void): CustomLayerInterface;
    export function getRequestHeaders(authURL: string): Promise<{
        'x-mappedin-tiles-key': string;
    }>;
    export function cyrb53(str: string, seed?: number): number;
    export const linearEase: (t: number) => number;
    export const quadEaseIn: (t: number) => number;
    export const easeIn: (x: number) => number;
    export const quadEaseOut: (t: number) => number;
    export function interpolate(value: number, inputMin: number, inputMax: number, outputMin: number, outputMax: number, easeFunc?: (t: number) => number): number;
    export function interpolateMulti(value: number, inputRange: number[], outputRange: number[], easeFunc?: (t: number) => number): number;
    /**
    /*  getProjectionScaleFactor()
    /*  finds the scale ratio between screen coordinates and 3D coordinates (in X-Z plane)
    /*
          *                                    R
          *                                  /|
          *    C : Camera                  /  |
          *    PQ : Projection Plane     /    |
          *    OR : Origin             /      |
          *    F : FOV               /        |
          *                      Q /          |
          *                      /|           |
          *                    /  |           |
          *                  /    |           |
          *                /      |           |
          *              /        |           |
          *            / F/2      |           |
          *         C ------------P------------ O
          *
          *
          *   ProjectionScaleFactor = ( OR / PQ )
          *   PQ = canvasHeight / 2
          *   CQ = zoom
          *
          *   OR / C0 = tan(F/2)
          *   so OR = CO * tan(F/2)
          */
    export function getProjectionScaleFactor(FOV: number, canvasHeight: number, zoom: number): number;
    export function getBoundingBoxCenter(bbox: Position[]): [number, number];
    export { getCornersOfBoundingBox } from '@mappedin/mappedin-js/geojson/src/utils/bounding-box';
    export { getGeometryByGeometryId } from '@mappedin/mappedin-js/geojson/src/utils/ecs';
    export { getPixelRatio } from '@mappedin/mappedin-js/geojson/src/utils/get-pixel-ratio';
    export { debounce } from '@mappedin/mappedin-js/geojson/src/utils/async';
    export { shouldDisableOffscreenCanvas } from '@mappedin/mappedin-js/geojson/src/utils/browser';
    export { noop, pick, isEmpty, type KeysOfUnion } from '@mappedin/mappedin-js/geojson/src/utils/fp';
    export { transformRequest } from '@mappedin/mappedin-js/geojson/src/utils/tranform-request';
    export { normalizeAngle } from '@mappedin/mappedin-js/geojson/src/utils/math';
    export function shouldExpandZoomLevel(minZoomFromCurrentPanBounds: number, cameraZoomLevel: number): boolean;
    export function getGroupContainerOpacity(entity: Geometry3DTypes | GeometryGroupObject3D): number;
}

declare module '@mappedin/mappedin-js/geojson/src/utils/constants' {
    import type { InsetPadding } from '@mappedin/mappedin-js/geojson/src/types';
    export const DEFAULT_INSET_PADDING: InsetPadding;
    export const MAPPEDIN_LAYER_ID = "mappedin";
    export enum ENTITY_3D_LAYERS {
        DEFAULT = 0,
        OUTLINES = 1
    }
    /**
      * Duration of zoom in/out animation when double tapping with one finger or single tapping with two fingers.
      */
    export const TAP_ZOOM_DURATION = 250;
}

declare module '@mappedin/mappedin-js/geojson/src/utils/debug' {
    import type Core from '@mappedin/mappedin-js/geojson/src/renderer';
    const DEFAULT_DEBUG_STATE: {
        showPolygonLabelTextAreaMesh: boolean;
        showEnvMap: boolean;
    };
    export type DebugState = typeof DEFAULT_DEBUG_STATE;
    export class Debug {
        state: {
            showPolygonLabelTextAreaMesh: boolean;
            showEnvMap: boolean;
        };
        core: Core;
        constructor(core: Core);
        update(updateState: Partial<DebugState>): void;
    }
    export {};
}

declare module '@mappedin/mappedin-js/geojson/src/services/test-mode' {
    export function enableTestMode(): void;
    export function isTestMode(): boolean;
}

declare module '@mappedin/mappedin-js/geojson/src/systems/watermark/system' {
    import type { PerspectiveCamera } from 'three';
    import { PubSub } from '@packages/internal/common';
    import type { Geometry2D } from '@mappedin/mappedin-js/geojson/src/entities';
    import type { QuadTree } from '@packages/internal/quad-tree';
    import type { RendererState } from '@mappedin/mappedin-js/geojson/src/renderer';
    export type WatermarkPosition = 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right' | 'center' | 'top' | 'bottom' | 'left' | 'right';
    export type WatermarkOptions = {
            /**
                * Padding in pixels. Can be a number or an object with top, right, bottom, and left properties.
                * @default 16
                */
            padding?: number | {
                    top?: number;
                    right?: number;
                    bottom?: number;
                    left?: number;
            };
            /**
                * Position of the watermark on the screen.
                * @default 'bottom-left'
                */
            position?: WatermarkPosition;
            /**
                * Show only the Mappedin icon without text.
                * @default false
                */
            iconOnly?: boolean;
            /**
                * Color of the watermark.
                * @default 'dark'
                */
            color?: 'light' | 'dark';
            /**
                * Scale of the watermark between 0.5 and 1.5.
                * @default 1
                */
            scale?: number;
            /**
                * Callback when the watermark is clicked.
                * @hidden
                */
            onClick?: () => void;
            /**
                * Whether the watermark is interactive.
                * @default true
                */
            interactive?: boolean;
            /**
                * Whether the watermark should be visible.
                * @hidden
                * @default true
                */
            visible?: boolean;
    };
    export type WatermarkUpdateOptions = Omit<WatermarkOptions, 'onClick' | 'visible'> & {
            /** Show the Mappedin watermark. Once it is visible it cannot be hidden again. */
            visible?: true;
            /** Set the interactivity of the watermark. */
            interactive?: boolean;
    };
    export class WatermarkSystem extends PubSub<{
            'texture-loaded': void;
    }> {
            #private;
            dirty: boolean;
            get options(): Required<WatermarkOptions>;
            set options(options: WatermarkUpdateOptions);
            get icon(): string;
            constructor(cameraObject: PerspectiveCamera, rendererState: RendererState, options?: Partial<WatermarkOptions>);
            get width(): number;
            get height(): number;
            getPositionAlignedOffset(width: number, height: number): {
                    x: number;
                    y: number;
            };
            getPositionAlignedCanvasCoordinates: (canvasWidth: number, canvasHeight: number) => {
                    x: number;
                    y: number;
            };
            getPositionAlignedPadding: () => {
                    x: number;
                    y: number;
            };
            insertIntoQuadTree(quadTree: QuadTree<{
                    entityId: Geometry2D['id'];
            }>): void;
            resize(canvasWidth: number, canvasHeight: number): void;
            update(): void;
            destroy(): void;
    }
}

declare module '@mappedin/mappedin-js/geojson/src/systems/text3d/system' {
    import type { RendererState } from '@mappedin/mappedin-js/geojson/src/renderer';
    import type { RendererCore } from '@mappedin/mappedin-js/geojson/src';
    import { PubSub } from '@packages/internal/common';
    import { GroupContainerObject3D } from '@mappedin/mappedin-js/geojson/src/entities/group-container';
    import type { Text, BatchedText } from 'troika-three-text';
    export class Text3DSystem extends PubSub<{
            render: undefined;
    }> {
            textSet: Set<string>;
            batchedTextMap: Map<GroupContainerObject3D, Promise<BatchedText>>;
            remove(id: string): void;
            constructor(rendererState: RendererState, convertTo3DMapPosition: RendererCore['convertTo3DMapPosition']);
            update(cameraRotationRadians: number): Promise<void[]>;
            showTextAreaMesh(): void;
            hideTextAreaMesh(): void;
    }
    /**
        *  Preload fonts and optionally pre-generate the SDF textures for particular glyphs up front.
        *  This is to avoid ondemand font generation can take long.
        *  @param fontUrl - url of the font file served.
        *  @returns  A promise that resolves when the font is loaded
        *
        */
    export function preloadFont(fontUrl?: string): Promise<string>;
    export function doesBatchedTextContainsText(batchedText: BatchedText, text: Text): boolean;
    export const DEFAULT_VERTICAL_OFFSET = 0.5;
}

declare module '@mappedin/mappedin-js/geojson/src/systems/exporter' {
    export { ExporterSystem, type GLTFExportOptions } from '@mappedin/mappedin-js/geojson/src/systems/exporter/exporter';
}

declare module '@mappedin/mappedin-js/geojson/src/systems/html-controls/system' {
    import type { Map } from '@mappedin/mappedin-js/packages/outdoor-context-v4';
    import '../../styles/html-controls.scss';
    /**
        * All possible control anchor positions.
        */
    export const ATTRIBUTION_POSITIONS: readonly ["top-left", "top-right", "bottom-left", "bottom-right"];
    export type AttributionPosition = (typeof ATTRIBUTION_POSITIONS)[number];
    export type AttributionControlOptions = {
            custom?: string[];
            position?: AttributionPosition;
            feedback?: boolean;
    };
    export class HTMLControlsSystem {
            controlContainerEl: HTMLDivElement;
            controlPositions: Record<AttributionPosition, HTMLDivElement>;
            compact: boolean | undefined;
            attribContainerEl?: HTMLDetailsElement;
            attribInnerEl?: HTMLDivElement;
            attribButtonEl?: HTMLElement;
            feedbackLinkEl?: HTMLAnchorElement;
            attribHTML: string;
            customAttributions: string[];
            constructor(container: HTMLElement);
            addAttributionControl(options?: AttributionControlOptions): void;
            toggleAttribution: (e: MouseEvent) => void;
            destroyAttributionControl(): void;
            resize(canvasWidth: number): void;
            /**
                * This should fire when Maplibre data changes.
                */
            updateData(map: Map): void;
            destroy(): void;
    }
}

declare module '@mappedin/mappedin-js/geojson/src/components/styles' {
    export { StyleComponent, DEFAULT_COLOR, type MaterialSide } from '@mappedin/mappedin-js/geojson/src/components/styles/style';
    export { Text3DStyleComponent, type Text3DStyle, DEFAULT_TEXT_STYLE } from '@mappedin/mappedin-js/geojson/src/components/styles/text-style';
    export { ModelStyleComponnet, type ModelStyle } from '@mappedin/mappedin-js/geojson/src/components/styles/model-style';
    export { DEFAULT_ROTATION, DEFAULT_SCALE } from '@mappedin/mappedin-js/geojson/src/components/styles/constants';
}

declare module '@mappedin/mappedin-js/mappedin-js/src/api-geojson/api' {
    import type { RendererCore, WatermarkUpdateOptions } from '@mappedin/core-sdk';
    import { type TShow3DMapOptions } from '@mappedin/mappedin-js/mappedin-js/src';
    import { WALLS, DOORS } from '@mappedin/mappedin-js/mappedin-js/src/types';
    import type MapData from '@mappedin/mappedin-js/mappedin-js/src/map-data';
    import type { FloorStack, MapDataInternal } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    import { Facade, Coordinate, MapObject, Space, Floor, Door } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    import type { MapView } from '@mappedin/mappedin-js/mappedin-js/src/map-view';
    import { Label, Marker, Shape } from '@mappedin/mappedin-js/mappedin-js/src/map-view-objects';
    import { Text3D as Text3DView, Model, Path, type Image } from '@mappedin/mappedin-js/mappedin-js/src/map-view-objects';
    import { Navigation } from '@mappedin/mappedin-js/mappedin-js/src/navigation';
    import type { TGetState, TUpdateState } from '@mappedin/mappedin-js/mappedin-js/src/types';
    import { Camera } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/camera';
    import { Exporter } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/exporter';
    import { Labels } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/labels';
    import { GeojsonApiMapObject } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/map-object';
    import { Markers } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/markers';
    import { Images } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/images';
    import { Models } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/models';
    import { Paths } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/paths';
    import { BlueDot } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/blue-dot/blue-dot';
    import type { TFloorChangeReason } from '@mappedin/mappedin-js/mappedin-js/src/events';
    import { Shapes } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/shapes';
    import { Style } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/style';
    import Outdoor from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/outdoor';
    import { type BBox } from 'geojson';
    import { Text3D } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/text3d';
    import { PathSegment } from '@mappedin/mappedin-js/mappedin-js/src/map-view-objects/path';
    export class GeoJsonApi {
            core: RendererCore;
            mapObjects: GeojsonApiMapObject[];
            id: string;
            mapDataExternal: {
                    [key in string]: MapData;
            };
            mapData?: MapData;
            currentMap: GeojsonApiMapObject;
            hiddenOutdoorGeometries: [
                    BBox,
                    polygons: GeoJSON.Feature<GeoJSON.Polygon | GeoJSON.MultiPolygon, any>[],
                    layers: string[]
            ][];
            mapView: MapView;
            Camera: Camera;
            Labels: Labels;
            Text3D: Text3D;
            Markers: Markers;
            Models: Models;
            Paths: Paths;
            Exporter: Exporter;
            Navigation: Navigation;
            Outdoor: Outdoor;
            BlueDot: BlueDot;
            Shapes: Shapes;
            Style: Style;
            Images: Images;
            get DynamicFocus(): import("..").DynamicFocus;
            get StackedMaps(): import("..").StackedMaps;
            constructor(rendererCore: RendererCore, mapView: MapView);
            updateState<T extends Space | Text3DView | MapObject | Label | Shape | Marker | Model | Door | Facade | Floor | WALLS | DOORS | Path | PathSegment | (string & NonNullable<unknown>)>(target: T, state: TUpdateState<T>): void;
            update: () => void;
            getMapDataInternal(): MapDataInternal | undefined;
            getMapData(): MapData | undefined;
            addMap(mapData: MapData, options?: TShow3DMapOptions): Promise<MapData>;
            setFloor(floor: Floor | string, reason?: TFloorChangeReason): void;
            setFloorStack(floorStack: FloorStack | string): void;
            updateWatermark(options: WatermarkUpdateOptions): void;
            get currentFloorStack(): FloorStack;
            get currentFloor(): Floor;
            getState<T extends Space | Text3DView | MapObject | Label | Marker | Image | Shape | Model | Path | PathSegment | Floor | Facade | string>(target: T): TGetState<T>;
            setHoverColor(c: string): void;
            getHoverColor(): string | undefined;
            /**
                * Create a coordinate from a screen coordinate
                * @param x - The x coordinate of the screen
                * @param y - The y coordinate of the screen
                * @param floor - The floor to use for the coordinate
                * @returns The coordinate
                */
            createCoordinateFromScreenCoordinate(x: number, y: number, floor?: Floor): Coordinate | undefined;
            getScreenCoordinateFromCoordinate(coordinate: Coordinate): {
                    x: number;
                    y: number;
            };
            isInView(target: Space | MapObject | Label | Marker | string): boolean;
            auto(): {
                    labels: Label[];
            };
            /**
                * @internal
                */
            get __core(): RendererCore;
            clear(): void;
            destroy(): void;
    }
}

declare module '@mappedin/mappedin-js/mappedin-js/src/api-geojson/map-object' {
    import type { ParsedMVF } from '@mappedin/mvf';
    import type { FeatureCollection, LineString, MultiPolygon, Polygon } from 'geojson';
    import { PubSub } from '@packages/internal/common';
    import type { Position, AddLabelOptions, RendererCore, PathState, MarkerState, LineStyle, PaintStyle, EntityId } from '@mappedin/core-sdk';
    import { FloorObject } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/floor-object';
    import type { Directions, Floor, TAddMarkerOptions, TAddPathOptions, TShow3DMapOptions } from '@mappedin/mappedin-js/mappedin-js/src';
    import type { GLTFExportOptions, TAnimationOptions, TAddModelOptions, TAddImageOptions, TDirectionInstruction, TAddText3DOptions, IAnchorable, TAddLabelOptions } from '@mappedin/mappedin-js/mappedin-js/src/types';
    import { type AggregatedStyleMap } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/utils';
    import { StackedMaps } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/stacked-maps/stacked-maps';
    import type { TFloorChangeReason } from '@mappedin/mappedin-js/mappedin-js/src/events';
    import type { Path, Shape, Label } from '@mappedin/mappedin-js/mappedin-js/src/map-view-objects';
    import type { MapDataInternal } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    import { Space, Coordinate } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    import { type GeoJsonApi } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/api';
    import { FloorStackObject } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/floor-stack-object';
    import { DynamicFocus } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/dynamic-focus';
    import type { Text3DState } from '@mappedin/core-sdk/src/components/text3d';
    export class GeojsonApiMapObject extends PubSub<{
        'floor-change': {
            reason?: TFloorChangeReason;
            floorId: string;
            previousFloorId: string;
        };
        'floor-change-start': {
            reason?: TFloorChangeReason;
            floorId: string;
            previousFloorId: string;
        };
        'navigation-connection-click': {
            fromFloor?: Floor;
            toFloor: Floor;
            instruction: TDirectionInstruction;
        };
        'navigation-active-path-change': {
            directions: Directions;
            path: Path;
        };
    }> {
        #private;
        floorStacksById: Map<string, FloorStackObject>;
        floorsById: Map<string, FloorObject>;
        currentFloorId: string;
        currentFloorStackId: string;
        outdoorFloorStacks: Set<string>;
        id: string;
        renderer: RendererCore;
        api: GeoJsonApi;
        mvf: ParsedMVF;
        options: TShow3DMapOptions;
        styleMap: AggregatedStyleMap;
        StackedMaps: StackedMaps;
        DynamicFocus: DynamicFocus;
        get currentFloorStack(): FloorStackObject;
        setFloorStack(floorStackId: string, reason?: TFloorChangeReason): void;
        get currentFloor(): FloorObject;
        /** @deprecated use `currentFloorStack.floorObjects` or `floorsById` instead */
        get floors(): FloorObject[];
        processFloorChange(floorId: string): void;
        setFloor(floorId: string, reason?: TFloorChangeReason): void;
        Models: {
            add: (id: string, targets: Coordinate[], opts: TAddModelOptions & {
                floorId?: string;
                url: string;
            }) => (import("@mappedin/core-sdk").GeometryState | import("@mappedin/core-sdk").ModelState)[];
            remove: (_id: string, _groupId: string) => void;
        };
        Images: {
            add: (target: Position, url: string, opts: TAddImageOptions & {
                floorId?: string;
            }) => EntityId<import("@mappedin/core-sdk/src/components/image").ImageState> | undefined;
            remove: (id: string) => void;
            removeAll: () => void;
        };
        Markers: {
            add: (coordinate: Coordinate, html: string, opts: TAddMarkerOptions) => EntityId<MarkerState> | undefined;
            remove: (id: string) => void;
            getContentEl: (id: string) => HTMLElement | undefined;
            removeAll: () => void;
            setPosition: (id: string, coordinate: Position, targetFloorId: string) => void;
            animateTo: (id: string, coordinate: Position, targetFloorId: string, options?: TAnimationOptions) => Promise<void>;
        };
        Exporter: {
            getCurrentSceneGLTF: (options: GLTFExportOptions) => Promise<Blob>;
        };
        Shapes: {
            add: <T extends FeatureCollection<Polygon | MultiPolygon | LineString, any>>(geometry: T, style: T extends FeatureCollection<LineString, any> ? LineStyle : PaintStyle, opts: {
                floorId?: string;
            }) => string;
            remove: (customGeometry: Shape) => string;
        };
        Text3D: {
            label: (target: Space, content?: string, options?: TAddText3DOptions) => Text3DInfo | undefined;
            labelAll: (option?: TAddText3DOptions) => Text3DInfo[];
            remove: (id: string) => string | undefined;
        };
        Labels: {
            all: ({ onCreate, labelOptions, }: {
                onCreate: (labelId: string | number, text: string, target: IAnchorable) => void;
                labelOptions?: TAddLabelOptions;
            }) => void;
            add: (coordinate: Coordinate, text: string, opts?: AddLabelOptions & {
                floorId?: string;
                parentId?: string;
                verticalOffset?: number;
            }) => {
                id: string | number;
            };
            remove: ({ label, entityId }: {
                label: Label;
                entityId: string;
            }) => void;
            removeAll: () => void;
        };
        Paths: {
            add: (coordinates: Coordinate[], options?: TAddPathOptions & {
                id?: string;
            }) => {
                paths: (EntityId<PathState> & {
                    coordinates: Coordinate[];
                })[];
                animation: Promise<void>;
            };
            remove: (entityIds: string[]) => void;
        };
        constructor(id: string, mapDataInternal: MapDataInternal | undefined, options: TShow3DMapOptions | undefined, api: GeoJsonApi);
    }
    export type Text3DInfo = {
        target: Space;
        textInfo: EntityId<Text3DState>;
    };
}

declare module '@mappedin/mappedin-js/mappedin-js/src/map-view-objects/label' {
    import type { IAnchorable, IFocusable } from '@mappedin/mappedin-js/mappedin-js/src/types';
    /**
        * Class representing a label on the {@link MapView}.
        *
        * Labels contain text and an image that are anchored to a specific point on the map. They automatically rotate and show and hide based on priority and zoom level.
        * Use them to inform users about location names, points of interest and more!
        *
        * Effective use of labels allows an app to convey additional information to the user.
        * For example labels can be used to show room names, important points of interest, main entrances or any other piece of contextual information that is useful to the user.
        *
        * Refer to the [Labels Guide](https://developer.mappedin.com/web-sdk/labels) for more information and interactive examples.
        */
    export class Label implements IFocusable {
            /**
                * The label's id
                */
            readonly id: string;
            /**
                * The label's text
                */
            readonly text: string;
            /**
                * The target object where the label is anchored.
                */
            readonly target: IAnchorable;
            /**
                * @internal
                */
            static readonly __type = "Label";
            /**
                * @internal
                */
            readonly __type = "Label";
            /**
                * Checks if the provided instance is of type Label.
                *
                * @param instance The instance to check.
                * @returns {boolean} True if the instance is a Label, false otherwise.
                */
            static is(instance: object): instance is Label;
            /** @internal */
            get focusTarget(): import("..").Coordinate;
            /**
                * @internal
                */
            constructor(id: string, text: string, target: IAnchorable);
    }
}

declare module '@mappedin/mappedin-js/mappedin-js/src/map-view-objects/marker' {
    import type { IAnchorable, IFocusable } from '@mappedin/mappedin-js/mappedin-js/src/types';
    /**
        * Mappedin JS allows adding and removing Markers on a map using the {@link Markers} class. Markers are elements containing HTML that Mappedin JS anchors to a {@link Door}, {@link Space}, {@link Coordinate} or {@link Node}.
        * They are automatically rotated and repositioned when the camera moves.
        *
        * Refer to the [Markers Guide](https://developer.mappedin.com/web-sdk/markers) for more information and interactive examples.
        */
    export class Marker implements IFocusable {
            #private;
            /**
                * The marker's id
                */
            id: string;
            /**
                * @internal
                */
            static readonly __type = "Marker";
            get target(): IAnchorable;
            get coordinate(): import("..").Coordinate;
            /**
                * @internal
                */
            readonly __type = "Marker";
            /**
                * The HTML element that represents the marker.
                */
            readonly contentEl: HTMLElement;
            /**
                * Checks if the provided instance is of type Marker"
                *
                * @param instance The instance to check.
                * @returns {boolean} True if the instance is a Marker, false otherwise.
                */
            static is(instance: object): instance is Marker;
            /**
                * @internal
                */
            constructor(id: string, contentEl: HTMLElement, target: IAnchorable);
            /** @internal */
            get focusTarget(): import("..").Coordinate;
            /**
                * @internal
                */
            updateTarget(target: IAnchorable): void;
    }
}

declare module '@mappedin/mappedin-js/mappedin-js/src/map-view-objects/image' {
    import type { IAnchorable } from '@mappedin/mappedin-js/mappedin-js/src/types';
    /**
        * Class representing an Image on the {@link MapView}.
        */
    export class Image {
            #private;
            /**
                * The image's target
                */
            readonly target: IAnchorable;
            /**
                * @internal
                */
            static readonly __type = "Image";
            /**
                * @internal
                */
            readonly __type = "Image";
            /**
                * Checks if the provided instance is of type Image"
                *
                * @param instance The instance to check.
                * @returns {boolean} True if the instance is a Image, false otherwise.
                */
            static is(instance: object): instance is Image;
            /**
                * @internal
                */
            constructor(id: string, url: string, target: IAnchorable);
            /**
                * The image's id
                */
            get id(): string;
            /**
                * The image's url
                */
            get url(): string;
    }
}

declare module '@mappedin/mappedin-js/mappedin-js/src/map-view-objects/model' {
    import { IAnchorable } from '@mappedin/mappedin-js/mappedin-js/src/types';
    /**
        * Class representing a 3D model on the {@link MapView}.
        *
        * Adding 3D models to a map can be a great way to represent landmarks to help users find key locations. They could also be used to show the location of assets or represent furniture to provide a rich indoor layout.
    
        * Mappedin JS supports models in Graphics Library Transmission Format (GLTF) and GL Transmission Format Binary (GLB) format. Models with nested meshes are not supported and should not be used.
        *
        * 3D Models can be added to a {@link Coordinate}, {@link Door} or {@link Space}.
        * When adding the same model to multiple locations at the same time always use an array instead of calling the add method multiple times.
        * This allows the SDK to re-use the same instance of the model to reduce RAM usage and rendering time, resulting in better performance.
        *
        * Models are added using {@link Models.add}.
        *
        * Refer to the [3D Models Guide](https://developer.mappedin.com/web-sdk/3d-models) for more information and interactive examples.
        */
    export class Model {
            #private;
            /**
                * The model's id
                */
            id: string;
            /**
                * The group's id
                */
            groupId: string;
            /**
                * @internal
                */
            static readonly __type = "Model";
            /**
                * @internal
                */
            readonly __type = "Model";
            get target(): IAnchorable;
            /**
                * Checks if the provided instance is of type Model
                *
                * @param instance The instance to check.
                * @returns {boolean} True if the instance is a Marker, false otherwise.
                */
            static is(instance: object): instance is Model;
            /**
                * @internal
                */
            constructor(id: string, groupId: string, target: IAnchorable);
            /**
                * @internal
                */
            updateTarget(target: IAnchorable): void;
    }
}

declare module '@mappedin/mappedin-js/mappedin-js/src/map-view-objects/shape' {
    import type { IFocusable } from '@mappedin/mappedin-js/mappedin-js/src/types';
    /**
        * Class representing GeoJSON shape on the {@link MapView}.
        *
        * Refer to the [Shapes Guide](https://developer.mappedin.com/web-sdk/shapes) for more information and interactive examples.
        */
    export class Shape implements IFocusable {
            /**
                * id of Shape
                */
            readonly id: string;
            /**
                * @internal
                */
            static readonly __type = "Shape";
            /**
                * @internal
                */
            readonly __type = "Shape";
            /**
                * Checks if the provided instance is of type Shape.
                *
                * @param instance The instance to check.
                * @returns {boolean} True if the instance is a Shape, false otherwise.
                */
            static is(instance: object): instance is Shape;
            /** @internal */
            get focusTarget(): this;
            /**
                * @internal
                */
            constructor(id: string);
    }
}

declare module '@mappedin/mappedin-js/mappedin-js/src/map-view-objects/text3d' {
    import type { Space, EnterpriseLocation } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    /**
        * Class representing an Text3D on the {@link MapView}.
        */
    export class Text3D {
            /**
                * The text3d's id
                */
            readonly id: string;
            /**
                * @internal
                */
            constructor(id: string, target: Space | EnterpriseLocation);
            /**
                * The text3d's target
                */
            readonly target: Space | EnterpriseLocation;
            /**
                * @internal
                */
            static readonly __type = "Text3D";
            readonly __type = "Text3D";
            /**
                * Checks if the provided instance is of type Text3D
                *
                * @param instance The instance to check.
                * @returns {boolean} True if the instance is a text3d, false otherwise.
                */
            static is(instance: object): instance is Text3D;
    }
}

declare module '@mappedin/mappedin-js/mappedin-js/src/api-geojson/camera' {
    import type { IFocusable, TCameraAnimationOptions, TCameraTarget, TFocusOnOptions, TCameraInteractionsSetOptions } from '@mappedin/mappedin-js/mappedin-js/src/types';
    import type { InsetPadding } from '@mappedin/mappedin-js/geojson/src';
    import { Coordinate } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    import type { GeoJsonApi } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/api';
    /**
        * The Camera class is used to control the camera's position, pitch, bearing, and zoom level. It can also be used to focus
        * on one or more locations on the map. The camera can be repositioned instantly or animated to a new position.
        *
        * This class is accessed using {@link MapView.Camera}
        *
        * Refer to the [Camera Guide](https://developer.mappedin.com/web-sdk/camera) for more information and interactive examples.
        */
    export class Camera {
            #private;
            /**
                * @internal
                */
            constructor(api: GeoJsonApi);
            /**
                * Controls which camera interactions are enabled/disabled.
                */
            interactions: {
                    set: (options: TCameraInteractionsSetOptions) => void;
                    enable: () => void;
                    disable: () => void;
            };
            /**
                * Define an area of the screen that is safe for the camera. Anything outside the safe area is assumed to be covered in some way. The camera will not place any map elements there when calling {@link Camera.focusOn}.
                *
                * @param padding The padding in pixels.
                */
            setScreenOffsets(padding: InsetPadding): void;
            get screenOffsets(): InsetPadding;
            /**
                * The camera's current pan mode.
                */
            get panMode(): "default" | "elevation";
            /**
                * Set the camera's pan mode. 'elevation' moves the camera up and down, while 'default' allows the camera to pan in all directions.
                * @experimental
                * @param panMode The new pan mode.
                */
            setPanMode(panMode: 'default' | 'elevation'): void;
            /**
                * Get the camera transform that can be used to focus on a target or array of targets. Similar to {@link Camera.focusOn} but returns the transform directly.
                * @param target The target(s) to get the camera transform for.
                * @param options Optional settings for the camera transform.
                * @returns The camera transform which can then be passed to {@link Camera.set} or {@link Camera.animateTo}.
                *
                * @example
                * // Focus on a single space
                * const transform = mapView.Camera.getCameraFocusTransform(space, { minZoomLevel: 5 });
                * mapView.Camera.animateTo(transform);
                */
            getFocusOnTransform(target: IFocusable | IFocusable[], options?: TFocusOnOptions): TCameraTarget;
            /**
                * Focuses the camera on a specific target or array of targets.
                *
                * @param target The target(s) to focus on, either a single element or an array of elements.
                * @param options Optional settings for focusing the camera.
                * @example
                * // Focus on a single space
                * mapView.Camera.focusOn(space, { minZoomLevel: 5, duration: 1000 });
                */
            focusOn(target: IFocusable | IFocusable[], options?: TFocusOnOptions): Promise<void>;
            /**
                * Animates the camera to a specified target.
                * @param target The target configuration for the camera.
                * @param options Optional settings for the camera animation.
                * @example
                * mapView.Camera.animateTo({ center: coordinate, zoomLevel: 10 }, { duration: 500 });
                */
            animateTo(target: TCameraTarget, options?: TCameraAnimationOptions): Promise<void>;
            /**
                * Sets the camera to a specified target without animation.
                * @param target The target configuration for the camera.
                * @example
                * mapView.Camera.set({ center: coordinate, zoomLevel: 10 });
                */
            set(target: TCameraTarget): void;
            /**
                * The current center coordinate ({@link Coordinate}) of the camera.
                */
            get center(): Coordinate;
            /**
                * Toggle the mode of the camera to automatically set the minimum zoom level based on the size of the scene.
                * It will be automatically disabled when the minimum zoom level is set manually.
                * @param value The new value for the auto min zoom level mode.
                */
            setAutoMinZoomLevel(value: boolean): void;
            /**
                * The mode of the camera to automatically set the minimum zoom level based on the size of the scene.
                */
            get autoMinZoomLevel(): boolean;
            /**
                * The current zoom level of the camera in mercator zoom levels.
                *
                * @see https://wiki.openstreetmap.org/wiki/Zoom_levels
                */
            get zoomLevel(): number;
            /**
                * The current pitch of the camera in degrees.
                */
            get pitch(): number;
            /**
                * The minimum pitch of the camera in degrees.
                */
            get minPitch(): number;
            /**
                * The maximum pitch of the camera in degrees.
                */
            get maxPitch(): number;
            /**
                * Update the minimum pitch of the camera in degrees.
                * @param minPitch The new minimum pitch.
                */
            setMinPitch: (minPitch: number) => void;
            /**
                * Update the maximum pitch of the camera in degrees.
                * @param maxPitch The new maximum pitch.
                */
            setMaxPitch: (maxPitch: number) => void;
            /**
                * The current bearing of the camera in degrees clockwise from North. 0 degrees is North, 90 degrees is East, 180 degrees is South, and 270 degrees is West.
                */
            get bearing(): number;
            /**
                * The minimum zoom level of the camera in mercator zoom levels.
                *
                * @see https://wiki.openstreetmap.org/wiki/Zoom_levels
                */
            get minZoomLevel(): number;
            /**
                * Update the minimum zoom level of the camera in mercator zoom levels.
                * @param zoomLevel The new minimum zoom level.
                * @see https://wiki.openstreetmap.org/wiki/Zoom_levels
                */
            setMinZoomLevel: (zoomLevel: number) => void;
            /**
                * The maximum zoom level of the camera in mercator zoom levels.
                *
                * @see https://wiki.openstreetmap.org/wiki/Zoom_levels
                */
            get maxZoomLevel(): number;
            /**
                * Update the maximum zoom level of the camera in mercator zoom levels.
                * @param zoomLevel The new maximum zoom level.
                * @see https://wiki.openstreetmap.org/wiki/Zoom_levels
                * @default 22
                * @max 24
                * @min 0
                */
            setMaxZoomLevel: (zoomLevel: number) => void;
            /**
                * Set the camera's elevation in meters.
                * @experimental
                * @param elevation The new elevation in meters.
                */
            setElevation(elevation: number): void;
            /**
                * The current elevation of the camera in meters.
                */
            get elevation(): number;
            /**
                * Animate the camera's elevation to a specified elevation.
                * @experimental
                * @param elevation The target elevation in meters.
                * @param options Optional settings for the camera animation.
                */
            animateElevation(elevation: number, options?: TCameraAnimationOptions): Promise<void>;
    }
}

declare module '@mappedin/mappedin-js/mappedin-js/src/api-geojson/labels' {
    import type { IAnchorable, TAddLabelOptions } from '@mappedin/mappedin-js/mappedin-js/src/types';
    import { Label } from '@mappedin/mappedin-js/mappedin-js/src/map-view-objects';
    import type { GeojsonApiMapObject } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/map-object';
    /**
        * Class used to add and remove a {@link Label} on the {@link MapView}.
        *
        * Labels contain text and an image that are anchored to a specific point on the map. They automatically rotate and show and hide based on priority and zoom level.
        * Use them to inform users about location names, points of interest and more!
        *
        * Effective use of labels allows an app to convey additional information to the user.
        * For example labels can be used to show room names, important points of interest, main entrances or any other piece of contextual information that is useful to the user.
        *
        * This class is accessed using {@link MapView.Labels}.
        *
        * Refer to the [Labels Guide](https://developer.mappedin.com/web-sdk/labels) for more information and interactive examples.
        */
    export class Labels {
            #private;
            /**
                * @internal
                */
            get currentMap(): GeojsonApiMapObject | undefined;
            /**
                * @internal
                */
            constructor({ currentMapGetter }: {
                    currentMapGetter: CurrentMapGetter;
            });
            /**
                * @internal
                */
            getById(id: string): {
                    label: Label;
                    entityId: string;
            } | undefined;
            /**
                * Adds a label ({@link Label}) to the map.
                *
                * @param target The target object ({@link IAnchorable}) where the label should be added.
                * @param text The text of the label.
                * @param options Optional additional options for the label.
                * @returns {Label | undefined} The created label, or undefined if creation failed.
                * @example
                *
                * mapView.Labels.add(space, 'Welcome', { appearance: { color: 'blue' } });
                */
            add(target: IAnchorable, text: string, options?: TAddLabelOptions | undefined): Label;
            /**
                * Automatically adds all the labels ({@link Label}) to the map.
                *
                * The text, appearance, priority, etc. of the labels will be automatically determined based on the external data.
                *
                * @param options Optional additional options for the labels, similar to those in the `add` method.
                * @example
                * // Add all the labels to the map
                * mapView.Labels.all();
                */
            all(options?: TAddLabelOptions): Label[];
            /**
                * Removes a label ({@link Label}) from the map.
                *
                * @param label The label which should be removed.
                * @example
                * mapView.Labels.remove(space);
                */
            remove(label: Label): void;
            /**
                * Removes all the labels ({@link Label}) from the map.
                *
                * @example
                * mapView.Labels.removeAll();
                */
            removeAll(): Label[];
    }
    type CurrentMapGetter = () => GeojsonApiMapObject | undefined;
    export {};
}

declare module '@mappedin/mappedin-js/mappedin-js/src/api-geojson/markers' {
    import type { IAnchorable, TAddMarkerOptions, TAnimationOptions } from '@mappedin/mappedin-js/mappedin-js/src/types';
    import { Marker } from '@mappedin/mappedin-js/mappedin-js/src/map-view-objects';
    import type { GeojsonApiMapObject } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/map-object';
    /**
        * Mappedin JS allows adding and removing Markers on a map. Markers are elements containing HTML that Mappedin JS anchors to a {@link Door}, {@link Space}, {@link Coordinate} or {@link Node}.
        * They are automatically rotated and repositioned when the camera moves.
        *
        * This class is accessed using {@link MapView.Markers}.
        *
        * Refer to the [Markers Guide](https://developer.mappedin.com/web-sdk/markers) for more information and interactive examples.
        */
    export class Markers {
            #private;
            /**
                * @internal
                */
            get currentMap(): GeojsonApiMapObject | undefined;
            /**
                * @internal
                */
            constructor({ currentMapGetter }: {
                    currentMapGetter: CurrentMapGetter;
            });
            /**
                * @internal
                */
            getById(id: string): {
                    marker: Marker;
                    entityId: string;
            } | undefined;
            /**
                * Adds a marker to the map.
                *
                * @param target The target object ({@link IAnchorable}) for the marker.
                * @param html The HTML content for the {@link Marker}.
                * @param options Optional additional options for the {@link Marker}.
                * @returns {Marker | undefined} The created {@link Marker}, or undefined if creation failed.
                * @example
                * // Add an interactive Marker to the map with custom HTML content.
                * mapView.Markers.add(coordinate, '<div>Marker Content</div>', { interactive: true });
                */
            add(target: IAnchorable, html: string, options?: TAddMarkerOptions): Marker;
            /**
                * Removes a marker from the map.
                *
                * @param marker {Marker} The {@link Marker} which should be removed.
                * @example
                * mapView.Markers.remove(marker);
                */
            remove(marker: Marker): void;
            /**
                * Remove all the markers from the map.
                *
                * @example
                * mapView.Markers.removeAll();
                */
            removeAll(): Marker[];
            /**
                * Update the position of a marker.
                * @param marker The {@link Marker} which should be removed.
                * @param target The new target object ({@link Space}, {@link Door}, or {@link Coordinate}) for the marker.
                * @example
                * const marker = mapView.Markers.add(coordinate, '<div>Marker Content</div>');
                * mapView.Markers.setPosition(marker, newCoordinate);
                */
            setPosition(marker: Marker, target: IAnchorable): void;
            /**
                * Update the position of a marker with an animation.
                * @param marker The {@link Marker} which should be updated.
                * @param target The new target object ({@link Space}, {@link Door}, or {@link Coordinate}) for the marker.
                * @param options Optional additional options for the animation.
                * @returns {Promise<void>} A promise that resolves when the animation is complete.
                * @example
                * const marker = mapView.Markers.add(coordinate, '<div>Marker Content</div>');
                * mapView.Markers.animateTo(marker, newCoordinate, { duration: 1000 });
                */
            animateTo(marker: Marker, target: IAnchorable, options?: TAnimationOptions): Promise<void>;
    }
    type CurrentMapGetter = () => GeojsonApiMapObject | undefined;
    export {};
}

declare module '@mappedin/mappedin-js/mappedin-js/src/api-geojson/models' {
    import type { TAddModelOptions } from '@mappedin/mappedin-js/mappedin-js/src/types';
    import { Model } from '@mappedin/mappedin-js/mappedin-js/src/map-view-objects';
    import type { CurrentMapGetter } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/types';
    import type { Coordinate } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    /**
        * Adding 3D models to a map can be a great way to represent landmarks to help users find key locations. They could also be used to show the location of assets or represent furniture to provide a rich indoor layout.
    
        * Mappedin JS supports models in Graphics Library Transmission Format (GLTF) and GL Transmission Format Binary (GLB) format. Models with nested meshes are not supported and should not be used.
        *
        * 3D Models can be added to a {@link Coordinate}.
        * When adding the same model to multiple locations at the same time always use an array instead of calling the add method multiple times.
        * This allows the SDK to re-use the same instance of the model to reduce RAM usage and rendering time, resulting in better performance.
        *
        * This class is accessed using {@link MapView.Models}.
        *
        * Refer to the [3D Models Guide](https://developer.mappedin.com/web-sdk/3d-models) for more information and interactive examples.
        */
    export class Models {
            #private;
            /**
                * @internal
                */
            get currentMap(): import("./map-object").GeojsonApiMapObject | undefined;
            /**
                * @internal
                */
            constructor({ currentMapGetter }: {
                    currentMapGetter: CurrentMapGetter;
            });
            /**
                * @internal
                */
            getById(id: string): {
                    model: Model;
                    entityId: string;
                    groupId: string;
            } | undefined;
            /**
                * Adds a 3D model to the map at the specified coordinate.
                *
                * @param coordinate - The {@link Coordinate} where the model will be placed.
                * @param url - The URL to the GLTF or GLB model file or a inline base64 encoded 3D asset from the {@link https://mappedin.com/3d-assets|Mappedin 3D Assets} library.
                * @param options - Configuration options for the model using {@link TAddModelOptions}.
                * @returns A {@link Model} instance representing the added 3D model.
                * @example
                * ```ts
                * // Add a model to a coordinate
                * import { truck } from '@mappedin/3d-assets';
                * const model = mapView.Models.add(coordinate, truck, {
                *   scale: [0.5, 0.5, 0.5],
                *   rotation: [0, 90, 0],
                *   interactive: true
                * });
                * ```
                */
            add(coordinate: Coordinate, url: string, options?: TAddModelOptions): Model;
            /**
                * Removes a model from the map.
                *
                * @param model - The {@link Model} instance which should be removed.
                * @example
                * mapView.Models.remove(model);
                */
            remove(model: Model): void;
            /**
                * Remove all the models from the map.
                *
                * @returns An array of all removed {@link Model} instances.
                * @example
                * const removedModels = mapView.Models.removeAll();
                */
            removeAll(): Model[];
    }
}

declare module '@mappedin/mappedin-js/mappedin-js/src/api-geojson/paths' {
    import type { GeojsonApiMapObject } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/map-object';
    import type { TAddPathOptions } from '@mappedin/mappedin-js/mappedin-js/src';
    import { Path } from '@mappedin/mappedin-js/mappedin-js/src/map-view-objects';
    import type { Coordinate } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    /**
        * While {@link Navigation} provides a complete start and end navigation illustration, it may be desired to draw just the path. This can be done using Paths.
        *
        * Paths is accessed using {@link MapView.Paths}.
        *
        * Paths can be drawn from one coordinate to another using {@link Paths.add}. If using just two coordinates, the path will be drawn straight between the two points.
        * This may work for some scenarios, but in most cases an app will need to show the user their walking path, going through doors and avoiding walls and other objects.
        * Such a path of coordinates can be created by calling the {@link MapData.getDirections} method, passing in a start and end {@link TNavigationTarget}. Note that a Space requires an entrance to be used as a target.
        *
        * The width of the path is set using the {@link TAddPathOptions.nearRadius} and {@link TAddPathOptions.farRadius} parameters. These values are in meters. `nearRadius` is the path width used at the lowest zoom level closest to the ground and `farRadius` is used at the highest zoom level. Additional path styles are outlined later in this guide in the Path Styles section.
        *
        * Refer to the [Drawing a Path](https://developer.mappedin.com/web-sdk/wayfinding#drawing-a-path) in the Wayfinding Guide for more information and interactive examples.
        */
    export class Paths {
            #private;
            /**
                * @internal
                */
            get currentMap(): GeojsonApiMapObject | undefined;
            /**
                * @internal
                */
            constructor({ currentMapGetter }: {
                    currentMapGetter: CurrentMapGetter;
            });
            /**
                * @internal
                */
            getById(id: string): {
                    path: Path;
                    entityIds: string[];
            } | undefined;
            /**
                * Adds a path ({@link Path}) to the map.
                * @param coordinate Array of coordinates ({@link Coordinate}) to form the path.
                * @param options Optional additional option
                * @example
                * // Add a red path to the map
                * mapView.Paths.add(coordinate,  { color: '#ff0000' });
                */
            add(coordinate: Coordinate[], options?: TAddPathOptions): Path;
            /**
                * Removes a specific path ({@link Path}) from the map.
                * @param path The path to be removed.
                * @example
                * mapView.Paths.remove(path);
                */
            remove(path: Path): void;
            /**
                * Removes all paths ({@link Path}) from the map.
                *
                * @example
                * mapView.Paths.removeAll();
                */
            removeAll(): Path[];
    }
    type CurrentMapGetter = () => GeojsonApiMapObject | undefined;
    export {};
}

declare module '@mappedin/mappedin-js/mappedin-js/src/navigation/index' {
    import { type TDirectionInstruction } from '@mappedin/mappedin-js/mappedin-js/src';
    import type { Directions, GeoJsonApi } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson';
    import type { GeojsonApiMapObject } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/map-object';
    import type { Floor, FloorStack } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    import { Path, Marker } from '@mappedin/mappedin-js/mappedin-js/src/map-view-objects';
    import type { RendererCore } from '@mappedin/core-sdk';
    /**
        * Options for navigation.
        */
    export type TNavigationOptions = {
            /**
                * Controls whether the map should be set to the floor of the connection point when a connection point is clicked.
                * @default true
                */
            setMapOnConnectionClick?: boolean;
            /**
                * Controls whether the map should be set to the floor of the departure point when the path is drawn.
                * @default true
                */
            setMapToDeparture?: boolean;
            /**
                * Controls whether markers are created for the departure, destination, and connection points.
                */
            createMarkers?: {
                    /**
                        * Controls whether a marker is created for the departure point and allows a custom marker to be created.
                        * @default true
                        */
                    departure?: boolean | ((instruction: TDirectionInstruction) => Marker);
                    /**
                        * Controls whether a marker is created for the destination point and allows a custom marker to be created.
                        * @default true
                        */
                    destination?: boolean | ((instruction: TDirectionInstruction) => Marker);
                    /**
                        * Controls whether markers are created for connection points and allows a custom marker to be created.
                        * @default true
                        */
                    connection?: boolean | ((instruction: TDirectionInstruction) => Marker);
            };
            /**
                * Path Options for the non-current path in multi-destination mode.
                */
            inactivePathOptions?: {
                    /**
                        * Duration in milliseconds for the path to be drawn.
                        * @default 1000
                        */
                    drawDuration?: number;
                    /**
                        * The color of the path.
                        * @default '#40A9FF'
                        */
                    color?: string;
                    /**
                        * Whether the path should be clickable.
                        *
                        * @defaultValue false
                        */
                    interactive?: boolean;
                    /**
                        * The accent color of the path. This is applied to arrows if they are displayed
                        * @default 'blue'
                        */
                    accentColor?: string;
                    /**
                        * The radius of the path near the markers.
                        * @default 0.25
                        */
                    nearRadius?: number;
                    /**
                        * The zoom level at which the path should be at its near radius. This will default to the Camera maxZoomLevel.
                        */
                    nearZoomLevel?: number;
                    /**
                        * The radius of the path far from the markers.
                        * @default 1
                        */
                    farRadius?: number;
                    /**
                        * The zoom level at which the path should be at its far radius. This will default to the Camera minZoomLevel.
                        */
                    farZoomLevel?: number;
                    /**
                        * Controls whether arrows are displayed on the path.
                        * @default false
                        */
                    displayArrowsOnPath?: boolean;
                    /**
                        * Controls whether arrows are animated.
                        * @default false
                        */
                    animateArrowsOnPath?: boolean;
            };
            /**
                * Options for the path.
                */
            pathOptions?: {
                    /**
                        * Duration in milliseconds for the path to be drawn.
                        * @default 1000
                        */
                    drawDuration?: number;
                    /**
                        * The color of the path.
                        * @default '#40A9FF'
                        */
                    color?: string;
                    /**
                        * Whether the path should be clickable.
                        *
                        * @defaultValue false
                        */
                    interactive?: boolean;
                    /**
                        * The accent color of the path. This is applied to arrows if they are displayed
                        * @default 'blue'
                        */
                    accentColor?: string;
                    /**
                        * The radius of the path near the markers.
                        * @default 0.25
                        */
                    nearRadius?: number;
                    /**
                        * The zoom level at which the path should be at its near radius. This will default to the Camera maxZoomLevel.
                        */
                    nearZoomLevel?: number;
                    /**
                        * The radius of the path far from the markers.
                        * @default 1
                        */
                    farRadius?: number;
                    /**
                        * The zoom level at which the path should be at its far radius. This will default to the Camera minZoomLevel.
                        */
                    farZoomLevel?: number;
                    /**
                        * Controls whether arrows are displayed on the path.
                        * @default false
                        */
                    displayArrowsOnPath?: boolean;
                    /**
                        * Controls whether arrows are animated.
                        * @default false
                        */
                    animateArrowsOnPath?: boolean;
            };
            /**
                * Options for the markers at the departure and destination.
                */
            markerOptions?: {
                    /**
                        * The color of the departure marker.
                        * @default '#1890FF'
                        */
                    departureColor?: string;
                    /**
                        * The color of the destination marker.
                        * @default '#722ED1'
                        */
                    destinationColor?: string;
            };
    };
    /**
        * When a user needs to get from point A to point B, drawing a path on the map helps them to navigate to their destination. It can help them to visualize the route they'll need to take, like a good treasure map.
    
        * Navigation is a helper class to display wayfinding easily on the map. Functionality of Navigation could be replicated by drawing the paths using {@link Paths} and adding well designed tooltips at connection points.
        *
        * This class is accessed using {@link MapView.Navigation}.
        *
        * {@link Navigation.draw} allows for easily drawing multiple components that make up a wayfinding illustration. It shows a human figure to mark the start point, a path with animated directional arrows, pulses in the direction of travel and a pin to mark the destination. Each of these components can be customized to match an app's style.
        *
        * Refer to the [Drawing Navigation](https://developer.mappedin.com/web-sdk/wayfinding#drawing-navigation) in the Wayfinding Guide for more information and interactive examples.
        */
    export class Navigation {
            #private;
            /**
                * @internal
                */
            get currentMap(): GeojsonApiMapObject;
            /**
                * Returns true if the navigation is for a multi-floor path.
                */
            get isMultiFloor(): boolean;
            /**
                * @internal
                */
            constructor(core: RendererCore, geoJSONApi: GeoJsonApi, currentMapGetter: CurrentMapGetter);
            /**
                * @internal
                */
            getPathById(id: string): {
                    path: Path;
                    entityIds: string[];
            } | undefined;
            /**
                * @internal
                */
            getMarkerById(id: string): {
                    instruction: TDirectionInstruction;
                    marker: Marker;
            } | undefined;
            /**
                * @internal
                */
            get paths(): Path[];
            /**
                * The currently active directions.
                */
            get activeDirections(): Directions | undefined;
            /**
                * The currently active path.
                */
            get activePath(): Path | undefined;
            /**
                * The current list of floor stacks along the navigation paths.
                */
            get floorStacks(): FloorStack[];
            /**
                * The current list of floors along the navigation paths.
                */
            get floors(): Floor[];
            /**
                * Sets the active path by index.
                */
            setActivePathByIndex(target: number): void;
            /**
                * Sets the active path.
                */
            setActivePath(target: Path): void;
            /**
                * Sets the active path by directions.
                */
            setActivePathByDirections(target: Directions): void;
            /**
                * @internal
                */
            drawSync(directions: Directions | Directions[], options?: TNavigationOptions): void;
            /**
                * Draws the specified directions on the map.
                * @param directions The directions to be drawn.
                * @param options Optional additional options for the navigation.
                */
            draw(directions: Directions | Directions[], options?: TNavigationOptions): Promise<unknown>;
            /**
                * Clears any drawn navigation paths or directions from the map.
                */
            clear(): void;
    }
    type CurrentMapGetter = () => GeojsonApiMapObject | undefined;
    export {};
}

declare module '@mappedin/mappedin-js/mappedin-js/src/api-geojson/exporter' {
    import type { GeojsonApiMapObject } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/map-object';
    import type { GLTFExportOptions } from '@mappedin/mappedin-js/mappedin-js/src/types';
    /**
        * API to export the scene.
        *
        * @hidden
        */
    export class Exporter {
            #private;
            /**
                * @internal
                */
            get currentMap(): GeojsonApiMapObject | undefined;
            /**
                * @internal
                */
            constructor({ currentMapGetter }: {
                    currentMapGetter: CurrentMapGetter;
            });
            /**
                * Exports the current scene as a GLTF file.
                *
                * @hidden
                */
            getCurrentSceneGLTF(userOptions: GLTFExportOptions): Promise<Blob>;
    }
    type CurrentMapGetter = () => GeojsonApiMapObject | undefined;
    export {};
}

declare module '@mappedin/mappedin-js/mappedin-js/src/api-geojson/style' {
    import type { StyleCollection } from '@mappedin/mvf';
    import type { GeojsonApiMapObject } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/map-object';
    export class Style {
            #private;
            /**
                * @internal
                */
            get currentMap(): GeojsonApiMapObject | undefined;
            /**
                * @internal
                */
            constructor({ currentMapGetter }: {
                    currentMapGetter: CurrentMapGetter;
            });
            setFromStyleCollection(styleCollection: StyleCollection): void;
    }
    type CurrentMapGetter = () => GeojsonApiMapObject | undefined;
    export {};
}

declare module '@mappedin/mappedin-js/mappedin-js/src/api-geojson/outdoor' {
    import { type RendererCore } from '@mappedin/core-sdk';
    import type { BBox } from 'geojson';
    export type HiddenOutdoorGeometry = [
            BBox,
            polygons: GeoJSON.Feature<GeoJSON.Polygon | GeoJSON.MultiPolygon, any>[],
            layers: string[]
    ];
    /**
        * The outdoor map shown around the Mappedin indoor map can be manipulated to show or hide additional information. It can be used to add GeoJSON based geometry, images, deck.gl layers and more.
        *
        * The outdoor map is accessed using {@link MapView.Outdoor.map}, which returns a maplibregl.Map object.
        * [MapLibre GL JS](https://maplibre.org/maplibre-gl-js/docs/) is a TypeScript library that uses WebGL to render interactive maps from vector tiles in a browser. The Mappedin SDK makes use of it to display the outdoor map.
        *
        * By providing access to the MapLibre map used to draw the outdoor map, the Mappedin SDK enables developers to draw on and manipulate the outdoor map.
        * Developers can use most capabilities of MapLibre GL JS with key exceptions being Interactivity and Camera, which are not available.
        *
        * User touch and click events are handled by Mappedin JS and are not propagated to the outdoor map layer. Camera movement is also handled by Mappedin JS and cannot be manipulated using MapLibre controls.
        *
        * Refer to the [Outdoor Map Guide](https://developer.mappedin.com/web-sdk/outdoor-map) for more information and interactive examples.
        */
    export default class Outdoor {
            #private;
            /**
                * @internal
                */
            constructor(core: RendererCore, hiddenOutdoorGeometry?: HiddenOutdoorGeometry[]);
            /**
                * Set the style of the outdoor map. Use one of [Mappedin's predefined styles](https://developer.mappedin.com/web-sdk/outdoor-map#styles) or link to a custom style.
                * @param style {any}
                */
            setStyle(style: any): void;
            /**
                * Returns a Maplibre map for advanced usage.
                *
                * @returns {object} Maplibre map instance
                *
                * Limitations:
                * - Maplibre interaction events are not supported, use Mappedin JS interaction events.
                * - Maplibre markers and labels may overlap as they are not integrated with the Mappedin JS collision engine.
                */
            get map(): import("@packages/internal/outdoor-context-v4").Map | undefined;
            /**
                * Whether the outdoorView is enabled.
                */
            get enabled(): boolean;
            /**
                * Whether the outdoorView is visible.
                */
            get visible(): boolean;
            /**
                * Show the outdoor map.
                */
            show(): void;
            /**
                * Hide the outdoor map.
                * @param excludedStyleLayerIds {string[]}
                */
            hide(excludedStyleLayerIds?: string[]): void;
            /**
                * Set outdoor view opacity.
                * @param targetOpacity {number | 'initial'}
                * @param excludedStyleLayerIds {string[]}
                */
            setOpacity(targetOpacity: number | 'initial', excludedStyleLayerIds?: string[]): void;
    }
}

declare module '@mappedin/mappedin-js/mappedin-js/src/api-geojson/images' {
    import type { IAnchorable, TAddImageOptions } from '@mappedin/mappedin-js/mappedin-js/src/types';
    import { Image } from '@mappedin/mappedin-js/mappedin-js/src/map-view-objects';
    import type { GeojsonApiMapObject } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/map-object';
    /**
        * Images can enhance the fidelity of an indoor map. They can be used to add custom branding, highlight important features, or provide additional information to users.
        * Images can be placed on any {@link Door}, {@link Space}, or {@link Coordinate} on the map and given a verticalOffset to control the height at which the image is displayed.
        *
        * This class is accessed using {@link MapView.Images}.
        *
        * JPEG and PNG images are supported. It's important to consider the size of all unique image files displayed on a map at one time.
        * Using many unique images may cause instability on mobile devices with limited GPU memory. The Mappedin SDK will cache and reuse images that have the same URL, resulting in reduced memory usage.
        *
        * The following calculations illustrates how much memory is used for a given image:
        *
        * Formula: `width * height * 4 bytes/pixel = memory used`
        *
        * 512 x 512 Pixel Image: `512px * 512px * 4 bytes/pixel = 1MB`
        *
        * 4096 x 4096 Pixel Image: `4096px * 4096px * 4 bytes/pixel = 64MB`
        *
        *  Refer to the [Images Guide](https://developer.mappedin.com/web-sdk/images-textures) for more information and interactive examples.
        */
    export class Images {
            #private;
            /**
                * @internal
                */
            get currentMap(): GeojsonApiMapObject | undefined;
            /**
                * @internal
                */
            constructor({ currentMapGetter }: {
                    currentMapGetter: CurrentMapGetter;
            });
            /**
                * @internal
                */
            getById(id: string): {
                    image: Image;
                    entityId: string;
            } | undefined;
            /**
                * Adds an image to the map.
                *
                * @param target The target object ({@link IAnchorable}) for the image.
                * @param url The URL of the image.
                * @param options Optional additional options for the {@link Image}.
                * @returns {Image | undefined} The created {@link Image}, or undefined if creation failed.
                * @example
                * // Add an interactive {@link Image} to the map with custom HTML content.
                * mapView.Images.add(coordinate, '<div>Image Content</div>', { interactive: true });
                */
            add(target: IAnchorable, url: string, options: TAddImageOptions): Image;
            /**
                * Removes a image from the map.
                *
                * @param image {Image} The {@link Image} which should be removed.
                * @example
                * mapView.Images.remove(image);
                */
            remove(image: Image): void;
            /**
                * Remove all the images from the map.
                *
                * @example
                * mapView.Images.removeAll();
                */
            removeAll(): Image[];
    }
    type CurrentMapGetter = () => GeojsonApiMapObject | undefined;
    export {};
}

declare module '@mappedin/mappedin-js/mappedin-js/src/api-geojson/dynamic-focus' {
    export { DynamicFocus } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/dynamic-focus/dynamic-focus';
}

declare module '@mappedin/mappedin-js/mappedin-js/src/search/internal' {
    import type { SearchResult as MiniSearchResult, Suggestion, MatchInfo } from 'minisearch';
    import type { Places } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    import { EnterpriseLocation, EnterpriseCategory } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    import type MapData from '@mappedin/mappedin-js/mappedin-js/src/map-data';
    import { z } from 'zod';
    export class InternalSearch {
            #private;
            constructor(mapData: MapData);
            /**
                * Populates the search indexes with the map data.
                * @returns A promise that resolves when the indexes are populated.
                */
            populate(): Promise<any[]>;
            search(term: string, options?: SearchOptions): Promise<SearchResult>;
            suggest(term: string, options?: SuggestOptions): Promise<Suggestion[]>;
    }
    export type SearchResultItem<T extends Places | EnterpriseLocation | EnterpriseCategory> = {
            type: T['__type'];
            match: MiniSearchResult['match'];
            score: number;
            item: T;
    };
    /**
        * @interface
        */
    export type SearchResultEnterpriseCategory = SearchResultItem<EnterpriseCategory>;
    /**
        * @interface
        */
    export type SearchResultEnterpriseLocations = SearchResultItem<EnterpriseLocation>;
    /**
        * @interface
        */
    export type SearchResultPlaces = SearchResultItem<Places>;
    /**
        * Search results
        */
    export type SearchResult = {
            /**
                * Places search results
                */
            places: SearchResultPlaces[];
            /**
                * Enterprise Locations search results
                */
            enterpriseLocations?: SearchResultEnterpriseLocations[];
            /**
                * Enterprise Categories search results
                */
            enterpriseCategories?: SearchResultEnterpriseCategory[];
    };
    export function removeAccents(it: string): string;
    const searchOptionsSchema: z.ZodObject<{
            /**
                * Options for searching places.
                * @property {Object} [fields] - Fields to search in places.
                * @property {boolean} [name] - Whether to search in the name field of places.
                * @property {boolean} [description] - Whether to search in the description field of places.
                * @property {number} [limit] - Maximum number of place results to return.
                */
            places: z.ZodOptional<z.ZodObject<{
                    /**
                        * Fields to search in places.
                        * @property {boolean} [name] - Whether to search in the name field of places.
                        * @property {boolean} [description] - Whether to search in the description field of places.
                        */
                    fields: z.ZodOptional<z.ZodObject<{
                            /** Enable searching by place name */
                            name: z.ZodOptional<z.ZodBoolean>;
                            /** Enable searching by place description */
                            description: z.ZodOptional<z.ZodBoolean>;
                    }, "strip", z.ZodTypeAny, {
                            name?: boolean | undefined;
                            description?: boolean | undefined;
                    }, {
                            name?: boolean | undefined;
                            description?: boolean | undefined;
                    }>>;
                    /** Maximum number of place results to return */
                    limit: z.ZodOptional<z.ZodNumber>;
            }, "strip", z.ZodTypeAny, {
                    limit?: number | undefined;
                    fields?: {
                            name?: boolean | undefined;
                            description?: boolean | undefined;
                    } | undefined;
            }, {
                    limit?: number | undefined;
                    fields?: {
                            name?: boolean | undefined;
                            description?: boolean | undefined;
                    } | undefined;
            }>>;
            /**
                * Options for searching categories.
                * @property {Object} [fields] - Fields to search in categories.
                * @property {boolean} [name] - Whether to search in the name field of categories.
                * @property {boolean} [description] - Whether to search in the description field of categories.
                * @property {boolean} ['locations.name'] - Whether to search in the locations' names of categories.
                * @property {number} [limit] - Maximum number of category results to return.
                */
            enterpriseCategories: z.ZodOptional<z.ZodObject<{
                    /**
                        * Fields to search in categories.
                        * @property {boolean} [name] - Whether to search in the name field of categories.
                        * @property {boolean} [description] - Whether to search in the description field of categories.
                        * @property {boolean} ['locations.name'] - Whether to search in the locations' names of categories.
                        */
                    fields: z.ZodOptional<z.ZodObject<{
                            /** Enable searching by category name */
                            name: z.ZodOptional<z.ZodBoolean>;
                            /** Enable searching by category description */
                            description: z.ZodOptional<z.ZodBoolean>;
                            /** Enable searching by names of locations within the category */
                            'locations.name': z.ZodOptional<z.ZodBoolean>;
                    }, "strip", z.ZodTypeAny, {
                            name?: boolean | undefined;
                            description?: boolean | undefined;
                            'locations.name'?: boolean | undefined;
                    }, {
                            name?: boolean | undefined;
                            description?: boolean | undefined;
                            'locations.name'?: boolean | undefined;
                    }>>;
                    /** Maximum number of category results to return */
                    limit: z.ZodOptional<z.ZodNumber>;
            }, "strip", z.ZodTypeAny, {
                    limit?: number | undefined;
                    fields?: {
                            name?: boolean | undefined;
                            description?: boolean | undefined;
                            'locations.name'?: boolean | undefined;
                    } | undefined;
            }, {
                    limit?: number | undefined;
                    fields?: {
                            name?: boolean | undefined;
                            description?: boolean | undefined;
                            'locations.name'?: boolean | undefined;
                    } | undefined;
            }>>;
            /**
                * Options for searching locations.
                * @property {Object} [fields] - Fields to search in locations.
                * @property {boolean} [name] - Whether to search in the name field of locations.
                * @property {boolean} [tags] - Whether to search in the tags field of locations.
                * @property {boolean} [description] - Whether to search in the description field of locations.
                * @property {number} [limit] - Maximum number of location results to return.
                */
            enterpriseLocations: z.ZodOptional<z.ZodObject<{
                    /**
                        * Fields to search in locations.
                        * @property {boolean} [name] - Whether to search in the name field of locations.
                        * @property {boolean} [tags] - Whether to search in the tags field of locations.
                        * @property {boolean} [description] - Whether to search in the description field of locations.
                        */
                    fields: z.ZodOptional<z.ZodObject<{
                            /** Enable searching by location name */
                            name: z.ZodOptional<z.ZodBoolean>;
                            /** Enable searching by location tags */
                            tags: z.ZodOptional<z.ZodBoolean>;
                            /** Enable searching by location description */
                            description: z.ZodOptional<z.ZodBoolean>;
                    }, "strip", z.ZodTypeAny, {
                            name?: boolean | undefined;
                            description?: boolean | undefined;
                            tags?: boolean | undefined;
                    }, {
                            name?: boolean | undefined;
                            description?: boolean | undefined;
                            tags?: boolean | undefined;
                    }>>;
                    /** Maximum number of location results to return */
                    limit: z.ZodOptional<z.ZodNumber>;
            }, "strip", z.ZodTypeAny, {
                    limit?: number | undefined;
                    fields?: {
                            name?: boolean | undefined;
                            description?: boolean | undefined;
                            tags?: boolean | undefined;
                    } | undefined;
            }, {
                    limit?: number | undefined;
                    fields?: {
                            name?: boolean | undefined;
                            description?: boolean | undefined;
                            tags?: boolean | undefined;
                    } | undefined;
            }>>;
    }, "strip", z.ZodTypeAny, {
            enterpriseLocations?: {
                    limit?: number | undefined;
                    fields?: {
                            name?: boolean | undefined;
                            description?: boolean | undefined;
                            tags?: boolean | undefined;
                    } | undefined;
            } | undefined;
            enterpriseCategories?: {
                    limit?: number | undefined;
                    fields?: {
                            name?: boolean | undefined;
                            description?: boolean | undefined;
                            'locations.name'?: boolean | undefined;
                    } | undefined;
            } | undefined;
            places?: {
                    limit?: number | undefined;
                    fields?: {
                            name?: boolean | undefined;
                            description?: boolean | undefined;
                    } | undefined;
            } | undefined;
    }, {
            enterpriseLocations?: {
                    limit?: number | undefined;
                    fields?: {
                            name?: boolean | undefined;
                            description?: boolean | undefined;
                            tags?: boolean | undefined;
                    } | undefined;
            } | undefined;
            enterpriseCategories?: {
                    limit?: number | undefined;
                    fields?: {
                            name?: boolean | undefined;
                            description?: boolean | undefined;
                            'locations.name'?: boolean | undefined;
                    } | undefined;
            } | undefined;
            places?: {
                    limit?: number | undefined;
                    fields?: {
                            name?: boolean | undefined;
                            description?: boolean | undefined;
                    } | undefined;
            } | undefined;
    }>;
    const suggestOptionsSchema: z.ZodObject<{
            /**
                * Options for searching places.
                * @property {boolean} [enabled] - Whether to search in places.
                */
            places: z.ZodOptional<z.ZodObject<{
                    /** Enable searching by place name */
                    enabled: z.ZodOptional<z.ZodBoolean>;
            }, "strip", z.ZodTypeAny, {
                    enabled?: boolean | undefined;
            }, {
                    enabled?: boolean | undefined;
            }>>;
            /**
                * Options for searching locations.
                * @property {boolean} [enabled] - Whether to search in locations.
                */
            enterpriseLocations: z.ZodOptional<z.ZodObject<{
                    /** Enable searching by location name */
                    enabled: z.ZodOptional<z.ZodBoolean>;
            }, "strip", z.ZodTypeAny, {
                    enabled?: boolean | undefined;
            }, {
                    enabled?: boolean | undefined;
            }>>;
    }, "strip", z.ZodTypeAny, {
            enterpriseLocations?: {
                    enabled?: boolean | undefined;
            } | undefined;
            places?: {
                    enabled?: boolean | undefined;
            } | undefined;
    }, {
            enterpriseLocations?: {
                    enabled?: boolean | undefined;
            } | undefined;
            places?: {
                    enabled?: boolean | undefined;
            } | undefined;
    }>;
    /**
        * @interface
        */
    export type SearchOptions = z.infer<typeof searchOptionsSchema>;
    /**
        * @interface
        */
    export type SuggestOptions = z.infer<typeof suggestOptionsSchema>;
    export { Suggestion, MatchInfo };
}

declare module '@mappedin/mappedin-js/mappedin-js/src/search/external' {
    import type MapData from '@mappedin/mappedin-js/mappedin-js/src/map-data';
    import type { InternalSearch, SearchOptions, SuggestOptions } from '@mappedin/mappedin-js/mappedin-js/src/search/internal';
    import type { MapDataInternal } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    /**
        * Search allows users to search for locations, categories, and other points of interest within the venue.
        *
        * Refer to the [Search Guide](https://developer.mappedin.com/web-sdk/enterprise-data#enterprise-search) for more information and interactive examples.
        */
    export class Search {
            #private;
            /**
                * Whether the search is enabled.
                * @default false
                */
            enabled: boolean;
            /**
                * @internal
                */
            constructor(mapData: MapData, mapDataInternal: MapDataInternal, { enabled }?: {
                    enabled?: boolean;
            });
            /**
                * Use query to search for locations based on a string input:
                *
                * - {@link EnterpriseLocation}: Specific places such as stores, restaurants, or washrooms.
                * - {@link EnterpriseCategory}: Groups of locations, such as "Food Court" or "Electronics."
                * - {@link Places}: Any main objects that can be searched for such as Space, Door, Point of Interest
                *
                * Search query returns a list of matching {@	link SearchResults} based on the input string.
                *
                * {@link SearchResults} include information about the type of match, the score (relevance), and detailed metadata about the matching items.
                *
                * @param term - The search term.
                * @param options - The search options.
                * @returns The search results.
                * @example
                * ```ts
                * const results = await search.query('Coffee Shop');
                * console.log(results.locations);
                * ```
                */
            query(term: string, options?: SearchOptions): ReturnType<typeof InternalSearch.prototype.search>;
            /**
                * Suggests the names of places, locations, and categories based on partial input. This is useful for creating an autocomplete feature for a search bar.
                * @param term - The search term.
                * @param options - The suggest options.
                * @returns The search suggestions.
                * @example
                * ```ts
                * const suggestions = await search.suggest('Coffee');
                * console.log(suggestions);
                * ```
                */
            suggest(term: string, options?: SuggestOptions): Promise<import("minisearch").Suggestion[]>;
            /**
                * Enables the search.
                */
            enable(): Promise<void>;
    }
    export type SearchState = {
            /**
                * Whether the search is enabled.
                */
            enabled: boolean;
    };
}

declare module '@mappedin/mappedin-js/mappedin-js/src/query/external' {
    import type { Annotation, Coordinate, Door, MapDataInternal, Node, PointOfInterest } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    /**
        * Query allows users to query for nodes, locations, categories, and other points of interest within the venue.
        */
    export class Query {
            #private;
            /**
                * @internal
                */
            constructor(mapDataInternal: MapDataInternal);
            /**
                * Find the nearest feature to the origin
                * @param origin - The origin object
                * @param options - The options for the query
                * @returns The nearest feature to the origin
                */
            nearest(origin: Coordinate | PointOfInterest | Door | Annotation | Node, options: TFindNearestOptions): TFindNearestResult | undefined;
    }
    export type TFindNearestResult = {
            distance: number;
            feature: TQueriables;
    }[];
    export type TFindNearestOptions = {
            /**
                * Limit query to a set of floors. Only applies if the origin has floor information. If it doesn't, it limits the query to all floor-stacks' default floors.
                *
                * @default 'same-floor'
                */
            limit?: 'same-floor'
            /**
                * Limit query to all floors at the same elevation as the origin
                */
             | 'same-elevation';
            /**
                * The radius to search for features within
                */
            radius?: number;
            /**
                * The types to query for
                */
            types: [TQueriables['__type'], ...TQueriables['__type'][]];
    };
    export type TQueriables = PointOfInterest | Door | Annotation | Node;
}

declare module '@mappedin/mappedin-js/mappedin-js/src/analytics/customer' {
    /**
        * Valid track-analytics API contexts. These should match the expected values of that endpoint or the requests will fail.
        * If a set context is not in this list, it will default to the first VALID_CONTEXTS value.
        */
    export const VALID_CONTEXTS: readonly ["websdk", "web", "webv2", "kiosk-v2", "mobile", "iossdk", "androidsdk", "reactnativesdk", "gen7", "bespoke"];
    type ValidContext = (typeof VALID_CONTEXTS)[number];
    export const DEFAULT_CONTEXT: "websdk";
    export const ANALYTICS_URL = "https://api-gateway.mappedin.com/track-analytics/a/";
    export const FOUND_POSITION = "found-position";
    export const FOUND_FLOOR = "found-floor";
    type BlueDotEvents = typeof FOUND_FLOOR | typeof FOUND_POSITION;
    export class AnalyticsInternal {
            #private;
            constructor();
            init(options: AnalyticsUpdateOptions): void;
            /**
                * Reset state and options
                */
            reset(): void;
            updateState(update: UpdateStateParam): void;
            get authReady(): boolean;
            getState(): AnalyticState;
            capture<T extends keyof CaptureEventsPayloadMap>(eventName: T, query: CaptureEventsPayloadMap[T]): Promise<Response> | Promise<void>;
            capture<T extends keyof CaptureEventsPayloadMap | (string & NonNullable<unknown>)>(target: T, query: T extends keyof CaptureEventsPayloadMap ? CaptureEventsPayloadMap[T] : Record<string, any>): Promise<Response> | Promise<void>;
            /**
                * @internal
                */
            sendGetMapDataEvent(payload: {
                    parseDuration: number;
                    downloadDuration: number;
                    viewId?: string;
            }): void | Promise<Response> | Promise<void>;
            sendChangeLanguageEvent(payload: {
                    fromLanguage: string;
            }): void | Promise<Response> | Promise<void>;
            sendWatchPositionDenied(): void | Promise<Response> | Promise<void>;
            /**
                * @internal
                */
            sendMapViewLoadedEvent({ firstRenderDuration, dimension, }: {
                    firstRenderDuration: number;
                    dimension: {
                            height: number;
                            width: number;
                    };
            }): void | Promise<Response> | Promise<void>;
            /**
                * @internal
                */
            sendGetDirectionsEvent: (start: string, end: string) => void;
            sendBlueDotEvents(event: BlueDotEvents): void | Promise<Response> | Promise<void>;
    }
    type UpdateStateParam = Partial<Pick<AnalyticState, 'geolocationMode' | 'context' | 'logEvents' | 'userPosition' | 'mapId' | 'sendEvents' | 'logEvents' | 'accessToken' | 'sessionId'>>;
    type CaptureEventsPayloadMap = {
            '$select-location': {
                    id: string;
            };
            '$select-category': {
                    id: string;
            };
            '$query-suggest': {
                    query: string;
                    suggestions?: string[];
            };
            '$query-search': {
                    query: string;
                    hits?: string[];
            };
    };
    export const analyticsInternal: AnalyticsInternal;
    export class Analytics {
            #private;
            /**
                * @internal
                */
            constructor(internalAnalytics: AnalyticsInternal);
            /**
                * Captures an analytic event with a custom target and query payload.
                *
                * @param target - The event name or target can be one of: `$select-location`, `$select-category`, `$query-suggest`, `$query-search`
                * @param query - The payload associated with the event.
                * @returns A promise that resolves to the server response or void.
                */
            capture: typeof AnalyticsInternal.prototype.capture;
            /**
                * Updates the analytics state with the provided parameters.
                * @param update - The state parameters to update.
                */
            updateState: (update: TAnalyticsUpdateState) => void;
            /**
                * Returns the current analytics state.
                * @internal
                * @returns the current analytics state
                */
            getState(): {
                    version: string;
                    /** The platform string to be included in analytics. */
                    platformString: string;
                    /** The base URI for the analytics endpoint. */
                    baseUri: string;
                    /** The base URI with mapId appended. */
                    analyticsBaseUrl: string;
                    /** Flag to disable authentication. */
                    noAuth: boolean;
                    /** Flag to enable geolocation mode. */
                    geolocationMode: boolean;
                    /** The device ID to be used for analytics. */
                    deviceId: string;
                    /** The session ID to be used for analytics. */
                    sessionId: string;
                    /** The context in which the analytics are being used. */
                    context: ValidContext;
                    /** The last known user position. */
                    userPosition?: AnalyticsUserPosition;
                    /** The ID of the map to be used for analytics. */
                    mapId?: string;
                    /** Flag to enable logging of events. */
                    logEvents: boolean;
                    /** Flag to enable sending of events. */
                    sendEvents: boolean;
            } & AnalyticsAuth;
    }
    type AnalyticsUserPosition = {
            bluedotTimestamp: number;
            latitude: number;
            longitude: number;
            floorLevel?: number;
            accuracy?: number;
    };
    type AnalyticsAuth = {
            /** The API key for authentication. */
            key?: string;
            /** The API secret for authentication. */
            secret?: string;
            /** The access token for authentication. */
            accessToken?: string;
    };
    export type AnalyticState = {
            version: string;
            /** The platform string to be included in analytics. */
            platformString: string;
            /** The base URI for the analytics endpoint. */
            baseUri: string;
            /** The base URI with mapId appended. */
            analyticsBaseUrl: string;
            /** Flag to disable authentication. */
            noAuth: boolean;
            /** Flag to enable geolocation mode. */
            geolocationMode: boolean;
            /** The device ID to be used for analytics. */
            deviceId: string;
            /** The session ID to be used for analytics. */
            sessionId: string;
            /** The context in which the analytics are being used. */
            context: ValidContext;
            /** The last known user position. */
            userPosition?: AnalyticsUserPosition;
            /** The ID of the map to be used for analytics. */
            mapId?: string;
            /** Flag to enable logging of events. */
            logEvents: boolean;
            /** Flag to enable sending of events. */
            sendEvents: boolean;
    } & AnalyticsAuth;
    type AnalyticsOptions = Partial<Omit<AnalyticState, 'version' | 'analyticsBaseUrl' | 'geolocationMode' | 'userPosition'>>;
    export type AnalyticsUpdateOptions = Omit<AnalyticsOptions, keyof AnalyticsAuth> & ((Required<Pick<AnalyticsAuth, 'key' | 'secret'>> & Partial<Pick<AnalyticsAuth, 'accessToken'>>) | (Required<Pick<AnalyticsAuth, 'accessToken'>> & Partial<Pick<AnalyticsAuth, 'key' | 'secret'>>));
    /**
        * Options for updating the current state of analytics.
        * @interface
        */
    export type TAnalyticsUpdateState = Pick<Partial<AnalyticState>, 'logEvents' | 'sendEvents' | 'baseUri' | 'accessToken'>;
    export {};
}

declare module '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/base-metadata-object' {
    export default abstract class BaseMetaData {
        /**
          * The identity of the map metadata.
          */
        readonly id: string;
        constructor(id: string);
    }
}

declare module '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/detailed-map-data' {
    import type { Details, Feature as MVFFeature, Geometry } from '@mappedin/mvf';
    import type LocationProfile from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/location-profile';
    import Hyperlink from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/hyperlink';
    import type { MapDataInternal } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    import ImageMetaData from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/image';
    import BaseMapData from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/base-object';
    type PropertiesWithDetails = {
            id: string;
            externalId?: string;
            details?: Details;
    };
    export default abstract class DetailedMapData<MVFData extends MVFFeature<Geometry, PropertiesWithDetails>> extends BaseMapData {
            #private;
            constructor(data: MapDataInternal, mvfData: MVFData);
            /**
                * Gets the external identifier of the map feature.
                *
                * @returns {string} The external ID of the map feature, or an empty string if no external ID exists.
                */
            get externalId(): string;
            /**
                * Gets the name of the map feature.
                *
                * @returns {string} The name of the map feature.
                */
            get name(): string;
            /**
                * Gets the description of the map feature.
                *
                * @returns {string} The description of the map feature, or an empty string if no description exists.
                */
            get description(): string;
            /**
                * Gets the array of {@link ImageMetaData}s associated with this map feature.
                *
                * @returns {ImageMetaData[]} An array of Image objects, or an empty array if no images exist.
                */
            get images(): ImageMetaData[];
            /**
                * Gets the array of {@link Hyperlink}s associated with this map feature.
                *
                * @returns {Hyperlink[]} An array of Hyperlink objects, or an empty array if no links exist.
                */
            get links(): Hyperlink[];
            /**
                * Gets the {@link LocationProfile}s attached to this feature.
                *
                * @returns {LocationProfile[]} An array of location profiles.
                */
            get locationProfiles(): LocationProfile[];
    }
    export {};
}

declare module '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/base-object' {
    import type { BBox, Feature, LineString, MultiPolygon, Point, Polygon } from 'geojson';
    import type { MapDataInternal } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    export default abstract class BaseMapData {
            #private;
            /**
                * The identity of the map data.
                */
            readonly id: string;
            constructor(id: string, _data: MapDataInternal);
            /**
                * Gets the bounding box of the geoJSON geometry.
                *
                * @returns {BBox} The bounding box of the geoJSON geometry
                */
            get geoJSONBoundingBox(): BBox | undefined;
            get geoJSON(): Feature<Polygon | MultiPolygon | LineString | Point, null>;
    }
}

declare module '@mappedin/mappedin-js/mappedin-js/src/map-data-objects/opening-hours' {
    import type { OpeningHoursSpecification } from '@mappedin/mvf';
    /**
        * Represents the opening hours of a location.
        */
    export class OpeningHours {
            #private;
            constructor(mvfData: OpeningHoursSpecification[]);
            /**
                * Gets the raw opening hours data.
                */
            get raw(): OpeningHoursSpecification[];
    }
}

declare module '@mappedin/mappedin-js/geojson/src/systems/collisions/system' {
    import { QuadTree } from '@packages/internal/quad-tree';
    import '../../styles/collisions.scss';
    import type { MarkerComponent } from '@mappedin/mappedin-js/geojson/src/components/marker';
    import type LabelComponent from '@mappedin/mappedin-js/geojson/src/components/label';
    import { PubSub } from '@mappedin/mappedin-js/packages/common/pubsub';
    import type { RendererState } from '@mappedin/mappedin-js/geojson/src/renderer';
    import type { TSerializedCollider, TSerializedColliderResponse } from '@mappedin/mappedin-js/geojson/src/systems/collisions/collider-processor';
    import type { WatermarkPosition } from '@mappedin/mappedin-js/geojson/src/systems/watermark/system';
    export type TMessageEvent = MessageEvent<{
        msgId: string;
        colliders: TSerializedColliderResponse[];
        debug: {
            x: number;
            y: number;
            w: number;
            h: number;
        }[];
    }>;
    export type TMessage = {
        msgId: string;
        totalWidth: number;
        totalHeight: number;
        watermarkWidth: number;
        watermarkHeight: number;
        watermarkPosition: WatermarkPosition;
        colliders: TSerializedCollider[];
        devicePixelRatio: number;
    };
    type TCollisionSystemEvent = {
        'visibility-changed': undefined;
    };
    export type PackedBBox = [x: number, y: number, w: number, h: number, index: number];
    export type PackedBBoxes = PackedBBox[];
    export type PackedCollider = [
        bboxes: PackedBBoxes,
        enabled: 0 | 1,
        alwaysVisible: 0 | 1,
        x: number,
        y: number,
        shouldCollideWithScreenEdges?: 0 | 1,
        onlyExposeStrategyIndex?: number
    ];
    export type PackedMessage = [
        colliders: PackedCollider[],
        devicePixelRatio: number,
        totalHeight: number,
        totalWidth: number,
        watermarkWidth: number,
        watermarkHeight: number,
        watermarkPosition: WatermarkPosition
    ];
    export class CollisionSystem extends PubSub<TCollisionSystemEvent, keyof TCollisionSystemEvent> {
        collidersDirty: boolean;
        packedMessage: PackedMessage;
        visibleCollidersQTree: QuadTree<{
            entityId: string | number;
        }>;
        interactiveCollidersQTree: QuadTree<{
            entityId: string | number;
        }>;
        coreState: RendererState;
        constructor(debugCanvas: HTMLCanvasElement, coreState: RendererState, worker?: Worker);
        postMessage: () => void;
        showCollisionBoxes: () => void;
        hideCollisionBoxes: () => void;
        currentMsgId: string;
        working: boolean;
        componentArray: (MarkerComponent | LabelComponent)[];
        update: (watermarkWidth: number, watermarkHeight: number, watermarkPosition?: WatermarkPosition, isPanning?: boolean) => void;
        resize(watermarkWidth: number, watermarkHeight: number, watermarkPosition: WatermarkPosition): void;
        /**
          * Resolve collisions
          */
        resolve: (e: MessageEvent<{
            msgId: string;
            colliders: TSerializedColliderResponse[];
        }>) => void;
        drawDebug: () => void;
        destroy: () => void;
    }
    export {};
}

declare module '@mappedin/mappedin-js/geojson/src/entities/geometry3d' {
    import { Object3D } from 'three';
    import type { Mesh, Object3DEventMap, ShaderMaterial, Texture, TubeGeometry, Color, Vector2, Raycaster } from 'three';
    import type { InteractionComponent } from '@mappedin/mappedin-js/geojson/src/components/interaction';
    import type { MeshComponent } from '@mappedin/mappedin-js/geojson/src/components/mesh';
    import type { ModelComponent } from '@mappedin/mappedin-js/geojson/src/components/model';
    import type { PathComponent } from '@mappedin/mappedin-js/geojson/src/components/path';
    import type { StyleComponent } from '@mappedin/mappedin-js/geojson/src/components/styles/style';
    import type { ImageComponent } from '@mappedin/mappedin-js/geojson/src/components/image';
    import type { CustomGeometryComponent } from '@mappedin/mappedin-js/geojson/src/components/custom';
    import type { GroupContainerObject3D } from '@mappedin/mappedin-js/geojson/src/entities/group-container';
    import type { Geometry2D } from '@mappedin/mappedin-js/geojson/src/entities/geometry2d';
    import { GeometryGroupObject3D } from '@mappedin/mappedin-js/geojson/src/entities/geometry-group';
    import type { Text3DComponent } from '@mappedin/mappedin-js/geojson/src/components/text3d';
    import type { ModelStyleComponnet, Text3DStyleComponent } from '@mappedin/mappedin-js/geojson/src/components/styles';
    export enum Geometry3DComponents {
            Mesh = 0,
            Style = 1,
            Interaction = 2
    }
    type Geometry3DObjectTypes = 'geometry' | 'path' | 'model' | 'custom-geometry' | 'image' | 'text3d';
    export class Geometry3DObject3D extends Object3D {
            type: Geometry3DObjectTypes;
            userData: {
                    entityId: string;
                    /**
                        * TODO: remove this when proper instancing is handled
                        */
                    isSingleModel?: boolean;
                    type: Geometry3DObjectTypes;
            };
            /**
                * Custom raycast implementation for model objects only.
                * This selectively enables recursive raycasting just for models, which have complex hierarchies,
                * while avoiding the performance cost of recursive raycasting for other object types.
                */
            raycast(raycaster: Raycaster, intersects: any[]): void;
    }
    export type PathMaterial = ShaderMaterial & {
            uniforms: PathUniforms;
    };
    export type PathMesh = Mesh<TubeGeometry, PathMaterial, Object3DEventMap>;
    export class PatMeshContainer extends Geometry3DObject3D {
            children: [PathMesh, PathMesh];
    }
    export type MeshComponentTypes = MeshComponent | PathComponent | ModelComponent | CustomGeometryComponent | Text3DComponent | ImageComponent;
    type MappedComponentType<M> = M extends MeshComponent ? 'geometry' : M extends PathComponent ? 'path' : M extends ModelComponent ? 'model' : M extends CustomGeometryComponent ? 'custom-geometry' : M extends ImageComponent ? 'image' : M extends Text3DComponent ? 'text3d' : never;
    export class Geometry3D<M extends MeshComponentTypes = MeshComponent, S extends StyleComponent | Text3DStyleComponent | ModelStyleComponnet = StyleComponent, I extends InteractionComponent = InteractionComponent, T extends MappedComponentType<M> = MappedComponentType<M>> {
            id: string | number;
            components: [M, S, I?];
            get object3d(): M["mesh"];
            get parentObject3D(): GroupContainerObject3D | GeometryGroupObject3D | null;
            get type(): T;
            entities2D: Map<string | number, Geometry2D>;
            constructor(meshComponent: M, styleComponent: S);
            addEntity(entity: Geometry2D): void;
            removeEntity(entity: Geometry2D): void;
            removeAllEntities(): void;
    }
    export type TextGeometry3D = Geometry3D<Text3DComponent, Text3DStyleComponent, InteractionComponent, 'text3d'>;
    export type CustomGeometry3D = Geometry3D<CustomGeometryComponent, StyleComponent, InteractionComponent, 'custom-geometry'>;
    export type ModelGeometry3D = Geometry3D<ModelComponent, ModelStyleComponnet, InteractionComponent, 'model'>;
    export type PathGeometry3D = Geometry3D<PathComponent, StyleComponent, InteractionComponent, 'path'>;
    export type ImageGeometry3D = Geometry3D<ImageComponent, StyleComponent, InteractionComponent, 'image'>;
    export type MeshGeometry3D = Geometry3D<MeshComponent, StyleComponent, InteractionComponent, 'geometry'>;
    export type Geometry3DTypes = TextGeometry3D | CustomGeometry3D | PathGeometry3D | ImageGeometry3D | MeshGeometry3D | ModelGeometry3D;
    export interface PathUniforms {
            vertexes: {
                    type: 'f';
                    value: number;
            };
            resolution: {
                    type: 'v2';
                    value: Vector2;
            };
            cameraParameters: {
                    type: 'v2';
                    value: Vector2;
            };
            complete: {
                    type: 'f';
                    value: number;
            };
            color: {
                    type: 'c';
                    value: Color;
            };
            pathLength: {
                    type: 'f';
                    value: number;
            };
            nearRadius: {
                    type: 'f';
                    value: number;
            };
            farRadius: {
                    type: 'f';
                    value: number;
            };
            nearZoom: {
                    type: 'f';
                    value: number;
            };
            farZoom: {
                    type: 'f';
                    value: number;
            };
            pulseColor: {
                    type: 'c';
                    value: Color;
            };
            pulse: {
                    type: 'f';
                    value: number;
            };
            pulseLength: {
                    type: 'f';
                    value: number;
            };
            pathIsVertical: {
                    type: 'b';
                    value: boolean;
            };
            arrowAnimationTimer: {
                    type: 'f';
                    value: number;
            };
            arrowTexture: {
                    type: 't';
                    value: Texture;
            };
            displayArrowsOnPath: {
                    type: 'b';
                    value: boolean;
            };
            flattenFactor: {
                    type: 'f';
                    value: number;
            };
            showPulse: {
                    type: 'b';
                    value: boolean;
            };
            opacityMultiplier: {
                    type: 'f';
                    value: number;
            };
    }
    export {};
}

declare module '@mappedin/mappedin-js/geojson/src/entities/geometry2d' {
    import { Object3D, Vector3 } from 'three';
    import type { MarkerComponent } from '@mappedin/mappedin-js/geojson/src/components/marker';
    import type LabelComponent from '@mappedin/mappedin-js/geojson/src/components/label';
    import type { GroupContainerObject3D } from '@mappedin/mappedin-js/geojson/src/entities/group-container';
    import type { InteractionComponent } from '@mappedin/mappedin-js/geojson/src/components/interaction';
    import { type GeometryGroupObject3D } from '@mappedin/mappedin-js/geojson/src/entities/geometry-group';
    export enum Geometry2DComponents {
        UI = 0,
        Interaction = 1
    }
    export class Geometry2DObject3D extends Object3D {
    }
    export class Geometry2D {
        id: string | number;
        get type(): 'label' | 'marker';
        get parentObject3D(): GroupContainerObject3D | GeometryGroupObject3D | null;
        verticalOffset: number;
        /**
          * When the position of the entity changes, this should be set to true, so that systems like pan bounds can update
          */
        positionDirty: boolean;
        occluderId?: number;
        object3d: Geometry2DObject3D;
        components: [MarkerComponent | LabelComponent, InteractionComponent?];
        disposed: boolean;
        constructor(ui: MarkerComponent | LabelComponent, position: Vector3, verticalOffset?: number);
        get position(): Vector3;
        setAltitude(z: number): void;
    }
}

declare module '@mappedin/mappedin-js/geojson/src/components/stack' {
    export class StackComponent {
        percentExpanded: number;
        activeId: string;
        gap: number;
        dirty: boolean;
    }
}

declare module '@mappedin/mappedin-js/geojson/src/components/interaction' {
    export class InteractionComponent {
        hover: boolean | 'user-interaction';
        dirty: boolean;
    }
}

declare module '@mappedin/mappedin-js/geojson/src/services/text3d/text3d' {
    import { type Text3DStyleComponent } from '@mappedin/mappedin-js/geojson/src/components/styles';
    import { BatchedText, Text } from 'troika-three-text';
    import type { RendererCore } from '@mappedin/mappedin-js/geojson/src';
    import type { Text3DComponent } from '@mappedin/mappedin-js/geojson/src/components/text3d';
    export function createTroikaTextPoint(entityId: string | number, text3DComponent: Text3DComponent, styleComponent: Text3DStyleComponent, convertTo3DMapPosition: RendererCore['convertTo3DMapPosition']): Promise<{
            text: Text;
    }>;
    export function createTroikaTextArea(entityId: string | number, text3DComponent: Text3DComponent, styleComponent: Text3DStyleComponent, convertTo3DMapPosition: RendererCore['convertTo3DMapPosition']): Promise<{
            text: Text;
    } | undefined>;
    export { BatchedText, Text };
    /**
        * Promise caches the base64 font string. Then shared across all needed
        */
    export let fontPreloadLoadPromise: Promise<string> | undefined;
    /**
        * Preloads a font from the given URL. Enable developer to preload font way before scene is ready
        *
        * @param  fontUrl - The URL of the font to preload. When undefined, default font (Roboto) is loaded
        * @returns A promise that resolves when the font is successfully preloaded, or rejects with an error if the font cannot be loaded.
        */
    export function preloadFont(fontUrl?: string): Promise<string>;
    /**
        * typeof module is forbiten in typescript. see: [@typescript-eslint/consistent-type-imports]
        */
    export type ModuleType = {
            createTroikaTextPoint: typeof createTroikaTextPoint;
            createTroikaTextArea: typeof createTroikaTextArea;
            preloadFont: typeof preloadFont;
            BatchedText: typeof BatchedText;
    };
}

declare module '@mappedin/mappedin-js/geojson/src/components/geometry-group-style' {
    import { type Shading } from '@mappedin/mappedin-js/geojson/src/types';
    type GeometryGroupStyle = {
        color: string;
        topColor?: string;
        opacity: number;
        height?: number;
        shading?: Shading;
        outline: boolean;
        texture?: string;
        topTexture?: string;
    };
    export class GeometryGroupStyleComponent implements GeometryGroupStyle {
        #private;
        color: string;
        initialColor: string;
        topColor?: string;
        initialTopColor?: string;
        opacity: number;
        height?: number;
        outline: boolean;
        texture?: string;
        topTexture?: string;
        /**
          * Ideally for handling all style component changes. However, it's only used for handling outline for now.
          * Color update is handled separately in each child. See: https://github.com/MappedIn/sdk/blob/v6.0.1-beta.1/sdks/geojson/src/entities/utils.ts#L70
          */
        dirty: boolean;
        get shading(): Required<Shading> | undefined;
        set shading(value: Shading | undefined);
        constructor(style?: Partial<GeometryGroupStyle>);
    }
    export {};
}

declare module '@mappedin/mappedin-js/geojson/src/components/image' {
    import type { LineSegments, PlaneGeometry, MeshLambertMaterial } from 'three';
    import { Vector3, Mesh } from 'three';
    import type { Position } from '@mappedin/mappedin-js/geojson/src/types';
    import type { Feature, Point } from 'geojson';
    import { Geometry3DObject3D } from '@mappedin/mappedin-js/geojson/src/entities/geometry3d';
    import { z } from 'zod';
    export class EntityMesh extends Mesh {
            userData: {
                    entityId: string | number;
            };
    }
    export type ImageStyle = {
            /**
                * Attempt to keep the image facing the camera as much as possible
                */
            flipImageToFaceCamera?: boolean;
            /**
                * url of the image
                */
            url: string;
    };
    export type ImageProperties = {
            width: number;
            height: number;
            rotation?: number;
            verticalOffset?: number;
    };
    export const addImageFeatureStyleSchema: z.ZodObject<{
            flipImageToFaceCamera: z.ZodOptional<z.ZodBoolean>;
            url: z.ZodString;
    }, "strip", z.ZodTypeAny, {
            url: string;
            flipImageToFaceCamera?: boolean | undefined;
    }, {
            url: string;
            flipImageToFaceCamera?: boolean | undefined;
    }>;
    export const addImageFeatureSchema: z.ZodObject<{
            type: z.ZodEnum<["Feature"]>;
            properties: z.ZodObject<{
                    width: z.ZodNumber;
                    height: z.ZodNumber;
                    rotation: z.ZodOptional<z.ZodNumber>;
                    verticalOffset: z.ZodOptional<z.ZodNumber>;
            }, "strip", z.ZodTypeAny, {
                    height: number;
                    width: number;
                    verticalOffset?: number | undefined;
                    rotation?: number | undefined;
            }, {
                    height: number;
                    width: number;
                    verticalOffset?: number | undefined;
                    rotation?: number | undefined;
            }>;
            geometry: z.ZodObject<{
                    type: z.ZodEnum<["Point"]>;
                    coordinates: z.ZodArray<z.ZodNumber, "many">;
            }, "strip", z.ZodTypeAny, {
                    type: "Point";
                    coordinates: number[];
            }, {
                    type: "Point";
                    coordinates: number[];
            }>;
    }, "strip", z.ZodTypeAny, {
            type: "Feature";
            geometry: {
                    type: "Point";
                    coordinates: number[];
            };
            properties: {
                    height: number;
                    width: number;
                    verticalOffset?: number | undefined;
                    rotation?: number | undefined;
            };
    }, {
            type: "Feature";
            geometry: {
                    type: "Point";
                    coordinates: number[];
            };
            properties: {
                    height: number;
                    width: number;
                    verticalOffset?: number | undefined;
                    rotation?: number | undefined;
            };
    }>;
    export function validateImage(id: string | number, feature: Feature<Point, ImageProperties>, style: ImageStyle): void;
    /**
        * State representing an Image
        */
    export type ImageState = {
            readonly id: string | number;
            readonly type: 'image';
            /**
                * The position of the image in [lon, lat]
                */
            readonly position: Position;
            /**
                * The offset of the image in the z direction
                */
            readonly verticalOffset: number;
            /**
                * Whether the image is visible
                */
            visible: boolean;
            /**
                * Attempt to keep the image facing the camera as much as possible
                */
            flipImageToFaceCamera: boolean;
    };
    export class ImageComponent {
            mesh: Geometry3DObject3D;
            imageMesh?: EntityMesh;
            outline?: LineSegments;
            readonly type = "image";
            instanceIndex: number;
            geometry?: PlaneGeometry;
            material?: MeshLambertMaterial;
            feature: Feature<Point, ImageProperties>;
            constructor(feature: Feature<Point, ImageProperties>);
            get visible(): boolean;
            set visible(visible: boolean);
            position: Vector3;
    }
}

declare module '@mappedin/mappedin-js/geojson/src/types/options' {
    import type { Position } from '@mappedin/mappedin-js/geojson/src/types/geometry';
    import type { Map as MapLibreMap } from '@mappedin/mappedin-js/packages/outdoor-context-v4';
    import type { AttributionControlOptions } from '@mappedin/mappedin-js/geojson/src/systems/html-controls/system';
    import type { ImagePlacementOptions, WatermarkOptions } from '@mappedin/mappedin-js/geojson/src';
    import type { TransformImageRequest } from '@mappedin/mappedin-js/geojson/src/types';
    export type EnvMapOptions = 'basic' | false;
    export type RendererCoreOptions = Partial<{
        center?: Position;
        zoomLevel?: number;
        pitch?: number;
        bearing?: number;
        naturalBearing?: number;
        outdoorView: {
            headers: {
                'x-mappedin-tiles-key': string;
            };
            style?: string;
            enabled: boolean;
            lowDpi?: boolean;
        };
        gl?: WebGLRenderingContext;
        map?: MapLibreMap;
        mode?: 'standalone' | 'outdoors-interleaved' | 'outdoors-overlay';
        antialias?: boolean;
        onWebGLRendererError?: (error: Error) => void;
        onWebGLContextCreationError?: (event: Event) => void;
        onWebGLContextLost?: (event: Event) => void;
        onWebGLContextRestored?: (event: Event) => void;
        backgroundColor?: string;
        backgroundAlpha?: number;
        watermark?: WatermarkOptions;
        attribution?: AttributionControlOptions;
        imagePlacementOptions?: ImagePlacementOptions;
        /**
          * environment map for reflections.
          * @default 'basic'
          */
        environment?: EnvMapOptions;
        occlusionEnabled?: boolean;
        /** Callback to intercept and modify requests for images. */
        transformImageRequest?: TransformImageRequest;
    }>;
}

declare module '@mappedin/mappedin-js/geojson/src/systems/mesh-creation-and-optimization/batched-material' {
    import { MeshLambertMaterial, type Color, type Texture, type MeshLambertMaterialParameters } from 'three';
    export class BatchedStandardMaterial extends MeshLambertMaterial {
        constructor(params: MeshLambertMaterialParameters, geometryCount: number, scaleFactor?: number);
        /**
          * These control the repeat factor of the texture in the Y direction.
          * So when we scale a geometry, it needs to scale the texture as well.
          * For now this only applies to detached geometries.
          */
        get repeatYFactor(): number;
        set repeatYFactor(value: number);
        get texture(): Texture;
        set texture(texture: Texture);
        get topTexture(): Texture;
        set topTexture(texture: Texture);
        get blendTexture(): boolean;
        set blendTexture(value: boolean);
        setGradientShading(start: number, end: number, intensity: number): void;
        setColor(batchId: number, color: Color, topColor: Color): void;
        getColor(batchId: number): {
            color: Color;
            topColor: Color;
        };
        showTextures: (batchId: number) => void;
        hideTextures(batchId: number): void;
        removeSideTexture(batchId: number): void;
        removeTopTexture(batchId: number): void;
        dispose(): void;
    }
}

declare module '@mappedin/mappedin-js/packages/common/pubsub' {
    /**
        * Generic PubSub class implementing the Publish-Subscribe pattern for event handling.
        *
        * @template EVENT_PAYLOAD - The type of the event payload.
        * @template EVENT - The type of the event.
        */
    export class PubSub<EVENT_PAYLOAD, EVENT extends keyof EVENT_PAYLOAD = keyof EVENT_PAYLOAD> {
            /**
                * @private
                * @internal
                */
            _subscribers: any;
            /**
                * @private
                * @internal
                */
            publish<EVENT_NAME extends EVENT>(eventName: EVENT_NAME, data?: EVENT_PAYLOAD[EVENT_NAME]): void;
            /**
                * Subscribe a function to an event.
                *
                * @param eventName An event name which, when fired, will call the provided
                * function.
                * @param fn A callback that gets called when the corresponding event is fired. The
                * callback will get passed an argument with a type that's one of event payloads.
                * @example
                * // Subscribe to the 'click' event
                * const handler = (event) => {
                *  const { coordinate } = event;
                *  const { latitude, longitude } = coordinate;
                * 	console.log(`Map was clicked at ${latitude}, ${longitude}`);
                * };
                * map.on('click', handler);
                */
            on<EVENT_NAME extends EVENT>(eventName: EVENT_NAME, fn: (payload: EVENT_PAYLOAD[EVENT_NAME] extends {
                    data: null;
            } ? EVENT_PAYLOAD[EVENT_NAME]['data'] : EVENT_PAYLOAD[EVENT_NAME]) => void): void;
            /**
                * Unsubscribe a function previously subscribed with {@link on}
                *
                * @param eventName An event name to which the provided function was previously
                * subscribed.
                * @param fn A function that was previously passed to {@link on}. The function must
                * have the same reference as the function that was subscribed.
                * @example
                * // Unsubscribe from the 'click' event
                * const handler = (event) => {
                * 	console.log('Map was clicked', event);
                * };
                * map.off('click', handler);
                */
            off<EVENT_NAME extends EVENT>(eventName: EVENT_NAME, fn: (payload: EVENT_PAYLOAD[EVENT_NAME] extends {
                    data: null;
            } ? EVENT_PAYLOAD[EVENT_NAME]['data'] : EVENT_PAYLOAD[EVENT_NAME]) => void): void;
            /**
                * @private
                * @internal
                */
            destroy(): void;
    }
}

declare module '@mappedin/mappedin-js/geojson/src/services/renderer' {
    import type { Scene, Camera } from 'three';
    import { Color, WebGLRenderer } from 'three';
    export type TRendererOptions = Partial<{
            canvas: HTMLCanvasElement | OffscreenCanvas;
            antialias: boolean;
            backgroundColor: string;
            backgroundAlpha: number;
            alpha: boolean;
            onWebGLRendererError: (e: Error) => void;
            xRayPath: boolean;
            onWebGLContextCreationError: (e: Event) => void;
            onWebGLContextLost: (e: Event) => void;
            onWebGLContextRestored: (e: Event) => void;
    }>;
    export class Renderer {
            backgroundAlpha: number;
            backgroundColor: Color;
            width: number;
            height: number;
            options: TRendererOptions;
            renderer?: WebGLRenderer;
            constructor(renderOptions: TRendererOptions);
            /**
                * Dispose of the renderer and its buffers.
                */
            destroy(): void;
            enabledLayers: Set<number>;
            /**
                * Re-render the scene, depending on which parts of the scene have been
                * invalidated.
                *
                * @method render
                * @param renderTarget {null or WebGLRenderTarget}
                * @param scene {Scene}
                * @param sceneCamera {Camera}
                */
            render(scene: Scene, sceneCamera: Camera): void;
            clear(): void;
            /**
                * Set the size of the renderer, composer, and all its internal buffers.
                *
                * @method setBufferSize
                * @param width {number}
                * @param height {number}
                */
            setBufferSize(width: number, height: number): void;
            /**
                * Set the color and opacity that will be drawn behind the scene.
                *
                * @method setBackgroundColor
                * @param color {Color}
                * @param alpha {number}
                */
            setBackgroundColor(color: any, alpha: any): void;
            domElement(): HTMLCanvasElement | undefined;
            handleWebGLContextCreationError: (event: Event) => void;
            handleWebGLContextLost: (event: Event) => void;
            handleWebGLContextRestored: (event: Event) => void;
    }
}

declare module '@mappedin/mappedin-js/geojson/src/systems/interactions' {
    export { InteractionSystem } from '@mappedin/mappedin-js/geojson/src/systems/interactions/system';
}

declare module '@mappedin/mappedin-js/geojson/src/systems/mesh-creation-and-optimization/system' {
    import type { BufferGeometry } from 'three';
    import type { RendererState } from '@mappedin/mappedin-js/geojson/src/renderer';
    import { Geometry3D, Geometry3DObject3D } from '@mappedin/mappedin-js/geojson/src/entities/geometry3d';
    import { MeshComponent, type MeshComponentProperties } from '@mappedin/mappedin-js/geojson/src/components/mesh';
    import { StyleComponent } from '@mappedin/mappedin-js/geojson/src/components/styles/style';
    import type { Feature, LineString, MultiPolygon, Point, Polygon } from 'geojson';
    import type { LineStyle, ModelProperties, PaintStyle } from '@mappedin/mappedin-js/geojson/src/types';
    import { GeometryGroupObject3D } from '@mappedin/mappedin-js/geojson/src/entities/geometry-group';
    import type { ModelGeometry3D } from '@mappedin/mappedin-js/geojson/src/entities';
    import { PubSub } from '@packages/internal/common';
    import type { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
    import type { ModelStyle } from '@mappedin/mappedin-js/geojson/src/components/styles';
    export class MeshCreationAndOptimizationSystem extends PubSub<{
        'model-loaded': void;
        'geometry-2d-added': void;
    }> {
        state: RendererState;
        convertTo3DMapPosition: any;
        loader?: GLTFLoader;
        constructor(state: RendererState, convertTo3DMapPosition: any);
        getGLTFLoader(): Promise<GLTFLoader>;
        createEntityFromFeature(id: string | number, feature: Feature<Polygon | LineString | MultiPolygon, MeshComponentProperties>, style?: LineStyle | PaintStyle): Geometry3D<MeshComponent, StyleComponent, import("../../components/interaction").InteractionComponent, "geometry">;
        createModelFromFeature(id: string | number, feature: Feature<Point, ModelProperties>, style?: Partial<ModelStyle>): ModelGeometry3D;
        populateEntityMesh(entity: Geometry3D, geometry: BufferGeometry): void;
        populateModelGroup(entities: Set<string | number>, url: string, tree: GeometryGroupObject3D): Promise<Geometry3DObject3D>;
        populateEntityGroup(entities: Set<string | number>): Set<string | number>;
        optimize(tree: any): void;
        update(): Promise<void[]> | undefined;
    }
}

declare module '@mappedin/mappedin-js/geojson/src/systems/dom-visiblity/system' {
    import type { RendererState } from '@mappedin/mappedin-js/geojson/src/renderer';
    import type { Entity2DHTMLDivElementContainer } from '@mappedin/mappedin-js/geojson/src/types';
    export class DOMVisibilitySystem {
        state: RendererState;
        dirty: boolean;
        domTree: Entity2DHTMLDivElementContainer;
        constructor(state: RendererState, domTree: Entity2DHTMLDivElementContainer);
        update(): void;
    }
}

declare module '@mappedin/mappedin-js/geojson/src/systems/2d-projection/system' {
    import type { Vector2, Vector3 } from 'three';
    import type { RendererState } from '@mappedin/mappedin-js/geojson/src/renderer';
    export class TwoDProjectionSystem {
        state: RendererState;
        project: (projection: Vector2, position: Vector3) => void;
        constructor(state: RendererState, project: (projection: Vector2, position: Vector3) => void);
        update(): void;
    }
}

declare module '@mappedin/mappedin-js/geojson/src/systems/2d-draw/system' {
    import type { RendererState, TransformImageRequest } from '@mappedin/mappedin-js/geojson/src/renderer';
    import LabelComponent from '@mappedin/mappedin-js/geojson/src/components/label';
    import { PubSub } from '@packages/internal/common';
    export const INACTIVE_MARKER_SIZE_NO_ICON = 3.5;
    enum TEXTALIGN {
        LEFT = "left",
        CENTER = "center",
        RIGHT = "right"
    }
    export class TwoDDrawSystem extends PubSub<{
        'img:loaded': undefined;
    }> {
        dirty: boolean;
        state: RendererState;
        colliderContext: CanvasRenderingContext2D;
        colliderCanvas: HTMLCanvasElement;
        transformRequestFunc?: TransformImageRequest;
        constructor(state: RendererState, colliderCanvas: HTMLCanvasElement, transformImageRequest?: TransformImageRequest);
        transformRequest: (url: string) => Promise<{
            url: string;
        }>;
        pinCache: {
            [key in number]: [HTMLCanvasElement | OffscreenCanvas, HTMLCanvasElement | OffscreenCanvas];
        };
        /** Stores the loaded images ready to be drawn. */
        imageCache: {
            [key in number]: HTMLImageElement | ImageBitmap;
        };
        /** Stores the promises for each image fetch. */
        imagePromiseCache: {
            [key in number]: Promise<HTMLImageElement | ImageBitmap>;
        };
        imageDimensionsCache: {
            [key in number]: {
                width: number;
                height: number;
            };
        };
        textCache: {
            [key in string]: {
                left?: OffscreenCanvas | HTMLCanvasElement;
                center?: OffscreenCanvas | HTMLCanvasElement;
                right?: OffscreenCanvas | HTMLCanvasElement;
            };
        };
        update: (zoomLevel: number) => void;
        processText: (text: string, size: number, maxWidth: number, maxLines: number, lineHeight: number) => {
            textDrawFn: import("@packages/internal/shave-text/shave-text").TDrawFn;
            width: number;
            height: number;
        };
        textToCanvas: (textDrawFn: (ctx: CanvasRenderingContext2D, x: number, y: number) => void, size: number, textAlign: TEXTALIGN, width: number, height: number, foregroundColor: string, backgroundColor: string) => any;
        cacheImage: (label: LabelComponent) => void;
        createPinCanvas: (label: LabelComponent, markerSize: number, backgroundColor: string, foregroundColor: string) => HTMLCanvasElement | OffscreenCanvas;
        prepare: (label: LabelComponent, labelCacheId: string, context: CanvasRenderingContext2D) => void;
        draw(label: LabelComponent, labelCacheId: string, context: CanvasRenderingContext2D): void;
    }
    export {};
}

declare module '@mappedin/mappedin-js/geojson/src/systems/draw/system' {
    import { PubSub } from '@packages/internal/common';
    import { MeshComponent } from '@mappedin/mappedin-js/geojson/src/components/mesh';
    import type { StyleComponent } from '@mappedin/mappedin-js/geojson/src/components/styles/style';
    import type { Position, RendererState } from '@mappedin/mappedin-js/geojson/src/renderer';
    import type { InteractionComponent } from '@mappedin/mappedin-js/geojson/src/components/interaction';
    import type { Vector3 } from 'three';
    import type { GeometryGroupStyleComponent } from '@mappedin/mappedin-js/geojson/src/components/geometry-group-style';
    export class DrawSystem extends PubSub<{
        'texture-loaded': void;
    }> {
        #private;
        state: RendererState;
        convertTo3DMapPosition: (position: Position) => Vector3;
        constructor(state: RendererState, convertTo3DMapPosition: (position: Position) => Vector3);
        processTextures(component: MeshComponent, styleComponent: StyleComponent | GeometryGroupStyleComponent, interactionComponent?: InteractionComponent): void;
        update(): void;
        destroy(): void;
    }
}

declare module '@mappedin/mappedin-js/geojson/src/systems/2d-visibility/system' {
    import type { RendererState } from '@mappedin/mappedin-js/geojson/src/renderer';
    import { PubSub } from '@mappedin/mappedin-js/packages/common/pubsub';
    import LabelComponent from '@mappedin/mappedin-js/geojson/src/components/label';
    export class TwoDVisibilitySystem extends PubSub<{
        'draw:2d': undefined;
        'animate:2d': undefined;
    }> {
        state: RendererState;
        constructor(state: RendererState);
        animating: Map<LabelComponent, [number, number]>;
        isAnimating: boolean;
        startTime: number;
        showDuration: number;
        hideDuration: number;
        update: () => void;
        playAnimations: () => void;
        _playAnimations(): void;
    }
}

declare module '@mappedin/mappedin-js/geojson/src/systems/render/system' {
    import type { Camera, PerspectiveCamera, Scene } from 'three';
    import type { RendererState, Systems } from '@mappedin/mappedin-js/geojson/src/renderer';
    import type RendererCore from '@mappedin/mappedin-js/geojson/src/renderer';
    import type { Renderer } from '@mappedin/mappedin-js/geojson/src/services/renderer';
    import { PubSub } from '@packages/internal/common';
    export class RenderSystem extends PubSub<{
            'measure-canvas': undefined;
            'pre-render': undefined;
            'post-render': undefined;
    }> {
            constructor(renderer: Renderer, state: RendererState, mode: RendererCore['mode'], scene: Scene, cameraObject: PerspectiveCamera, viewCamera: Camera, systems: Systems);
            needs2DRecompute: boolean;
            twoDdirty: boolean;
            threeDdirty: boolean;
            update: (sync?: boolean) => Promise<any> | undefined;
            destroy(): void;
    }
}

declare module '@mappedin/mappedin-js/geojson/src/systems/stack/system' {
    import type { RendererState } from '@mappedin/mappedin-js/geojson/src/renderer';
    export class StackSystem {
        rendererState: RendererState;
        constructor(rendererState: RendererState);
        update(): void;
    }
}

declare module '@mappedin/mappedin-js/geojson/src/systems/camera' {
    export { CameraSystem } from '@mappedin/mappedin-js/geojson/src/systems/camera/system';
    export type { AnimateCameraTarget } from '@mappedin/mappedin-js/geojson/src/systems/camera/types';
    export * as CAMERA_CONSTANTS from '@mappedin/mappedin-js/geojson/src/systems/camera/constants';
}

declare module '@mappedin/mappedin-js/geojson/src/systems/dom-draw/system' {
    import type { RendererState } from '@mappedin/mappedin-js/geojson/src/renderer';
    export const ANIMATION_DURATION = 300;
    export class DOMDrawSystem {
        #private;
        state: RendererState;
        constructor(state: RendererState);
        update(isUserInteracting: boolean): void;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4' {
    import { Map } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/map';
    import { NavigationControl } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/control/navigation_control';
    import { GeolocateControl } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/control/geolocate_control';
    import { AttributionControl } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/control/attribution_control';
    import { LogoControl } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/control/logo_control';
    import { ScaleControl } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/control/scale_control';
    import { FullscreenControl } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/control/fullscreen_control';
    import { TerrainControl } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/control/terrain_control';
    import { Popup } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/popup';
    import { Marker } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/marker';
    import { Style } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style';
    import { LngLat, LngLatLike } from '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/lng_lat';
    import { LngLatBounds, LngLatBoundsLike } from '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/lng_lat_bounds';
    import Point from '@mapbox/point-geometry';
    import { MercatorCoordinate } from '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/mercator_coordinate';
    import { Evented } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/evented';
    import { config } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/config';
    import { prewarm, clearPrewarmedResources } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/global_worker_pool';
    import { AJAXError } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/ajax';
    import { GeoJSONSource } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/geojson_source';
    import { CanvasSource, CanvasSourceSpecification } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/canvas_source';
    import { ImageSource } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/image_source';
    import { RasterDEMTileSource } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/raster_dem_tile_source';
    import { RasterTileSource } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/raster_tile_source';
    import { VectorTileSource } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/vector_tile_source';
    import { VideoSource } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/video_source';
    import { Source, addSourceType } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/source';
    import { addProtocol, removeProtocol } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/protocol_crud';
    import { IControl } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/control/control';
    import { EdgeInsets, PaddingOptions } from '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/edge_insets';
    import { MapTerrainEvent, MapStyleImageMissingEvent, MapStyleDataEvent, MapSourceDataEvent, MapLibreZoomEvent, MapLibreEvent, MapLayerTouchEvent, MapLayerMouseEvent, MapLayerEventType, MapEventType, MapDataEvent, MapContextEvent, MapWheelEvent, MapTouchEvent, MapMouseEvent } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/events';
    import { BoxZoomHandler } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/box_zoom';
    import { DragRotateHandler } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/shim/drag_rotate';
    import { DragPanHandler } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/shim/drag_pan';
    import { ScrollZoomHandler } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/scroll_zoom';
    import { TwoFingersTouchZoomRotateHandler } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/shim/two_fingers_touch';
    import { CustomLayerInterface } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/custom_style_layer';
    import { PointLike } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/camera';
    import { Hash } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/hash';
    import { CooperativeGesturesHandler } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/cooperative_gestures';
    import { DoubleClickZoomHandler } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/shim/dblclick_zoom';
    import { KeyboardHandler } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/keyboard';
    import { TwoFingersTouchPitchHandler, TwoFingersTouchRotateHandler, TwoFingersTouchZoomHandler } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/two_fingers_touch';
    export type * from '@maplibre/maplibre-gl-style-spec';
    /**
        * Sets the map's [RTL text plugin](https://www.mapbox.com/mapbox-gl-js/plugins/#mapbox-gl-rtl-text).
        * Necessary for supporting the Arabic and Hebrew languages, which are written right-to-left.
        *
        * @param pluginURL - URL pointing to the Mapbox RTL text plugin source.
        * @param lazy - If set to `true`, mapboxgl will defer loading the plugin until rtl text is encountered,
        * rtl text will then be rendered only after the plugin finishes loading.
        * @example
        * ```ts
        * setRTLTextPlugin('https://unpkg.com/@mapbox/mapbox-gl-rtl-text@0.2.3/mapbox-gl-rtl-text.js', false);
        * ```
        * @see [Add support for right-to-left scripts](https://maplibre.org/maplibre-gl-js/docs/examples/mapbox-gl-rtl-text/)
        */
    function setRTLTextPlugin(pluginURL: string, lazy: boolean): Promise<void>;
    /**
        * Gets the map's [RTL text plugin](https://www.mapbox.com/mapbox-gl-js/plugins/#mapbox-gl-rtl-text) status.
        * The status can be `unavailable` (i.e. not requested or removed), `loading`, `loaded` or `error`.
        * If the status is `loaded` and the plugin is requested again, an error will be thrown.
        *
        * @example
        * ```ts
        * const pluginStatus = getRTLTextPluginStatus();
        * ```
        */
    function getRTLTextPluginStatus(): string;
    /**
        * Returns the package version of the library
        * @returns Package version of the library
        */
    function getVersion(): string;
    /**
        * Gets the number of web workers instantiated on a page with GL JS maps.
        * By default, workerCount is 1 except for Safari browser where it is set to half the number of CPU cores (capped at 3).
        * Make sure to set this property before creating any map instances for it to have effect.
        *
        * @returns Number of workers currently configured.
        * @example
        * ```ts
        * const workerCount = getWorkerCount()
        * ```
        */
    function getWorkerCount(): number;
    /**
        * Sets the number of web workers instantiated on a page with GL JS maps.
        * By default, workerCount is 1 except for Safari browser where it is set to half the number of CPU cores (capped at 3).
        * Make sure to set this property before creating any map instances for it to have effect.
        *
        * @example
        * ```ts
        * setWorkerCount(2);
        * ```
        */
    function setWorkerCount(count: number): void;
    /**
        * Gets and sets the maximum number of images (raster tiles, sprites, icons) to load in parallel,
        * which affects performance in raster-heavy maps. 16 by default.
        *
        * @returns Number of parallel requests currently configured.
        * @example
        * ```ts
        * getMaxParallelImageRequests();
        * ```
        */
    function getMaxParallelImageRequests(): number;
    /**
        * Sets the maximum number of images (raster tiles, sprites, icons) to load in parallel,
        * which affects performance in raster-heavy maps. 16 by default.
        *
        * @example
        * ```ts
        * setMaxParallelImageRequests(10);
        * ```
        */
    function setMaxParallelImageRequests(numRequests: number): void;
    /**
        * Gets the worker url
        * @returns The worker url
        */
    function getWorkerUrl(): string;
    /**
        * Sets the worker url
        */
    function setWorkerUrl(value: string): void;
    /**
        * Allows loading javascript code in the worker thread.
        * *Note* that since this is using some very internal classes and flows it is considered experimental and can break at any point.
        *
        * It can be useful for the following examples:
        * 1. Using `self.addProtocol` in the worker thread - note that you might need to also register the protocol on the main thread.
        * 2. Using `self.registerWorkerSource(workerSource: WorkerSource)` to register a worker source, which sould come with `addSourceType` usually.
        * 3. using `self.actor.registerMessageHandler` to override some internal worker operations
        * @param workerUrl - the worker url e.g. a url of a javascript file to load in the worker
        * @returns
        *
        * @example
        * ```ts
        * // below is an example of sending a js file to the worker to load the method there
        * // Note that you'll need to call the global function `addProtocol` in the worker to register the protocol there.
        * // add-protocol-worker.js
        * async function loadFn(params, abortController) {
        *     const t = await fetch(`https://${params.url.split("://")[1]}`);
        *     if (t.status == 200) {
        *         const buffer = await t.arrayBuffer();
        *         return {data: buffer}
        *     } else {
        *         throw new Error(`Tile fetch error: ${t.statusText}`);
        *     }
        * }
        * self.addPRotocol('custom', loadFn);
        *
        * // main.js
        * importScriptInWorkers('add-protocol-worker.js');
        * ```
        */
    function importScriptInWorkers(workerUrl: string): Promise<void[]>;
    export { Map, NavigationControl, GeolocateControl, AttributionControl, LogoControl, ScaleControl, FullscreenControl, TerrainControl, Hash, Popup, Marker, Style, LngLat, LngLatBounds, Point, MercatorCoordinate, Evented, AJAXError, config, CanvasSource, GeoJSONSource, ImageSource, RasterDEMTileSource, RasterTileSource, VectorTileSource, VideoSource, EdgeInsets, BoxZoomHandler, DragRotateHandler, DragPanHandler, ScrollZoomHandler, TwoFingersTouchZoomRotateHandler, CooperativeGesturesHandler, DoubleClickZoomHandler, KeyboardHandler, TwoFingersTouchZoomHandler, TwoFingersTouchRotateHandler, TwoFingersTouchPitchHandler, MapWheelEvent, MapTouchEvent, MapMouseEvent, type IControl, type CustomLayerInterface, type CanvasSourceSpecification, type PaddingOptions, type LngLatLike, type PointLike, type LngLatBoundsLike, type Source, type MapTerrainEvent, type MapStyleImageMissingEvent, type MapStyleDataEvent, type MapSourceDataEvent, type MapLibreZoomEvent, type MapLibreEvent, type MapLayerTouchEvent, type MapLayerMouseEvent, type MapLayerEventType, type MapEventType, type MapDataEvent, type MapContextEvent, setRTLTextPlugin, getRTLTextPluginStatus, prewarm, clearPrewarmedResources, getVersion, getWorkerCount, setWorkerCount, getMaxParallelImageRequests, setMaxParallelImageRequests, getWorkerUrl, setWorkerUrl, addProtocol, removeProtocol, addSourceType, importScriptInWorkers, };
}

declare module '@mappedin/mappedin-js/geojson/src/systems/dom-resize/system' {
    import { PubSub } from '@packages/internal/common';
    import type { RendererState } from '@mappedin/mappedin-js/geojson/src/renderer';
    import type { Entity2DHTMLDivElementContainer } from '@mappedin/mappedin-js/geojson/src/types';
    export class DOMResizeSystem extends PubSub<{
        'dimensions-update': void;
    }> {
        state: RendererState;
        dirty: boolean;
        domTree: Entity2DHTMLDivElementContainer;
        observers: Map<string | number, ResizeObserver>;
        constructor(state: RendererState, domTree: Entity2DHTMLDivElementContainer);
        setupObserver(): void;
        updateDimensions: (mutations: any) => void;
        update(): void;
        destroy(): void;
    }
}

declare module '@mappedin/mappedin-js/geojson/src/systems/pan-bounds/system' {
    import type { CameraSystem } from '@mappedin/mappedin-js/geojson/src/systems/camera';
    import type { RendererState } from '@mappedin/mappedin-js/geojson/src/renderer';
    import { PubSub } from '@packages/internal/common';
    export class PanBoundsSystem extends PubSub<{
        update: void;
    }> {
        dirty: boolean;
        autoMinZoomLevel: boolean;
        constructor(state: RendererState, cameraSystem: CameraSystem);
        /**
          * Recomputes the pan bounds based on the current 2D and 3D entities in the scene
          * This is only additive, meaning removing entities will not shrink the pan bounds
          */
        update(): void;
    }
}

declare module '@mappedin/mappedin-js/geojson/src/systems/custom-geometry/system' {
    import type { RendererCore } from '@mappedin/mappedin-js/geojson/src';
    import type { RendererState } from '@mappedin/mappedin-js/geojson/src/renderer';
    /**
      * System that renders and updates custom geometry entities. For every custom geometry entity, this calls the builder's
      * setup method once (when it is visible) and then the update method every frame.
      */
    export class CustomGeometrySystem {
        constructor(state: RendererState, convertTo3DMapPosition: RendererCore['convertTo3DMapPosition']);
        update(): void;
    }
}

declare module '@mappedin/mappedin-js/geojson/src/systems/outline-interpolation/system' {
    import type { RendererState } from '@mappedin/mappedin-js/geojson/src/renderer';
    export class OutlineInterpolationSystem {
            #private;
            /**
                * Set to true when we need to update the outline color of all entities, regardless of zoom level.
                */
            dirty: boolean;
            get geometries3DDirty(): boolean;
            set geometries3DDirty(value: boolean);
            constructor(rendererState: RendererState);
            /**
                * Update the outline color of all entities with an outline component.
                * @param zoomLevel - The current zoom level.
                * @param isCameraZoomDirty - Whether the zoom level has changed since the last update. If this is true, the system will update if zoomLevel falls between range.
                */
            update(zoomLevel: number, isCameraZoomDirty?: boolean): void;
    }
}

declare module '@mappedin/mappedin-js/geojson/src/systems/image/system' {
    import type { ImagePlacementOptions, RendererState } from '@mappedin/mappedin-js/geojson/src/renderer';
    import { type Texture } from 'three';
    import type { RendererCore } from '@mappedin/mappedin-js/geojson/src';
    import { PubSub } from '@packages/internal/common';
    export const DEFAULT_VERTICAL_OFFSET = 0.01;
    export class ImageSystem extends PubSub<{
        'image-loaded': void;
    }> {
        constructor(rendererState: RendererState, convertTo3DMapPosition: RendererCore['convertTo3DMapPosition'], initialBearing?: number, naturalBearing?: number, imagePlacementOptions?: ImagePlacementOptions);
        /**
          * We need to track the loaded state separately from the promise since we can't check
          * the resolution state of a promise after it settles. This allows components to check
          * if an image has finished loading without having to await the promise.
          */
        imageLoadingCache: Map<string, {
            loaded: boolean;
            promise: Promise<Texture>;
        }>;
        update(cameraRotationRadians: number): void;
    }
}

declare module '@mappedin/mappedin-js/geojson/src/systems/geometry-in-focus/system' {
    import { PubSub } from '@packages/internal/common';
    import type { RendererState } from '@mappedin/mappedin-js/geojson/src/renderer';
    import { type PerspectiveCamera } from 'three';
    export class GeometryInFocusSystem extends PubSub<{
            /**
                * Returns the list of entities that are likely in focus, sorted by the weight of the raycast.
                */
            'geometry-in-focus': string[];
    }> {
            #private;
            cameraDirty: boolean;
            focusablesDirty: boolean;
            constructor(state: RendererState, camera: PerspectiveCamera);
            resize(): void;
            update: (cameraIsMoving?: boolean, cameraStoppedMovingTime?: number) => void;
            updateRaf(): void;
            showRaycasters(): void;
            hideRaycasters(): void;
            destroy(): void;
    }
}

declare module '@mappedin/mappedin-js/geojson/src/systems/outdoor-layers/system' {
    import type { Map } from '@packages/internal/outdoor-context-v4';
    import type { Position } from '@mappedin/mappedin-js/geojson/src/renderer';
    import { type BBox } from 'geojson';
    export class OutdoorLayers {
        dirty: boolean;
        hideLayersUnderPoint(point: Position, layers: string[]): void;
        hideLayersIntersectingPolygons(bbox: BBox, polygons: GeoJSON.Feature<GeoJSON.Polygon | GeoJSON.MultiPolygon, any>[], layers: string[]): void;
        constructor(map?: Map);
        destroy(): void;
    }
}

declare module '@mappedin/mappedin-js/geojson/src/systems/path' {
    export { PathSystem } from '@mappedin/mappedin-js/geojson/src/systems/path/system';
}

declare module '@mappedin/mappedin-js/geojson/src/systems/mesh-detachment/system' {
    import { type All3DTypes, type RendererState } from '@mappedin/mappedin-js/geojson/src/renderer';
    /**
      * This system is responsible for updating the opacity of the mesh, which results in the mesh
      * being detached from the parent's optimized geometry group and rendered as a separate mesh.
      */
    export class MeshDetachmentSystem {
        #private;
        rendererState: RendererState;
        dirty: boolean;
        constructor(rendererState: RendererState);
        updateOne(geometry: All3DTypes | undefined): void;
        update(): void;
    }
}

declare module '@mappedin/mappedin-js/geojson/src/systems/mesh-modification/system' {
    import type { EntityTypes, RendererState } from '@mappedin/mappedin-js/geojson/src/renderer';
    /**
      * Any physical changes to geometry should go in here. This includes height changes, etc.
      * This is to ensure that physical changes apply before any other systems need to do their work,
      * such as the outline system.
      *
      * TODO: For now, this piggybacks of style.dirty, but we may want to create a flag indicating geometry dirty.
      */
    export class MeshModificationSystem {
        #private;
        rendererState: RendererState;
        dirty: boolean;
        constructor(rendererState: RendererState);
        updateOne(entity?: EntityTypes): void;
        update(): void;
        cleanup(): void;
    }
}

declare module '@mappedin/mappedin-js/geojson/src/systems/2d-occlusion/system' {
    import type { RendererState } from '@mappedin/mappedin-js/geojson/src/renderer';
    import { type Vector3 } from 'three';
    import type { Renderer } from '@mappedin/mappedin-js/geojson/src/services/renderer';
    import type { Position as GeoJsonPosition } from 'geojson';
    export function fillArrayWithColor(array: Float32Array | Uint8Array, count: number, color: number): void;
    export class Occlusion2DSystem {
        backgroundId: number;
        constructor(state: RendererState, convertTo3DMapPosition: (position: GeoJsonPosition) => Vector3, renderer?: Renderer);
        reserveOccluderId(): number;
        enable(): void;
        disable(): void;
        resize: () => void;
        activeOccluders: Set<unknown>;
        update: () => void;
        destroy(): void;
    }
}

declare module '@mappedin/mappedin-js/geojson/src/components/styles/style' {
    import type { LineStyle } from '@mappedin/mappedin-js/geojson/src/renderer';
    export const DEFAULT_COLOR = "#ffffff";
    export const DEFAULT_HEIGHT = 0.1;
    /**
      * Determines how a material is rendered, back face, front face or both (default)
      */
    export type MaterialSide = 'back' | 'front' | 'double';
    type Style = {
        color: string;
        width: number;
        opacity: number;
        visible: boolean;
        height: number;
        altitude: number;
        join: LineStyle['join'];
        cap: LineStyle['cap'];
        topColor?: string;
        texture?: string;
        topTexture?: string;
        outline: boolean;
        showImage: boolean;
        flipImageToFaceCamera: boolean;
        url?: string;
        side?: MaterialSide;
        renderOrder?: number;
    };
    export class StyleComponent implements Style {
        initialColor: string;
        color: string;
        initialTopColor?: string;
        topColor?: string;
        topTexture?: string;
        texture?: string;
        hoverColor?: string;
        dirty: boolean;
        visible: boolean;
        opacity: number;
        width: number;
        height: number;
        initialHeight: number;
        altitude: number;
        join: LineStyle['join'];
        cap: LineStyle['cap'];
        outline: boolean;
        showImage: boolean;
        flipImageToFaceCamera: boolean;
        url?: string;
        side: MaterialSide;
        renderOrder: number;
        constructor(style?: Partial<Style>);
    }
    export {};
}

declare module '@mappedin/mappedin-js/packages/geojson-navigator/src' {
    export { Navigator } from '@mappedin/mappedin-js/packages/geojson-navigator/src/navigator';
    export type { SimplifyDirectionsOptions } from '@mappedin/mappedin-js/packages/geojson-navigator/src/navigator/navigator';
    export type { NodeCollection, NodeProperties, NodeFeature, NodeNeighbor } from '@mappedin/mappedin-js/packages/geojson-navigator/src/types/node';
    export type { ObstructionCollection, ObstructionProperties, ObstructionFeature } from '@mappedin/mappedin-js/packages/geojson-navigator/src/types/obstruction';
    export type { DirectionsCollection, DirectionProperties, DirectionFeature } from '@mappedin/mappedin-js/packages/geojson-navigator/src/types/directions';
    export type { CoordinateFeature, CoordinateProperties } from '@mappedin/mappedin-js/packages/geojson-navigator/src/types/coordinate';
}

declare module '@mappedin/mappedin-js/geojson/src/utils/bounding-box' {
    import { type Box3, Vector3 } from 'three';
    export function getCornersOfBoundingBox(boundingBox: Box3): Vector3[];
}

declare module '@mappedin/mappedin-js/geojson/src/utils/ecs' {
    import type { Geometry2D, Geometry3DTypes } from '@mappedin/mappedin-js/geojson/src/entities';
    import type { GroupContainerObject3D } from '@mappedin/mappedin-js/geojson/src/entities/group-container';
    import type { GeometryGroupObject3D } from '@mappedin/mappedin-js/geojson/src/entities/geometry-group';
    import type { EntityId, EntityState, RendererState } from '@mappedin/mappedin-js/geojson/src/renderer';
    import { Box3, Vector3 } from 'three';
    import type RendererCore from '@mappedin/mappedin-js/geojson/src/renderer';
    export function getGeometryByGeometryId(state: RendererState, geometryOrGeometryId?: string | number | Record<string, any>): Geometry3DTypes | GeometryGroupObject3D | GroupContainerObject3D | Geometry2D | undefined;
    export function getVerticesOfEntity(core: RendererCore, geometryOrGeometryId?: string | number | EntityId<EntityState>, vertices?: Vector3[], bounds?: Box3, zOffset?: number): Vector3[];
}

declare module '@mappedin/mappedin-js/geojson/src/utils/get-pixel-ratio' {
    export function getPixelRatio(): number;
}

declare module '@mappedin/mappedin-js/geojson/src/utils/async' {
    export function throttle<T>(func: () => void, wait: number, options?: any): () => void;
    export function debounce<T extends (...args: any[]) => void>(func: T, wait: number, immediate?: boolean): (...args: Parameters<T>) => void;
}

declare module '@mappedin/mappedin-js/geojson/src/utils/browser' {
    type DeviceType = {
            isIpad: boolean;
            isMobile: boolean;
            isSafari12: boolean;
            isFirefox: boolean;
            isWindows: boolean;
    };
    /**
        * Get device OS info
        * export for testing purpose
        * @returns DeviceType
        */
    export const _deviceTypeControl: {
            getDeviceType(): DeviceType;
            _reset(): void;
    };
    export const getDeviceType: () => DeviceType;
    /**
        * Creates a closure encapsulating the logic of getting device GPU info.
        * inspired by https://github.com/pmndrs/detect-gpu
        * export for testing
        */
    export const _gpuInfoControl: {
            getInfo: () => string | undefined;
            shouldDisableOffscreenCanvas: () => boolean;
            _setCanvas(c: HTMLCanvasElement): void;
    };
    export const getGPUInfo: () => string | undefined;
    /**
        * Check if device is certain intel integrated GPU.
        * This is for implementing workaround - https://issues.chromium.org/issues/40251953
        * The reason we want to disable OffscreenCanvas at all is due to `willReadFrequently` flag only works in FF.
        * In order to ensure the integrated intel GPU render text correctly
        */
    export const shouldDisableOffscreenCanvas: () => boolean;
    export {};
}

declare module '@mappedin/mappedin-js/geojson/src/utils/fp' {
    export function noop(): void;
    export type KeysOfUnion<T> = T extends T ? keyof T : never;
    /**
      * Given an object and a number of properties as strings, return version
      * of that object with only those properties.
      *
      * @param src - the object
      * @param properties - an array of property names chosen
      * to appear on the resulting object.
      * @returns object with limited properties.
      * @example
      * ```ts
      * let foo = { name: 'Charlie', age: 10 };
      * let justName = pick(foo, ['name']); // justName = { name: 'Charlie' }
      * ```
      */
    export function pick<T extends object>(src: T, properties: KeysOfUnion<T>[]): Partial<T>;
    export function isEmpty(obj: Record<string, any>): boolean;
}

declare module '@mappedin/mappedin-js/geojson/src/utils/tranform-request' {
    export const transformRequest: (headers: {
        "x-mappedin-tiles-key": string;
    }) => (url: string) => {
        url: string;
        headers: {};
    };
}

declare module '@mappedin/mappedin-js/geojson/src/utils/math' {
    export function normalizeAngle(angle: number): number;
}

declare module '@mappedin/mappedin-js/geojson/src/entities' {
    export { updateInteractivity } from '@mappedin/mappedin-js/geojson/src/entities/utils';
    export { Geometry2D, Geometry2DComponents } from '@mappedin/mappedin-js/geojson/src/entities/geometry2d';
    export { Geometry3D, Geometry3DComponents } from '@mappedin/mappedin-js/geojson/src/entities/geometry3d';
    export type { PathMesh, PatMeshContainer, PathMaterial, Geometry3DTypes, ImageGeometry3D, TextGeometry3D, ModelGeometry3D, CustomGeometry3D, MeshGeometry3D, } from '@mappedin/mappedin-js/geojson/src/entities/geometry3d';
}

declare module '@mappedin/mappedin-js/geojson/src/systems/exporter/exporter' {
    import type { RendererState } from '@mappedin/mappedin-js/geojson/src/renderer';
    export type GLTFExportOptions = {
            onlyVisible?: boolean;
            binary?: boolean;
            scale?: number;
            light?: boolean;
    };
    /**
        * Class for exporting a three.js scene as a GLTF file.
        */
    export class ExporterSystem {
            #private;
            /**
                * @hidden
                */
            constructor(state: RendererState);
            /**
                * Exports the current scene as a GLTF file.
                * @param {GLTFExportOptions} userOptions - User-defined options for exporting.
                * @returns {Promise<Blob>} - A promise that resolves to a Blob containing the GLTF data.
                */
            getCurrentSceneGLTF: (userOptions: GLTFExportOptions) => Promise<Blob>;
            /**
                * Cleans up resources used by the ExporterSystem.
                */
            destroy(): void;
    }
}

declare module '@mappedin/mappedin-js/geojson/src/components/styles/text-style' {
    /**
        * avoid storying default values on the text style to save space
        */
    export class Text3DStyleComponent implements Partial<Text3DStyle> {
            visible?: boolean;
            altitude?: number;
            color?: string;
            dirty: boolean;
            maxWidth?: number;
            maxHeight?: number;
            hoverByPolygon?: boolean;
            flipToFaceCamera?: boolean | undefined;
            font?: string;
            fillOpacity?: number;
            fontSize?: number;
            margin?: number;
            outlineWidth?: number;
            outlineBlur?: number | string;
            outlineOffsetX?: number;
            strokeColor?: string;
            strokeOpacity?: number;
            strokeWidth?: number;
            hoverColor?: string | undefined;
            outlineOffsetY?: number;
            outlineColor?: string;
            outlineOpacity?: number;
            constructor(initialState?: Partial<Text3DStyle>);
            /**
                * Put together a json ignore all the undefined fields.
                * This is helpful when we Object.assign(instance, json) to update the instance.
                */
            getState(includeDirty?: boolean): Partial<Text3DStyle>;
    }
    /**
        * Not directly storing default values on the text style to save space
        * TODO: lookign at text style spec from maplibre. we can also support:
        * letterSpacing?: number;
        * lineHeight: number;
        * anchor: number;  => .anchorX & .anchorY
        * justify: nubmer; => .textAlign
        * tarnsform: string;
        * offset: number;
        */
    export const DEFAULT_TEXT_STYLE: Readonly<Text3DStyle>;
    export type Text3DStyle = {
            /**
                * Controls the visibility of the text element.
                * @default true
                */
            visible: boolean;
            /**
                * The color of the text. Will change to hoverColor when the associated polygon is hovered.
                * Accepts any CSS color string.
                * @default 'black'
                */
            color: string;
            /**
                * When true, the text will flip to face the camera while maintaining its position.
                * @default true
                */
            flipToFaceCamera: boolean;
            /**
                * URL to a custom font file (.ttf, .otf, .woff).
                * Falls back to Roboto if undefined.
                */
            font: string | undefined;
            /**
                * The size of the text in meters. Will be automatically adjusted if it exceeds
                * the text area bounds.
                */
            fontSize: number;
            /**
                * Padding between the text and its bounding box, in meters.
                * Can be specified as either:
                * - A single number for uniform padding on all sides
                * - An array of 4 numbers [top, right, bottom, left] for individual side padding
                * @default [0.2, 1, 0.2, 1.5]
                */
            margin: number | [number, number, number, number];
            /**
                * Color of the text outline.
                * Accepts any CSS color string.
                * @default 'black'
                */
            outlineColor: string;
            /**
                * Opacity of the text outline.
                * Accepts values between 0 and 1.
                * @default 1
                */
            outlineOpacity: number;
            /**
                * Blur radius for the text outline.
                * Can be a number in pixels or a string with units.
                */
            outlineBlur: number | string;
            /**
                * Width of the text outline effect in pixels.
                */
            outlineWidth: number;
            /**
                * Horizontal offset of the outline effect from the text, in pixels.
                */
            outlineOffsetX: number;
            /**
                * Vertical offset of the outline effect from the text, in pixels.
                */
            outlineOffsetY: number;
            /**
                * Width of the inner stroke of each text glyph.
                * @default 0
                */
            strokeWidth: number;
            /**
                * Maximum width constraint for the text area in meters.
                * Overrides default text field constraints when set.
                */
            maxWidth: number | undefined;
            /**
                * Maximum height constraint for the text area in meters.
                * Overrides default text field constraints when set.
                */
            maxHeight: number | undefined;
            /**
                * Opacity of the text stroke when strokeWidth > 0.
                * @default 1
                */
            strokeOpacity: number;
            /**
                * Color of the text stroke when strokeWidth > 0.
                * Accepts any CSS color string.
                * @default 'black'
                */
            strokeColor: string;
            /**
                * Opacity of the text fill, independent of stroke and outline opacity.
                * Set to 0 to show only stroke/outline.
                * Accepts values between 0 and 1.
                */
            fillOpacity: number;
            /**
                * Color to display when text is hovered.
                * Falls back to global hover color if undefined.
                */
            hoverColor: string | undefined;
    };
}

declare module '@mappedin/mappedin-js/geojson/src/components/styles/model-style' {
    type MaterialStyle = {
            color: string;
    };
    export type ModelStyle = {
            /**
                * Model's URL. Can be based64 inlined url.
                */
            url: string;
            /**
                * Visiiblity of the model group
                */
            visible: boolean;
            /**
                * Opacity of the model group.
                */
            opacity: number;
            /**
                * Change material state by name
                * @example
                * ```ts
                * mapView.Models.add(
                *   { target: new Coordinate(45, -75) },
                *   {
                *     url: 'bed.glb',
                *     materials: {
                *       Default: {
                *         color: MAPPEDIN_COLOR.orange,
                *       },
                *     },
                *   },
                * );
                * ```
                */
            material: {
                    [name: string]: MaterialStyle;
            };
            /**
                * vertical offset of the model in meters off the floor
                */
            verticalOffset: number;
            /**
                * Color property designed for use with @mappedin/3d-assets.
                * Updates the accent color of 3d assets by applying the color to materials named
                * ['Default', 'Fabric', 'Mpdn_Logo', 'Fabric_Logo'].
                * For custom colors on non-Mappedin models, use the {@link ModelStyle.material | material} property.
                * If both the `material` and `color` properties are provided, `material` property updates will take higher precedence than `color` property updates.
                */
            color: string;
            /**
                * The rotation of the model in degrees [x, y, z].
                * - x: Rotation around x-axis (pitch)
                * - y: Rotation around y-axis (yaw)
                * - z: Rotation around z-axis (roll), where z points up
                *
                * Rotations are applied in order: x, then y, then z.
                * 0 degrees means the model faces north (or the parent group's forward direction).
                * Positive rotations follow the right-hand rule.
                */
            rotation: [number, number, number];
            /**
                * The scale of the model in [x, y, z]
                */
            scale: [number, number, number];
    };
    export class ModelStyleComponnet implements Partial<ModelStyle> {
            dirty: boolean;
            visible: boolean;
            opacity: number;
            verticalOffset: number;
            interactive: boolean;
            color?: string;
            material?: ModelStyle['material'];
            rotation?: [number, number, number];
            scale?: [number, number, number];
            constructor(init?: Partial<ModelStyle>);
    }
    export {};
}

declare module '@mappedin/mappedin-js/geojson/src/components/styles/constants' {
    export const DEFAULT_SCALE: number[];
    export const DEFAULT_ROTATION: number[];
}

declare module '@mappedin/mappedin-js/mappedin-js/src/api-geojson/floor-object' {
    import type { Polygon, MultiPolygon, FloorProperties as MVFFloor, ParsedMVF, Feature } from '@mappedin/mvf';
    import type { RendererCore, BBox } from '@mappedin/core-sdk';
    import type { AggregatedStyleMap } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/utils';
    import type { TShow3DMapOptions } from '@mappedin/mappedin-js/mappedin-js/src';
    import type { MapDataInternal } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    class Layer {
        containerId: string;
        labelIds: Set<string>;
        layers: Map<string, string>;
        renderer: RendererCore;
        constructor(renderer: RendererCore, containerId: string, layers?: Map<any, any>);
        show(): void;
        hide(): void;
    }
    export class FloorObject implements MVFFloor {
        #private;
        id: string;
        name?: string;
        elevation: number;
        containerId: string;
        externalId: string;
        metadata?: Partial<Record<string, unknown>> | undefined;
        shortName?: string | undefined;
        subtitle?: string | undefined;
        occluderId?: number;
        layers: Map<string, Layer>;
        footprint?: Feature<Polygon | MultiPolygon | null, MVFFloor>;
        floorStackId: string;
        /** Map of styleId to array of facadeIds for styling */
        facadesByStyleId: Map<string, string[]>;
        get geoJSONBoundingBox(): BBox | undefined;
        constructor(parentId: string, floor: MVFFloor, renderer: RendererCore, multiFloorView: Required<TShow3DMapOptions['multiFloorView']>, options: TShow3DMapOptions, mvf?: ParsedMVF, styleMap?: AggregatedStyleMap, mapDataInternal?: MapDataInternal);
        load: () => this;
        get visible(): boolean;
        setVisible(visible: boolean): void;
    }
    export {};
}

declare module '@mappedin/mappedin-js/mappedin-js/src/api-geojson/utils' {
    import { Coordinate, type Floor, type MapObject, type Space, type Facade } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    import type { EntranceCollection, LineString, Polygon, Point, SpaceProperties, ObstructionProperties, StyleCollection, PolygonStyle, LineStringStyle, Feature, ObstructionCollection, PointStyle } from '@mappedin/mvf';
    import type { PolygonFeatureProperties } from '@packages/internal/mvf-utils';
    import type { BBox, FeatureCollection, MultiLineString } from 'geojson';
    import type { LabelState, MarkerState, GeometryState, CollisionRankingTier, LineStyle, PaintStyle, Position, GroupContainerState } from '@mappedin/core-sdk';
    import { type TGeometryState, type TLabelState, type TDirectionInstructionAction, type TShow3DMapOptions, type Label, type Marker, type Model } from '@mappedin/mappedin-js/mappedin-js/src';
    import type { TDoorsState, TFloorState, TMarkerState, TWallsState } from '@mappedin/mappedin-js/mappedin-js/src/types';
    import type { Image, Path, Shape, Text3D } from '@mappedin/mappedin-js/mappedin-js/src/map-view-objects';
    import type { GeoJsonApi } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/api';
    import type { Tween } from '@tweenjs/tween.js';
    import type { PathSegment } from '@mappedin/mappedin-js/mappedin-js/src/map-view-objects/path';
    import { FloorObject } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/floor-object';
    export function convertCoordinateToPosition(coord: Coordinate): Position;
    export function convertPositionToCoordinate(coord: Position): Coordinate;
    export const cutEntrancesFromLineStrings: (lineStrings: ObstructionCollection["features"], entranceCollection: EntranceCollection["features"]) => {
        entrances: FeatureCollection<LineString, any>;
        walls: Feature<MultiLineString, any>;
    };
    export function translateLabelStateToGeojsonCore(state: Partial<TLabelState>, currentState: Partial<LabelState>): Partial<LabelState>;
    export function translateMarkerStateToGeojsonCore(state: Partial<TMarkerState>, currentState: Partial<MarkerState>): Partial<MarkerState>;
    export function translateDoorsStateToGeojsonCore(state: Partial<TDoorsState>, currentState: Partial<GeometryState>): Partial<GeometryState>;
    export function translateWallsStateToGeojsonCore(state: Partial<TWallsState>, currentState: Partial<GeometryState>): Partial<GeometryState>;
    export function translateSpaceStateToGeojsonCore(state: Partial<TGeometryState>, currentState: Partial<GeometryState>): Partial<GeometryState>;
    export function translateFloorGeometryStateToGeojsonCore(state: TFloorState['geometry']): Partial<GroupContainerState>;
    export function differenceBetweenAngles(a: number, b: number): number;
    export function getRelativeBearing(relativeBearingAngle: number, threshold: number): TDirectionInstructionAction['bearing'];
    export function convertCollisionRankingTeirToNumber(tier: CollisionRankingTier): number;
    export type StyleCollectionWithId = {
        [groupId: string]: WithId<PolygonStyle> | WithId<LineStringStyle> | WithId<PointStyle> | undefined;
    };
    export type AggregatedStyleMap = {
        [id: string]: StyleCollectionWithId[keyof StyleCollectionWithId];
    };
    export function extractStyleMap(styles: StyleCollection): AggregatedStyleMap;
    export type WithId<T> = T & {
        id?: string;
    };
    export function groupGeometryByStyle(features: Feature<LineString | Polygon | Point, PolygonFeatureProperties<SpaceProperties | ObstructionProperties>>[], styleMap: AggregatedStyleMap): Map<WithId<PolygonStyle> | WithId<LineStringStyle> | WithId<PointStyle>, Feature<Polygon | LineString | Point, PolygonFeatureProperties<SpaceProperties | ObstructionProperties>>[]>;
    export function translateToCoreStyle(style: PolygonStyle | LineStringStyle, userOptions?: TShow3DMapOptions): PaintStyle | LineStyle;
    export const getTargetID: <T extends Space | Shape | MapObject | Label | Text3D | Marker | Model | Path | PathSegment | Image | Floor | Facade | string>(target: T, api: GeoJsonApi) => string | undefined;
    export function tweenToPromise(tween: Tween): Promise<void>;
    export function getBoundingBox(geometry: GeoJSON.Feature<GeoJSON.Polygon | GeoJSON.MultiPolygon, any>): BBox;
    export function expandBbox(bbox: BBox, bboxToExpand: BBox): number[];
    export function unique<T>(array: T[]): T[];
    export function getTargetFloorObject(coordinate: Coordinate, floorsById: Map<string, FloorObject>, defaultFloor: FloorObject): FloorObject;
}

declare module '@mappedin/mappedin-js/mappedin-js/src/api-geojson/floor-stack-object' {
    import type { RendererCore } from '@mappedin/core-sdk';
    import type { FloorId, FloorStack as MVFFloorStack, Facade as MVFFacade } from '@mappedin/mvf';
    import type { FloorObject } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/floor-object';
    export class FloorStackObject implements Omit<MVFFloorStack, 'maps' | 'floors' | 'defaultFloor' | 'footprint'> {
        #private;
        id: MVFFloorStack['id'];
        externalId: MVFFloorStack['externalId'];
        name: MVFFloorStack['name'];
        type: MVFFloorStack['type'];
        floorIds: FloorId[];
        defaultFloorId?: MVFFloorStack['defaultFloor'];
        /** Sorted floor objects by elevation */
        floorObjects: FloorObject[];
        floorObjectsByElevation: Map<number, FloorObject>;
        metadata?: MVFFloorStack['metadata'];
        containerId: string;
        facade?: MVFFacade;
        constructor(floorStack: MVFFloorStack, parentId: string, renderer: RendererCore, facade?: MVFFacade);
        get defaultFloor(): FloorObject;
        addFloor(floor: FloorObject): void;
        setFacadeVisible(visible: boolean): void;
    }
}

declare module '@mappedin/mappedin-js/mappedin-js/src/api-geojson/dynamic-focus/dynamic-focus' {
    import { type RendererCore } from '@mappedin/core-sdk';
    import { PubSub } from '@packages/internal/common';
    import type { Floor, FloorStack } from '@mappedin/mappedin-js/mappedin-js/src/map-data-objects';
    import type { GeoJsonApi } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/api';
    import type { GeojsonApiMapObject } from '@mappedin/mappedin-js/mappedin-js/src/api-geojson/map-object';
    /**
        * @experimental
        * @internal
        */
    export type TDynamicFocusEvents = {
            'focus-change': {
                    facades: string[];
                    spaces: string[];
            };
    };
    /**
        * @experimental
        * @internal
        */
    export type TDynamicFocusOptions = {
            /**
                * The minimum zoom level at which Dynamic Focus will detect a Facade and reveal the interior spaces.
                * @default 17
                */
            minZoomLevel?: number;
    };
    /**
        * @experimental
        * @internal
        */
    export class DynamicFocus extends PubSub<TDynamicFocusEvents> {
            #private;
            /** @internal */
            constructor(core: RendererCore, geoJSONApi: GeoJsonApi, { currentMapGetter }: {
                    currentMapGetter: CurrentMapGetter;
            });
            get focusedFacades(): import("../../map-data-objects").Facade[];
            /**
                * @experimental
                * Enables Dynamic Focus and allows the camera to automatically set the floor stack when a facade is hovered.
                */
            enable(options?: TDynamicFocusOptions): void;
            /**
                * @experimental
                * Disables Dynamic Focus and prevents the camera from automatically setting the floor stack when a facade is hovered.
                */
            disable(): void;
            /**
                * @experimental
                * Returns the enabled state of Dynamic Focus.
                */
            get enabled(): boolean;
            /**
                * @experimental
                * Sets the default floor for a floor stack. This is the floor that will be shown when the floor stack is in focus.
                * See {@link resetDefaultFloorForStack} to reset the default floor.
                * @param floorStack - The floor stack to set the default floor for.
                * @param floor - The floor to set as the default floor.
                */
            setDefaultFloorForStack(floorStack: FloorStack, floor: Floor): void;
            /**
                * @experimental
                * Resets the default floor for a floor stack to it's initial value.
                * @param floorStack - The floor stack to reset the default floor for.
                */
            resetDefaultFloorForStack(floorStack: FloorStack): void;
    }
    type CurrentMapGetter = () => GeojsonApiMapObject | undefined;
    export {};
}

declare module '@mappedin/mappedin-js/geojson/src/systems/collisions/collider-processor' {
    import { Rectangle } from '@packages/internal/quad-tree';
    export type TSerializedCollider = {
        rank: number;
        enabledAndVisible: boolean;
        x: number;
        y: number;
        bboxes: {
            index: number;
            boundingBox: [number, number, number, number];
            boundingRect?: Rectangle;
        }[];
        shouldCollideWithScreenEdges?: boolean;
        lockedToStrategyIndex?: number;
        visible?: boolean;
    };
    export type TSerializedColliderResponse = [number, 1 | 0, Rectangle?];
    export function processColliders(colliders: TSerializedCollider[], totalWidth: any, totalHeight: any, watermarkWidth: any, watermarkHeight: any, watermarkPosition: any, msgId?: string): {
        msgId: string;
        colliders: TSerializedColliderResponse[];
        debug: {
            x: number;
            y: number;
            w: number;
            h: number;
        }[];
    };
}

declare module '@mappedin/mappedin-js/geojson/src/systems/interactions/system' {
    import type { PerspectiveCamera, Vector3, Object3D, Intersection, Object3DEventMap } from 'three';
    import { Mesh, Raycaster, Vector2 } from 'three';
    import type { Geometry2D } from '@mappedin/mappedin-js/geojson/src/entities/geometry2d';
    import { QuadTree } from '@packages/internal/quad-tree';
    import type { Geometry3D } from '@mappedin/mappedin-js/geojson/src/entities/geometry3d';
    import { PubSub } from '@mappedin/mappedin-js/packages/common/pubsub';
    import type { EntityMesh } from '@mappedin/mappedin-js/geojson/src/types';
    import { TapsController } from '@mappedin/mappedin-js/geojson/src/systems/interactions/tap-controller';
    import type { RendererState } from '@mappedin/mappedin-js/geojson/src/renderer';
    import '../../styles/interactions.scss';
    import type { EntityBatchedMesh } from '@mappedin/mappedin-js/geojson/src/components/mesh';
    import type { GroupContainerObject3D } from '@mappedin/mappedin-js/geojson/src/entities/group-container';
    type InteractionPayload = {
            entity2D?: Geometry2D;
            entity3D?: Geometry3D;
            position?: Vector3;
            groupContainers?: GroupContainerObject3D[];
            pointerEvent: Pick<PointerEvent, 'button'>;
    };
    type InteractionEvents = {
            click: InteractionPayload;
            hover: Omit<InteractionPayload, 'pointerEvent'>;
            'singletap-with-twofinger': PointerEvent;
            'doubletap-with-onefinger': PointerEvent;
    };
    type CursorTypes = 'grabbing' | 'grab' | 'pointer';
    type InteractionState = {
            distanceFromMouseDown: number | undefined;
            isPanning: boolean;
            mouseDownStart: {
                    time: number;
                    timestamp: number;
                    clientX: number;
                    clientY: number;
            } | undefined;
    };
    export type InteractionRequiredCoreStateProps = {
            geometry2DIdsInScene: Set<Geometry2D['id']>;
            geometry3DIdsInScene: Set<Geometry3D['id']>;
    };
    /**
        * TODO: touch support
        */
    export class InteractionSystem extends PubSub<InteractionEvents> {
            #private;
            raycaster: Raycaster;
            _quadtree: QuadTree<{
                    entityId: Geometry2D['id'];
            }>;
            _container: HTMLCanvasElement;
            constructor(container: HTMLCanvasElement, coreState: RendererState, camera: PerspectiveCamera, worldPlane: Mesh, isUserInteracting: () => boolean);
            updateQuadtree(takeIT: QuadTree<{
                    entityId: Geometry2D['id'];
            }>): void;
            setHovered3DEntityInteractionComponentDirty(): void;
            hasTouched: boolean;
            onPointerMoveRaf: (event: PointerEvent) => void;
            tapsControl: TapsController;
            getThreeDIntersectsFromXY(point: Vector2): Intersection<Object3D<Object3DEventMap>>[];
            getGroupContainerIntersectsFromXY(point: Vector2): any;
            handleHover(e?: PointerEvent): void;
            dirty3D: boolean;
            get _hitBoxes(): {
                    entities: (Object3D | EntityMesh<Geometry3D> | EntityBatchedMesh)[];
                    groups: GroupContainerObject3D[];
            };
            getMouseRayIntersects(): Intersection<Object3D<Object3DEventMap>>[];
            destroy(): void;
            debugPanel: HTMLDivElement | undefined;
            enableDebug(): void;
            get _state(): {
                    hovered3DEntity: Geometry3D | undefined;
                    hovered2DEntity: Geometry2D | undefined;
                    hovered3DContainers: GroupContainerObject3D[] | undefined;
                    lastHover: Geometry3D | undefined;
                    interaction: InteractionState;
            };
            /**
                * Get the current cursor type determined by the interaction.
                */
            getCursor(): CursorTypes;
    }
    export function findModelParent(object: Object3D): Object3D<Object3DEventMap> | undefined;
    export {};
}

declare module '@mappedin/mappedin-js/geojson/src/systems/camera/system' {
    import type { PerspectiveCamera, Scene, WebGLRenderer } from 'three';
    import { Object3D, Vector2, Vector3 } from 'three';
    import { PubSub } from '@mappedin/mappedin-js/packages/common/pubsub';
    import * as CAMERA_CONSTANTS from '@mappedin/mappedin-js/geojson/src/systems/camera/constants';
    import type { AnimateCameraTarget, CameraControlsOptions, CameraFocusOnOptions } from '@mappedin/mappedin-js/geojson/src/systems/camera/types';
    import type { InsetPadding, RendererState } from '@mappedin/mappedin-js/geojson/src/renderer';
    export enum CameraControlsState {
            NONE = -1,
            ROTATE = 0,
            DOLLY = 1,
            PAN = 2,
            WHEEL_ZOOM = 3,
            TOUCH_TILT = 4,
            TOUCH_DOLLY = 5,
            TOUCH_PAN = 6,
            MULTI = 7,
            PEDESTAL = 8,
            TOUCH_PEDESTAL = 9
    }
    type CameraEventName = (typeof CAMERA_CONSTANTS.EVENTS)[number];
    type SpecificCameraEvents = {
            'multi-start': {
                    zooming: boolean;
                    rotating: boolean;
                    tilting: boolean;
            };
            'multi-end': {
                    zooming: boolean;
                    rotating: boolean;
                    tilting: boolean;
            };
            'multi-cancel': {
                    zooming: boolean;
                    rotating: boolean;
                    tilting: boolean;
            };
            'pedestal-change': {
                    pedestal: number;
                    scrolledToTop?: boolean;
                    scrolledToBottom?: boolean;
                    scrollPercent?: number;
            };
    };
    type CameraEvents = {
            [Event in CameraEventName]: Event extends keyof SpecificCameraEvents ? SpecificCameraEvents[Event] : undefined;
    };
    /**
        * The advanced, manual camera controls.
        * This class will let you do things like change the min/max zoom, tilt, and pan, attach to camera events, and move/animate the camera to specifc points.
        *
        * The camera works by setting an anchor point on the scene at ground level and pointing the camera at it.
        * The camera will always be pointed directly at the anchor point.
        */
    class CameraSystem extends PubSub<CameraEvents> {
            #private;
            dirty: boolean;
            zoomDirty: boolean;
            rotationDirty: boolean;
            panDirty: boolean;
            /**
                * Factor that controls how fast zooming in and out happens in response to mouse wheel events
                *
                * @property zoomSpeed {Float}
                * @default 5.0
                */
            zoomSpeed: number;
            /**
                * Factor to multiple mouse movement by to get tilt/rotation.
                *
                * @property rotateSpeed {Float}
                * @default 100
                */
            rotateSpeed: number;
            /**
                * Disable or re-enable user input.
                *
                * @property enabled {Boolean}
                * @default true
                */
            enabled: boolean;
            /**
                * Disable or re-enable user zoom.
                *
                * @property enableZoom {Boolean}
                * @default true
                */
            enableZoom: boolean;
            /**
                * Disable or re-enable user pan.
                *
                * @property enablePan {Boolean}
                * @default true
                */
            enablePan: boolean;
            /**
                * Disable or re-enable user pedestal.
                *
                * @property enablePedestal {Boolean}
                * @default false
                */
            enablePedestal: boolean;
            /**
                * Max amount to allow scrolling maps down
                * (In Z-axis units, at the origin, down is positive)
                *
                * @property maxPedestal {Number}
                * @default Infinity
                */
            maxPedestal: number;
            /**
                * Max amount to allow scrolling maps up
                * (In Z-axis units, at the origin, up is negative)
                *
                * @property minPedestal {Number}
                * @default 0
                */
            minPedestal: number;
            /**
                * Disable or re-enable user tilt/rotation.
                *
                * @property enableRotate {Boolean}
                * @default true
                */
            enableRotate: boolean;
            /**
                * This is actually the minium distance the camera can get from it's anchor on the ground. May be worth changing if your map has very tall buildings to avoid the camera clipping through them.
                *
                * @property minZoomAltitude {Number}
                * @default 0
                */
            minZoomAltitude: number;
            /**
                * Maximum distance the camera can get from it's anchor on the ground. Setting this too high will result in parts of the map falling out of the camera's clipping plane and disappearing.
                *
                * @property maxZoomAltitude {Number}
                * @default Infinity
                */
            maxZoomAltitude: number;
            /**
                * How far the camera can zoom in towards the ground.
                *
                * This is equivalent to the minZoomAltitude property in mercator zoom level units.
                * @default 0
                */
            get maxZoomLevel(): number;
            /**
                * Sets distance the camera can zoom in towards the ground.
                * @default Infinity
                */
            setMaxZoomLevel(zoomLevel: number): void;
            /**
                * The default minimum zoom level of the camera in mercator zoom levels.
                */
            get defaultMinZoomLevel(): number;
            /**
                * How far the camera can zoom out away from the ground.
                *
                * This is equivalent to the maxZoomAltitude property in mercator zoom level units.
                */
            get minZoomLevel(): number;
            /**
                * Sets distance the camera can zoom away from the ground.
                */
            setMinZoomLevel(zoomLevel: number): void;
            /**
                * ignoreZoomLimits; use with caution for special effects
                * @default false
                */
            ignoreZoomLimits: boolean;
            /**
                * Multiplier for min and max zoom, for convenience.
                *
                * @hidden
                * @property zoomFactor {Number}
                * @default 1
                */
            zoomFactor: number;
            /**
                * Constrains the camera from panning to far away from the scene. It's set automatically based on the size of the map.
                * If you want to change anything, you probably want to change the margin property, which is the factor the min and max in
                * each dimension are multiplied by to give the true bounds. For example, on a truely huge venue a 1.25 margin could get you
                * way out into space when zoomed in.
                *
                * @property panBounds {Object}
             @property panBounds.min {Object} An x, y pair representing the bounds of one corner of the map.
             @property panBounds.max {Object} An x, y pair representing the bounds of the other corner of the map.
                */
            panBounds: {
                    min: Vector3;
                    max: Vector3;
                    center: Vector3;
                    radius: number;
            };
            /**
                * Minium camera tilt, in radians. If it's anything other than 0, you won't be able to look at the venue from the top down perspective.
                *
                * @property minTilt {Number}
                * @default 0.0
                */
            minTilt: number;
            /**
                * Minium camera tilt, in radians. If you set it too high, the camera will be able to tilt down through the geometery of the scene, which will produce clipping issues.
                *
                * @property maxTilt {Number}
                * @default 1.2
                */
            maxTilt: number;
            state: CameraControlsState;
            constructor(camera: PerspectiveCamera, scene: Scene, renderer: WebGLRenderer, rendererState: RendererState, options: CameraControlsOptions);
            /**
                * The amount the camera is shifted up/down
                * (corresponds to scroll amount in multifloor mode)
                * 100% == camera is as far up as it will go
                * 0% == camera is as far down as it will go
                */
            get scrollPercent(): number;
            /**
                * Returns current field of view(FOV) in degrees
                */
            get fov(): number;
            /**
                * Returns whether the maps are scrolled to bottom
                */
            get scrolledToBottom(): boolean;
            /**
                * Returns whether the maps are scrolled to top
                */
            get scrolledToTop(): boolean;
            /**
                * The camera's current center in [longitude, latitude] degrees.
                */
            get center(): [number, number];
            /**
                * @param center The center in [longitude, latitude] degrees.
                */
            setCenter(longitude: number, latitude: number): void;
            /**
                * @hidden
                */
            raycastToFloor: (pos: Vector2) => Vector3;
            /**
                * Returns true if the the user is currently manipulating the camera.
                *
                * @return {Boolean} True if the user is currently manipulating the camera, false otherwise.
                */
            isUserInteracting: () => boolean;
            /**
                * Returns the current camera position.
                *
                * @return {Object} An {x, y} object of the current camera postion.
                */
            getPosition: () => Vector3;
            /**
                * Returns the current camera pedestal zoom level.
                */
            getPedestal: () => number;
            /**
                * Pans the camera right and down from the current position
                *
                * @param right {Number} The units to move right. Negative will pan left. This is in relation to the global coordinate system, not the current camera rotation.
                * @param down {Number} The units to move down. Negative will pan up. This is in relation to the global coordinate system, not the current camera rotation.
                */
            pan: (right: number, down: number) => void;
            /**
                * Anything we need to do after we render the camera, like update anchors for the mouse/touch controls.
                *
                * @hidden
                */
            postRender: () => void;
            /**
                * Returns true if the camera is currently animating.
                * @return {Boolean} True if the camera is animating, false otherwise.
                */
            get isAnimating(): boolean;
            /**
                * Returns true if the camera is currently moving (it's animating, the user is manipulating it).
                *
                * @return {Boolean} True if the camera is moving, false otherwise.
                */
            isCameraMoving: () => boolean;
            /**
                * Returns the most recent time the camera stopped moving.
                *
                * @returns {Number} The time in ms the camera stopped moving.
                */
            lastCameraStoppedMovingTime: () => number;
            /**
                * Sets the camera anchor to a specifc x/y positon, in the global reference frame. 0,0 will be roughly the middle of the map, and panBounds holds the min/max points.
                *
                * @param x {Number} The x position to move the camera to. +x will take you right, from the default camera rotation of 0.
                * @param y {Number} The y position to move the camera to. +y will take you down (towards the viewer) in the default camera rotation of 0.
                */
            setPosition: (x: number, y: number) => void;
            /**
                * Tilts the camera up or down by some number of radians. Bounded by minTilt and maxTilt.
                *
                * @param radians {Number} Number of radians to increase or decrease the current tilt by.
                */
            tilt: (radians: number) => void;
            /**
                * Zooms the camera in on the center of the current view.
                *
                * @param duration {Number} The duration of the zoom animation, in ms.
                * @param curve {Function} The easing function to use for the zoom animation.
                * @param callback {Function} A callback that will be executed when the zoom animation is done.
                */
            zoomIn: (duration: number, curve: (n: number) => number, callback: (...args: any) => void) => void;
            /**
                * Zooms the camera out from the center of the current view.
                *
                * @param duration
                * @param curve
                * @param callback
                */
            zoomOut: (duration: number, curve: (n: number) => number, callback: (...args: any) => void) => void;
            /**
                * Returns the current camera rotation.
                *
                * @return {Number} The current rotation of the camera, in radians.
                */
            getRotation: () => number;
            /**
                * Cancel animation- for the new API
                */
            cancelAnimation: () => void;
            /**
                * Animates the camera from it's current position to the state specified in target. You only
                * need to specify the properties you actually want to change.
                *
                * You can also specify a duration, animation curve, and a callback for when it's done.
                *
                * @param target {Object} A list of optional parameters you can set that represent the camera state.
             @param [target.position] {Object} An {x, y, z} object representing the position to move to.
             @param [target.zoom] {Number} The zoom level to end at.
             @param [target.tilt] {Number} The tilt to end at, in radians.
             @param [target.rotation] {Number} The rotation to end at, in radians.
             @param [target.doNotAutoStart=false] {Boolean} Set this to true if you want to start the tween yourself.
                * @param [duration] {Number} The duration to animate the camera for, in ms.
                * @param [curve] {Mappedin.Easing} The animation curve to use for the animation.
                * @param [callback] {Function} A callback that will be executed when the animation is done.
                * @param [options] {Object} An Options object
                * @param [options.interruptible=true] {Boolean} Determines if this animation must complete before any new animations start
             it will cancel and omit any previous animations. Set to "chain" to chain instead
                *
                * @return {Mappedin.Tween} The tween being used, if you want to do anything to control it manually. Do not overide it's events.
                */
            animateCamera: (target: AnimateCameraTarget, duration: number, curve?: (n: number) => number, callback?: (...args: any) => void, cancelledCallback?: (...args: any) => void, options?: {
                    interruptible?: boolean;
            }) => Promise<void>;
            /**
                * Allows you to set any of the Camera's position, zoom, rotation and tilt at once, with one function.
                *
                * @param [position] {Object} an {x, y, z} object representing the new position.
                * @param [zoom] {Number} The new zoom distance.
                * @param [rotation] {Number} The new rotation, in radians.
                * @param [tilt] {Number} The new tilt, in radians.
                */
            setMulti: (position?: {
                    x?: number;
                    y?: number;
                    z?: number;
            }, zoom?: number, rotation?: number, tilt?: number, publishChangeEvent?: boolean) => void;
            /**
                * Returns the actual zoom minimum based on real-world distance.
                *
                * @return {Number} The actual zoom minimum in map units.
                */
            getZoomScaledMin: () => number;
            /**
                * Returns the actual zoom maximum based on visible map size.
                *
                * @return {Number} The actual zoom maximum in map units.
                */
            getZoomScaledMax: () => number;
            /**
                * Sets the rotation to a specific orientation, clockwise in radians. Mostly useful to orient the map a certain way for a physical directory.
                *
                * @param radians {Number} Absolute rotation to set the camera to, in radians. 0 in the starting point.
                * @param silent {Boolean} Whether to avoid emitting events
                */
            setRotation: (radians: number, silent?: boolean) => void;
            /**
                * Sets the camera to be a certain distance from the anchor point, along it's tilt and rotation.
                * Keeps it inside minZoom and maxZoom.
                *
                * @param zoom {Number} The distance to set the camera to.
                */
            setZoomAltitude: (zoom: number) => void;
            /**
                * Set the camera's zoom level in mercator zoom level units.
                */
            setZoomLevel: (zoomLevel: number) => void;
            /**
                * Returns the current camera zoom
                *
                * @return {Number} The distance of the camera from the anchor.
                */
            getZoomAltitude: () => number;
            /**
                * Current camera zoom in mercator zoom level units.
                */
            getZoomLevel: () => number;
            /**
                * Sets the tilt to a specific level, in radians. 0 is top down. Bounded by minTilt and maxTilt.
                *
                * @param radians {Number} Tilt to set the camera to, in radians.
                * @param silent {Boolean} Whether to avoid emitting events.
                */
            setTilt: (radians: number, silent?: boolean) => void;
            /**
                * Returns the current camera tilt
                *
                * @return {Number} The current tilt of the camera, in radians.
                */
            getTilt: () => number;
            /**
                * @param elevation {number}
                * @hidden
                */
            setCameraPlaneElevation: (elevation: number) => void;
            /**
                * Moves the camera towards or away from the camera by a set amount. Positive will zoom in (bringing the distance closer to 0).
                *
                * @param zoom {Number} The distance to increase or decrease the zoom.
                */
            zoom: (zoomDelta: number) => void;
            /**
                * Returns the current projection scale factor.
                * @param FOV {number} Field of view
                * @param canvasHeight {number} Height of the canvas
                * @param zoom{number} Zoom level
                */
            getProjectionScaleFactor: (FOV: number, canvasHeight: number, zoom: number) => number;
            /**
                * Should probably be "pre-render". Anything we need to do before rendering the scene.
                *
                * @hidden
                */
            update: () => void;
            setPedestal: (z: number, emitEvent?: boolean) => void;
            /**
                * Disposes of the camera and all of it's events.
                *
                * @hidden
                */
            dispose: () => void;
            /**
                * Converts the altitude to the mercator zoom level.
                * @param altitude {number} The altitude in meters.
                */
            convertAltitudeToZoomLevel: (altitude: number) => number;
            /**
                * Converts a mercator zoom level to an altitude in meters.
                * @param zoomLevel{number} The mercator zoom level
                */
            convertZoomLevelToAltitude: (zoomLevel: number) => number;
            static CAMERA_FRAME_PADDING_SIDES: readonly ["top", "bottom", "left", "right"];
            debugContainer: Object3D<import("three").Object3DEventMap>;
            getCameraFrameForCoordinates(pointCloud: Vector3[], options: CameraFocusOnOptions & {
                    padding: InsetPadding;
            }): {
                    center: Vector3;
                    zoomLevel: number;
            };
            focusOn(pointCloud: Vector3[], options: CameraFocusOnOptions & {
                    padding: InsetPadding;
            }): void;
            resize(canvasWidth: number, canvasHeight: number): void;
    }
    export { CameraSystem };
    export function getCameraFrameForPoints(pointCloud: Vector3[], { canvasWidth, orbit, paddingOption, verticalPadding, canvasHeight, minZoom, maxZoom, camera, position, }: {
            paddingOption: InsetPadding;
            canvasWidth: number;
            canvasHeight: number;
            minZoom: number;
            maxZoom: number;
            orbit: Object3D;
            camera: PerspectiveCamera;
            position: Vector3;
            verticalPadding?: number;
    }): {
            position: Vector3;
            zoom: number;
    };
}

declare module '@mappedin/mappedin-js/geojson/src/systems/camera/types' {
    import type { Vector2, Vector3 } from 'three';
    import type { TouchAnchor, InputSet } from '@mappedin/mappedin-js/geojson/src/systems/camera/helpers';
    import type { InsetPadding, RendererCore } from '@mappedin/mappedin-js/geojson/src';
    type AnimateCameraTarget = {
            position?: {
                    x?: number;
                    y?: number;
                    z?: number;
            };
            zoom?: number;
            tilt?: number;
            rotation?: number;
            doNotAutoStart?: boolean;
    };
    type CameraControlsTweenPoint = {
            x?: number;
            y?: number;
            z?: number;
            zoom?: number;
            rotation?: number;
            tilt?: number;
    };
    type CameraControlsCoords = {
            mouse: Vector2;
            rotateStart: Vector2;
            rotateEnd: Vector2;
            rotateDelta: Vector2;
            panStart: Vector3;
            panCameraStart: Vector3;
            panEnd: Vector3;
            panDelta: Vector3;
            initialShiftPos: Vector2;
            initialPedestal: number;
            floorAnchor: Vector3;
    };
    type CameraControlsTouch = {
            origin: CameraControlsTouchOrigin;
            touches: Vector2[];
            anchor1: TouchAnchor | null;
            anchor2: TouchAnchor | null;
            inputs: InputSet | null;
    };
    type CameraEvents = {
            change: undefined;
            'pan-start': undefined;
            'pan-end': undefined;
            'rotate-start': undefined;
            'rotate-end': undefined;
            'zoom-start': undefined;
            'zoom-end': undefined;
            'multi-start': {
                    zooming: boolean;
                    rotating: boolean;
                    tilting: boolean;
            };
            'multi-end': {
                    zooming: boolean;
                    rotating: boolean;
                    tilting: boolean;
            };
            'multi-cancel': {
                    zooming: boolean;
                    rotating: boolean;
                    tilting: boolean;
            };
            'pedestal-start': undefined;
            'pedestal-change': {
                    pedestal: number;
                    scrolledToTop: boolean;
                    scrolledToBottom: boolean;
                    scrollPercent: number;
            };
            'pedestal-end': undefined;
            'user-pan-start': undefined;
            'user-pedestal-start': undefined;
            'user-rotate-start': undefined;
            'user-dolly-start': undefined;
            'user-zoom-start': undefined;
            'user-tilt-start': undefined;
            'user-pan-end': undefined;
            'user-pedestal-end': undefined;
            'user-rotate-end': undefined;
            'user-dolly-end': undefined;
            'user-zoom-end': undefined;
            'user-tilt-end': undefined;
            'position-updated': undefined;
            'zoom-updated': undefined;
            'tilt-updated': undefined;
            'rotation-updated': undefined;
    };
    type CameraControlsTouchOrigin = {
            offsetLeft: number;
            offsetTop: number;
    };
    type CameraControlsOptions = {
            mode: RendererCore['mode'];
            canvasHeight: number;
            canvasWidth: number;
    };
    export type { AnimateCameraTarget, CameraControlsOptions, CameraControlsTouchOrigin, CameraControlsCoords, CameraControlsTouch, CameraControlsTweenPoint, CameraEvents, };
    export type CameraFocusOnOptions = {
            /**
                * The duration (in ms) the focus animation should last for.
                * @defaultValue `100`
                */
            duration?: number;
            /**
                * The animation curve to use for zooming in. Uses the animateCamera one by default.
                */
            curve?: (n: number) => number;
            /**
                * Camera tilt between 0 (top-down) to 1 (from the side)
                */
            tilt?: number;
            /**
                * Rotation in degrees
                */
            rotation?: number;
            /**
                * You can overide the {{#crossLink "MapView/focusZoomFactor:property"}}{{/crossLink}} for a specific {{#crossLink "MapView/focusOn:method"}}{{/crossLink}} call, rather than globally, if you like.
                */
            focusZoomFactor?: number;
            /**
                * Sets a floor for how close you can zoom in on the scene. If it's lower than mapView.controls.minZoom, it's ignored.
                * @defaultValue: 0
                */
            minZoom?: number;
            maxZoom?: number;
            padding?: InsetPadding;
            points?: any[];
            boundingBox?: any;
            callback?: () => void;
            cancelledCallback?: () => void;
            interruptible?: boolean;
            verticalPadding?: number;
    };
}

declare module '@mappedin/mappedin-js/geojson/src/systems/camera/constants' {
    export const MAPLIBRE_TILE_SIZE = 512;
    export const MIN_LAT = -85.051129;
    export const MAX_LAT = 85.051129;
    export const CLIPPING_RADIUS = 10000;
    export const CONTROL_OPTIONS: {
        chain: string;
        cancel: string;
    };
    export const TWO_PI: number;
    export const ZRANGE = 100;
    export const WHEEL_ZOOM_MULTIPLIER = 10000;
    export const MIN_MERCATOR_ZOOM_LEVEL = 0;
    export const MAX_MERCATOR_ZOOM_LEVEL = 24;
    export const BLOCK_MERCATOR_ZOOM_LEVEL = 17;
    export const ROOM_MERCATOR_ZOOM_LEVEL = 20;
    export const DEFAULT_ANIMATION_DURATION = 200;
    export const EVENTS: readonly ["change", "pan-start", "pan-end", "rotate-start", "rotate-end", "zoom-start", "zoom-end", "multi-start", "multi-end", "multi-cancel", "pedestal-start", "pedestal-change", "pedestal-end", "user-pan-start", "user-pedestal-start", "user-rotate-start", "user-dolly-start", "user-zoom-start", "user-tilt-start", "user-pan-end", "user-pedestal-end", "user-rotate-end", "user-dolly-end", "user-zoom-end", "user-tilt-end", "position-updated", "zoom-updated", "tilt-updated", "rotation-updated"];
    export const DEFAULT_ZOOM_LEVEL = 18;
    export const DEFAULT_MIN_ZOOM_LEVEL = 12;
    export const DEFAULT_MAX_ZOOM_LEVEL = 22;
    export const DEFAULT_PITCH = 0;
    export const DEFAULT_BEARING = 0;
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/map' {
    import { GetResourceResponse } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/ajax';
    import { RequestManager } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/request_manager';
    import { Style, StyleSwapOptions } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style';
    import { Painter } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/painter';
    import { Hash } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/hash';
    import { HandlerManager } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler_manager';
    import { Camera, CameraOptions, CameraUpdateTransformFunction, FitBoundsOptions } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/camera';
    import { LngLat } from '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/lng_lat';
    import { LngLatBounds } from '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/lng_lat_bounds';
    import Point from '@mapbox/point-geometry';
    import { AttributionControlOptions } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/control/attribution_control';
    import { Listener } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/evented';
    import { MapEventType, MapLayerEventType, MapSourceDataEvent, MapStyleDataEvent } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/events';
    import { TaskQueue } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/task_queue';
    import { Source } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/source';
    import { StyleLayer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer';
    import { defaultLocale } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/default_locale';
    import type { RequestTransformFunction } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/request_manager';
    import type { LngLatLike } from '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/lng_lat';
    import type { LngLatBoundsLike } from '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/lng_lat_bounds';
    import type { AddLayerObject, FeatureIdentifier, StyleOptions, StyleSetterOptions } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style';
    import type { StyleImage, StyleImageInterface, StyleImageMetadata } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_image';
    import type { PointLike } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/camera';
    import type { ScrollZoomHandler } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/scroll_zoom';
    import type { BoxZoomHandler } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/box_zoom';
    import type { AroundCenterOptions, TwoFingersTouchPitchHandler } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/two_fingers_touch';
    import type { DragRotateHandler } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/shim/drag_rotate';
    import type { DragPanHandler, DragPanOptions } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/shim/drag_pan';
    import type { CooperativeGesturesHandler, GestureOptions } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/cooperative_gestures';
    import type { KeyboardHandler } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/keyboard';
    import type { DoubleClickZoomHandler } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/shim/dblclick_zoom';
    import type { TwoFingersTouchZoomRotateHandler } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/shim/two_fingers_touch';
    import type { TaskID } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/task_queue';
    import type { FilterSpecification, StyleSpecification, LightSpecification, SourceSpecification, TerrainSpecification } from '@maplibre/maplibre-gl-style-spec';
    import type { MapGeoJSONFeature } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/vectortile_to_geojson';
    import type { ControlPosition, IControl } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/control/control';
    import type { QueryRenderedFeaturesOptions, QuerySourceFeatureOptions } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/query_features';
    /**
        * The {@link Map} options object.
        */
    export type MapOptions = {
            /**
                * If `true`, the map's position (zoom, center latitude, center longitude, bearing, and pitch) will be synced with the hash fragment of the page's URL.
                * For example, `http://path/to/my/page.html#2.59/39.26/53.07/-24.1/60`.
                * An additional string may optionally be provided to indicate a parameter-styled hash,
                * e.g. http://path/to/my/page.html#map=2.59/39.26/53.07/-24.1/60&foo=bar, where foo
                * is a custom parameter and bar is an arbitrary hash distinct from the map hash.
                * @defaultValue false
                */
            hash?: boolean | string;
            /**
                * If `false`, no mouse, touch, or keyboard listeners will be attached to the map, so it will not respond to interaction.
                * @defaultValue true
                */
            interactive?: boolean;
            /**
                * The HTML element in which MapLibre GL JS will render the map, or the element's string `id`. The specified element must have no children.
                */
            container: HTMLElement | string;
            /**
                * The threshold, measured in degrees, that determines when the map's
                * bearing will snap to north. For example, with a `bearingSnap` of 7, if the user rotates
                * the map within 7 degrees of north, the map will automatically snap to exact north.
                * @defaultValue 7
                */
            bearingSnap?: number;
            /**
                * If set, an {@link AttributionControl} will be added to the map with the provided options.
                * To disable the attribution control, pass `false`.
                * Note: showing the logo of MapLibre is not required for using MapLibre.
                * @defaultValue compact: true, customAttribution: "MapLibre ...".
                */
            attributionControl?: false | AttributionControlOptions;
            /**
                * If `true`, the MapLibre logo will be shown.
                * @defaultValue false
                */
            maplibreLogo?: boolean;
            /**
                * A string representing the position of the MapLibre wordmark on the map. Valid options are `top-left`,`top-right`, `bottom-left`, or `bottom-right`.
                * @defaultValue 'bottom-left'
                */
            logoPosition?: ControlPosition;
            /**
                * If `true`, map creation will fail if the performance of MapLibre GL JS would be dramatically worse than expected
                * (i.e. a software renderer would be used).
                * @defaultValue false
                */
            failIfMajorPerformanceCaveat?: boolean;
            /**
                * If `true`, the map's canvas can be exported to a PNG using `map.getCanvas().toDataURL()`. This is `false` by default as a performance optimization.
                * @defaultValue false
                */
            preserveDrawingBuffer?: boolean;
            /**
                * If `true`, the gl context will be created with MSAA antialiasing, which can be useful for antialiasing custom layers. This is `false` by default as a performance optimization.
                */
            antialias?: boolean;
            /**
                * If `false`, the map won't attempt to re-request tiles once they expire per their HTTP `cacheControl`/`expires` headers.
                * @defaultValue true
                */
            refreshExpiredTiles?: boolean;
            /**
                * If set, the map will be constrained to the given bounds.
                */
            maxBounds?: LngLatBoundsLike;
            /**
                * If `true`, the "scroll to zoom" interaction is enabled. {@link AroundCenterOptions} are passed as options to {@link ScrollZoomHandler#enable}.
                * @defaultValue true
                */
            scrollZoom?: boolean | AroundCenterOptions;
            /**
                * The minimum zoom level of the map (0-24).
                * @defaultValue 0
                */
            minZoom?: number | null;
            /**
                * The maximum zoom level of the map (0-24).
                * @defaultValue 22
                */
            maxZoom?: number | null;
            /**
                * The minimum pitch of the map (0-85). Values greater than 60 degrees are experimental and may result in rendering issues. If you encounter any, please raise an issue with details in the MapLibre project.
                * @defaultValue 0
                */
            minPitch?: number | null;
            /**
                * The maximum pitch of the map (0-85). Values greater than 60 degrees are experimental and may result in rendering issues. If you encounter any, please raise an issue with details in the MapLibre project.
                * @defaultValue 60
                */
            maxPitch?: number | null;
            /**
                * If `true`, the "box zoom" interaction is enabled (see {@link BoxZoomHandler}).
                * @defaultValue true
                */
            boxZoom?: boolean;
            /**
                * If `true`, the "drag to rotate" interaction is enabled (see {@link DragRotateHandler}).
                * @defaultValue true
                */
            dragRotate?: boolean;
            /**
                * If `true`, the "drag to pan" interaction is enabled. An `Object` value is passed as options to {@link DragPanHandler#enable}.
                * @defaultValue true
                */
            dragPan?: boolean | DragPanOptions;
            /**
                * If `true`, keyboard shortcuts are enabled (see {@link KeyboardHandler}).
                * @defaultValue true
                */
            keyboard?: boolean;
            /**
                * If `true`, the "double click to zoom" interaction is enabled (see {@link DoubleClickZoomHandler}).
                * @defaultValue true
                */
            doubleClickZoom?: boolean;
            /**
                * If `true`, the "pinch to rotate and zoom" interaction is enabled. An `Object` value is passed as options to {@link TwoFingersTouchZoomRotateHandler#enable}.
                * @defaultValue true
                */
            touchZoomRotate?: boolean | AroundCenterOptions;
            /**
                * If `true`, the "drag to pitch" interaction is enabled. An `Object` value is passed as options to {@link TwoFingersTouchPitchHandler#enable}.
                * @defaultValue true
                */
            touchPitch?: boolean | AroundCenterOptions;
            /**
                * If `true` or set to an options object, the map is only accessible on desktop while holding Command/Ctrl and only accessible on mobile with two fingers. Interacting with the map using normal gestures will trigger an informational screen. With this option enabled, "drag to pitch" requires a three-finger gesture. Cooperative gestures are disabled when a map enters fullscreen using {@link FullscreenControl}.
                * @defaultValue undefined
                */
            cooperativeGestures?: GestureOptions;
            /**
                * If `true`, the map will automatically resize when the browser window resizes.
                * @defaultValue true
                */
            trackResize?: boolean;
            /**
                * The initial geographical centerpoint of the map. If `center` is not specified in the constructor options, MapLibre GL JS will look for it in the map's style object. If it is not specified in the style, either, it will default to `[0, 0]` Note: MapLibre GL JS uses longitude, latitude coordinate order (as opposed to latitude, longitude) to match GeoJSON.
                * @defaultValue [0, 0]
                */
            center?: LngLatLike;
            /**
                * The initial zoom level of the map. If `zoom` is not specified in the constructor options, MapLibre GL JS will look for it in the map's style object. If it is not specified in the style, either, it will default to `0`.
                * @defaultValue 0
                */
            zoom?: number;
            /**
                * The initial bearing (rotation) of the map, measured in degrees counter-clockwise from north. If `bearing` is not specified in the constructor options, MapLibre GL JS will look for it in the map's style object. If it is not specified in the style, either, it will default to `0`.
                * @defaultValue 0
                */
            bearing?: number;
            /**
                * The initial pitch (tilt) of the map, measured in degrees away from the plane of the screen (0-85). If `pitch` is not specified in the constructor options, MapLibre GL JS will look for it in the map's style object. If it is not specified in the style, either, it will default to `0`. Values greater than 60 degrees are experimental and may result in rendering issues. If you encounter any, please raise an issue with details in the MapLibre project.
                * @defaultValue 0
                */
            pitch?: number;
            /**
                * If `true`, multiple copies of the world will be rendered side by side beyond -180 and 180 degrees longitude. If set to `false`:
                *
                * - When the map is zoomed out far enough that a single representation of the world does not fill the map's entire
                * container, there will be blank space beyond 180 and -180 degrees longitude.
                * - Features that cross 180 and -180 degrees longitude will be cut in two (with one portion on the right edge of the
                * map and the other on the left edge of the map) at every zoom level.
                * @defaultValue true
                */
            renderWorldCopies?: boolean;
            /**
                * The maximum number of tiles stored in the tile cache for a given source. If omitted, the cache will be dynamically sized based on the current viewport which can be set using `maxTileCacheZoomLevels` constructor options.
                * @defaultValue null
                */
            maxTileCacheSize?: number;
            /**
                * The maximum number of zoom levels for which to store tiles for a given source. Tile cache dynamic size is calculated by multiplying `maxTileCacheZoomLevels` with the approximate number of tiles in the viewport for a given source.
                * @defaultValue 5
                */
            maxTileCacheZoomLevels?: number;
            /**
                * A callback run before the Map makes a request for an external URL. The callback can be used to modify the url, set headers, or set the credentials property for cross-origin requests.
                * Expected to return an object with a `url` property and optionally `headers` and `credentials` properties.
                */
            transformRequest?: RequestTransformFunction;
            /**
                * A callback run before the map's camera is moved due to user input or animation. The callback can be used to modify the new center, zoom, pitch and bearing.
                * Expected to return an object containing center, zoom, pitch or bearing values to overwrite.
                */
            transformCameraUpdate?: CameraUpdateTransformFunction;
            /**
                * A patch to apply to the default localization table for UI strings, e.g. control tooltips. The `locale` object maps namespaced UI string IDs to translated strings in the target language; see `src/ui/default_locale.js` for an example with all supported string IDs. The object may specify all UI strings (thereby adding support for a new translation) or only a subset of strings (thereby patching the default translation table).
                * @defaultValue null
                */
            locale?: any;
            /**
                * Controls the duration of the fade-in/fade-out animation for label collisions after initial map load, in milliseconds. This setting affects all symbol layers. This setting does not affect the duration of runtime styling transitions or raster tile cross-fading.
                * @defaultValue 300
                */
            fadeDuration?: number;
            /**
                * If `true`, symbols from multiple sources can collide with each other during collision detection. If `false`, collision detection is run separately for the symbols in each source.
                * @defaultValue true
                */
            crossSourceCollisions?: boolean;
            /**
                * If `true`, Resource Timing API information will be collected for requests made by GeoJSON and Vector Tile web workers (this information is normally inaccessible from the main Javascript thread). Information will be returned in a `resourceTiming` property of relevant `data` events.
                * @defaultValue false
                */
            collectResourceTiming?: boolean;
            /**
                * The max number of pixels a user can shift the mouse pointer during a click for it to be considered a valid click (as opposed to a mouse drag).
                * @defaultValue true
                */
            clickTolerance?: number;
            /**
                * The initial bounds of the map. If `bounds` is specified, it overrides `center` and `zoom` constructor options.
                */
            bounds?: LngLatBoundsLike;
            /**
                * A {@link FitBoundsOptions} options object to use _only_ when fitting the initial `bounds` provided above.
                */
            fitBoundsOptions?: FitBoundsOptions;
            /**
                *  Defines a CSS
                * font-family for locally overriding generation of glyphs in the 'CJK Unified Ideographs', 'Hiragana', 'Katakana' and 'Hangul Syllables' ranges.
                * In these ranges, font settings from the map's style will be ignored, except for font-weight keywords (light/regular/medium/bold).
                * Set to `false`, to enable font settings from the map's style for these glyph ranges.
                * The purpose of this option is to avoid bandwidth-intensive glyph server requests. (See [Use locally generated ideographs](https://maplibre.org/maplibre-gl-js/docs/examples/local-ideographs).)
                * @defaultValue 'sans-serif'
                */
            localIdeographFontFamily?: string | false;
            /**
                * The map's MapLibre style. This must be a JSON object conforming to
                * the schema described in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/),
                * or a URL to such JSON.
                */
            style: StyleSpecification | string;
            /**
                * If `false`, the map's pitch (tilt) control with "drag to rotate" interaction will be disabled.
                * @defaultValue true
                */
            pitchWithRotate?: boolean;
            /**
                * The pixel ratio. The canvas' `width` attribute will be `container.clientWidth * pixelRatio` and its `height` attribute will be `container.clientHeight * pixelRatio`. Defaults to `devicePixelRatio` if not specified.
                */
            pixelRatio?: number;
            /**
                * If false, style validation will be skipped. Useful in production environment.
                * @defaultValue true
                */
            validateStyle?: boolean;
            /**
                * The canvas' `width` and `height` max size. The values are passed as an array where the first element is max width and the second element is max height.
                * You shouldn't set this above WebGl `MAX_TEXTURE_SIZE`. Defaults to [4096, 4096].
                */
            maxCanvasSize?: [number, number];
            _canvas?: HTMLCanvasElement;
            _canvasContainer?: HTMLElement;
    };
    export type AddImageOptions = {};
    type Complete<T> = {
            [P in keyof Required<T>]: Pick<T, P> extends Required<Pick<T, P>> ? T[P] : T[P] | undefined;
    };
    export type CompleteMapOptions = Complete<MapOptions>;
    /**
        * The `Map` object represents the map on your page. It exposes methods
        * and properties that enable you to programmatically change the map,
        * and fires events as users interact with it.
        *
        * You create a `Map` by specifying a `container` and other options, see {@link MapOptions} for the full list.
        * Then MapLibre GL JS initializes the map on the page and returns your `Map` object.
        *
        * @group Main
        *
        * @example
        * ```ts
        * let map = new Map({
        *   container: 'map',
        *   center: [-122.420679, 37.772537],
        *   zoom: 13,
        *   style: style_object,
        *   hash: true,
        *   transformRequest: (url, resourceType)=> {
        *     if(resourceType === 'Source' && url.startsWith('http://myHost')) {
        *       return {
        *        url: url.replace('http', 'https'),
        *        headers: { 'my-custom-header': true},
        *        credentials: 'include'  // Include cookies for cross-origin requests
        *      }
        *     }
        *   }
        * });
        * ```
        * @see [Display a map](https://maplibre.org/maplibre-gl-js/docs/examples/simple-map/)
        */
    export class Map extends Camera {
            style: Style;
            painter: Painter;
            handlers: HandlerManager;
            _container: HTMLElement;
            _canvasContainer: HTMLElement;
            _controlContainer: HTMLElement;
            _controlPositions: {
                    [_: string]: HTMLElement;
            };
            _interactive: boolean;
            _showTileBoundaries: boolean;
            _showCollisionBoxes: boolean;
            _showPadding: boolean;
            _showOverdrawInspector: boolean;
            _repaint: boolean;
            _vertices: boolean;
            _canvas: HTMLCanvasElement;
            _maxTileCacheSize: number;
            _maxTileCacheZoomLevels: number;
            _frameRequest: AbortController;
            _styleDirty: boolean;
            _sourcesDirty: boolean;
            _placementDirty: boolean;
            _loaded: boolean;
            _idleTriggered: boolean;
            _fullyLoaded: boolean;
            _trackResize: boolean;
            _resizeObserver: ResizeObserver;
            _preserveDrawingBuffer: boolean;
            _failIfMajorPerformanceCaveat: boolean;
            _antialias: boolean;
            _refreshExpiredTiles: boolean;
            _hash: Hash;
            _delegatedListeners: any;
            _fadeDuration: number;
            _crossSourceCollisions: boolean;
            _crossFadingFactor: number;
            _collectResourceTiming: boolean;
            _renderTaskQueue: TaskQueue;
            _controls: Array<IControl>;
            _mapId: number;
            _localIdeographFontFamily: string | false;
            _validateStyle: boolean;
            _requestManager: RequestManager;
            _locale: typeof defaultLocale;
            _removed: boolean;
            _clickTolerance: number;
            _overridePixelRatio: number | null;
            _maxCanvasSize: [number, number];
            _terrainDataCallback: (e: MapStyleDataEvent | MapSourceDataEvent) => void;
            /**
                * @internal
                * image queue throttling handle. To be used later when clean up
                */
            _imageQueueHandle: number;
            /**
                * The map's {@link ScrollZoomHandler}, which implements zooming in and out with a scroll wheel or trackpad.
                * Find more details and examples using `scrollZoom` in the {@link ScrollZoomHandler} section.
                */
            scrollZoom: ScrollZoomHandler;
            /**
                * The map's {@link BoxZoomHandler}, which implements zooming using a drag gesture with the Shift key pressed.
                * Find more details and examples using `boxZoom` in the {@link BoxZoomHandler} section.
                */
            boxZoom: BoxZoomHandler;
            /**
                * The map's {@link DragRotateHandler}, which implements rotating the map while dragging with the right
                * mouse button or with the Control key pressed. Find more details and examples using `dragRotate`
                * in the {@link DragRotateHandler} section.
                */
            dragRotate: DragRotateHandler;
            /**
                * The map's {@link DragPanHandler}, which implements dragging the map with a mouse or touch gesture.
                * Find more details and examples using `dragPan` in the {@link DragPanHandler} section.
                */
            dragPan: DragPanHandler;
            /**
                * The map's {@link KeyboardHandler}, which allows the user to zoom, rotate, and pan the map using keyboard
                * shortcuts. Find more details and examples using `keyboard` in the {@link KeyboardHandler} section.
                */
            keyboard: KeyboardHandler;
            /**
                * The map's {@link DoubleClickZoomHandler}, which allows the user to zoom by double clicking.
                * Find more details and examples using `doubleClickZoom` in the {@link DoubleClickZoomHandler} section.
                */
            doubleClickZoom: DoubleClickZoomHandler;
            /**
                * The map's {@link TwoFingersTouchZoomRotateHandler}, which allows the user to zoom or rotate the map with touch gestures.
                * Find more details and examples using `touchZoomRotate` in the {@link TwoFingersTouchZoomRotateHandler} section.
                */
            touchZoomRotate: TwoFingersTouchZoomRotateHandler;
            /**
                * The map's {@link TwoFingersTouchPitchHandler}, which allows the user to pitch the map with touch gestures.
                * Find more details and examples using `touchPitch` in the {@link TwoFingersTouchPitchHandler} section.
                */
            touchPitch: TwoFingersTouchPitchHandler;
            /**
                * The map's {@link CooperativeGesturesHandler}, which allows the user to see cooperative gesture info when user tries to zoom in/out.
                * Find more details and examples using `cooperativeGestures` in the {@link CooperativeGesturesHandler} section.
                */
            cooperativeGestures: CooperativeGesturesHandler;
            constructor(options: MapOptions);
            /**
                * @internal
                * Returns a unique number for this map instance which is used for the MapLoadEvent
                * to make sure we only fire one event per instantiated map object.
                * @returns the uniq map ID
                */
            _getMapId(): number;
            /**
                * Adds an {@link IControl} to the map, calling `control.onAdd(this)`.
                *
                * An {@link ErrorEvent} will be fired if the image parameter is invald.
                *
                * @param control - The {@link IControl} to add.
                * @param position - position on the map to which the control will be added.
                * Valid values are `'top-left'`, `'top-right'`, `'bottom-left'`, and `'bottom-right'`. Defaults to `'top-right'`.
                * @returns `this`
                * @example
                * Add zoom and rotation controls to the map.
                * ```ts
                * map.addControl(new NavigationControl());
                * ```
                * @see [Display map navigation controls](https://maplibre.org/maplibre-gl-js/docs/examples/navigation/)
                */
            addControl(control: IControl, position?: ControlPosition): Map;
            /**
                * Removes the control from the map.
                *
                * An {@link ErrorEvent} will be fired if the image parameter is invald.
                *
                * @param control - The {@link IControl} to remove.
                * @returns `this`
                * @example
                * ```ts
                * // Define a new navigation control.
                * let navigation = new NavigationControl();
                * // Add zoom and rotation controls to the map.
                * map.addControl(navigation);
                * // Remove zoom and rotation controls from the map.
                * map.removeControl(navigation);
                * ```
                */
            removeControl(control: IControl): Map;
            /**
                * Checks if a control exists on the map.
                *
                * @param control - The {@link IControl} to check.
                * @returns true if map contains control.
                * @example
                * ```ts
                * // Define a new navigation control.
                * let navigation = new NavigationControl();
                * // Add zoom and rotation controls to the map.
                * map.addControl(navigation);
                * // Check that the navigation control exists on the map.
                * map.hasControl(navigation);
                * ```
                */
            hasControl(control: IControl): boolean;
            calculateCameraOptionsFromTo(from: LngLat, altitudeFrom: number, to: LngLat, altitudeTo?: number): CameraOptions;
            /**
                * Resizes the map according to the dimensions of its
                * `container` element.
                *
                * Checks if the map container size changed and updates the map if it has changed.
                * This method must be called after the map's `container` is resized programmatically
                * or when the map is shown after being initially hidden with CSS.
                *
                * Triggers the following events: `movestart`, `move`, `moveend`, and `resize`.
                *
                * @param eventData - Additional properties to be passed to `movestart`, `move`, `resize`, and `moveend`
                * events that get triggered as a result of resize. This can be useful for differentiating the
                * source of an event (for example, user-initiated or programmatically-triggered events).
                * @returns `this`
                * @example
                * Resize the map when the map container is shown after being initially hidden with CSS.
                * ```ts
                * let mapDiv = document.getElementById('map');
                * if (mapDiv.style.visibility === true) map.resize();
                * ```
                */
            resize(eventData?: any): Map;
            /**
                * @internal
                * Return the map's pixel ratio eventually scaled down to respect maxCanvasSize.
                * Internally you should use this and not getPixelRatio().
                */
            _getClampedPixelRatio(width: number, height: number): number;
            /**
                * Returns the map's pixel ratio.
                * Note that the pixel ratio actually applied may be lower to respect maxCanvasSize.
                * @returns The pixel ratio.
                */
            getPixelRatio(): number;
            /**
                * Sets the map's pixel ratio. This allows to override `devicePixelRatio`.
                * After this call, the canvas' `width` attribute will be `container.clientWidth * pixelRatio`
                * and its height attribute will be `container.clientHeight * pixelRatio`.
                * Set this to null to disable `devicePixelRatio` override.
                * Note that the pixel ratio actually applied may be lower to respect maxCanvasSize.
                * @param pixelRatio - The pixel ratio.
                */
            setPixelRatio(pixelRatio: number): void;
            /**
                * Returns the map's geographical bounds. When the bearing or pitch is non-zero, the visible region is not
                * an axis-aligned rectangle, and the result is the smallest bounds that encompasses the visible region.
                * @returns The geographical bounds of the map as {@link LngLatBounds}.
                * @example
                * ```ts
                * let bounds = map.getBounds();
                * ```
                */
            getBounds(): LngLatBounds;
            /**
                * Returns the maximum geographical bounds the map is constrained to, or `null` if none set.
                * @returns The map object.
                * @example
                * ```ts
                * let maxBounds = map.getMaxBounds();
                * ```
                */
            getMaxBounds(): LngLatBounds | null;
            /**
                * Sets or clears the map's geographical bounds.
                *
                * Pan and zoom operations are constrained within these bounds.
                * If a pan or zoom is performed that would
                * display regions outside these bounds, the map will
                * instead display a position and zoom level
                * as close as possible to the operation's request while still
                * remaining within the bounds.
                *
                * @param bounds - The maximum bounds to set. If `null` or `undefined` is provided, the function removes the map's maximum bounds.
                * @returns `this`
                * @example
                * Define bounds that conform to the `LngLatBoundsLike` object as set the max bounds.
                * ```ts
                * let bounds = [
                *   [-74.04728, 40.68392], // [west, south]
                *   [-73.91058, 40.87764]  // [east, north]
                * ];
                * map.setMaxBounds(bounds);
                * ```
                */
            setMaxBounds(bounds?: LngLatBoundsLike | null): Map;
            /**
                * Sets or clears the map's minimum zoom level.
                * If the map's current zoom level is lower than the new minimum,
                * the map will zoom to the new minimum.
                *
                * It is not always possible to zoom out and reach the set `minZoom`.
                * Other factors such as map height may restrict zooming. For example,
                * if the map is 512px tall it will not be possible to zoom below zoom 0
                * no matter what the `minZoom` is set to.
                *
                * A {@link ErrorEvent} event will be fired if minZoom is out of bounds.
                *
                * @param minZoom - The minimum zoom level to set (-2 - 24).
                * If `null` or `undefined` is provided, the function removes the current minimum zoom (i.e. sets it to -2).
                * @returns `this`
                * @example
                * ```ts
                * map.setMinZoom(12.25);
                * ```
                */
            setMinZoom(minZoom?: number | null): Map;
            /**
                * Returns the map's minimum allowable zoom level.
                *
                * @returns minZoom
                * @example
                * ```ts
                * let minZoom = map.getMinZoom();
                * ```
                */
            getMinZoom(): number;
            /**
                * Sets or clears the map's maximum zoom level.
                * If the map's current zoom level is higher than the new maximum,
                * the map will zoom to the new maximum.
                *
                * A {@link ErrorEvent} event will be fired if minZoom is out of bounds.
                *
                * @param maxZoom - The maximum zoom level to set.
                * If `null` or `undefined` is provided, the function removes the current maximum zoom (sets it to 22).
                * @returns `this`
                * @example
                * ```ts
                * map.setMaxZoom(18.75);
                * ```
                */
            setMaxZoom(maxZoom?: number | null): Map;
            /**
                * Returns the map's maximum allowable zoom level.
                *
                * @returns The maxZoom
                * @example
                * ```ts
                * let maxZoom = map.getMaxZoom();
                * ```
                */
            getMaxZoom(): number;
            /**
                * Sets or clears the map's minimum pitch.
                * If the map's current pitch is lower than the new minimum,
                * the map will pitch to the new minimum.
                *
                * A {@link ErrorEvent} event will be fired if minPitch is out of bounds.
                *
                * @param minPitch - The minimum pitch to set (0-85). Values greater than 60 degrees are experimental and may result in rendering issues. If you encounter any, please raise an issue with details in the MapLibre project.
                * If `null` or `undefined` is provided, the function removes the current minimum pitch (i.e. sets it to 0).
                * @returns `this`
                */
            setMinPitch(minPitch?: number | null): Map;
            /**
                * Returns the map's minimum allowable pitch.
                *
                * @returns The minPitch
                */
            getMinPitch(): number;
            /**
                * Sets or clears the map's maximum pitch.
                * If the map's current pitch is higher than the new maximum,
                * the map will pitch to the new maximum.
                *
                * A {@link ErrorEvent} event will be fired if maxPitch is out of bounds.
                *
                * @param maxPitch - The maximum pitch to set (0-85). Values greater than 60 degrees are experimental and may result in rendering issues. If you encounter any, please raise an issue with details in the MapLibre project.
                * If `null` or `undefined` is provided, the function removes the current maximum pitch (sets it to 60).
                * @returns `this`
                */
            setMaxPitch(maxPitch?: number | null): Map;
            /**
                * Returns the map's maximum allowable pitch.
                *
                * @returns The maxPitch
                */
            getMaxPitch(): number;
            /**
                * Returns the state of `renderWorldCopies`. If `true`, multiple copies of the world will be rendered side by side beyond -180 and 180 degrees longitude. If set to `false`:
                *
                * - When the map is zoomed out far enough that a single representation of the world does not fill the map's entire
                * container, there will be blank space beyond 180 and -180 degrees longitude.
                * - Features that cross 180 and -180 degrees longitude will be cut in two (with one portion on the right edge of the
                * map and the other on the left edge of the map) at every zoom level.
                * @returns The renderWorldCopies
                * @example
                * ```ts
                * let worldCopiesRendered = map.getRenderWorldCopies();
                * ```
                * @see [Render world copies](https://maplibre.org/maplibre-gl-js/docs/examples/render-world-copies/)
                */
            getRenderWorldCopies(): boolean;
            /**
                * Sets the state of `renderWorldCopies`.
                *
                * @param renderWorldCopies - If `true`, multiple copies of the world will be rendered side by side beyond -180 and 180 degrees longitude. If set to `false`:
                *
                * - When the map is zoomed out far enough that a single representation of the world does not fill the map's entire
                * container, there will be blank space beyond 180 and -180 degrees longitude.
                * - Features that cross 180 and -180 degrees longitude will be cut in two (with one portion on the right edge of the
                * map and the other on the left edge of the map) at every zoom level.
                *
                * `undefined` is treated as `true`, `null` is treated as `false`.
                * @returns `this`
                * @example
                * ```ts
                * map.setRenderWorldCopies(true);
                * ```
                * @see [Render world copies](https://maplibre.org/maplibre-gl-js/docs/examples/render-world-copies/)
                */
            setRenderWorldCopies(renderWorldCopies?: boolean | null): Map;
            /**
                * Returns a [Point](https://github.com/mapbox/point-geometry) representing pixel coordinates, relative to the map's `container`,
                * that correspond to the specified geographical location.
                *
                * @param lnglat - The geographical location to project.
                * @returns The [Point](https://github.com/mapbox/point-geometry) corresponding to `lnglat`, relative to the map's `container`.
                * @example
                * ```ts
                * let coordinate = [-122.420679, 37.772537];
                * let point = map.project(coordinate);
                * ```
                */
            project(lnglat: LngLatLike): Point;
            /**
                * Returns a {@link LngLat} representing geographical coordinates that correspond
                * to the specified pixel coordinates.
                *
                * @param point - The pixel coordinates to unproject.
                * @returns The {@link LngLat} corresponding to `point`.
                * @example
                * ```ts
                * map.on('click', function(e) {
                *   // When the map is clicked, get the geographic coordinate.
                *   let coordinate = map.unproject(e.point);
                * });
                * ```
                */
            unproject(point: PointLike): LngLat;
            /**
                * Returns true if the map is panning, zooming, rotating, or pitching due to a camera animation or user gesture.
                * @returns true if the map is moving.
                * @example
                * ```ts
                * let isMoving = map.isMoving();
                * ```
                */
            isMoving(): boolean;
            /**
                * Returns true if the map is zooming due to a camera animation or user gesture.
                * @returns true if the map is zooming.
                * @example
                * ```ts
                * let isZooming = map.isZooming();
                * ```
                */
            isZooming(): boolean;
            /**
                * Returns true if the map is rotating due to a camera animation or user gesture.
                * @returns true if the map is rotating.
                * @example
                * ```ts
                * map.isRotating();
                * ```
                */
            isRotating(): boolean;
            _createDelegatedListener(type: keyof MapEventType | string, layerId: string, listener: Listener): {
                    layer: string;
                    listener: Listener;
                    delegates: {
                            [type in keyof MapEventType]?: (e: any) => void;
                    };
            };
            /**
                * @event
                * Adds a listener for events of a specified type, optionally limited to features in a specified style layer.
                * See {@link MapEventType} and {@link MapLayerEventType} for a full list of events and their description.
                *
                * | Event                  | Compatible with `layerId` |
                * |------------------------|---------------------------|
                * | `mousedown`            | yes                       |
                * | `mouseup`              | yes                       |
                * | `mouseover`            | yes                       |
                * | `mouseout`             | yes                       |
                * | `mousemove`            | yes                       |
                * | `mouseenter`           | yes (required)            |
                * | `mouseleave`           | yes (required)            |
                * | `click`                | yes                       |
                * | `dblclick`             | yes                       |
                * | `contextmenu`          | yes                       |
                * | `touchstart`           | yes                       |
                * | `touchend`             | yes                       |
                * | `touchcancel`          | yes                       |
                * | `wheel`                |                           |
                * | `resize`               |                           |
                * | `remove`               |                           |
                * | `touchmove`            |                           |
                * | `movestart`            |                           |
                * | `move`                 |                           |
                * | `moveend`              |                           |
                * | `dragstart`            |                           |
                * | `drag`                 |                           |
                * | `dragend`              |                           |
                * | `zoomstart`            |                           |
                * | `zoom`                 |                           |
                * | `zoomend`              |                           |
                * | `rotatestart`          |                           |
                * | `rotate`               |                           |
                * | `rotateend`            |                           |
                * | `pitchstart`           |                           |
                * | `pitch`                |                           |
                * | `pitchend`             |                           |
                * | `boxzoomstart`         |                           |
                * | `boxzoomend`           |                           |
                * | `boxzoomcancel`        |                           |
                * | `webglcontextlost`     |                           |
                * | `webglcontextrestored` |                           |
                * | `load`                 |                           |
                * | `render`               |                           |
                * | `idle`                 |                           |
                * | `error`                |                           |
                * | `data`                 |                           |
                * | `styledata`            |                           |
                * | `sourcedata`           |                           |
                * | `dataloading`          |                           |
                * | `styledataloading`     |                           |
                * | `sourcedataloading`    |                           |
                * | `styleimagemissing`    |                           |
                * | `dataabort`            |                           |
                * | `sourcedataabort`      |                           |
                *
                * @param type - The event type to listen for. Events compatible with the optional `layerId` parameter are triggered
                * when the cursor enters a visible portion of the specified layer from outside that layer or outside the map canvas.
                * @param layer - The ID of a style layer or a listener if no ID is provided. Event will only be triggered if its location
                * is within a visible feature in this layer. The event will have a `features` property containing
                * an array of the matching features. If `layer` is not supplied, the event will not have a `features` property.
                * Please note that many event types are not compatible with the optional `layer` parameter.
                * @param listener - The function to be called when the event is fired.
                * @returns `this`
                * @example
                * ```ts
                * // Set an event listener that will fire
                * // when the map has finished loading
                * map.on('load', function() {
                *   // Once the map has finished loading,
                *   // add a new layer
                *   map.addLayer({
                *     id: 'points-of-interest',
                *     source: {
                *       type: 'vector',
                *       url: 'https://maplibre.org/maplibre-style-spec/'
                *     },
                *     'source-layer': 'poi_label',
                *     type: 'circle',
                *     paint: {
                *       // MapLibre Style Specification paint properties
                *     },
                *     layout: {
                *       // MapLibre Style Specification layout properties
                *     }
                *   });
                * });
                * ```
                * @example
                * ```ts
                * // Set an event listener that will fire
                * // when a feature on the countries layer of the map is clicked
                * map.on('click', 'countries', (e) => {
                *   new Popup()
                *     .setLngLat(e.lngLat)
                *     .setHTML(`Country name: ${e.features[0].properties.name}`)
                *     .addTo(map);
                * });
                * ```
                * @see [Display popup on click](https://maplibre.org/maplibre-gl-js/docs/examples/popup-on-click/)
                * @see [Center the map on a clicked symbol](https://maplibre.org/maplibre-gl-js/docs/examples/center-on-symbol/)
                * @see [Create a hover effect](https://maplibre.org/maplibre-gl-js/docs/examples/hover-styles/)
                * @see [Create a draggable marker](https://maplibre.org/maplibre-gl-js/docs/examples/drag-a-point/)
                */
            on<T extends keyof MapLayerEventType>(type: T, layer: string, listener: (ev: MapLayerEventType[T] & Object) => void): Map;
            /**
                * Overload of the `on` method that allows to listen to events without specifying a layer.
                * @event
                * @param type - The type of the event.
                * @param listener - The listener callback.
                * @returns `this`
                */
            on<T extends keyof MapEventType>(type: T, listener: (ev: MapEventType[T] & Object) => void): this;
            /**
                * Overload of the `on` method that allows to listen to events without specifying a layer.
                * @event
                * @param type - The type of the event.
                * @param listener - The listener callback.
                * @returns `this`
                */
            on(type: keyof MapEventType | string, listener: Listener): this;
            /**
                * Adds a listener that will be called only once to a specified event type, optionally limited to features in a specified style layer.
                *
                * @event
                * @param type - The event type to listen for; one of `'mousedown'`, `'mouseup'`, `'click'`, `'dblclick'`,
                * `'mousemove'`, `'mouseenter'`, `'mouseleave'`, `'mouseover'`, `'mouseout'`, `'contextmenu'`, `'touchstart'`,
                * `'touchend'`, or `'touchcancel'`. `mouseenter` and `mouseover` events are triggered when the cursor enters
                * a visible portion of the specified layer from outside that layer or outside the map canvas. `mouseleave`
                * and `mouseout` events are triggered when the cursor leaves a visible portion of the specified layer, or leaves
                * the map canvas.
                * @param layer - The ID of a style layer or a listener if no ID is provided. Only events whose location is within a visible
                * feature in this layer will trigger the listener. The event will have a `features` property containing
                * an array of the matching features.
                * @param listener - The function to be called when the event is fired.
                * @returns `this` if listener is provided, promise otherwise to allow easier usage of async/await
                */
            once<T extends keyof MapLayerEventType>(type: T, layer: string, listener?: (ev: MapLayerEventType[T] & Object) => void): this | Promise<MapLayerEventType[T] & Object>;
            /**
                * Overload of the `once` method that allows to listen to events without specifying a layer.
                * @event
                * @param type - The type of the event.
                * @param listener - The listener callback.
                * @returns `this`
                */
            once<T extends keyof MapEventType>(type: T, listener?: (ev: MapEventType[T] & Object) => void): this | Promise<any>;
            /**
                * Overload of the `once` method that allows to listen to events without specifying a layer.
                * @event
                * @param type - The type of the event.
                * @param listener - The listener callback.
                * @returns `this`
                */
            once(type: keyof MapEventType | string, listener?: Listener): this | Promise<any>;
            /**
                * Removes an event listener for events previously added with `Map#on`.
                *
                * @event
                * @param type - The event type previously used to install the listener.
                * @param layer - The layer ID or listener previously used to install the listener.
                * @param listener - The function previously installed as a listener.
                * @returns `this`
                */
            off<T extends keyof MapLayerEventType>(type: T, layer: string, listener: (ev: MapLayerEventType[T] & Object) => void): this;
            /**
                * Overload of the `off` method that allows to listen to events without specifying a layer.
                * @event
                * @param type - The type of the event.
                * @param listener - The function previously installed as a listener.
                * @returns `this`
                */
            off<T extends keyof MapEventType>(type: T, listener: (ev: MapEventType[T] & Object) => void): this;
            /**
                * Overload of the `off` method that allows to listen to events without specifying a layer.
                * @event
                * @param type - The type of the event.
                * @param listener - The function previously installed as a listener.
                * @returns `this`
                */
            off(type: keyof MapEventType | string, listener: Listener): this;
            /**
                * Returns an array of MapGeoJSONFeature objects
                * representing visible features that satisfy the query parameters.
                *
                * @param geometryOrOptions - (optional) The geometry of the query region:
                * either a single point or southwest and northeast points describing a bounding box.
                * Omitting this parameter (i.e. calling {@link Map#queryRenderedFeatures} with zero arguments,
                * or with only a `options` argument) is equivalent to passing a bounding box encompassing the entire
                * map viewport.
                * The geometryOrOptions can receive a {@link QueryRenderedFeaturesOptions} only to support a situation where the function receives only one parameter which is the options parameter.
                * @param options - (optional) Options object.
                *
                * @returns An array of MapGeoJSONFeature objects.
                *
                * The `properties` value of each returned feature object contains the properties of its source feature. For GeoJSON sources, only
                * string and numeric property values are supported (i.e. `null`, `Array`, and `Object` values are not supported).
                *
                * Each feature includes top-level `layer`, `source`, and `sourceLayer` properties. The `layer` property is an object
                * representing the style layer to  which the feature belongs. Layout and paint properties in this object contain values
                * which are fully evaluated for the given zoom level and feature.
                *
                * Only features that are currently rendered are included. Some features will **not** be included, like:
                *
                * - Features from layers whose `visibility` property is `"none"`.
                * - Features from layers whose zoom range excludes the current zoom level.
                * - Symbol features that have been hidden due to text or icon collision.
                *
                * Features from all other layers are included, including features that may have no visible
                * contribution to the rendered result; for example, because the layer's opacity or color alpha component is set to
                * 0.
                *
                * The topmost rendered feature appears first in the returned array, and subsequent features are sorted by
                * descending z-order. Features that are rendered multiple times (due to wrapping across the antemeridian at low
                * zoom levels) are returned only once (though subject to the following caveat).
                *
                * Because features come from tiled vector data or GeoJSON data that is converted to tiles internally, feature
                * geometries may be split or duplicated across tile boundaries and, as a result, features may appear multiple
                * times in query results. For example, suppose there is a highway running through the bounding rectangle of a query.
                * The results of the query will be those parts of the highway that lie within the map tiles covering the bounding
                * rectangle, even if the highway extends into other tiles, and the portion of the highway within each map tile
                * will be returned as a separate feature. Similarly, a point feature near a tile boundary may appear in multiple
                * tiles due to tile buffering.
                *
                * @example
                * Find all features at a point
                * ```ts
                * let features = map.queryRenderedFeatures(
                *   [20, 35],
                *   { layers: ['my-layer-name'] }
                * );
                * ```
                *
                * @example
                * Find all features within a static bounding box
                * ```ts
                * let features = map.queryRenderedFeatures(
                *   [[10, 20], [30, 50]],
                *   { layers: ['my-layer-name'] }
                * );
                * ```
                *
                * @example
                * Find all features within a bounding box around a point
                * ```ts
                * let width = 10;
                * let height = 20;
                * let features = map.queryRenderedFeatures([
                *   [point.x - width / 2, point.y - height / 2],
                *   [point.x + width / 2, point.y + height / 2]
                * ], { layers: ['my-layer-name'] });
                * ```
                *
                * @example
                * Query all rendered features from a single layer
                * ```ts
                * let features = map.queryRenderedFeatures({ layers: ['my-layer-name'] });
                * ```
                * @see [Get features under the mouse pointer](https://maplibre.org/maplibre-gl-js/docs/examples/queryrenderedfeatures/)
                */
            queryRenderedFeatures(geometryOrOptions?: PointLike | [PointLike, PointLike] | QueryRenderedFeaturesOptions, options?: QueryRenderedFeaturesOptions): MapGeoJSONFeature[];
            /**
                * Returns an array of MapGeoJSONFeature objects
                * representing features within the specified vector tile or GeoJSON source that satisfy the query parameters.
                *
                * @param sourceId - The ID of the vector tile or GeoJSON source to query.
                * @param parameters - The options object.
                * @returns An array of MapGeoJSONFeature objects.
                *
                * In contrast to {@link Map#queryRenderedFeatures}, this function returns all features matching the query parameters,
                * whether or not they are rendered by the current style (i.e. visible). The domain of the query includes all currently-loaded
                * vector tiles and GeoJSON source tiles: this function does not check tiles outside the currently
                * visible viewport.
                *
                * Because features come from tiled vector data or GeoJSON data that is converted to tiles internally, feature
                * geometries may be split or duplicated across tile boundaries and, as a result, features may appear multiple
                * times in query results. For example, suppose there is a highway running through the bounding rectangle of a query.
                * The results of the query will be those parts of the highway that lie within the map tiles covering the bounding
                * rectangle, even if the highway extends into other tiles, and the portion of the highway within each map tile
                * will be returned as a separate feature. Similarly, a point feature near a tile boundary may appear in multiple
                * tiles due to tile buffering.
                *
                * @example
                * Find all features in one source layer in a vector source
                * ```ts
                * let features = map.querySourceFeatures('your-source-id', {
                *   sourceLayer: 'your-source-layer'
                * });
                * ```
                *
                */
            querySourceFeatures(sourceId: string, parameters?: QuerySourceFeatureOptions | null): MapGeoJSONFeature[];
            /**
                * Updates the map's MapLibre style object with a new value.
                *
                * If a style is already set when this is used and options.diff is set to true, the map renderer will attempt to compare the given style
                * against the map's current state and perform only the changes necessary to make the map style match the desired state. Changes in sprites
                * (images used for icons and patterns) and glyphs (fonts for label text) **cannot** be diffed. If the sprites or fonts used in the current
                * style and the given style are different in any way, the map renderer will force a full update, removing the current style and building
                * the given one from scratch.
                *
                *
                * @param style - A JSON object conforming to the schema described in the
                * [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/), or a URL to such JSON.
                * @param options - The options object.
                * @returns `this`
                *
                * @example
                * ```ts
                * map.setStyle("https://demotiles.maplibre.org/style.json");
                *
                * map.setStyle('https://demotiles.maplibre.org/style.json', {
                *   transformStyle: (previousStyle, nextStyle) => ({
                *       ...nextStyle,
                *       sources: {
                *           ...nextStyle.sources,
                *           // copy a source from previous style
                *           'osm': previousStyle.sources.osm
                *       },
                *       layers: [
                *           // background layer
                *           nextStyle.layers[0],
                *           // copy a layer from previous style
                *           previousStyle.layers[0],
                *           // other layers from the next style
                *           ...nextStyle.layers.slice(1).map(layer => {
                *               // hide the layers we don't need from demotiles style
                *               if (layer.id.startsWith('geolines')) {
                *                   layer.layout = {...layer.layout || {}, visibility: 'none'};
                *               // filter out US polygons
                *               } else if (layer.id.startsWith('coastline') || layer.id.startsWith('countries')) {
                *                   layer.filter = ['!=', ['get', 'ADM0_A3'], 'USA'];
                *               }
                *               return layer;
                *           })
                *       ]
                *   })
                * });
                * ```
                */
            setStyle(style: StyleSpecification | string | null, options?: StyleSwapOptions & StyleOptions): this;
            /**
                *  Updates the requestManager's transform request with a new function
                *
                * @param transformRequest - A callback run before the Map makes a request for an external URL. The callback can be used to modify the url, set headers, or set the credentials property for cross-origin requests.
                * Expected to return an object with a `url` property and optionally `headers` and `credentials` properties
                *
                * @returns `this`
                *
                * @example
                * ```ts
                * map.setTransformRequest((url: string, resourceType: string) => {});
                * ```
                */
            setTransformRequest(transformRequest: RequestTransformFunction): this;
            _getUIString(key: keyof typeof defaultLocale): string;
            _updateStyle(style: StyleSpecification | string | null, options?: StyleSwapOptions & StyleOptions): this;
            _lazyInitEmptyStyle(): void;
            _diffStyle(style: StyleSpecification | string, options?: StyleSwapOptions & StyleOptions): void;
            _updateDiff(style: StyleSpecification, options?: StyleSwapOptions & StyleOptions): void;
            /**
                * Returns the map's MapLibre style object, a JSON object which can be used to recreate the map's style.
                *
                * @returns The map's style JSON object.
                *
                * @example
                * ```ts
                * let styleJson = map.getStyle();
                * ```
                *
                */
            getStyle(): StyleSpecification;
            /**
                * Returns a Boolean indicating whether the map's style is fully loaded.
                *
                * @returns A Boolean indicating whether the style is fully loaded.
                *
                * @example
                * ```ts
                * let styleLoadStatus = map.isStyleLoaded();
                * ```
                */
            isStyleLoaded(): boolean | void;
            /**
                * Adds a source to the map's style.
                *
                * Events triggered:
                *
                * Triggers the `source.add` event.
                *
                * @param id - The ID of the source to add. Must not conflict with existing sources.
                * @param source - The source object, conforming to the
                * MapLibre Style Specification's [source definition](https://maplibre.org/maplibre-style-spec/sources) or
                * {@link CanvasSourceSpecification}.
                * @returns `this`
                * @example
                * ```ts
                * map.addSource('my-data', {
                *   type: 'vector',
                *   url: 'https://demotiles.maplibre.org/tiles/tiles.json'
                * });
                * ```
                * @example
                * ```ts
                * map.addSource('my-data', {
                *   "type": "geojson",
                *   "data": {
                *     "type": "Feature",
                *     "geometry": {
                *       "type": "Point",
                *       "coordinates": [-77.0323, 38.9131]
                *     },
                *     "properties": {
                *       "title": "Mapbox DC",
                *       "marker-symbol": "monument"
                *     }
                *   }
                * });
                * ```
                * @see GeoJSON source: [Add live realtime data](https://maplibre.org/maplibre-gl-js/docs/examples/live-geojson/)
                */
            addSource(id: string, source: SourceSpecification): this;
            /**
                * Returns a Boolean indicating whether the source is loaded. Returns `true` if the source with
                * the given ID in the map's style has no outstanding network requests, otherwise `false`.
                *
                * A {@link ErrorEvent} event will be fired if there is no source wit the specified ID.
                *
                * @param id - The ID of the source to be checked.
                * @returns A Boolean indicating whether the source is loaded.
                * @example
                * ```ts
                * let sourceLoaded = map.isSourceLoaded('bathymetry-data');
                * ```
                */
            isSourceLoaded(id: string): boolean;
            /**
                * Loads a 3D terrain mesh, based on a "raster-dem" source.
                *
                * Triggers the `terrain` event.
                *
                * @param options - Options object.
                * @returns `this`
                * @example
                * ```ts
                * map.setTerrain({ source: 'terrain' });
                * ```
                */
            setTerrain(options: TerrainSpecification | null): this;
            /**
                * Get the terrain-options if terrain is loaded
                * @returns the TerrainSpecification passed to setTerrain
                * @example
                * ```ts
                * map.getTerrain(); // { source: 'terrain' };
                * ```
                */
            getTerrain(): TerrainSpecification | null;
            /**
                * Returns a Boolean indicating whether all tiles in the viewport from all sources on
                * the style are loaded.
                *
                * @returns A Boolean indicating whether all tiles are loaded.
                * @example
                * ```ts
                * let tilesLoaded = map.areTilesLoaded();
                * ```
                */
            areTilesLoaded(): boolean;
            /**
                * Removes a source from the map's style.
                *
                * @param id - The ID of the source to remove.
                * @returns `this`
                * @example
                * ```ts
                * map.removeSource('bathymetry-data');
                * ```
                */
            removeSource(id: string): Map;
            /**
                * Returns the source with the specified ID in the map's style.
                *
                * This method is often used to update a source using the instance members for the relevant
                * source type as defined in [Sources](#sources).
                * For example, setting the `data` for a GeoJSON source or updating the `url` and `coordinates`
                * of an image source.
                *
                * @param id - The ID of the source to get.
                * @returns The style source with the specified ID or `undefined` if the ID
                * corresponds to no existing sources.
                * The shape of the object varies by source type.
                * A list of options for each source type is available on the MapLibre Style Specification's
                * [Sources](https://maplibre.org/maplibre-style-spec/sources/) page.
                * @example
                * ```ts
                * let sourceObject = map.getSource('points');
                * ```
                * @see [Create a draggable point](https://maplibre.org/maplibre-gl-js/docs/examples/drag-a-point/)
                * @see [Animate a point](https://maplibre.org/maplibre-gl-js/docs/examples/animate-point-along-line/)
                * @see [Add live realtime data](https://maplibre.org/maplibre-gl-js/docs/examples/live-geojson/)
                */
            getSource(id: string): Source | undefined;
            /**
                * Add an image to the style. This image can be displayed on the map like any other icon in the style's
                * sprite using the image's ID with
                * [`icon-image`](https://maplibre.org/maplibre-style-spec/layers/#layout-symbol-icon-image),
                * [`background-pattern`](https://maplibre.org/maplibre-style-spec/layers/#paint-background-background-pattern),
                * [`fill-pattern`](https://maplibre.org/maplibre-style-spec/layers/#paint-fill-fill-pattern),
                * or [`line-pattern`](https://maplibre.org/maplibre-style-spec/layers/#paint-line-line-pattern).
                *
                * A {@link ErrorEvent} event will be fired if the image parameter is invalid or there is not enough space in the sprite to add this image.
                *
                * @param id - The ID of the image.
                * @param image - The image as an `HTMLImageElement`, `ImageData`, `ImageBitmap` or object with `width`, `height`, and `data`
                * properties with the same format as `ImageData`.
                * @param options - Options object.
                * @returns `this`
                * @example
                * ```ts
                * // If the style's sprite does not already contain an image with ID 'cat',
                * // add the image 'cat-icon.png' to the style's sprite with the ID 'cat'.
                * map.loadImage('https://upload.wikimedia.org/wikipedia/commons/thumb/6/60/Cat_silhouette.svg/400px-Cat_silhouette.svg.png', function(error, image) {
                *    if (error) throw error;
                *    if (!map.hasImage('cat')) map.addImage('cat', image);
                * });
                *
                * // Add a stretchable image that can be used with `icon-text-fit`
                * // In this example, the image is 600px wide by 400px high.
                * map.loadImage('https://upload.wikimedia.org/wikipedia/commons/8/89/Black_and_White_Boxed_%28bordered%29.png', function(error, image) {
                *    if (error) throw error;
                *    if (!map.hasImage('border-image')) {
                *      map.addImage('border-image', image, {
                *          content: [16, 16, 300, 384], // place text over left half of image, avoiding the 16px border
                *          stretchX: [[16, 584]], // stretch everything horizontally except the 16px border
                *          stretchY: [[16, 384]], // stretch everything vertically except the 16px border
                *      });
                *    }
                * });
                * ```
                * @see Use `HTMLImageElement`: [Add an icon to the map](https://maplibre.org/maplibre-gl-js/docs/examples/add-image/)
                * @see Use `ImageData`: [Add a generated icon to the map](https://maplibre.org/maplibre-gl-js/docs/examples/add-image-generated/)
                */
            addImage(id: string, image: HTMLImageElement | ImageBitmap | ImageData | {
                    width: number;
                    height: number;
                    data: Uint8Array | Uint8ClampedArray;
            } | StyleImageInterface, options?: Partial<StyleImageMetadata>): this;
            /**
                * Update an existing image in a style. This image can be displayed on the map like any other icon in the style's
                * sprite using the image's ID with
                * [`icon-image`](https://maplibre.org/maplibre-style-spec/layers/#layout-symbol-icon-image),
                * [`background-pattern`](https://maplibre.org/maplibre-style-spec/layers/#paint-background-background-pattern),
                * [`fill-pattern`](https://maplibre.org/maplibre-style-spec/layers/#paint-fill-fill-pattern),
                * or [`line-pattern`](https://maplibre.org/maplibre-style-spec/layers/#paint-line-line-pattern).
                *
                * An {@link ErrorEvent} will be fired if the image parameter is invald.
                *
                * @param id - The ID of the image.
                * @param image - The image as an `HTMLImageElement`, `ImageData`, `ImageBitmap` or object with `width`, `height`, and `data`
                * properties with the same format as `ImageData`.
                * @returns `this`
                * @example
                * ```ts
                * // If an image with the ID 'cat' already exists in the style's sprite,
                * // replace that image with a new image, 'other-cat-icon.png'.
                * if (map.hasImage('cat')) map.updateImage('cat', './other-cat-icon.png');
                * ```
                */
            updateImage(id: string, image: HTMLImageElement | ImageBitmap | ImageData | {
                    width: number;
                    height: number;
                    data: Uint8Array | Uint8ClampedArray;
            } | StyleImageInterface): this;
            /**
                * Returns an image, specified by ID, currently available in the map.
                * This includes both images from the style's original sprite
                * and any images that have been added at runtime using {@link Map#addImage}.
                *
                * @param id - The ID of the image.
                * @returns An image in the map with the specified ID.
                *
                * @example
                * ```ts
                * let coffeeShopIcon = map.getImage("coffee_cup");
                * ```
                */
            getImage(id: string): StyleImage;
            /**
                * Check whether or not an image with a specific ID exists in the style. This checks both images
                * in the style's original sprite and any images
                * that have been added at runtime using {@link Map#addImage}.
                *
                * An {@link ErrorEvent} will be fired if the image parameter is invald.
                *
                * @param id - The ID of the image.
                *
                * @returns A Boolean indicating whether the image exists.
                * @example
                * Check if an image with the ID 'cat' exists in the style's sprite.
                * ```ts
                * let catIconExists = map.hasImage('cat');
                * ```
                */
            hasImage(id: string): boolean;
            /**
                * Remove an image from a style. This can be an image from the style's original
                * sprite or any images
                * that have been added at runtime using {@link Map#addImage}.
                *
                * @param id - The ID of the image.
                *
                * @example
                * ```ts
                * // If an image with the ID 'cat' exists in
                * // the style's sprite, remove it.
                * if (map.hasImage('cat')) map.removeImage('cat');
                * ```
                */
            removeImage(id: string): void;
            /**
                * Load an image from an external URL to be used with {@link Map#addImage}. External
                * domains must support [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS).
                *
                * @param url - The URL of the image file. Image file must be in png, webp, or jpg format.
                * @returns a promise that is resolved when the image is loaded
                *
                * @example
                * Load an image from an external URL.
                * ```ts
                * const response = await map.loadImage('https://picsum.photos/50/50');
                * // Add the loaded image to the style's sprite with the ID 'photo'.
                * map.addImage('photo', response.data);
                * ```
                * @see [Add an icon to the map](https://maplibre.org/maplibre-gl-js/docs/examples/add-image/)
                */
            loadImage(url: string): Promise<GetResourceResponse<HTMLImageElement | ImageBitmap>>;
            /**
                * Returns an Array of strings containing the IDs of all images currently available in the map.
                * This includes both images from the style's original sprite
                * and any images that have been added at runtime using {@link Map#addImage}.
                *
                * @returns An Array of strings containing the names of all sprites/images currently available in the map.
                *
                * @example
                * ```ts
                * let allImages = map.listImages();
                * ```
                */
            listImages(): Array<string>;
            /**
                * Adds a [MapLibre style layer](https://maplibre.org/maplibre-style-spec/layers)
                * to the map's style.
                *
                * A layer defines how data from a specified source will be styled. Read more about layer types
                * and available paint and layout properties in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/layers).
                *
                * @param layer - The layer to add,
                * conforming to either the MapLibre Style Specification's [layer definition](https://maplibre.org/maplibre-style-spec/layers) or,
                * less commonly, the {@link CustomLayerInterface} specification. Can also be a layer definition with an embedded source definition.
                * The MapLibre Style Specification's layer definition is appropriate for most layers.
                *
                * @param beforeId - The ID of an existing layer to insert the new layer before,
                * resulting in the new layer appearing visually beneath the existing layer.
                * If this argument is not specified, the layer will be appended to the end of the layers array
                * and appear visually above all other layers.
                *
                * @returns `this`
                *
                * @example
                * Add a circle layer with a vector source
                * ```ts
                * map.addLayer({
                *   id: 'points-of-interest',
                *   source: {
                *     type: 'vector',
                *     url: 'https://demotiles.maplibre.org/tiles/tiles.json'
                *   },
                *   'source-layer': 'poi_label',
                *   type: 'circle',
                *   paint: {
                *     // MapLibre Style Specification paint properties
                *   },
                *   layout: {
                *     // MapLibre Style Specification layout properties
                *   }
                * });
                * ```
                *
                * @example
                * Define a source before using it to create a new layer
                * ```ts
                * map.addSource('state-data', {
                *   type: 'geojson',
                *   data: 'path/to/data.geojson'
                * });
                *
                * map.addLayer({
                *   id: 'states',
                *   // References the GeoJSON source defined above
                *   // and does not require a `source-layer`
                *   source: 'state-data',
                *   type: 'symbol',
                *   layout: {
                *     // Set the label content to the
                *     // feature's `name` property
                *     text-field: ['get', 'name']
                *   }
                * });
                * ```
                *
                * @example
                * Add a new symbol layer before an existing layer
                * ```ts
                * map.addLayer({
                *   id: 'states',
                *   // References a source that's already been defined
                *   source: 'state-data',
                *   type: 'symbol',
                *   layout: {
                *     // Set the label content to the
                *     // feature's `name` property
                *     text-field: ['get', 'name']
                *   }
                * // Add the layer before the existing `cities` layer
                * }, 'cities');
                * ```
                * @see [Create and style clusters](https://maplibre.org/maplibre-gl-js/docs/examples/cluster/)
                * @see [Add a vector tile source](https://maplibre.org/maplibre-gl-js/docs/examples/vector-source/)
                * @see [Add a WMS source](https://maplibre.org/maplibre-gl-js/docs/examples/wms/)
                */
            addLayer(layer: AddLayerObject, beforeId?: string): this;
            /**
                * Moves a layer to a different z-position.
                *
                * @param id - The ID of the layer to move.
                * @param beforeId - The ID of an existing layer to insert the new layer before. When viewing the map, the `id` layer will appear beneath the `beforeId` layer. If `beforeId` is omitted, the layer will be appended to the end of the layers array and appear above all other layers on the map.
                * @returns `this`
                *
                * @example
                * Move a layer with ID 'polygon' before the layer with ID 'country-label'. The `polygon` layer will appear beneath the `country-label` layer on the map.
                * ```ts
                * map.moveLayer('polygon', 'country-label');
                * ```
                */
            moveLayer(id: string, beforeId?: string): this;
            /**
                * Removes the layer with the given ID from the map's style.
                *
                * An {@link ErrorEvent} will be fired if the image parameter is invald.
                *
                * @param id - The ID of the layer to remove
                * @returns `this`
                *
                * @example
                * If a layer with ID 'state-data' exists, remove it.
                * ```ts
                * if (map.getLayer('state-data')) map.removeLayer('state-data');
                * ```
                */
            removeLayer(id: string): this;
            /**
                * Returns the layer with the specified ID in the map's style.
                *
                * @param id - The ID of the layer to get.
                * @returns The layer with the specified ID, or `undefined`
                * if the ID corresponds to no existing layers.
                *
                * @example
                * ```ts
                * let stateDataLayer = map.getLayer('state-data');
                * ```
                * @see [Filter symbols by toggling a list](https://maplibre.org/maplibre-gl-js/docs/examples/filter-markers/)
                * @see [Filter symbols by text input](https://maplibre.org/maplibre-gl-js/docs/examples/filter-markers-by-input/)
                */
            getLayer(id: string): StyleLayer | undefined;
            /**
                * Return the ids of all layers currently in the style, including custom layers, in order.
                *
                * @returns ids of layers, in order
                *
                * @example
                * ```ts
                * const orderedLayerIds = map.getLayersOrder();
                * ```
                */
            getLayersOrder(): string[];
            /**
                * Sets the zoom extent for the specified style layer. The zoom extent includes the
                * [minimum zoom level](https://maplibre.org/maplibre-style-spec/layers/#minzoom)
                * and [maximum zoom level](https://maplibre.org/maplibre-style-spec/layers/#maxzoom))
                * at which the layer will be rendered.
                *
                * Note: For style layers using vector sources, style layers cannot be rendered at zoom levels lower than the
                * minimum zoom level of the _source layer_ because the data does not exist at those zoom levels. If the minimum
                * zoom level of the source layer is higher than the minimum zoom level defined in the style layer, the style
                * layer will not be rendered at all zoom levels in the zoom range.
                *
                * @param layerId - The ID of the layer to which the zoom extent will be applied.
                * @param minzoom - The minimum zoom to set (0-24).
                * @param maxzoom - The maximum zoom to set (0-24).
                * @returns `this`
                *
                * @example
                * ```ts
                * map.setLayerZoomRange('my-layer', 2, 5);
                * ```
                */
            setLayerZoomRange(layerId: string, minzoom: number, maxzoom: number): this;
            /**
                * Sets the filter for the specified style layer.
                *
                * Filters control which features a style layer renders from its source.
                * Any feature for which the filter expression evaluates to `true` will be
                * rendered on the map. Those that are false will be hidden.
                *
                * Use `setFilter` to show a subset of your source data.
                *
                * To clear the filter, pass `null` or `undefined` as the second parameter.
                *
                * @param layerId - The ID of the layer to which the filter will be applied.
                * @param filter - The filter, conforming to the MapLibre Style Specification's
                * [filter definition](https://maplibre.org/maplibre-style-spec/layers/#filter).  If `null` or `undefined` is provided, the function removes any existing filter from the layer.
                * @param options - Options object.
                * @returns `this`
                *
                * @example
                * Display only features with the 'name' property 'USA'
                * ```ts
                * map.setFilter('my-layer', ['==', ['get', 'name'], 'USA']);
                * ```
                * @example
                * Display only features with five or more 'available-spots'
                * ```ts
                * map.setFilter('bike-docks', ['>=', ['get', 'available-spots'], 5]);
                * ```
                * @example
                * Remove the filter for the 'bike-docks' style layer
                * ```ts
                * map.setFilter('bike-docks', null);
                * ```
                * @see [Create a timeline animation](https://maplibre.org/maplibre-gl-js/docs/examples/timeline-animation/)
                */
            setFilter(layerId: string, filter?: FilterSpecification | null, options?: StyleSetterOptions): this;
            /**
                * Returns the filter applied to the specified style layer.
                *
                * @param layerId - The ID of the style layer whose filter to get.
                * @returns The layer's filter.
                */
            getFilter(layerId: string): FilterSpecification | void;
            /**
                * Sets the value of a paint property in the specified style layer.
                *
                * @param layerId - The ID of the layer to set the paint property in.
                * @param name - The name of the paint property to set.
                * @param value - The value of the paint property to set.
                * Must be of a type appropriate for the property, as defined in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/).
                * Pass `null` to unset the existing value.
                * @param options - Options object.
                * @returns `this`
                * @example
                * ```ts
                * map.setPaintProperty('my-layer', 'fill-color', '#faafee');
                * ```
                * @see [Change a layer's color with buttons](https://maplibre.org/maplibre-gl-js/docs/examples/color-switcher/)
                * @see [Create a draggable point](https://maplibre.org/maplibre-gl-js/docs/examples/drag-a-point/)
                */
            setPaintProperty(layerId: string, name: string, value: any, options?: StyleSetterOptions): this;
            /**
                * Returns the value of a paint property in the specified style layer.
                *
                * @param layerId - The ID of the layer to get the paint property from.
                * @param name - The name of a paint property to get.
                * @returns The value of the specified paint property.
                */
            getPaintProperty(layerId: string, name: string): unknown;
            /**
                * Sets the value of a layout property in the specified style layer.
                *
                * @param layerId - The ID of the layer to set the layout property in.
                * @param name - The name of the layout property to set.
                * @param value - The value of the layout property. Must be of a type appropriate for the property, as defined in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/).
                * @param options - The options object.
                * @returns `this`
                * @example
                * ```ts
                * map.setLayoutProperty('my-layer', 'visibility', 'none');
                * ```
                */
            setLayoutProperty(layerId: string, name: string, value: any, options?: StyleSetterOptions): this;
            /**
                * Returns the value of a layout property in the specified style layer.
                *
                * @param layerId - The ID of the layer to get the layout property from.
                * @param name - The name of the layout property to get.
                * @returns The value of the specified layout property.
                */
            getLayoutProperty(layerId: string, name: string): any;
            /**
                * Sets the value of the style's glyphs property.
                *
                * @param glyphsUrl - Glyph URL to set. Must conform to the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/glyphs/).
                * @param options - Options object.
                * @returns `this`
                * @example
                * ```ts
                * map.setGlyphs('https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf');
                * ```
                */
            setGlyphs(glyphsUrl: string | null, options?: StyleSetterOptions): this;
            /**
                * Returns the value of the style's glyphs URL
                *
                * @returns glyphs Style's glyphs url
                */
            getGlyphs(): string | null;
            /**
                * Adds a sprite to the map's style. Fires the `style` event.
                *
                * @param id - The ID of the sprite to add. Must not conflict with existing sprites.
                * @param url - The URL to load the sprite from
                * @param options - Options object.
                * @returns `this`
                * @example
                * ```ts
                * map.addSprite('sprite-two', 'http://example.com/sprite-two');
                * ```
                */
            addSprite(id: string, url: string, options?: StyleSetterOptions): this;
            /**
                * Removes the sprite from the map's style. Fires the `style` event.
                *
                * @param id - The ID of the sprite to remove. If the sprite is declared as a single URL, the ID must be "default".
                * @returns `this`
                * @example
                * ```ts
                * map.removeSprite('sprite-two');
                * map.removeSprite('default');
                * ```
                */
            removeSprite(id: string): this;
            /**
                * Returns the as-is value of the style's sprite.
                *
                * @returns style's sprite list of id-url pairs
                */
            getSprite(): {
                    id: string;
                    url: string;
            }[];
            /**
                * Sets the value of the style's sprite property.
                *
                * @param spriteUrl - Sprite URL to set.
                * @param options - Options object.
                * @returns `this`
                * @example
                * ```ts
                * map.setSprite('YOUR_SPRITE_URL');
                * ```
                */
            setSprite(spriteUrl: string | null, options?: StyleSetterOptions): this;
            /**
                * Sets the any combination of light values.
                *
                * @param light - Light properties to set. Must conform to the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/light).
                * @param options - Options object.
                * @returns `this`
                *
                * @example
                * ```ts
                * let layerVisibility = map.getLayoutProperty('my-layer', 'visibility');
                * ```
                */
            setLight(light: LightSpecification, options?: StyleSetterOptions): this;
            /**
                * Returns the value of the light object.
                *
                * @returns light Light properties of the style.
                */
            getLight(): LightSpecification;
            /**
                * Sets the `state` of a feature.
                * A feature's `state` is a set of user-defined key-value pairs that are assigned to a feature at runtime.
                * When using this method, the `state` object is merged with any existing key-value pairs in the feature's state.
                * Features are identified by their `feature.id` attribute, which can be any number or string.
                *
                * This method can only be used with sources that have a `feature.id` attribute. The `feature.id` attribute can be defined in three ways:
                *
                * - For vector or GeoJSON sources, including an `id` attribute in the original data file.
                * - For vector or GeoJSON sources, using the [`promoteId`](https://maplibre.org/maplibre-style-spec/sources/#vector-promoteId) option at the time the source is defined.
                * - For GeoJSON sources, using the [`generateId`](https://maplibre.org/maplibre-style-spec/sources/#geojson-generateId) option to auto-assign an `id` based on the feature's index in the source data. If you change feature data using `map.getSource('some id').setData(..)`, you may need to re-apply state taking into account updated `id` values.
                *
                * _Note: You can use the [`feature-state` expression](https://maplibre.org/maplibre-style-spec/expressions/#feature-state) to access the values in a feature's state object for the purposes of styling._
                *
                * @param feature - Feature identifier. Feature objects returned from
                * {@link Map#queryRenderedFeatures} or event handlers can be used as feature identifiers.
                * @param state - A set of key-value pairs. The values should be valid JSON types.
                * @returns `this`
                *
                * @example
                * ```ts
                * // When the mouse moves over the `my-layer` layer, update
                * // the feature state for the feature under the mouse
                * map.on('mousemove', 'my-layer', function(e) {
                *   if (e.features.length > 0) {
                *     map.setFeatureState({
                *       source: 'my-source',
                *       sourceLayer: 'my-source-layer',
                *       id: e.features[0].id,
                *     }, {
                *       hover: true
                *     });
                *   }
                * });
                * ```
                * @see [Create a hover effect](https://maplibre.org/maplibre-gl-js/docs/examples/hover-styles/)
                */
            setFeatureState(feature: FeatureIdentifier, state: any): this;
            /**
                * Removes the `state` of a feature, setting it back to the default behavior.
                * If only a `target.source` is specified, it will remove the state for all features from that source.
                * If `target.id` is also specified, it will remove all keys for that feature's state.
                * If `key` is also specified, it removes only that key from that feature's state.
                * Features are identified by their `feature.id` attribute, which can be any number or string.
                *
                * @param target - Identifier of where to remove state. It can be a source, a feature, or a specific key of feature.
                * Feature objects returned from {@link Map#queryRenderedFeatures} or event handlers can be used as feature identifiers.
                * @param key - (optional) The key in the feature state to reset.
                * @returns `this`
                * @example
                * Reset the entire state object for all features in the `my-source` source
                * ```ts
                * map.removeFeatureState({
                *   source: 'my-source'
                * });
                * ```
                *
                * @example
                * When the mouse leaves the `my-layer` layer,
                * reset the entire state object for the
                * feature under the mouse
                * ```ts
                * map.on('mouseleave', 'my-layer', function(e) {
                *   map.removeFeatureState({
                *     source: 'my-source',
                *     sourceLayer: 'my-source-layer',
                *     id: e.features[0].id
                *   });
                * });
                * ```
                *
                * @example
                * When the mouse leaves the `my-layer` layer,
                * reset only the `hover` key-value pair in the
                * state for the feature under the mouse
                * ```ts
                * map.on('mouseleave', 'my-layer', function(e) {
                *   map.removeFeatureState({
                *     source: 'my-source',
                *     sourceLayer: 'my-source-layer',
                *     id: e.features[0].id
                *   }, 'hover');
                * });
                * ```
                */
            removeFeatureState(target: FeatureIdentifier, key?: string): this;
            /**
                * Gets the `state` of a feature.
                * A feature's `state` is a set of user-defined key-value pairs that are assigned to a feature at runtime.
                * Features are identified by their `feature.id` attribute, which can be any number or string.
                *
                * _Note: To access the values in a feature's state object for the purposes of styling the feature, use the [`feature-state` expression](https://maplibre.org/maplibre-style-spec/expressions/#feature-state)._
                *
                * @param feature - Feature identifier. Feature objects returned from
                * {@link Map#queryRenderedFeatures} or event handlers can be used as feature identifiers.
                * @returns The state of the feature: a set of key-value pairs that was assigned to the feature at runtime.
                *
                * @example
                * When the mouse moves over the `my-layer` layer,
                * get the feature state for the feature under the mouse
                * ```ts
                * map.on('mousemove', 'my-layer', function(e) {
                *   if (e.features.length > 0) {
                *     map.getFeatureState({
                *       source: 'my-source',
                *       sourceLayer: 'my-source-layer',
                *       id: e.features[0].id
                *     });
                *   }
                * });
                * ```
                */
            getFeatureState(feature: FeatureIdentifier): any;
            /**
                * Returns the map's containing HTML element.
                *
                * @returns The map's container.
                */
            getContainer(): HTMLElement;
            /**
                * Returns the HTML element containing the map's `<canvas>` element.
                *
                * If you want to add non-GL overlays to the map, you should append them to this element.
                *
                * This is the element to which event bindings for map interactivity (such as panning and zooming) are
                * attached. It will receive bubbled events from child elements such as the `<canvas>`, but not from
                * map controls.
                *
                * @returns The container of the map's `<canvas>`.
                * @see [Create a draggable point](https://maplibre.org/maplibre-gl-js/docs/examples/drag-a-point/)
                */
            getCanvasContainer(): HTMLElement;
            /**
                * Returns the map's `<canvas>` element.
                *
                * @returns The map's `<canvas>` element.
                * @see [Measure distances](https://maplibre.org/maplibre-gl-js/docs/examples/measure/)
                * @see [Display a popup on hover](https://maplibre.org/maplibre-gl-js/docs/examples/popup-on-hover/)
                * @see [Center the map on a clicked symbol](https://maplibre.org/maplibre-gl-js/docs/examples/center-on-symbol/)
                */
            getCanvas(): HTMLCanvasElement;
            _containerDimensions(): number[];
            _setupContainer(): void;
            _resizeCanvas(width: number, height: number, pixelRatio: number): void;
            _setupPainter(): void;
            _contextLost: (event: any) => void;
            _contextRestored: (event: any) => void;
            _onMapScroll: (event: any) => boolean;
            /**
                * Returns a Boolean indicating whether the map is fully loaded.
                *
                * Returns `false` if the style is not yet fully loaded,
                * or if there has been a change to the sources or style that
                * has not yet fully loaded.
                *
                * @returns A Boolean indicating whether the map is fully loaded.
                */
            loaded(): boolean;
            /**
                * @internal
                * Update this map's style and sources, and re-render the map.
                *
                * @param updateStyle - mark the map's style for reprocessing as
                * well as its sources
                * @returns `this`
                */
            _update(updateStyle?: boolean): this;
            /**
                * @internal
                * Request that the given callback be executed during the next render
                * frame.  Schedule a render frame if one is not already scheduled.
                *
                * @returns An id that can be used to cancel the callback
                */
            _requestRenderFrame(callback: () => void): TaskID;
            _cancelRenderFrame(id: TaskID): void;
            /**
                * @internal
                * Call when a (re-)render of the map is required:
                *
                * - The style has changed (`setPaintProperty()`, etc.)
                * - Source data has changed (e.g. tiles have finished loading)
                * - The map has is moving (or just finished moving)
                * - A transition is in progress
                *
                * @param paintStartTimeStamp - The time when the animation frame began executing.
                *
                * @returns `this`
                */
            _render(paintStartTimeStamp: number): this;
            /**
                * Force a synchronous redraw of the map.
                * @returns `this`
                * @example
                * ```ts
                * map.redraw();
                * ```
                */
            redraw(): this;
            /**
                * Clean up and release all internal resources associated with this map.
                *
                * This includes DOM elements, event bindings, web workers, and WebGL resources.
                *
                * Use this method when you are done using the map and wish to ensure that it no
                * longer consumes browser resources. Afterwards, you must not call any other
                * methods on the map.
                */
            remove(): void;
            /**
                * Trigger the rendering of a single frame. Use this method with custom layers to
                * repaint the map when the layer changes. Calling this multiple times before the
                * next frame is rendered will still result in only a single frame being rendered.
                * @example
                * ```ts
                * map.triggerRepaint();
                * ```
                * @see [Add a 3D model](https://maplibre.org/maplibre-gl-js/docs/examples/add-3d-model/)
                * @see [Add an animated icon to the map](https://maplibre.org/maplibre-gl-js/docs/examples/add-image-animated/)
                */
            triggerRepaint(): void;
            _onWindowOnline: () => void;
            /**
                * Gets and sets a Boolean indicating whether the map will render an outline
                * around each tile and the tile ID. These tile boundaries are useful for
                * debugging.
                *
                * The uncompressed file size of the first vector source is drawn in the top left
                * corner of each tile, next to the tile ID.
                *
                * @example
                * ```ts
                * map.showTileBoundaries = true;
                * ```
                */
            get showTileBoundaries(): boolean;
            set showTileBoundaries(value: boolean);
            /**
                * Gets and sets a Boolean indicating whether the map will visualize
                * the padding offsets.
                */
            get showPadding(): boolean;
            set showPadding(value: boolean);
            /**
                * Gets and sets a Boolean indicating whether the map will render boxes
                * around all symbols in the data source, revealing which symbols
                * were rendered or which were hidden due to collisions.
                * This information is useful for debugging.
                */
            get showCollisionBoxes(): boolean;
            set showCollisionBoxes(value: boolean);
            /**
                * Gets and sets a Boolean indicating whether the map should color-code
                * each fragment to show how many times it has been shaded.
                * White fragments have been shaded 8 or more times.
                * Black fragments have been shaded 0 times.
                * This information is useful for debugging.
                */
            get showOverdrawInspector(): boolean;
            set showOverdrawInspector(value: boolean);
            /**
                * Gets and sets a Boolean indicating whether the map will
                * continuously repaint. This information is useful for analyzing performance.
                */
            get repaint(): boolean;
            set repaint(value: boolean);
            get vertices(): boolean;
            set vertices(value: boolean);
            /**
                * Returns the package version of the library
                * @returns Package version of the library
                */
            get version(): string;
            /**
                * Returns the elevation for the point where the camera is looking.
                * This value corresponds to:
                * "meters above sea level" * "exaggeration"
                * @returns The elevation.
                */
            getCameraTargetElevation(): number;
    }
    export {};
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/control/navigation_control' {
    import Point from '@mapbox/point-geometry';
    import { MousePitchHandler, MouseRotateHandler } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/mouse';
    import { OneFingerTouchPitchHandler, OneFingerTouchRotateHandler } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/one_finger_touch_drag';
    import type { Map } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/map';
    import type { IControl } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/control/control';
    /**
        * The {@link NavigationControl} options object
        */
    type NavigationControlOptions = {
            /**
                * If `true` the compass button is included.
                */
            showCompass?: boolean;
            /**
                * If `true` the zoom-in and zoom-out buttons are included.
                */
            showZoom?: boolean;
            /**
                * If `true` the pitch is visualized by rotating X-axis of compass.
                */
            visualizePitch?: boolean;
    };
    /**
        * A `NavigationControl` control contains zoom buttons and a compass.
        *
        * @group Markers and Controls
        *
        * @example
        * ```ts
        * let nav = new NavigationControl();
        * map.addControl(nav, 'top-left');
        * ```
        * @see [Display map navigation controls](https://maplibre.org/maplibre-gl-js/docs/examples/navigation/)
        */
    export class NavigationControl implements IControl {
            _map: Map;
            options: NavigationControlOptions;
            _container: HTMLElement;
            _zoomInButton: HTMLButtonElement;
            _zoomOutButton: HTMLButtonElement;
            _compass: HTMLButtonElement;
            _compassIcon: HTMLElement;
            _handler: MouseRotateWrapper;
            /**
                * @param options - the control's options
                */
            constructor(options?: NavigationControlOptions);
            _updateZoomButtons: () => void;
            _rotateCompassArrow: () => void;
            /** {@inheritDoc IControl.onAdd} */
            onAdd(map: Map): HTMLElement;
            /** {@inheritDoc IControl.onRemove} */
            onRemove(): void;
            _createButton(className: string, fn: (e?: any) => unknown): HTMLButtonElement;
            _setButtonTitle: (button: HTMLButtonElement, title: "ZoomIn" | "ZoomOut" | "ResetBearing") => void;
    }
    class MouseRotateWrapper {
            map: Map;
            _clickTolerance: number;
            element: HTMLElement;
            mouseRotate: MouseRotateHandler;
            touchRotate: OneFingerTouchRotateHandler;
            mousePitch: MousePitchHandler;
            touchPitch: OneFingerTouchPitchHandler;
            _startPos: Point;
            _lastPos: Point;
            constructor(map: Map, element: HTMLElement, pitch?: boolean);
            startMouse(e: MouseEvent, point: Point): void;
            startTouch(e: TouchEvent, point: Point): void;
            moveMouse(e: MouseEvent, point: Point): void;
            moveTouch(e: TouchEvent, point: Point): void;
            off(): void;
            offTemp(): void;
            mousedown: (e: MouseEvent) => void;
            mousemove: (e: MouseEvent) => void;
            mouseup: (e: MouseEvent) => void;
            touchstart: (e: TouchEvent) => void;
            touchmove: (e: TouchEvent) => void;
            touchend: (e: TouchEvent) => void;
            reset: () => void;
    }
    export {};
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/control/geolocate_control' {
    import { Evented } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/evented';
    import { Marker } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/marker';
    import type { Map } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/map';
    import type { FitBoundsOptions } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/camera';
    import type { IControl } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/control/control';
    /**
        * The {@link GeolocateControl} options object
        */
    type GeolocateControlOptions = {
            /**
                * A Geolocation API [PositionOptions](https://developer.mozilla.org/en-US/docs/Web/API/PositionOptions) object.
                * @defaultValue `{enableHighAccuracy: false, timeout: 6000}`
                */
            positionOptions?: PositionOptions;
            /**
                * A options object to use when the map is panned and zoomed to the user's location. The default is to use a `maxZoom` of 15 to limit how far the map will zoom in for very accurate locations.
                */
            fitBoundsOptions?: FitBoundsOptions;
            /**
                * If `true` the `GeolocateControl` becomes a toggle button and when active the map will receive updates to the user's location as it changes.
                * @defaultValue false
                */
            trackUserLocation?: boolean;
            /**
                * By default, if `showUserLocation` is `true`, a transparent circle will be drawn around the user location indicating the accuracy (95% confidence level) of the user's location. Set to `false` to disable. Always disabled when `showUserLocation` is `false`.
                * @defaultValue true
                */
            showAccuracyCircle?: boolean;
            /**
                * By default a dot will be shown on the map at the user's location. Set to `false` to disable.
                * @defaultValue true
                */
            showUserLocation?: boolean;
    };
    /**
        * A `GeolocateControl` control provides a button that uses the browser's geolocation
        * API to locate the user on the map.
        *
        * Not all browsers support geolocation,
        * and some users may disable the feature. Geolocation support for modern
        * browsers including Chrome requires sites to be served over HTTPS. If
        * geolocation support is not available, the `GeolocateControl` will show
        * as disabled.
        *
        * The zoom level applied will depend on the accuracy of the geolocation provided by the device.
        *
        * The `GeolocateControl` has two modes. If `trackUserLocation` is `false` (default) the control acts as a button, which when pressed will set the map's camera to target the user location. If the user moves, the map won't update. This is most suited for the desktop. If `trackUserLocation` is `true` the control acts as a toggle button that when active the user's location is actively monitored for changes. In this mode the `GeolocateControl` has three interaction states:
        * * active - the map's camera automatically updates as the user's location changes, keeping the location dot in the center. Initial state and upon clicking the `GeolocateControl` button.
        * * passive - the user's location dot automatically updates, but the map's camera does not. Occurs upon the user initiating a map movement.
        * * disabled - occurs if Geolocation is not available, disabled or denied.
        *
        * These interaction states can't be controlled programmatically, rather they are set based on user interactions.
        * @group Markers and Controls
        *
        * @example
        * ```ts
        * map.addControl(new GeolocateControl({
        *     positionOptions: {
        *         enableHighAccuracy: true
        *     },
        *     trackUserLocation: true
        * }));
        * ```
        * @see [Locate the user](https://maplibre.org/maplibre-gl-js/docs/examples/locate-user/)
        *
        * ### Events
        *
        * @event `trackuserlocationend` - Fired when the `GeolocateControl` changes to the background state, which happens when a user changes the camera during an active position lock. This only applies when `trackUserLocation` is `true`. In the background state, the dot on the map will update with location updates but the camera will not.
        *
        * @event `trackuserlocationstart` - Fired when the `GeolocateControl` changes to the active lock state, which happens either upon first obtaining a successful Geolocation API position for the user (a `geolocate` event will follow), or the user clicks the geolocate button when in the background state which uses the last known position to recenter the map and enter active lock state (no `geolocate` event will follow unless the users's location changes).
        *
        * @event `geolocate` - Fired on each Geolocation API position update which returned as success.
        * `data` - The returned [Position](https://developer.mozilla.org/en-US/docs/Web/API/Position) object from the callback in [Geolocation.getCurrentPosition()](https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition) or [Geolocation.watchPosition()](https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/watchPosition).
        *
        * @event `error` - Fired on each Geolocation API position update which returned as an error.
        * `data` - The returned [PositionError](https://developer.mozilla.org/en-US/docs/Web/API/PositionError) object from the callback in [Geolocation.getCurrentPosition()](https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition) or [Geolocation.watchPosition()](https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/watchPosition).
        *
        * @event `outofmaxbounds` Fired on each Geolocation API position update which returned as success but user position is out of map `maxBounds`.
        * `data` - The returned [Position](https://developer.mozilla.org/en-US/docs/Web/API/Position) object from the callback in [Geolocation.getCurrentPosition()](https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition) or [Geolocation.watchPosition()](https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/watchPosition).
        *
        * @example
        * ```ts
        * // Initialize the geolocate control.
        * let geolocate = new GeolocateControl({
        *   positionOptions: {
        *       enableHighAccuracy: true
        *   },
        *   trackUserLocation: true
        * });
        * // Add the control to the map.
        * map.addControl(geolocate);
        * // Set an event listener that fires
        * // when a trackuserlocationend event occurs.
        * geolocate.on('trackuserlocationend', function() {
        *   console.log('A trackuserlocationend event has occurred.')
        * });
        * ```
        *
        * @example
        * ```ts
        * // Initialize the geolocate control.
        * let geolocate = new GeolocateControl({
        *   positionOptions: {
        *       enableHighAccuracy: true
        *   },
        *   trackUserLocation: true
        * });
        * // Add the control to the map.
        * map.addControl(geolocate);
        * // Set an event listener that fires
        * // when a trackuserlocationstart event occurs.
        * geolocate.on('trackuserlocationstart', function() {
        *   console.log('A trackuserlocationstart event has occurred.')
        * });
        * ```
        *
        * @example
        * ```ts
        * // Initialize the geolocate control.
        * let geolocate = new GeolocateControl({
        *   positionOptions: {
        *       enableHighAccuracy: true
        *   },
        *   trackUserLocation: true
        * });
        * // Add the control to the map.
        * map.addControl(geolocate);
        * // Set an event listener that fires
        * // when a geolocate event occurs.
        * geolocate.on('geolocate', function() {
        *   console.log('A geolocate event has occurred.')
        * });
        * ```
        *
        * @example
        * ```ts
        * // Initialize the geolocate control.
        * let geolocate = new GeolocateControl({
        *   positionOptions: {
        *       enableHighAccuracy: true
        *   },
        *   trackUserLocation: true
        * });
        * // Add the control to the map.
        * map.addControl(geolocate);
        * // Set an event listener that fires
        * // when an error event occurs.
        * geolocate.on('error', function() {
        *   console.log('An error event has occurred.')
        * });
        * ```
        *
        * @example
        * ```ts
        * // Initialize the geolocate control.
        * let geolocate = new GeolocateControl({
        *   positionOptions: {
        *       enableHighAccuracy: true
        *   },
        *   trackUserLocation: true
        * });
        * // Add the control to the map.
        * map.addControl(geolocate);
        * // Set an event listener that fires
        * // when an outofmaxbounds event occurs.
        * geolocate.on('outofmaxbounds', function() {
        *   console.log('An outofmaxbounds event has occurred.')
        * });
        * ```
        */
    export class GeolocateControl extends Evented implements IControl {
            _map: Map;
            options: GeolocateControlOptions;
            _container: HTMLElement;
            _dotElement: HTMLElement;
            _circleElement: HTMLElement;
            _geolocateButton: HTMLButtonElement;
            _geolocationWatchID: number;
            _timeoutId: ReturnType<typeof setTimeout>;
            _watchState: 'OFF' | 'ACTIVE_LOCK' | 'WAITING_ACTIVE' | 'ACTIVE_ERROR' | 'BACKGROUND' | 'BACKGROUND_ERROR';
            _lastKnownPosition: any;
            _userLocationDotMarker: Marker;
            _accuracyCircleMarker: Marker;
            _accuracy: number;
            _setup: boolean;
            constructor(options: GeolocateControlOptions);
            /** {@inheritDoc IControl.onAdd} */
            onAdd(map: Map): HTMLElement;
            /** {@inheritDoc IControl.onRemove} */
            onRemove(): void;
            /**
                * Check if the Geolocation API Position is outside the map's `maxBounds`.
                *
                * @param position - the Geolocation API Position
                * @returns `true` if position is outside the map's `maxBounds`, otherwise returns `false`.
                */
            _isOutOfMapMaxBounds(position: GeolocationPosition): boolean;
            _setErrorState(): void;
            /**
                * When the Geolocation API returns a new location, update the `GeolocateControl`.
                *
                * @param position - the Geolocation API Position
                */
            _onSuccess: (position: GeolocationPosition) => void;
            /**
                * Update the camera location to center on the current position
                *
                * @param position - the Geolocation API Position
                */
            _updateCamera: (position: GeolocationPosition) => void;
            /**
                * Update the user location dot Marker to the current position
                *
                * @param position - the Geolocation API Position
                */
            _updateMarker: (position?: GeolocationPosition | null) => void;
            _updateCircleRadius(): void;
            _onZoom: () => void;
            _onError: (error: GeolocationPositionError) => void;
            _finish: () => void;
            _setupUI: (supported: boolean) => void;
            /**
                * Programmatically request and move the map to the user's location.
                *
                * @returns `false` if called before control was added to a map, otherwise returns `true`.
                * @example
                * ```ts
                * // Initialize the geolocate control.
                * let geolocate = new GeolocateControl({
                *  positionOptions: {
                *    enableHighAccuracy: true
                *  },
                *  trackUserLocation: true
                * });
                * // Add the control to the map.
                * map.addControl(geolocate);
                * map.on('load', function() {
                *   geolocate.trigger();
                * });
                * ```
                */
            trigger(): boolean;
            _clearWatch(): void;
    }
    export {};
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/control/attribution_control' {
    import type { Map } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/map';
    import type { ControlPosition, IControl } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/control/control';
    import type { MapDataEvent } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/events';
    /**
        * The {@link AttributionControl} options object
        */
    export type AttributionControlOptions = {
            /**
                * If `true`, the attribution control will always collapse when moving the map. If `false`,
                * force the expanded attribution control. The default is a responsive attribution that collapses when the user moves the map on maps less than 640 pixels wide.
                * **Attribution should not be collapsed if it can comfortably fit on the map. `compact` should only be used to modify default attribution when map size makes it impossible to fit default attribution and when the automatic compact resizing for default settings are not sufficient.**
                */
            compact?: boolean;
            /**
                * Attributions to show in addition to any other attributions.
                */
            customAttribution?: string | Array<string>;
    };
    export const defaultAtributionControlOptions: AttributionControlOptions;
    /**
        * An `AttributionControl` control presents the map's attribution information. By default, the attribution control is expanded (regardless of map width).
        * @group Markers and Controls
        * @example
        * ```ts
        * let map = new Map({attributionControl: false})
        *     .addControl(new AttributionControl({
        *         compact: true
        *     }));
        * ```
        */
    export class AttributionControl implements IControl {
            options: AttributionControlOptions;
            _map: Map;
            _compact: boolean | undefined;
            _container: HTMLElement;
            _innerContainer: HTMLElement;
            _compactButton: HTMLElement;
            _editLink: HTMLAnchorElement;
            _attribHTML: string;
            styleId: string;
            styleOwner: string;
            /**
                * @param options - the attribution options
                */
            constructor(options?: AttributionControlOptions);
            getDefaultPosition(): ControlPosition;
            /** {@inheritDoc IControl.onAdd} */
            onAdd(map: Map): HTMLElement;
            /** {@inheritDoc IControl.onRemove} */
            onRemove(): void;
            _setElementTitle(element: HTMLElement, title: 'ToggleAttribution' | 'MapFeedback'): void;
            _toggleAttribution: () => void;
            _updateData: (e: MapDataEvent) => void;
            _updateAttributions(): void;
            _updateCompact: () => void;
            _updateCompactMinimize: () => void;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/control/logo_control' {
    import type { Map } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/map';
    import type { ControlPosition, IControl } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/control/control';
    /**
        * The {@link LogoControl} options object
        */
    type LogoControlOptions = {
            /**
                * If `true`, force a compact logo.
                * If `false`, force the full logo. The default is a responsive logo that collapses when the map is less than 640 pixels wide.
                */
            compact?: boolean;
    };
    /**
        * A `LogoControl` is a control that adds the watermark.
        *
        * @group Markers and Controls
        *
        * @example
        * ```ts
        * map.addControl(new LogoControl({compact: false}));
        * ```
        **/
    export class LogoControl implements IControl {
            options: LogoControlOptions;
            _map: Map;
            _compact: boolean;
            _container: HTMLElement;
            constructor(options?: LogoControlOptions);
            getDefaultPosition(): ControlPosition;
            /** {@inheritDoc IControl.onAdd} */
            onAdd(map: Map): HTMLElement;
            /** {@inheritDoc IControl.onRemove} */
            onRemove(): void;
            _updateCompact: () => void;
    }
    export {};
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/control/scale_control' {
    import type { Map } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/map';
    import type { ControlPosition, IControl } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/control/control';
    /**
        * The unit type for length to use for the {@link ScaleControl}
        */
    export type Unit = 'imperial' | 'metric' | 'nautical';
    /**
        * The {@link ScaleControl} options object
        */
    type ScaleControlOptions = {
            /**
                * The maximum length of the scale control in pixels.
                * @defaultValue 100
                */
            maxWidth?: number;
            /**
                * Unit of the distance (`'imperial'`, `'metric'` or `'nautical'`).
                * @defaultValue 'metric'
                */
            unit?: Unit;
    };
    /**
        * A `ScaleControl` control displays the ratio of a distance on the map to the corresponding distance on the ground.
        *
        * @group Markers and Controls
        *
        * @example
        * ```ts
        * let scale = new ScaleControl({
        *     maxWidth: 80,
        *     unit: 'imperial'
        * });
        * map.addControl(scale);
        *
        * scale.setUnit('metric');
        * ```
        */
    export class ScaleControl implements IControl {
            _map: Map;
            _container: HTMLElement;
            options: ScaleControlOptions;
            constructor(options?: ScaleControlOptions);
            getDefaultPosition(): ControlPosition;
            _onMove: () => void;
            /** {@inheritDoc IControl.onAdd} */
            onAdd(map: Map): HTMLElement;
            /** {@inheritDoc IControl.onRemove} */
            onRemove(): void;
            /**
                * Set the scale's unit of the distance
                *
                * @param unit - Unit of the distance (`'imperial'`, `'metric'` or `'nautical'`).
                */
            setUnit: (unit: Unit) => void;
    }
    export {};
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/control/fullscreen_control' {
    import { Evented } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/evented';
    import type { Map } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/map';
    import type { IControl } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/control/control';
    /**
        * The {@link FullscreenControl} options object
        */
    type FullscreenControlOptions = {
            /**
                * `container` is the [compatible DOM element](https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen#Compatible_elements) which should be made full screen. By default, the map container element will be made full screen.
                */
            container?: HTMLElement;
    };
    /**
        * A `FullscreenControl` control contains a button for toggling the map in and out of fullscreen mode.
        * When [requestFullscreen](https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullscreen) is not supported, fullscreen is handled via CSS properties.
        * The map's `cooperativeGestures` option is temporarily disabled while the map
        * is in fullscreen mode, and is restored when the map exist fullscreen mode.
        *
        * @group Markers and Controls
        * @param options - the full screen control options
        *
        * @example
        * ```ts
        * map.addControl(new FullscreenControl({container: document.querySelector('body')}));
        * ```
        * @see [View a fullscreen map](https://maplibre.org/maplibre-gl-js/docs/examples/fullscreen/)
        *
        * ### Events
        *
        * @event `fullscreenstart` - Fired when fullscreen mode has started
        *
        * @event `fullscreenend` - Fired when fullscreen mode has ended
        */
    export class FullscreenControl extends Evented implements IControl {
            _map: Map;
            _controlContainer: HTMLElement;
            _fullscreen: boolean;
            _fullscreenchange: string;
            _fullscreenButton: HTMLButtonElement;
            _container: HTMLElement;
            _prevCooperativeGesturesEnabled: boolean;
            constructor(options?: FullscreenControlOptions);
            /** {@inheritDoc IControl.onAdd} */
            onAdd(map: Map): HTMLElement;
            /** {@inheritDoc IControl.onRemove} */
            onRemove(): void;
            _setupUI(): void;
            _updateTitle(): void;
            _getTitle(): string;
            _isFullscreen(): boolean;
            _onFullscreenChange: () => void;
            _handleFullscreenChange(): void;
            _onClickFullscreen: () => void;
            _exitFullscreen(): void;
            _requestFullscreen(): void;
            _togglePseudoFullScreen(): void;
    }
    export {};
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/control/terrain_control' {
    import type { Map } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/map';
    import type { IControl } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/control/control';
    import type { TerrainSpecification } from '@maplibre/maplibre-gl-style-spec';
    /**
      * A `TerrainControl` control contains a button for turning the terrain on and off.
      *
      * @group Markers and Controls
      *
      * @example
      * ```ts
      * let map = new Map({TerrainControl: false})
      *     .addControl(new TerrainControl({
      *         source: "terrain"
      *     }));
      * ```
      */
    export class TerrainControl implements IControl {
        options: TerrainSpecification;
        _map: Map;
        _container: HTMLElement;
        _terrainButton: HTMLButtonElement;
        constructor(options: TerrainSpecification);
        /** {@inheritDoc IControl.onAdd} */
        onAdd(map: Map): HTMLElement;
        /** {@inheritDoc IControl.onRemove} */
        onRemove(): void;
        _toggleTerrain: () => void;
        _updateTerrainIcon: () => void;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/popup' {
    import { Evented } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/evented';
    import { MapMouseEvent } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/events';
    import { LngLat } from '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/lng_lat';
    import Point from '@mapbox/point-geometry';
    import type { PositionAnchor } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/anchor';
    import type { Map } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/map';
    import type { LngLatLike } from '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/lng_lat';
    import type { PointLike } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/camera';
    /**
        * A pixel offset specified as:
        *
        * - a single number specifying a distance from the location
        * - a {@link PointLike} specifying a constant offset
        * - an object of {@link Point}s specifying an offset for each anchor position
        *
        * Negative offsets indicate left and up.
        */
    export type Offset = number | PointLike | {
            [_ in PositionAnchor]: PointLike;
    };
    /**
        * The {@link Popup} options object
        */
    export type PopupOptions = {
            /**
                * If `true`, a close button will appear in the top right corner of the popup.
                * @defaultValue true
                */
            closeButton?: boolean;
            /**
                * If `true`, the popup will closed when the map is clicked.
                * @defaultValue true
                */
            closeOnClick?: boolean;
            /**
                * If `true`, the popup will closed when the map moves.
                * @defaultValue false
                */
            closeOnMove?: boolean;
            /**
                * If `true`, the popup will try to focus the first focusable element inside the popup.
                * @defaultValue true
                */
            focusAfterOpen?: boolean;
            /**
                * A string indicating the part of the Popup that should
                * be positioned closest to the coordinate set via {@link Popup#setLngLat}.
                * Options are `'center'`, `'top'`, `'bottom'`, `'left'`, `'right'`, `'top-left'`,
                * `'top-right'`, `'bottom-left'`, and `'bottom-right'`. If unset the anchor will be
                * dynamically set to ensure the popup falls within the map container with a preference
                * for `'bottom'`.
                */
            anchor?: PositionAnchor;
            /**
                * A pixel offset applied to the popup's location
                */
            offset?: Offset;
            /**
                * Space-separated CSS class names to add to popup container
                */
            className?: string;
            /**
                * A string that sets the CSS property of the popup's maximum width, eg `'300px'`.
                * To ensure the popup resizes to fit its content, set this property to `'none'`.
                * Available values can be found here: https://developer.mozilla.org/en-US/docs/Web/CSS/max-width
                * @defaultValue '240px'
                */
            maxWidth?: string;
            /**
                * If `true`, rounding is disabled for placement of the popup, allowing for
                * subpixel positioning and smoother movement when the popup is translated.
                * @defaultValue false
                */
            subpixelPositioning?: boolean;
    };
    /**
        * A popup component.
        *
        * @group Markers and Controls
        *
        *
        * @example
        * Create a popup
        * ```ts
        * let popup = new Popup();
        * // Set an event listener that will fire
        * // any time the popup is opened
        * popup.on('open', function(){
        *   console.log('popup was opened');
        * });
        * ```
        *
        * @example
        * Create a popup
        * ```ts
        * let popup = new Popup();
        * // Set an event listener that will fire
        * // any time the popup is closed
        * popup.on('close', function(){
        *   console.log('popup was closed');
        * });
        * ```
        *
        * @example
        * ```ts
        * let markerHeight = 50, markerRadius = 10, linearOffset = 25;
        * let popupOffsets = {
        *  'top': [0, 0],
        *  'top-left': [0,0],
        *  'top-right': [0,0],
        *  'bottom': [0, -markerHeight],
        *  'bottom-left': [linearOffset, (markerHeight - markerRadius + linearOffset) * -1],
        *  'bottom-right': [-linearOffset, (markerHeight - markerRadius + linearOffset) * -1],
        *  'left': [markerRadius, (markerHeight - markerRadius) * -1],
        *  'right': [-markerRadius, (markerHeight - markerRadius) * -1]
        *  };
        * let popup = new Popup({offset: popupOffsets, className: 'my-class'})
        *   .setLngLat(e.lngLat)
        *   .setHTML("<h1>Hello World!</h1>")
        *   .setMaxWidth("300px")
        *   .addTo(map);
        * ```
        * @see [Display a popup](https://maplibre.org/maplibre-gl-js/docs/examples/popup/)
        * @see [Display a popup on hover](https://maplibre.org/maplibre-gl-js/docs/examples/popup-on-hover/)
        * @see [Display a popup on click](https://maplibre.org/maplibre-gl-js/docs/examples/popup-on-click/)
        * @see [Attach a popup to a marker instance](https://maplibre.org/maplibre-gl-js/docs/examples/set-popup/)
        *
        * ### Events
        *
        * @event `open` Fired when the popup is opened manually or programmatically. `popup` object that was opened
        *
        * @event `close` Fired when the popup is closed manually or programmatically. `popup` object that was closed
        */
    export class Popup extends Evented {
            _map: Map;
            options: PopupOptions;
            _content: HTMLElement;
            _container: HTMLElement;
            _closeButton: HTMLButtonElement;
            _tip: HTMLElement;
            _lngLat: LngLat;
            _trackPointer: boolean;
            _pos: Point;
            _flatPos: Point;
            /**
                * @param options - the options
                */
            constructor(options?: PopupOptions);
            /**
                * Adds the popup to a map.
                *
                * @param map - The MapLibre GL JS map to add the popup to.
                * @returns `this`
                * @example
                * ```ts
                * new Popup()
                *   .setLngLat([0, 0])
                *   .setHTML("<h1>Null Island</h1>")
                *   .addTo(map);
                * ```
                * @see [Display a popup](https://maplibre.org/maplibre-gl-js/docs/examples/popup/)
                * @see [Display a popup on hover](https://maplibre.org/maplibre-gl-js/docs/examples/popup-on-hover/)
                * @see [Display a popup on click](https://maplibre.org/maplibre-gl-js/docs/examples/popup-on-click/)
                * @see [Show polygon information on click](https://maplibre.org/maplibre-gl-js/docs/examples/polygon-popup-on-click/)
                */
            addTo(map: Map): this;
            /**
                * @returns `true` if the popup is open, `false` if it is closed.
                */
            isOpen(): boolean;
            /**
                * Removes the popup from the map it has been added to.
                *
                * @example
                * ```ts
                * let popup = new Popup().addTo(map);
                * popup.remove();
                * ```
                * @returns `this`
                */
            remove: () => this;
            /**
                * Returns the geographical location of the popup's anchor.
                *
                * The longitude of the result may differ by a multiple of 360 degrees from the longitude previously
                * set by `setLngLat` because `Popup` wraps the anchor longitude across copies of the world to keep
                * the popup on screen.
                *
                * @returns The geographical location of the popup's anchor.
                */
            getLngLat(): LngLat;
            /**
                * Sets the geographical location of the popup's anchor, and moves the popup to it. Replaces trackPointer() behavior.
                *
                * @param lnglat - The geographical location to set as the popup's anchor.
                * @returns `this`
                */
            setLngLat(lnglat: LngLatLike): this;
            /**
                * Tracks the popup anchor to the cursor position on screens with a pointer device (it will be hidden on touchscreens). Replaces the `setLngLat` behavior.
                * For most use cases, set `closeOnClick` and `closeButton` to `false`.
                * @example
                * ```ts
                * let popup = new Popup({ closeOnClick: false, closeButton: false })
                *   .setHTML("<h1>Hello World!</h1>")
                *   .trackPointer()
                *   .addTo(map);
                * ```
                * @returns `this`
                */
            trackPointer(): this;
            /**
                * Returns the `Popup`'s HTML element.
                * @example
                * Change the `Popup` element's font size
                * ```ts
                * let popup = new Popup()
                *   .setLngLat([-96, 37.8])
                *   .setHTML("<p>Hello World!</p>")
                *   .addTo(map);
                * let popupElem = popup.getElement();
                * popupElem.style.fontSize = "25px";
                * ```
                * @returns element
                */
            getElement(): HTMLElement;
            /**
                * Sets the popup's content to a string of text.
                *
                * This function creates a [Text](https://developer.mozilla.org/en-US/docs/Web/API/Text) node in the DOM,
                * so it cannot insert raw HTML. Use this method for security against XSS
                * if the popup content is user-provided.
                *
                * @param text - Textual content for the popup.
                * @returns `this`
                * @example
                * ```ts
                * let popup = new Popup()
                *   .setLngLat(e.lngLat)
                *   .setText('Hello, world!')
                *   .addTo(map);
                * ```
                */
            setText(text: string): this;
            /**
                * Sets the popup's content to the HTML provided as a string.
                *
                * This method does not perform HTML filtering or sanitization, and must be
                * used only with trusted content. Consider {@link Popup#setText} if
                * the content is an untrusted text string.
                *
                * @param html - A string representing HTML content for the popup.
                * @returns `this`
                * @example
                * ```ts
                * let popup = new Popup()
                *   .setLngLat(e.lngLat)
                *   .setHTML("<h1>Hello World!</h1>")
                *   .addTo(map);
                * ```
                * @see [Display a popup](https://maplibre.org/maplibre-gl-js/docs/examples/popup/)
                * @see [Display a popup on hover](https://maplibre.org/maplibre-gl-js/docs/examples/popup-on-hover/)
                * @see [Display a popup on click](https://maplibre.org/maplibre-gl-js/docs/examples/popup-on-click/)
                * @see [Attach a popup to a marker instance](https://maplibre.org/maplibre-gl-js/docs/examples/set-popup/)
                */
            setHTML(html: string): this;
            /**
                * Returns the popup's maximum width.
                *
                * @returns The maximum width of the popup.
                */
            getMaxWidth(): string;
            /**
                * Sets the popup's maximum width. This is setting the CSS property `max-width`.
                * Available values can be found here: https://developer.mozilla.org/en-US/docs/Web/CSS/max-width
                *
                * @param maxWidth - A string representing the value for the maximum width.
                * @returns `this`
                */
            setMaxWidth(maxWidth: string): this;
            /**
                * Sets the popup's content to the element provided as a DOM node.
                *
                * @param htmlNode - A DOM node to be used as content for the popup.
                * @returns `this`
                * @example
                * Create an element with the popup content
                * ```ts
                * let div = document.createElement('div');
                * div.innerHTML = 'Hello, world!';
                * let popup = new Popup()
                *   .setLngLat(e.lngLat)
                *   .setDOMContent(div)
                *   .addTo(map);
                * ```
                */
            setDOMContent(htmlNode: Node): this;
            /**
                * Adds a CSS class to the popup container element.
                *
                * @param className - Non-empty string with CSS class name to add to popup container
                *
                * @example
                * ```ts
                * let popup = new Popup()
                * popup.addClassName('some-class')
                * ```
                */
            addClassName(className: string): void;
            /**
                * Removes a CSS class from the popup container element.
                *
                * @param className - Non-empty string with CSS class name to remove from popup container
                *
                * @example
                * ```ts
                * let popup = new Popup()
                * popup.removeClassName('some-class')
                * ```
                */
            removeClassName(className: string): void;
            /**
                * Sets the popup's offset.
                *
                * @param offset - Sets the popup's offset.
                * @returns `this`
                */
            setOffset(offset?: Offset): this;
            /**
                * Add or remove the given CSS class on the popup container, depending on whether the container currently has that class.
                *
                * @param className - Non-empty string with CSS class name to add/remove
                *
                * @returns if the class was removed return false, if class was added, then return true, undefined if there is no container
                *
                * @example
                * ```ts
                * let popup = new Popup()
                * popup.toggleClassName('toggleClass')
                * ```
                */
            toggleClassName(className: string): boolean | undefined;
            /**
                * Set the option to allow subpixel positioning of the popup by passing a boolean
                *
                * @param value - When boolean is true, subpixel positioning is enabled for the popup.
                *
                * @example
                * ```ts
                * let popup = new Popup()
                * popup.setSubpixelPositioning(true);
                * ```
                */
            setSubpixelPositioning(value: boolean): void;
            _createCloseButton(): void;
            _onMouseUp: (event: MapMouseEvent) => void;
            _onMouseMove: (event: MapMouseEvent) => void;
            _onDrag: (event: MapMouseEvent) => void;
            _update: (cursor?: Point) => void;
            _focusFirstElement(): void;
            _onClose: () => void;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/marker' {
    import { LngLat } from '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/lng_lat';
    import Point from '@mapbox/point-geometry';
    import type { PositionAnchor } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/anchor';
    import { Evented } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/evented';
    import type { Map } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/map';
    import { Popup } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/popup';
    import type { LngLatLike } from '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/lng_lat';
    import type { MapMouseEvent, MapTouchEvent } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/events';
    import type { PointLike } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/camera';
    /**
        * Alignment options of rotation and pitch
        */
    type Alignment = 'map' | 'viewport' | 'auto';
    /**
        * The {@link Marker} options object
        */
    type MarkerOptions = {
            /**
                * DOM element to use as a marker. The default is a light blue, droplet-shaped SVG marker.
                */
            element?: HTMLElement;
            /**
                * Space-separated CSS class names to add to marker element.
                */
            className?: string;
            /**
                * The offset in pixels as a {@link PointLike} object to apply relative to the element's center. Negatives indicate left and up.
                */
            offset?: PointLike;
            /**
                * A string indicating the part of the Marker that should be positioned closest to the coordinate set via {@link Marker#setLngLat}.
                * Options are `'center'`, `'top'`, `'bottom'`, `'left'`, `'right'`, `'top-left'`, `'top-right'`, `'bottom-left'`, and `'bottom-right'`.
                * @defaultValue 'center'
                * */
            anchor?: PositionAnchor;
            /**
                * The color to use for the default marker if options.element is not provided. The default is light blue.
                * @defaultValue '#3FB1CE'
                */
            color?: string;
            /**
                * The scale to use for the default marker if options.element is not provided. The default scale corresponds to a height of `41px` and a width of `27px`.
                * @defaultValue 1
                */
            scale?: number;
            /**
                * A boolean indicating whether or not a marker is able to be dragged to a new position on the map.
                * @defaultValue false
                */
            draggable?: boolean;
            /**
                * The max number of pixels a user can shift the mouse pointer during a click on the marker for it to be considered a valid click (as opposed to a marker drag). The default is to inherit map's clickTolerance.
                * @defaultValue 0
                */
            clickTolerance?: number;
            /**
                * The rotation angle of the marker in degrees, relative to its respective `rotationAlignment` setting. A positive value will rotate the marker clockwise.
                * @defaultValue 0
                */
            rotation?: number;
            /**
                * `map` aligns the `Marker`'s rotation relative to the map, maintaining a bearing as the map rotates. `viewport` aligns the `Marker`'s rotation relative to the viewport, agnostic to map rotations. `auto` is equivalent to `viewport`.
                * @defaultValue 'auto'
                */
            rotationAlignment?: Alignment;
            /**
                * `map` aligns the `Marker` to the plane of the map. `viewport` aligns the `Marker` to the plane of the viewport. `auto` automatically matches the value of `rotationAlignment`.
                * @defaultValue 'auto'
                */
            pitchAlignment?: Alignment;
            /**
                * Marker's opacity when it's in clear view (not behind 3d terrain)
                * @defaultValue 1
                */
            opacity?: string;
            /**
                * Marker's opacity when it's behind 3d terrain
                * @defaultValue 0.2
                */
            opacityWhenCovered?: string;
    };
    /**
        * Creates a marker component
        *
        * @group Markers and Controls
        *
        * @example
        * ```ts
        * let marker = new Marker()
        *   .setLngLat([30.5, 50.5])
        *   .addTo(map);
        * ```
        *
        * @example
        * Set options
        * ```ts
        * let marker = new Marker({
        *     color: "#FFFFFF",
        *     draggable: true
        *   }).setLngLat([30.5, 50.5])
        *   .addTo(map);
        * ```
        * @see [Add custom icons with Markers](https://maplibre.org/maplibre-gl-js/docs/examples/custom-marker-icons/)
        * @see [Create a draggable Marker](https://maplibre.org/maplibre-gl-js/docs/examples/drag-a-marker/)
        *
        * ### Events
        *
        * @event `dragstart` Fired when dragging starts, `marker` object that is being dragged
        *
        * @event `drag` Fired while dragging. `marker` object that is being dragged
        *
        * @event `dragend` Fired when the marker is finished being dragged, `marker` object that was dragged
        */
    export class Marker extends Evented {
            _map: Map;
            _anchor: PositionAnchor;
            _offset: Point;
            _element: HTMLElement;
            _popup: Popup;
            _lngLat: LngLat;
            _pos: Point;
            _flatPos: Point;
            _color: string;
            _scale: number;
            _defaultMarker: boolean;
            _draggable: boolean;
            _clickTolerance: number;
            _isDragging: boolean;
            _state: 'inactive' | 'pending' | 'active';
            _positionDelta: Point;
            _pointerdownPos: Point;
            _rotation: number;
            _pitchAlignment: Alignment;
            _rotationAlignment: Alignment;
            _originalTabIndex: string;
            _opacity: string;
            _opacityWhenCovered: string;
            _opacityTimeout: ReturnType<typeof setTimeout>;
            /**
                * @param options - the options
                */
            constructor(options?: MarkerOptions);
            /**
                * Attaches the `Marker` to a `Map` object.
                * @param map - The MapLibre GL JS map to add the marker to.
                * @returns `this`
                * @example
                * ```ts
                * let marker = new Marker()
                *   .setLngLat([30.5, 50.5])
                *   .addTo(map); // add the marker to the map
                * ```
                */
            addTo(map: Map): this;
            /**
                * Removes the marker from a map
                * @example
                * ```ts
                * let marker = new Marker().addTo(map);
                * marker.remove();
                * ```
                * @returns `this`
                */
            remove(): this;
            /**
                * Get the marker's geographical location.
                *
                * The longitude of the result may differ by a multiple of 360 degrees from the longitude previously
                * set by `setLngLat` because `Marker` wraps the anchor longitude across copies of the world to keep
                * the marker on screen.
                *
                * @returns A {@link LngLat} describing the marker's location.
                * @example
                * ```ts
                * // Store the marker's longitude and latitude coordinates in a variable
                * let lngLat = marker.getLngLat();
                * // Print the marker's longitude and latitude values in the console
                * console.log('Longitude: ' + lngLat.lng + ', Latitude: ' + lngLat.lat )
                * ```
                * @see [Create a draggable Marker](https://maplibre.org/maplibre-gl-js/docs/examples/drag-a-marker/)
                */
            getLngLat(): LngLat;
            /**
                * Set the marker's geographical position and move it.
                * @param lnglat - A {@link LngLat} describing where the marker should be located.
                * @returns `this`
                * @example
                * Create a new marker, set the longitude and latitude, and add it to the map
                * ```ts
                * new Marker()
                *   .setLngLat([-65.017, -16.457])
                *   .addTo(map);
                * ```
                * @see [Add custom icons with Markers](https://maplibre.org/maplibre-gl-js/docs/examples/custom-marker-icons/)
                * @see [Create a draggable Marker](https://maplibre.org/maplibre-gl-js/docs/examples/drag-a-marker/)
                */
            setLngLat(lnglat: LngLatLike): this;
            /**
                * Returns the `Marker`'s HTML element.
                * @returns element
                */
            getElement(): HTMLElement;
            /**
                * Binds a {@link Popup} to the {@link Marker}.
                * @param popup - An instance of the {@link Popup} class. If undefined or null, any popup
                * set on this {@link Marker} instance is unset.
                * @returns `this`
                * @example
                * ```ts
                * let marker = new Marker()
                *  .setLngLat([0, 0])
                *  .setPopup(new Popup().setHTML("<h1>Hello World!</h1>")) // add popup
                *  .addTo(map);
                * ```
                * @see [Attach a popup to a marker instance](https://maplibre.org/maplibre-gl-js/docs/examples/set-popup/)
                */
            setPopup(popup?: Popup | null): this;
            _onKeyPress: (e: KeyboardEvent) => void;
            _onMapClick: (e: MapMouseEvent) => void;
            /**
                * Returns the {@link Popup} instance that is bound to the {@link Marker}.
                * @returns popup
                * @example
                * ```ts
                * let marker = new Marker()
                *  .setLngLat([0, 0])
                *  .setPopup(new Popup().setHTML("<h1>Hello World!</h1>"))
                *  .addTo(map);
                *
                * console.log(marker.getPopup()); // return the popup instance
                * ```
                */
            getPopup(): Popup;
            /**
                * Opens or closes the {@link Popup} instance that is bound to the {@link Marker}, depending on the current state of the {@link Popup}.
                * @returns `this`
                * @example
                * ```ts
                * let marker = new Marker()
                *  .setLngLat([0, 0])
                *  .setPopup(new Popup().setHTML("<h1>Hello World!</h1>"))
                *  .addTo(map);
                *
                * marker.togglePopup(); // toggle popup open or closed
                * ```
                */
            togglePopup(): this;
            _updateOpacity(force?: boolean): void;
            _update: (e?: {
                    type: "move" | "moveend" | "terrain" | "render";
            }) => void;
            /**
                * Get the marker's offset.
                * @returns The marker's screen coordinates in pixels.
                */
            getOffset(): Point;
            /**
                * Sets the offset of the marker
                * @param offset - The offset in pixels as a {@link PointLike} object to apply relative to the element's center. Negatives indicate left and up.
                * @returns `this`
                */
            setOffset(offset: PointLike): this;
            /**
                * Adds a CSS class to the marker element.
                *
                * @param className - on-empty string with CSS class name to add to marker element
                *
                * @example
                * ```
                * let marker = new Marker()
                * marker.addClassName('some-class')
                * ```
                */
            addClassName(className: string): void;
            /**
                * Removes a CSS class from the marker element.
                *
                * @param className - Non-empty string with CSS class name to remove from marker element
                *
                * @example
                * ```ts
                * let marker = new Marker()
                * marker.removeClassName('some-class')
                * ```
                */
            removeClassName(className: string): void;
            /**
                * Add or remove the given CSS class on the marker element, depending on whether the element currently has that class.
                *
                * @param className - Non-empty string with CSS class name to add/remove
                *
                * @returns if the class was removed return false, if class was added, then return true
                *
                * @example
                * ```ts
                * let marker = new Marker()
                * marker.toggleClassName('toggleClass')
                * ```
                */
            toggleClassName(className: string): boolean;
            _onMove: (e: MapMouseEvent | MapTouchEvent) => void;
            _onUp: () => void;
            _addDragHandler: (e: MapMouseEvent | MapTouchEvent) => void;
            /**
                * Sets the `draggable` property and functionality of the marker
                * @param shouldBeDraggable - Turns drag functionality on/off
                * @returns `this`
                */
            setDraggable(shouldBeDraggable?: boolean): this;
            /**
                * Returns true if the marker can be dragged
                * @returns True if the marker is draggable.
                */
            isDraggable(): boolean;
            /**
                * Sets the `rotation` property of the marker.
                * @param rotation - The rotation angle of the marker (clockwise, in degrees), relative to its respective {@link Marker#setRotationAlignment} setting.
                * @returns `this`
                */
            setRotation(rotation?: number): this;
            /**
                * Returns the current rotation angle of the marker (in degrees).
                * @returns The current rotation angle of the marker.
                */
            getRotation(): number;
            /**
                * Sets the `rotationAlignment` property of the marker.
                * @param alignment - Sets the `rotationAlignment` property of the marker. defaults to 'auto'
                * @returns `this`
                */
            setRotationAlignment(alignment?: Alignment): this;
            /**
                * Returns the current `rotationAlignment` property of the marker.
                * @returns The current rotational alignment of the marker.
                */
            getRotationAlignment(): Alignment;
            /**
                * Sets the `pitchAlignment` property of the marker.
                * @param alignment - Sets the `pitchAlignment` property of the marker. If alignment is 'auto', it will automatically match `rotationAlignment`.
                * @returns `this`
                */
            setPitchAlignment(alignment?: Alignment): this;
            /**
                * Returns the current `pitchAlignment` property of the marker.
                * @returns The current pitch alignment of the marker in degrees.
                */
            getPitchAlignment(): Alignment;
            /**
                * Sets the `opacity` and `opacityWhenCovered` properties of the marker.
                * When called without arguments, resets opacity and opacityWhenCovered to defaults
                * @param opacity - Sets the `opacity` property of the marker.
                * @param opacityWhenCovered - Sets the `opacityWhenCovered` property of the marker.
                * @returns `this`
                */
            setOpacity(opacity?: string, opacityWhenCovered?: string): this;
    }
    export {};
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style' {
    import { Evented } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/evented';
    import { StyleLayer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer';
    import { ImageManager } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/image_manager';
    import { GlyphManager } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/glyph_manager';
    import { Light } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/light';
    import { LineAtlas } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/line_atlas';
    import { Dispatcher } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/dispatcher';
    import { Source } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/source';
    import { QueryRenderedFeaturesOptions, QuerySourceFeatureOptions } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/query_features';
    import { SourceCache } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/source_cache';
    import { DiffCommand } from '@maplibre/maplibre-gl-style-spec';
    import { PauseablePlacement } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/pauseable_placement';
    import { ZoomHistory } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/zoom_history';
    import { CrossTileSymbolIndex } from '@mappedin/mappedin-js/packages/outdoor-context-v4/symbol/cross_tile_symbol_index';
    import type { MapGeoJSONFeature } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/vectortile_to_geojson';
    import type { Map } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/map';
    import type { Transform } from '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/transform';
    import type { StyleImage } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_image';
    import type { EvaluationParameters } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/evaluation_parameters';
    import type { Placement } from '@mappedin/mappedin-js/packages/outdoor-context-v4/symbol/placement';
    import type { LayerSpecification, FilterSpecification, StyleSpecification, LightSpecification, SourceSpecification, SpriteSpecification, DiffOperations } from '@maplibre/maplibre-gl-style-spec';
    import type { CustomLayerInterface } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/custom_style_layer';
    import type { Validator } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/validate_style';
    import { type GetGlyphsParamerters, type GetGlyphsResponse, type GetImagesParamerters, type GetImagesResponse } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/actor_messages';
    /**
        * A feature identifier that is bound to a source
        */
    export type FeatureIdentifier = {
            /**
                * Unique id of the feature.
                */
            id?: string | number | undefined;
            /**
                * The id of the vector or GeoJSON source for the feature.
                */
            source: string;
            /**
                * *For vector tile sources, `sourceLayer` is required.*
                */
            sourceLayer?: string | undefined;
    };
    /**
        * The options object related to the {@link Map}'s style related methods
        */
    export type StyleOptions = {
            /**
                * If false, style validation will be skipped. Useful in production environment.
                */
            validate?: boolean;
            /**
                * Defines a CSS
                * font-family for locally overriding generation of glyphs in the 'CJK Unified Ideographs', 'Hiragana', 'Katakana' and 'Hangul Syllables' ranges.
                * In these ranges, font settings from the map's style will be ignored, except for font-weight keywords (light/regular/medium/bold).
                * Set to `false`, to enable font settings from the map's style for these glyph ranges.
                * Forces a full update.
                */
            localIdeographFontFamily?: string | false;
    };
    /**
        * Supporting type to add validation to another style related type
        */
    export type StyleSetterOptions = {
            /**
                * Whether to check if the filter conforms to the MapLibre Style Specification. Disabling validation is a performance optimization that should only be used if you have previously validated the values you will be passing to this function.
                */
            validate?: boolean;
    };
    /**
        * Part of {@link Map#setStyle} options, transformStyle is a convenience function that allows to modify a style after it is fetched but before it is committed to the map state
        * this function exposes previous and next styles, it can be commonly used to support a range of functionalities like:
        *      when previous style carries certain 'state' that needs to be carried over to a new style gracefully
        *      when a desired style is a certain combination of previous and incoming style
        *      when an incoming style requires modification based on external state
        *
        * @param previousStyle - The current style.
        * @param nextStyle - The next style.
        * @returns resulting style that will to be applied to the map
        *
        * @example
        * ```ts
        * map.setStyle('https://demotiles.maplibre.org/style.json', {
        *   transformStyle: (previousStyle, nextStyle) => ({
        *       ...nextStyle,
        *       sources: {
        *           ...nextStyle.sources,
        *           // copy a source from previous style
        *           'osm': previousStyle.sources.osm
        *       },
        *       layers: [
        *           // background layer
        *           nextStyle.layers[0],
        *           // copy a layer from previous style
        *           previousStyle.layers[0],
        *           // other layers from the next style
        *           ...nextStyle.layers.slice(1).map(layer => {
        *               // hide the layers we don't need from demotiles style
        *               if (layer.id.startsWith('geolines')) {
        *                   layer.layout = {...layer.layout || {}, visibility: 'none'};
        *               // filter out US polygons
        *               } else if (layer.id.startsWith('coastline') || layer.id.startsWith('countries')) {
        *                   layer.filter = ['!=', ['get', 'ADM0_A3'], 'USA'];
        *               }
        *               return layer;
        *           })
        *       ]
        *   })
        * });
        * ```
        */
    export type TransformStyleFunction = (previous: StyleSpecification | undefined, next: StyleSpecification) => StyleSpecification;
    /**
        * The options object related to the {@link Map}'s style related methods
        */
    export type StyleSwapOptions = {
            /**
                * If false, force a 'full' update, removing the current style
                * and building the given one instead of attempting a diff-based update.
                */
            diff?: boolean;
            /**
                * TransformStyleFunction is a convenience function
                * that allows to modify a style after it is fetched but before it is committed to the map state. Refer to {@link TransformStyleFunction}.
                */
            transformStyle?: TransformStyleFunction;
    };
    /**
        * Specifies a layer to be added to a {@link Style}. In addition to a standard {@link LayerSpecification}
        * or a {@link CustomLayerInterface}, a {@link LayerSpecification} with an embedded {@link SourceSpecification} can also be provided.
        */
    export type AddLayerObject = LayerSpecification | (Omit<LayerSpecification, 'source'> & {
            source: SourceSpecification;
    }) | CustomLayerInterface;
    /**
        * The Style base class
        */
    export class Style extends Evented {
            map: Map;
            stylesheet: StyleSpecification;
            dispatcher: Dispatcher;
            imageManager: ImageManager;
            glyphManager: GlyphManager;
            lineAtlas: LineAtlas;
            light: Light;
            _frameRequest: AbortController;
            _loadStyleRequest: AbortController;
            _spriteRequest: AbortController;
            _layers: {
                    [_: string]: StyleLayer;
            };
            _serializedLayers: {
                    [_: string]: LayerSpecification;
            };
            _order: Array<string>;
            sourceCaches: {
                    [_: string]: SourceCache;
            };
            zoomHistory: ZoomHistory;
            _loaded: boolean;
            _changed: boolean;
            _updatedSources: {
                    [_: string]: 'clear' | 'reload';
            };
            _updatedLayers: {
                    [_: string]: true;
            };
            _removedLayers: {
                    [_: string]: StyleLayer;
            };
            _changedImages: {
                    [_: string]: true;
            };
            _glyphsDidChange: boolean;
            _updatedPaintProps: {
                    [layer: string]: true;
            };
            _layerOrderChanged: boolean;
            _spritesImagesIds: {
                    [spriteId: string]: string[];
            };
            _availableImages: Array<string>;
            crossTileSymbolIndex: CrossTileSymbolIndex;
            pauseablePlacement: PauseablePlacement;
            placement: Placement;
            z: number;
            constructor(map: Map, options?: StyleOptions);
            _rtlPluginLoaded: () => void;
            loadURL(url: string, options?: StyleSwapOptions & StyleSetterOptions, previousStyle?: StyleSpecification): void;
            loadJSON(json: StyleSpecification, options?: StyleSetterOptions & StyleSwapOptions, previousStyle?: StyleSpecification): void;
            loadEmpty(): void;
            _load(json: StyleSpecification, options: StyleSwapOptions & StyleSetterOptions, previousStyle?: StyleSpecification): void;
            _loadSprite(sprite: SpriteSpecification, isUpdate?: boolean, completion?: (err: Error) => void): void;
            _unloadSprite(): void;
            _validateLayer(layer: StyleLayer): void;
            loaded(): boolean;
            hasTransitions(): boolean;
            _checkLoaded(): void;
            /**
                * @internal
                * Apply queued style updates in a batch and recalculate zoom-dependent paint properties.
                */
            update(parameters: EvaluationParameters): void;
            _updateTilesForChangedImages(): void;
            _updateTilesForChangedGlyphs(): void;
            _updateWorkerLayers(updatedIds: Array<string>, removedIds: Array<string>): void;
            _resetUpdates(): void;
            /**
                * Update this style's state to match the given style JSON, performing only
                * the necessary mutations.
                *
                * May throw an Error ('Unimplemented: METHOD') if the mapbox-gl-style-spec
                * diff algorithm produces an operation that is not supported.
                *
                * @returns true if any changes were made; false otherwise
                */
            setState(nextState: StyleSpecification, options?: StyleSwapOptions & StyleSetterOptions): boolean;
            _getOperationsToPerform(diff: DiffCommand<DiffOperations>[]): {
                    operations: Function[];
                    unimplemented: string[];
            };
            addImage(id: string, image: StyleImage): this;
            updateImage(id: string, image: StyleImage): void;
            getImage(id: string): StyleImage;
            removeImage(id: string): this;
            _afterImageUpdated(id: string): void;
            listImages(): string[];
            addSource(id: string, source: SourceSpecification, options?: StyleSetterOptions): void;
            /**
                * Remove a source from this stylesheet, given its id.
                * @param id - id of the source to remove
                * @throws if no source is found with the given ID
                * @returns `this`.
                */
            removeSource(id: string): this;
            /**
                * Set the data of a GeoJSON source, given its id.
                * @param id - id of the source
                * @param data - GeoJSON source
                */
            setGeoJSONSourceData(id: string, data: GeoJSON.GeoJSON | string): void;
            /**
                * Get a source by ID.
                * @param id - ID of the desired source
                * @returns source
                */
            getSource(id: string): Source | undefined;
            /**
                * Add a layer to the map style. The layer will be inserted before the layer with
                * ID `before`, or appended if `before` is omitted.
                * @param layerObject - The style layer to add.
                * @param before - ID of an existing layer to insert before
                * @param options - Style setter options.
                * @returns `this`.
                */
            addLayer(layerObject: AddLayerObject, before?: string, options?: StyleSetterOptions): this;
            /**
                * Moves a layer to a different z-position. The layer will be inserted before the layer with
                * ID `before`, or appended if `before` is omitted.
                * @param id - ID of the layer to move
                * @param before - ID of an existing layer to insert before
                */
            moveLayer(id: string, before?: string): void;
            /**
                * Remove the layer with the given id from the style.
                *
                * If no such layer exists, an `error` event is fired.
                *
                * @param id - id of the layer to remove
                * @event `error` - Fired if the layer does not exist
                */
            removeLayer(id: string): void;
            /**
                * Return the style layer object with the given `id`.
                *
                * @param id - id of the desired layer
                * @returns a layer, if one with the given `id` exists
                */
            getLayer(id: string): StyleLayer | undefined;
            /**
                * Return the ids of all layers currently in the style, including custom layers, in order.
                *
                * @returns ids of layers, in order
                */
            getLayersOrder(): string[];
            /**
                * Checks if a specific layer is present within the style.
                *
                * @param id - the id of the desired layer
                * @returns a boolean specifying if the given layer is present
                */
            hasLayer(id: string): boolean;
            setLayerZoomRange(layerId: string, minzoom?: number | null, maxzoom?: number | null): void;
            setFilter(layerId: string, filter?: FilterSpecification | null, options?: StyleSetterOptions): void;
            /**
                * Get a layer's filter object
                * @param layer - the layer to inspect
                * @returns the layer's filter, if any
                */
            getFilter(layer: string): FilterSpecification | void;
            setLayoutProperty(layerId: string, name: string, value: any, options?: StyleSetterOptions): void;
            /**
                * Get a layout property's value from a given layer
                * @param layerId - the layer to inspect
                * @param name - the name of the layout property
                * @returns the property value
                */
            getLayoutProperty(layerId: string, name: string): any;
            setPaintProperty(layerId: string, name: string, value: any, options?: StyleSetterOptions): void;
            getPaintProperty(layer: string, name: string): unknown;
            setFeatureState(target: FeatureIdentifier, state: any): void;
            removeFeatureState(target: FeatureIdentifier, key?: string): void;
            getFeatureState(target: FeatureIdentifier): import("@maplibre/maplibre-gl-style-spec").FeatureState;
            getTransition(): {
                    duration: number;
                    delay: number;
            } & import("@maplibre/maplibre-gl-style-spec").TransitionSpecification;
            serialize(): StyleSpecification;
            _updateLayer(layer: StyleLayer): void;
            _flattenAndSortRenderedFeatures(sourceResults: Array<{
                    [key: string]: Array<{
                            featureIndex: number;
                            feature: MapGeoJSONFeature;
                    }>;
            }>): any[];
            queryRenderedFeatures(queryGeometry: any, params: QueryRenderedFeaturesOptions, transform: Transform): any[];
            querySourceFeatures(sourceID: string, params?: QuerySourceFeatureOptions): any[];
            getLight(): LightSpecification;
            setLight(lightOptions: LightSpecification, options?: StyleSetterOptions): void;
            _validate(validate: Validator, key: string, value: any, props: any, options?: {
                    validate?: boolean;
            }): boolean;
            _remove(mapRemoved?: boolean): void;
            _clearSource(id: string): void;
            _reloadSource(id: string): void;
            _updateSources(transform: Transform): void;
            _generateCollisionBoxes(): void;
            _updatePlacement(transform: Transform, showCollisionBoxes: boolean, fadeDuration: number, crossSourceCollisions: boolean, forceFullPlacement?: boolean): boolean;
            _releaseSymbolFadeTiles(): void;
            getImages(mapId: string | number, params: GetImagesParamerters): Promise<GetImagesResponse>;
            getGlyphs(mapId: string | number, params: GetGlyphsParamerters): Promise<GetGlyphsResponse>;
            getGlyphsUrl(): string;
            setGlyphs(glyphsUrl: string | null, options?: StyleSetterOptions): void;
            /**
                * Add a sprite.
                *
                * @param id - The id of the desired sprite
                * @param url - The url to load the desired sprite from
                * @param options - The style setter options
                * @param completion - The completion handler
                */
            addSprite(id: string, url: string, options?: StyleSetterOptions, completion?: (err: Error) => void): void;
            /**
                * Remove a sprite by its id. When the last sprite is removed, the whole `this.stylesheet.sprite` object becomes
                * `undefined`. This falsy `undefined` value later prevents attempts to load the sprite when it's absent.
                *
                * @param id - the id of the sprite to remove
                */
            removeSprite(id: string): void;
            /**
                * Get the current sprite value.
                *
                * @returns empty array when no sprite is set; id-url pairs otherwise
                */
            getSprite(): {
                    id: string;
                    url: string;
            }[];
            /**
                * Set a new value for the style's sprite.
                *
                * @param sprite - new sprite value
                * @param options - style setter options
                * @param completion - the completion handler
                */
            setSprite(sprite: SpriteSpecification, options?: StyleSetterOptions, completion?: (err: Error) => void): void;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/lng_lat' {
    export const earthRadius = 6371008.8;
    /**
        * A {@link LngLat} object, an array of two numbers representing longitude and latitude,
        * or an object with `lng` and `lat` or `lon` and `lat` properties.
        *
        * @group Geography and Geometry
        *
        * @example
        * ```ts
        * let v1 = new LngLat(-122.420679, 37.772537);
        * let v2 = [-122.420679, 37.772537];
        * let v3 = {lon: -122.420679, lat: 37.772537};
        * ```
        */
    export type LngLatLike = LngLat | {
            lng: number;
            lat: number;
    } | {
            lon: number;
            lat: number;
    } | [number, number];
    /**
        * A `LngLat` object represents a given longitude and latitude coordinate, measured in degrees.
        * These coordinates are based on the [WGS84 (EPSG:4326) standard](https://en.wikipedia.org/wiki/World_Geodetic_System#WGS84).
        *
        * MapLibre GL JS uses longitude, latitude coordinate order (as opposed to latitude, longitude) to match the
        * [GeoJSON specification](https://tools.ietf.org/html/rfc7946).
        *
        * Note that any MapLibre GL JS method that accepts a `LngLat` object as an argument or option
        * can also accept an `Array` of two numbers and will perform an implicit conversion.
        * This flexible type is documented as {@link LngLatLike}.
        *
        * @group Geography and Geometry
        *
        * @example
        * ```ts
        * let ll = new LngLat(-123.9749, 40.7736);
        * ll.lng; // = -123.9749
        * ```
        * @see [Get coordinates of the mouse pointer](https://maplibre.org/maplibre-gl-js/docs/examples/mouse-position/)
        * @see [Display a popup](https://maplibre.org/maplibre-gl-js/docs/examples/popup/)
        * @see [Create a timeline animation](https://maplibre.org/maplibre-gl-js/docs/examples/timeline-animation/)
        */
    export class LngLat {
            lng: number;
            lat: number;
            /**
                * @param lng - Longitude, measured in degrees.
                * @param lat - Latitude, measured in degrees.
                */
            constructor(lng: number, lat: number);
            /**
                * Returns a new `LngLat` object whose longitude is wrapped to the range (-180, 180).
                *
                * @returns The wrapped `LngLat` object.
                * @example
                * ```ts
                * let ll = new LngLat(286.0251, 40.7736);
                * let wrapped = ll.wrap();
                * wrapped.lng; // = -73.9749
                * ```
                */
            wrap(): LngLat;
            /**
                * Returns the coordinates represented as an array of two numbers.
                *
                * @returns The coordinates represented as an array of longitude and latitude.
                * @example
                * ```ts
                * let ll = new LngLat(-73.9749, 40.7736);
                * ll.toArray(); // = [-73.9749, 40.7736]
                * ```
                */
            toArray(): [number, number];
            /**
                * Returns the coordinates represent as a string.
                *
                * @returns The coordinates represented as a string of the format `'LngLat(lng, lat)'`.
                * @example
                * ```ts
                * let ll = new LngLat(-73.9749, 40.7736);
                * ll.toString(); // = "LngLat(-73.9749, 40.7736)"
                * ```
                */
            toString(): string;
            /**
                * Returns the approximate distance between a pair of coordinates in meters
                * Uses the Haversine Formula (from R.W. Sinnott, "Virtues of the Haversine", Sky and Telescope, vol. 68, no. 2, 1984, p. 159)
                *
                * @param lngLat - coordinates to compute the distance to
                * @returns Distance in meters between the two coordinates.
                * @example
                * ```ts
                * let new_york = new LngLat(-74.0060, 40.7128);
                * let los_angeles = new LngLat(-118.2437, 34.0522);
                * new_york.distanceTo(los_angeles); // = 3935751.690893987, "true distance" using a non-spherical approximation is ~3966km
                * ```
                */
            distanceTo(lngLat: LngLat): number;
            /**
                * Converts an array of two numbers or an object with `lng` and `lat` or `lon` and `lat` properties
                * to a `LngLat` object.
                *
                * If a `LngLat` object is passed in, the function returns it unchanged.
                *
                * @param input - An array of two numbers or object to convert, or a `LngLat` object to return.
                * @returns A new `LngLat` object, if a conversion occurred, or the original `LngLat` object.
                * @example
                * ```ts
                * let arr = [-73.9749, 40.7736];
                * let ll = LngLat.convert(arr);
                * ll;   // = LngLat {lng: -73.9749, lat: 40.7736}
                * ```
                */
            static convert(input: LngLatLike): LngLat;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/lng_lat_bounds' {
    import { LngLat } from '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/lng_lat';
    import type { LngLatLike } from '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/lng_lat';
    /**
        * A {@link LngLatBounds} object, an array of {@link LngLatLike} objects in [sw, ne] order,
        * or an array of numbers in [west, south, east, north] order.
        *
        * @group Geography and Geometry
        *
        * @example
        * ```ts
        * let v1 = new LngLatBounds(
        *   new LngLat(-73.9876, 40.7661),
        *   new LngLat(-73.9397, 40.8002)
        * );
        * let v2 = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002])
        * let v3 = [[-73.9876, 40.7661], [-73.9397, 40.8002]];
        * ```
        */
    export type LngLatBoundsLike = LngLatBounds | [LngLatLike, LngLatLike] | [number, number, number, number];
    /**
        * A `LngLatBounds` object represents a geographical bounding box,
        * defined by its southwest and northeast points in longitude and latitude.
        *
        * If no arguments are provided to the constructor, a `null` bounding box is created.
        *
        * Note that any Mapbox GL method that accepts a `LngLatBounds` object as an argument or option
        * can also accept an `Array` of two {@link LngLatLike} constructs and will perform an implicit conversion.
        * This flexible type is documented as {@link LngLatBoundsLike}.
        *
        * @group Geography and Geometry
        *
        * @example
        * ```ts
        * let sw = new LngLat(-73.9876, 40.7661);
        * let ne = new LngLat(-73.9397, 40.8002);
        * let llb = new LngLatBounds(sw, ne);
        * ```
        */
    export class LngLatBounds {
            _ne: LngLat;
            _sw: LngLat;
            /**
                * @param sw - The southwest corner of the bounding box.
                * OR array of 4 numbers in the order of  west, south, east, north
                * OR array of 2 LngLatLike: [sw,ne]
                * @param ne - The northeast corner of the bounding box.
                * @example
                * ```ts
                * let sw = new LngLat(-73.9876, 40.7661);
                * let ne = new LngLat(-73.9397, 40.8002);
                * let llb = new LngLatBounds(sw, ne);
                * ```
                * OR
                * ```ts
                * let llb = new LngLatBounds([-73.9876, 40.7661, -73.9397, 40.8002]);
                * ```
                * OR
                * ```ts
                * let llb = new LngLatBounds([sw, ne]);
                * ```
                */
            constructor(sw?: LngLatLike | [number, number, number, number] | [LngLatLike, LngLatLike], ne?: LngLatLike);
            /**
                * Set the northeast corner of the bounding box
                *
                * @param ne - a {@link LngLatLike} object describing the northeast corner of the bounding box.
                * @returns `this`
                */
            setNorthEast(ne: LngLatLike): this;
            /**
                * Set the southwest corner of the bounding box
                *
                * @param sw - a {@link LngLatLike} object describing the southwest corner of the bounding box.
                * @returns `this`
                */
            setSouthWest(sw: LngLatLike): this;
            /**
                * Extend the bounds to include a given LngLatLike or LngLatBoundsLike.
                *
                * @param obj - object to extend to
                * @returns `this`
                */
            extend(obj: LngLatLike | LngLatBoundsLike): this;
            /**
                * Returns the geographical coordinate equidistant from the bounding box's corners.
                *
                * @returns The bounding box's center.
                * @example
                * ```ts
                * let llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);
                * llb.getCenter(); // = LngLat {lng: -73.96365, lat: 40.78315}
                * ```
                */
            getCenter(): LngLat;
            /**
                * Returns the southwest corner of the bounding box.
                *
                * @returns The southwest corner of the bounding box.
                */
            getSouthWest(): LngLat;
            /**
                * Returns the northeast corner of the bounding box.
                *
                * @returns The northeast corner of the bounding box.
                */
            getNorthEast(): LngLat;
            /**
                * Returns the northwest corner of the bounding box.
                *
                * @returns The northwest corner of the bounding box.
                */
            getNorthWest(): LngLat;
            /**
                * Returns the southeast corner of the bounding box.
                *
                * @returns The southeast corner of the bounding box.
                */
            getSouthEast(): LngLat;
            /**
                * Returns the west edge of the bounding box.
                *
                * @returns The west edge of the bounding box.
                */
            getWest(): number;
            /**
                * Returns the south edge of the bounding box.
                *
                * @returns The south edge of the bounding box.
                */
            getSouth(): number;
            /**
                * Returns the east edge of the bounding box.
                *
                * @returns The east edge of the bounding box.
                */
            getEast(): number;
            /**
                * Returns the north edge of the bounding box.
                *
                * @returns The north edge of the bounding box.
                */
            getNorth(): number;
            /**
                * Returns the bounding box represented as an array.
                *
                * @returns The bounding box represented as an array, consisting of the
                * southwest and northeast coordinates of the bounding represented as arrays of numbers.
                * @example
                * ```ts
                * let llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);
                * llb.toArray(); // = [[-73.9876, 40.7661], [-73.9397, 40.8002]]
                * ```
                */
            toArray(): [number, number][];
            /**
                * Return the bounding box represented as a string.
                *
                * @returns The bounding box represents as a string of the format
                * `'LngLatBounds(LngLat(lng, lat), LngLat(lng, lat))'`.
                * @example
                * ```ts
                * let llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);
                * llb.toString(); // = "LngLatBounds(LngLat(-73.9876, 40.7661), LngLat(-73.9397, 40.8002))"
                * ```
                */
            toString(): string;
            /**
                * Check if the bounding box is an empty/`null`-type box.
                *
                * @returns True if bounds have been defined, otherwise false.
                */
            isEmpty(): boolean;
            /**
                * Check if the point is within the bounding box.
                *
                * @param lnglat - geographic point to check against.
                * @returns `true` if the point is within the bounding box.
                * @example
                * ```ts
                * let llb = new LngLatBounds(
                *   new LngLat(-73.9876, 40.7661),
                *   new LngLat(-73.9397, 40.8002)
                * );
                *
                * let ll = new LngLat(-73.9567, 40.7789);
                *
                * console.log(llb.contains(ll)); // = true
                * ```
                */
            contains(lnglat: LngLatLike): boolean;
            /**
                * Converts an array to a `LngLatBounds` object.
                *
                * If a `LngLatBounds` object is passed in, the function returns it unchanged.
                *
                * Internally, the function calls `LngLat#convert` to convert arrays to `LngLat` values.
                *
                * @param input - An array of two coordinates to convert, or a `LngLatBounds` object to return.
                * @returns A new `LngLatBounds` object, if a conversion occurred, or the original `LngLatBounds` object.
                * @example
                * ```ts
                * let arr = [[-73.9876, 40.7661], [-73.9397, 40.8002]];
                * let llb = LngLatBounds.convert(arr); // = LngLatBounds {_sw: LngLat {lng: -73.9876, lat: 40.7661}, _ne: LngLat {lng: -73.9397, lat: 40.8002}}
                * ```
                */
            static convert(input: LngLatBoundsLike | null): LngLatBounds;
            /**
                * Returns a `LngLatBounds` from the coordinates extended by a given `radius`. The returned `LngLatBounds` completely contains the `radius`.
                *
                * @param center - center coordinates of the new bounds.
                * @param radius - Distance in meters from the coordinates to extend the bounds.
                * @returns A new `LngLatBounds` object representing the coordinates extended by the `radius`.
                * @example
                * ```ts
                * let center = new LngLat(-73.9749, 40.7736);
                * LngLatBounds.fromLngLat(100).toArray(); // = [[-73.97501862141328, 40.77351016847229], [-73.97478137858673, 40.77368983152771]]
                * ```
                */
            static fromLngLat(center: LngLat, radius?: number): LngLatBounds;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/mercator_coordinate' {
    import { LngLat } from '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/lng_lat';
    import type { LngLatLike } from '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/lng_lat';
    import { IMercatorCoordinate } from '@maplibre/maplibre-gl-style-spec';
    export function mercatorXfromLng(lng: number): number;
    export function mercatorYfromLat(lat: number): number;
    export function mercatorZfromAltitude(altitude: number, lat: number): number;
    export function lngFromMercatorX(x: number): number;
    export function latFromMercatorY(y: number): number;
    export function altitudeFromMercatorZ(z: number, y: number): number;
    /**
        * Determine the Mercator scale factor for a given latitude, see
        * https://en.wikipedia.org/wiki/Mercator_projection#Scale_factor
        *
        * At the equator the scale factor will be 1, which increases at higher latitudes.
        *
        * @param lat - Latitude
        * @returns scale factor
        */
    export function mercatorScale(lat: number): number;
    /**
        * A `MercatorCoordinate` object represents a projected three dimensional position.
        *
        * `MercatorCoordinate` uses the web mercator projection ([EPSG:3857](https://epsg.io/3857)) with slightly different units:
        *
        * - the size of 1 unit is the width of the projected world instead of the "mercator meter"
        * - the origin of the coordinate space is at the north-west corner instead of the middle
        *
        * For example, `MercatorCoordinate(0, 0, 0)` is the north-west corner of the mercator world and
        * `MercatorCoordinate(1, 1, 0)` is the south-east corner. If you are familiar with
        * [vector tiles](https://github.com/mapbox/vector-tile-spec) it may be helpful to think
        * of the coordinate space as the `0/0/0` tile with an extent of `1`.
        *
        * The `z` dimension of `MercatorCoordinate` is conformal. A cube in the mercator coordinate space would be rendered as a cube.
        *
        * @group Geography and Geometry
        *
        * @example
        * ```ts
        * let nullIsland = new MercatorCoordinate(0.5, 0.5, 0);
        * ```
        * @see [Add a custom style layer](https://maplibre.org/maplibre-gl-js/docs/examples/custom-style-layer/)
        */
    export class MercatorCoordinate implements IMercatorCoordinate {
            x: number;
            y: number;
            z: number;
            /**
                * @param x - The x component of the position.
                * @param y - The y component of the position.
                * @param z - The z component of the position.
                */
            constructor(x: number, y: number, z?: number);
            /**
                * Project a `LngLat` to a `MercatorCoordinate`.
                *
                * @param lngLatLike - The location to project.
                * @param altitude - The altitude in meters of the position.
                * @returns The projected mercator coordinate.
                * @example
                * ```ts
                * let coord = MercatorCoordinate.fromLngLat({ lng: 0, lat: 0}, 0);
                * coord; // MercatorCoordinate(0.5, 0.5, 0)
                * ```
                */
            static fromLngLat(lngLatLike: LngLatLike, altitude?: number): MercatorCoordinate;
            /**
                * Returns the `LngLat` for the coordinate.
                *
                * @returns The `LngLat` object.
                * @example
                * ```ts
                * let coord = new MercatorCoordinate(0.5, 0.5, 0);
                * let lngLat = coord.toLngLat(); // LngLat(0, 0)
                * ```
                */
            toLngLat(): LngLat;
            /**
                * Returns the altitude in meters of the coordinate.
                *
                * @returns The altitude in meters.
                * @example
                * ```ts
                * let coord = new MercatorCoordinate(0, 0, 0.02);
                * coord.toAltitude(); // 6914.281956295339
                * ```
                */
            toAltitude(): number;
            /**
                * Returns the distance of 1 meter in `MercatorCoordinate` units at this latitude.
                *
                * For coordinates in real world units using meters, this naturally provides the scale
                * to transform into `MercatorCoordinate`s.
                *
                * @returns Distance of 1 meter in `MercatorCoordinate` units.
                */
            meterInMercatorCoordinateUnits(): number;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/util/evented' {
    /**
        * A listener method used as a callback to events
        */
    export type Listener = (a: any) => any;
    type Listeners = {
            [_: string]: Array<Listener>;
    };
    /**
        * The event class
        */
    export class Event {
            readonly type: string;
            constructor(type: string, data?: any);
    }
    interface ErrorLike {
            message: string;
    }
    /**
        * An error event
        */
    export class ErrorEvent extends Event {
            error: ErrorLike;
            constructor(error: ErrorLike, data?: any);
    }
    /**
        * Methods mixed in to other classes for event capabilities.
        *
        * @group Event Related
        */
    export class Evented {
            _listeners: Listeners;
            _oneTimeListeners: Listeners;
            _eventedParent: Evented;
            _eventedParentData: any | (() => any);
            /**
                * Adds a listener to a specified event type.
                *
                * @param type - The event type to add a listen for.
                * @param listener - The function to be called when the event is fired.
                * The listener function is called with the data object passed to `fire`,
                * extended with `target` and `type` properties.
                * @returns `this`
                */
            on(type: string, listener: Listener): this;
            /**
                * Removes a previously registered event listener.
                *
                * @param type - The event type to remove listeners for.
                * @param listener - The listener function to remove.
                * @returns `this`
                */
            off(type: string, listener: Listener): this;
            /**
                * Adds a listener that will be called only once to a specified event type.
                *
                * The listener will be called first time the event fires after the listener is registered.
                *
                * @param type - The event type to listen for.
                * @param listener - The function to be called when the event is fired the first time.
                * @returns `this` or a promise if a listener is not provided
                */
            once(type: string, listener?: Listener): this | Promise<any>;
            fire(event: Event | string, properties?: any): this;
            /**
                * Returns a true if this instance of Evented or any forwardeed instances of Evented have a listener for the specified type.
                *
                * @param type - The event type
                * @returns `true` if there is at least one registered listener for specified event type, `false` otherwise
                */
            listens(type: string): boolean;
            /**
                * Bubble all events fired by this instance of Evented to this parent instance of Evented.
                * @returns `this`
                */
            setEventedParent(parent?: Evented | null, data?: any | (() => any)): this;
    }
    export {};
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/util/config' {
    import type { RequestParameters, GetResourceResponse } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/ajax';
    /**
        * This method type is used to register a protocol handler.
        * Use the abort controller for aborting requests.
        * Return a promise with the relevant resource response.
        */
    export type AddProtocolAction = (requestParameters: RequestParameters, abortController: AbortController) => Promise<GetResourceResponse<any>>;
    /**
        * This is a global config object used to store the configuration
        * It is available in the workers as well.
        * Only serializable data should be stored in it.
        */
    type Config = {
            MAX_PARALLEL_IMAGE_REQUESTS: number;
            MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: number;
            MAX_TILE_CACHE_ZOOM_LEVELS: number;
            REGISTERED_PROTOCOLS: {
                    [x: string]: AddProtocolAction;
            };
            WORKER_URL: string;
    };
    export const config: Config;
    export {};
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/util/global_worker_pool' {
    /**
        * Creates (if necessary) and returns the single, global WorkerPool instance
        * to be shared across each Map
        */
    export function getGlobalWorkerPool(): any;
    /**
        * Initializes resources like WebWorkers that can be shared across maps to lower load
        * times in some situations. `setWorkerUrl()` and `setWorkerCount()`, if being
        * used, must be set before `prewarm()` is called to have an effect.
        *
        * By default, the lifecycle of these resources is managed automatically, and they are
        * lazily initialized when a Map is first created. By invoking `prewarm()`, these
        * resources will be created ahead of time, and will not be cleared when the last Map
        * is removed from the page. This allows them to be re-used by new Map instances that
        * are created later. They can be manually cleared by calling
        * `clearPrewarmedResources()`. This is only necessary if your web page remains
        * active but stops using maps altogether.
        *
        * This is primarily useful when using GL-JS maps in a single page app, wherein a user
        * would navigate between various views that can cause Map instances to constantly be
        * created and destroyed.
        *
        * @example
        * ```ts
        * prewarm()
        * ```
        */
    export function prewarm(): void;
    /**
        * Clears up resources that have previously been created by `prewarm()`.
        * Note that this is typically not necessary. You should only call this function
        * if you expect the user of your app to not return to a Map view at any point
        * in your application.
        *
        * @example
        * ```ts
        * clearPrewarmedResources()
        * ```
        */
    export function clearPrewarmedResources(): void;
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/util/ajax' {
    /**
        * This is used to identify the global dispatcher id when sending a message from the worker without a target map id.
        */
    export const GLOBAL_DISPATCHER_ID = "global-dispatcher";
    /**
        * A type used to store the tile's expiration date and cache control definition
        */
    export type ExpiryData = {
            cacheControl?: string | null;
            expires?: Date | string | null;
    };
    /**
        * A `RequestParameters` object to be returned from Map.options.transformRequest callbacks.
        * @example
        * ```ts
        * // use transformRequest to modify requests that begin with `http://myHost`
        * transformRequest: function(url, resourceType) {
        *  if (resourceType === 'Source' && url.indexOf('http://myHost') > -1) {
        *    return {
        *      url: url.replace('http', 'https'),
        *      headers: { 'my-custom-header': true },
        *      credentials: 'include'  // Include cookies for cross-origin requests
        *    }
        *   }
        * }
        * ```
        */
    export type RequestParameters = {
            /**
                * The URL to be requested.
                */
            url: string;
            /**
                * The headers to be sent with the request.
                */
            headers?: any;
            /**
                * Request method `'GET' | 'POST' | 'PUT'`.
                */
            method?: 'GET' | 'POST' | 'PUT';
            /**
                * Request body.
                */
            body?: string;
            /**
                * Response body type to be returned.
                */
            type?: 'string' | 'json' | 'arrayBuffer' | 'image';
            /**
                * `'same-origin'|'include'` Use 'include' to send cookies with cross-origin requests.
                */
            credentials?: 'same-origin' | 'include';
            /**
                * If `true`, Resource Timing API information will be collected for these transformed requests and returned in a resourceTiming property of relevant data events.
                */
            collectResourceTiming?: boolean;
            /**
                * Parameters supported only by browser fetch API. Property of the Request interface contains the cache mode of the request. It controls how the request will interact with the browser's HTTP cache. (https://developer.mozilla.org/en-US/docs/Web/API/Request/cache)
                */
            cache?: RequestCache;
    };
    /**
        * The response object returned from a successful AJAx request
        */
    export type GetResourceResponse<T> = ExpiryData & {
            data: T;
    };
    /**
        * The response callback used in various places
        */
    export type ResponseCallback<T> = (error?: Error | null, data?: T | null, cacheControl?: string | null, expires?: string | Date | null) => void;
    /**
        * An error thrown when a HTTP request results in an error response.
        */
    export class AJAXError extends Error {
            /**
                * The response's HTTP status code.
                */
            status: number;
            /**
                * The response's HTTP status text.
                */
            statusText: string;
            /**
                * The request's URL.
                */
            url: string;
            /**
                * The response's body.
                */
            body: Blob;
            /**
                * @param status - The response's HTTP status code.
                * @param statusText - The response's HTTP status text.
                * @param url - The request's URL.
                * @param body - The response's body.
                */
            constructor(status: number, statusText: string, url: string, body: Blob);
    }
    /**
        * Ensure that we're sending the correct referrer from blob URL worker bundles.
        * For files loaded from the local file system, `location.origin` will be set
        * to the string(!) "null" (Firefox), or "file://" (Chrome, Safari, Edge),
        * and we will set an empty referrer. Otherwise, we're using the document's URL.
        */
    export const getReferrer: () => string;
    /**
        * We're trying to use the Fetch API if possible. However, requests for resources with the file:// URI scheme don't work with the Fetch API.
        * In this case we unconditionally use XHR on the current thread since referrers don't matter.
        * This method can also use the registered method if `addProtocol` was called.
        * @param requestParameters - The request parameters
        * @param abortController - The abort controller allowing to cancel the request
        * @returns a promise resolving to the response, including cache control and expiry data
        */
    export const makeRequest: (requestParameters: RequestParameters, abortController: AbortController) => Promise<GetResourceResponse<any>>;
    export const getJSON: <T>(requestParameters: RequestParameters, abortController: AbortController) => Promise<{
            data: T;
    } & ExpiryData>;
    export const getArrayBuffer: (requestParameters: RequestParameters, abortController: AbortController) => Promise<{
            data: ArrayBuffer;
    } & ExpiryData>;
    export function sameOrigin(inComingUrl: string): boolean;
    export const getVideo: (urls: Array<string>) => Promise<HTMLVideoElement>;
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/source/geojson_source' {
    import { Evented } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/evented';
    import type { Source } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/source';
    import type { Map } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/map';
    import type { Dispatcher } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/dispatcher';
    import type { Tile } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile';
    import type { Actor } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/actor';
    import type { GeoJSONSourceSpecification, PromoteIdSpecification } from '@maplibre/maplibre-gl-style-spec';
    import type { GeoJSONSourceDiff } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/geojson_source_diff';
    import type { GeoJSONWorkerOptions } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/geojson_worker_source';
    /**
        * Options object for GeoJSONSource.
        */
    export type GeoJSONSourceOptions = GeoJSONSourceSpecification & {
            workerOptions?: GeoJSONWorkerOptions;
            collectResourceTiming?: boolean;
            data: GeoJSON.GeoJSON | string;
    };
    export type GeoJSONSourceIntenalOptions = {
            data?: GeoJSON.GeoJSON | string | undefined;
            cluster?: boolean;
            clusterMaxZoom?: number;
            clusterRadius?: number;
            clusterMinPoints?: number;
            generateId?: boolean;
    };
    /**
        * The cluster options to set
        */
    export type SetClusterOptions = {
            /**
                * Whether or not to cluster
                */
            cluster?: boolean;
            /**
                * The cluster's max zoom
                */
            clusterMaxZoom?: number;
            /**
                * The cluster's radius
                */
            clusterRadius?: number;
    };
    /**
        * A source containing GeoJSON.
        * (See the [Style Specification](https://maplibre.org/maplibre-style-spec/#sources-geojson) for detailed documentation of options.)
        *
        * @group Sources
        *
        * @example
        * ```ts
        * map.addSource('some id', {
        *     type: 'geojson',
        *     data: 'https://d2ad6b4ur7yvpq.cloudfront.net/naturalearth-3.3.0/ne_10m_ports.geojson'
        * });
        * ```
        *
        * @example
        * ```ts
        * map.addSource('some id', {
        *    type: 'geojson',
        *    data: {
        *        "type": "FeatureCollection",
        *        "features": [{
        *            "type": "Feature",
        *            "properties": {},
        *            "geometry": {
        *                "type": "Point",
        *                "coordinates": [
        *                    -76.53063297271729,
        *                    39.18174077994108
        *                ]
        *            }
        *        }]
        *    }
        * });
        * ```
        *
        * @example
        * ```ts
        * map.getSource('some id').setData({
        *   "type": "FeatureCollection",
        *   "features": [{
        *       "type": "Feature",
        *       "properties": { "name": "Null Island" },
        *       "geometry": {
        *           "type": "Point",
        *           "coordinates": [ 0, 0 ]
        *       }
        *   }]
        * });
        * ```
        * @see [Draw GeoJSON points](https://maplibre.org/maplibre-gl-js/docs/examples/geojson-markers/)
        * @see [Add a GeoJSON line](https://maplibre.org/maplibre-gl-js/docs/examples/geojson-line/)
        * @see [Create a heatmap from points](https://maplibre.org/maplibre-gl-js/docs/examples/heatmap/)
        * @see [Create and style clusters](https://maplibre.org/maplibre-gl-js/docs/examples/cluster/)
        */
    export class GeoJSONSource extends Evented implements Source {
            type: 'geojson';
            id: string;
            minzoom: number;
            maxzoom: number;
            tileSize: number;
            attribution: string;
            promoteId: PromoteIdSpecification;
            isTileClipped: boolean;
            reparseOverscaled: boolean;
            _data: GeoJSON.GeoJSON | string | undefined;
            _options: GeoJSONSourceIntenalOptions;
            workerOptions: GeoJSONWorkerOptions;
            map: Map;
            actor: Actor;
            _pendingLoads: number;
            _collectResourceTiming: boolean;
            _removed: boolean;
            /** @internal */
            constructor(id: string, options: GeoJSONSourceOptions, dispatcher: Dispatcher, eventedParent: Evented);
            load(): Promise<void>;
            onAdd(map: Map): void;
            /**
                * Sets the GeoJSON data and re-renders the map.
                *
                * @param data - A GeoJSON data object or a URL to one. The latter is preferable in the case of large GeoJSON files.
                * @returns `this`
                */
            setData(data: GeoJSON.GeoJSON | string): this;
            /**
                * Updates the source's GeoJSON, and re-renders the map.
                *
                * For sources with lots of features, this method can be used to make updates more quickly.
                *
                * This approach requires unique IDs for every feature in the source. The IDs can either be specified on the feature,
                * or by using the promoteId option to specify which property should be used as the ID.
                *
                * It is an error to call updateData on a source that did not have unique IDs for each of its features already.
                *
                * Updates are applied on a best-effort basis, updating an ID that does not exist will not result in an error.
                *
                * @param diff - The changes that need to be applied.
                * @returns `this`
                */
            updateData(diff: GeoJSONSourceDiff): this;
            /**
                * To disable/enable clustering on the source options
                * @param options - The options to set
                * @returns `this`
                * @example
                * ```ts
                * map.getSource('some id').setClusterOptions({cluster: false});
                * map.getSource('some id').setClusterOptions({cluster: false, clusterRadius: 50, clusterMaxZoom: 14});
                * ```
                */
            setClusterOptions(options: SetClusterOptions): this;
            /**
                * For clustered sources, fetches the zoom at which the given cluster expands.
                *
                * @param clusterId - The value of the cluster's `cluster_id` property.
                * @returns a promise that is resolved with the zoom number
                */
            getClusterExpansionZoom(clusterId: number): Promise<number>;
            /**
                * For clustered sources, fetches the children of the given cluster on the next zoom level (as an array of GeoJSON features).
                *
                * @param clusterId - The value of the cluster's `cluster_id` property.
                * @returns a promise that is resolved when the features are retrieved
                */
            getClusterChildren(clusterId: number): Promise<Array<GeoJSON.Feature>>;
            /**
                * For clustered sources, fetches the original points that belong to the cluster (as an array of GeoJSON features).
                *
                * @param clusterId - The value of the cluster's `cluster_id` property.
                * @param limit - The maximum number of features to return.
                * @param offset - The number of features to skip (e.g. for pagination).
                * @returns a promise that is resolved when the features are retreived
                * @example
                * Retrieve cluster leaves on click
                * ```ts
                * map.on('click', 'clusters', (e) => {
                *   let features = map.queryRenderedFeatures(e.point, {
                *     layers: ['clusters']
                *   });
                *
                *   let clusterId = features[0].properties.cluster_id;
                *   let pointCount = features[0].properties.point_count;
                *   let clusterSource = map.getSource('clusters');
                *
                *   const features = await clusterSource.getClusterLeaves(clusterId, pointCount) 0, function(error, features) {
                *   // Print cluster leaves in the console
                *   console.log('Cluster leaves:', features);
                * });
                * ```
                */
            getClusterLeaves(clusterId: number, limit: number, offset: number): Promise<Array<GeoJSON.Feature>>;
            /**
                * Responsible for invoking WorkerSource's geojson.loadData target, which
                * handles loading the geojson data and preparing to serve it up as tiles,
                * using geojson-vt or supercluster as appropriate.
                * @param diff - the diff object
                */
            _updateWorkerData(diff?: GeoJSONSourceDiff): Promise<void>;
            loaded(): boolean;
            loadTile(tile: Tile): Promise<void>;
            abortTile(tile: Tile): Promise<void>;
            unloadTile(tile: Tile): Promise<void>;
            onRemove(): void;
            serialize(): GeoJSONSourceSpecification;
            hasTransition(): boolean;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/source/canvas_source' {
    import { ImageSource } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/image_source';
    import type { Map } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/map';
    import type { Dispatcher } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/dispatcher';
    import type { Evented } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/evented';
    /**
        * Options to add a canvas source type to the map.
        */
    export type CanvasSourceSpecification = {
            /**
                * Source type. Must be `"canvas"`.
                */
            type: 'canvas';
            /**
                * Four geographical coordinates denoting where to place the corners of the canvas, specified in `[longitude, latitude]` pairs.
                */
            coordinates: [[number, number], [number, number], [number, number], [number, number]];
            /**
                * Whether the canvas source is animated. If the canvas is static (i.e. pixels do not need to be re-read on every frame), `animate` should be set to `false` to improve performance.
                * @defaultValue true
                */
            animate?: boolean;
            /**
                * Canvas source from which to read pixels. Can be a string representing the ID of the canvas element, or the `HTMLCanvasElement` itself.
                */
            canvas?: string | HTMLCanvasElement;
    };
    /**
        * A data source containing the contents of an HTML canvas. See {@link CanvasSourceSpecification} for detailed documentation of options.
        *
        * @group Sources
        *
        * @example
        * ```ts
        * // add to map
        * map.addSource('some id', {
        *    type: 'canvas',
        *    canvas: 'idOfMyHTMLCanvas',
        *    animate: true,
        *    coordinates: [
        *        [-76.54, 39.18],
        *        [-76.52, 39.18],
        *        [-76.52, 39.17],
        *        [-76.54, 39.17]
        *    ]
        * });
        *
        * // update
        * let mySource = map.getSource('some id');
        * mySource.setCoordinates([
        *     [-76.54335737228394, 39.18579907229748],
        *     [-76.52803659439087, 39.1838364847587],
        *     [-76.5295386314392, 39.17683392507606],
        *     [-76.54520273208618, 39.17876344106642]
        * ]);
        *
        * map.removeSource('some id');  // remove
        * ```
        */
    export class CanvasSource extends ImageSource {
            options: CanvasSourceSpecification;
            animate: boolean;
            canvas: HTMLCanvasElement;
            width: number;
            height: number;
            /**
                * Enables animation. The image will be copied from the canvas to the map on each frame.
                */
            play: () => void;
            /**
                * Disables animation. The map will display a static copy of the canvas image.
                */
            pause: () => void;
            _playing: boolean;
            /** @internal */
            constructor(id: string, options: CanvasSourceSpecification, dispatcher: Dispatcher, eventedParent: Evented);
            load(): Promise<void>;
            /**
                * Returns the HTML `canvas` element.
                *
                * @returns The HTML `canvas` element.
                */
            getCanvas(): HTMLCanvasElement;
            onAdd(map: Map): void;
            onRemove(): void;
            prepare(): void;
            serialize(): CanvasSourceSpecification;
            hasTransition(): boolean;
            _hasInvalidDimensions(): boolean;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/source/image_source' {
    import { CanonicalTileID } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile_id';
    import { Evented } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/evented';
    import { RasterBoundsArray } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/array_types.g';
    import { SegmentVector } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/segment';
    import { Texture } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/texture';
    import { MercatorCoordinate } from '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/mercator_coordinate';
    import type { Source } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/source';
    import type { CanvasSourceSpecification } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/canvas_source';
    import type { Map } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/map';
    import type { Dispatcher } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/dispatcher';
    import type { Tile } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile';
    import type { VertexBuffer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/vertex_buffer';
    import type { ImageSourceSpecification, VideoSourceSpecification } from '@maplibre/maplibre-gl-style-spec';
    /**
        * Four geographical coordinates,
        * represented as arrays of longitude and latitude numbers, which define the corners of the image.
        * The coordinates start at the top left corner of the image and proceed in clockwise order.
        * They do not have to represent a rectangle.
        */
    export type Coordinates = [[number, number], [number, number], [number, number], [number, number]];
    /**
        * The options object for the {@link ImageSource#updateImage} method
        */
    export type UpdateImageOptions = {
            /**
                * Required image URL.
                */
            url: string;
            /**
                * The image coordinates
                */
            coordinates?: Coordinates;
    };
    /**
        * A data source containing an image.
        * (See the [Style Specification](https://maplibre.org/maplibre-style-spec/#sources-image) for detailed documentation of options.)
        *
        * @group Sources
        *
        * @example
        * ```ts
        * // add to map
        * map.addSource('some id', {
        *    type: 'image',
        *    url: 'https://www.maplibre.org/images/foo.png',
        *    coordinates: [
        *        [-76.54, 39.18],
        *        [-76.52, 39.18],
        *        [-76.52, 39.17],
        *        [-76.54, 39.17]
        *    ]
        * });
        *
        * // update coordinates
        * let mySource = map.getSource('some id');
        * mySource.setCoordinates([
        *     [-76.54335737228394, 39.18579907229748],
        *     [-76.52803659439087, 39.1838364847587],
        *     [-76.5295386314392, 39.17683392507606],
        *     [-76.54520273208618, 39.17876344106642]
        * ]);
        *
        * // update url and coordinates simultaneously
        * mySource.updateImage({
        *    url: 'https://www.maplibre.org/images/bar.png',
        *    coordinates: [
        *        [-76.54335737228394, 39.18579907229748],
        *        [-76.52803659439087, 39.1838364847587],
        *        [-76.5295386314392, 39.17683392507606],
        *        [-76.54520273208618, 39.17876344106642]
        *    ]
        * })
        *
        * map.removeSource('some id');  // remove
        * ```
        */
    export class ImageSource extends Evented implements Source {
            type: string;
            id: string;
            minzoom: number;
            maxzoom: number;
            tileSize: number;
            url: string;
            coordinates: Coordinates;
            tiles: {
                    [_: string]: Tile;
            };
            options: any;
            dispatcher: Dispatcher;
            map: Map;
            texture: Texture | null;
            image: HTMLImageElement | ImageBitmap;
            tileID: CanonicalTileID;
            _boundsArray: RasterBoundsArray;
            boundsBuffer: VertexBuffer;
            boundsSegments: SegmentVector;
            _loaded: boolean;
            _request: AbortController;
            /** @internal */
            constructor(id: string, options: ImageSourceSpecification | VideoSourceSpecification | CanvasSourceSpecification, dispatcher: Dispatcher, eventedParent: Evented);
            load(newCoordinates?: Coordinates): Promise<void>;
            loaded(): boolean;
            /**
                * Updates the image URL and, optionally, the coordinates. To avoid having the image flash after changing,
                * set the `raster-fade-duration` paint property on the raster layer to 0.
                *
                * @param options - The options object.
                * @returns `this`
                */
            updateImage(options: UpdateImageOptions): this;
            _finishLoading(): void;
            onAdd(map: Map): void;
            onRemove(): void;
            /**
                * Sets the image's coordinates and re-renders the map.
                *
                * @param coordinates - Four geographical coordinates,
                * represented as arrays of longitude and latitude numbers, which define the corners of the image.
                * The coordinates start at the top left corner of the image and proceed in clockwise order.
                * They do not have to represent a rectangle.
                * @returns `this`
                */
            setCoordinates(coordinates: Coordinates): this;
            prepare(): void;
            loadTile(tile: Tile): Promise<void>;
            serialize(): ImageSourceSpecification | VideoSourceSpecification | CanvasSourceSpecification;
            hasTransition(): boolean;
    }
    /**
        * Given a list of coordinates, get their center as a coordinate.
        *
        * @returns centerpoint
        * @internal
        */
    export function getCoordinatesCenterTileID(coords: Array<MercatorCoordinate>): CanonicalTileID;
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/source/raster_dem_tile_source' {
    import { Evented } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/evented';
    import { OverscaledTileID } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile_id';
    import { RasterTileSource } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/raster_tile_source';
    import '../data/dem_data';
    import type { DEMEncoding } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/dem_data';
    import type { Source } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/source';
    import type { Dispatcher } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/dispatcher';
    import type { Tile } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile';
    import type { RasterDEMSourceSpecification } from '@maplibre/maplibre-gl-style-spec';
    import { RGBAImage } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/image';
    /**
      * A source containing raster DEM tiles (See the [Style Specification](https://maplibre.org/maplibre-style-spec/) for detailed documentation of options.)
      * This source can be used to show hillshading and 3D terrain
      *
      * @group Sources
      *
      * @example
      * ```ts
      * map.addSource('raster-dem-source', {
      *      type: 'raster-dem',
      *      url: 'https://demotiles.maplibre.org/terrain-tiles/tiles.json',
      *      tileSize: 256
      * });
      * ```
      * @see [3D Terrain](https://maplibre.org/maplibre-gl-js/docs/examples/3d-terrain/)
      */
    export class RasterDEMTileSource extends RasterTileSource implements Source {
        encoding: DEMEncoding;
        redFactor?: number;
        greenFactor?: number;
        blueFactor?: number;
        baseShift?: number;
        constructor(id: string, options: RasterDEMSourceSpecification, dispatcher: Dispatcher, eventedParent: Evented);
        loadTile(tile: Tile): Promise<void>;
        readImageNow(img: ImageBitmap | HTMLImageElement): Promise<RGBAImage | ImageData>;
        _getNeighboringTiles(tileID: OverscaledTileID): {};
        unloadTile(tile: Tile): Promise<void>;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/source/raster_tile_source' {
    import { Evented } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/evented';
    import { TileBounds } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile_bounds';
    import type { Source } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/source';
    import type { OverscaledTileID } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile_id';
    import type { Map } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/map';
    import type { Dispatcher } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/dispatcher';
    import type { Tile } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile';
    import type { RasterSourceSpecification, RasterDEMSourceSpecification } from '@maplibre/maplibre-gl-style-spec';
    /**
        * A source containing raster tiles (See the [Style Specification](https://maplibre.org/maplibre-style-spec/) for detailed documentation of options.)
        *
        * @group Sources
        *
        * @example
        * ```ts
        * map.addSource('raster-source', {
        *     'type': 'raster',
        *     'tiles': ['https://tiles.stadiamaps.com/tiles/stamen_watercolor/{z}/{x}/{y}.jpg'],
        *     'tileSize': 256,
        * });
        * ```
        *
        * @example
        * ```ts
        * map.addSource('wms-test-source', {
        *      'type': 'raster',
        * // use the tiles option to specify a WMS tile source URL
        *      'tiles': [
        *          'https://img.nj.gov/imagerywms/Natural2015?bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&srs=EPSG:3857&transparent=true&width=256&height=256&layers=Natural2015'
        *      ],
        *      'tileSize': 256
        * });
        * ```
        * @see [Add a raster tile source](https://maplibre.org/maplibre-gl-js/docs/examples/map-tiles/)
        * @see [Add a WMS source](https://maplibre.org/maplibre-gl-js/docs/examples/wms/)
        * @see [Display a satellite map](https://maplibre.org/maplibre-gl-js/docs/examples/satellite-map/)
        */
    export class RasterTileSource extends Evented implements Source {
            type: 'raster' | 'raster-dem';
            id: string;
            minzoom: number;
            maxzoom: number;
            url: string;
            scheme: string;
            tileSize: number;
            bounds: [number, number, number, number];
            tileBounds: TileBounds;
            roundZoom: boolean;
            dispatcher: Dispatcher;
            map: Map;
            tiles: Array<string>;
            _loaded: boolean;
            _options: RasterSourceSpecification | RasterDEMSourceSpecification;
            _tileJSONRequest: AbortController;
            constructor(id: string, options: RasterSourceSpecification | RasterDEMSourceSpecification, dispatcher: Dispatcher, eventedParent: Evented);
            load(): Promise<void>;
            loaded(): boolean;
            onAdd(map: Map): void;
            onRemove(): void;
            setSourceProperty(callback: Function): void;
            /**
                * Sets the source `tiles` property and re-renders the map.
                *
                * @param tiles - An array of one or more tile source URLs, as in the raster tiles spec (See the [Style Specification](https://maplibre.org/maplibre-style-spec/)
                * @returns `this`
                */
            setTiles(tiles: Array<string>): this;
            /**
                * Sets the source `url` property and re-renders the map.
                *
                * @param url - A URL to a TileJSON resource. Supported protocols are `http:` and `https:`.
                * @returns `this`
                */
            setUrl(url: string): this;
            serialize(): RasterSourceSpecification | RasterDEMSourceSpecification;
            hasTile(tileID: OverscaledTileID): boolean;
            loadTile(tile: Tile): Promise<void>;
            abortTile(tile: Tile): Promise<void>;
            unloadTile(tile: Tile): Promise<void>;
            hasTransition(): boolean;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/source/vector_tile_source' {
    import { Evented } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/evented';
    import { TileBounds } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile_bounds';
    import type { Source } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/source';
    import type { OverscaledTileID } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile_id';
    import type { Map } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/map';
    import type { Dispatcher } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/dispatcher';
    import type { Tile } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile';
    import type { VectorSourceSpecification, PromoteIdSpecification } from '@maplibre/maplibre-gl-style-spec';
    export type VectorTileSourceOptions = VectorSourceSpecification & {
            collectResourceTiming?: boolean;
            tileSize?: number;
    };
    /**
        * A source containing vector tiles in [Mapbox Vector Tile format](https://docs.mapbox.com/vector-tiles/reference/).
        * (See the [Style Specification](https://maplibre.org/maplibre-style-spec/) for detailed documentation of options.)
        *
        * @group Sources
        *
        * @example
        * ```ts
        * map.addSource('some id', {
        *     type: 'vector',
        *     url: 'https://demotiles.maplibre.org/tiles/tiles.json'
        * });
        * ```
        *
        * @example
        * ```ts
        * map.addSource('some id', {
        *     type: 'vector',
        *     tiles: ['https://d25uarhxywzl1j.cloudfront.net/v0.1/{z}/{x}/{y}.mvt'],
        *     minzoom: 6,
        *     maxzoom: 14
        * });
        * ```
        *
        * @example
        * ```ts
        * map.getSource('some id').setUrl("https://demotiles.maplibre.org/tiles/tiles.json");
        * ```
        *
        * @example
        * ```ts
        * map.getSource('some id').setTiles(['https://d25uarhxywzl1j.cloudfront.net/v0.1/{z}/{x}/{y}.mvt']);
        * ```
        * @see [Add a vector tile source](https://maplibre.org/maplibre-gl-js/docs/examples/vector-source/)
        */
    export class VectorTileSource extends Evented implements Source {
            type: 'vector';
            id: string;
            minzoom: number;
            maxzoom: number;
            url: string;
            scheme: string;
            tileSize: number;
            promoteId: PromoteIdSpecification;
            _options: VectorSourceSpecification;
            _collectResourceTiming: boolean;
            dispatcher: Dispatcher;
            map: Map;
            bounds: [number, number, number, number];
            tiles: Array<string>;
            tileBounds: TileBounds;
            reparseOverscaled: boolean;
            isTileClipped: boolean;
            _tileJSONRequest: AbortController;
            _loaded: boolean;
            constructor(id: string, options: VectorTileSourceOptions, dispatcher: Dispatcher, eventedParent: Evented);
            load(): Promise<void>;
            loaded(): boolean;
            hasTile(tileID: OverscaledTileID): boolean;
            onAdd(map: Map): void;
            setSourceProperty(callback: Function): void;
            /**
                * Sets the source `tiles` property and re-renders the map.
                *
                * @param tiles - An array of one or more tile source URLs, as in the TileJSON spec.
                * @returns `this`
                */
            setTiles(tiles: Array<string>): this;
            /**
                * Sets the source `url` property and re-renders the map.
                *
                * @param url - A URL to a TileJSON resource. Supported protocols are `http:` and `https:`.
                * @returns `this`
                */
            setUrl(url: string): this;
            onRemove(): void;
            serialize(): VectorSourceSpecification;
            loadTile(tile: Tile): Promise<void>;
            abortTile(tile: Tile): Promise<void>;
            unloadTile(tile: Tile): Promise<void>;
            hasTransition(): boolean;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/source/video_source' {
    import { ImageSource } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/image_source';
    import type { Map } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/map';
    import type { Dispatcher } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/dispatcher';
    import type { Evented } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/evented';
    import type { VideoSourceSpecification } from '@maplibre/maplibre-gl-style-spec';
    /**
        * A data source containing video.
        * (See the [Style Specification](https://maplibre.org/maplibre-style-spec/#sources-video) for detailed documentation of options.)
        *
        * @group Sources
        *
        * @example
        * ```ts
        * // add to map
        * map.addSource('some id', {
        *    type: 'video',
        *    url: [
        *        'https://www.mapbox.com/blog/assets/baltimore-smoke.mp4',
        *        'https://www.mapbox.com/blog/assets/baltimore-smoke.webm'
        *    ],
        *    coordinates: [
        *        [-76.54, 39.18],
        *        [-76.52, 39.18],
        *        [-76.52, 39.17],
        *        [-76.54, 39.17]
        *    ]
        * });
        *
        * // update
        * let mySource = map.getSource('some id');
        * mySource.setCoordinates([
        *     [-76.54335737228394, 39.18579907229748],
        *     [-76.52803659439087, 39.1838364847587],
        *     [-76.5295386314392, 39.17683392507606],
        *     [-76.54520273208618, 39.17876344106642]
        * ]);
        *
        * map.removeSource('some id');  // remove
        * ```
        * @see [Add a video](https://maplibre.org/maplibre-gl-js/docs/examples/video-on-a-map/)
        *
        * Note that when rendered as a raster layer, the layer's `raster-fade-duration` property will cause the video to fade in.
        * This happens when playback is started, paused and resumed, or when the video's coordinates are updated. To avoid this behavior,
        * set the layer's `raster-fade-duration` property to `0`.
        */
    export class VideoSource extends ImageSource {
            options: VideoSourceSpecification;
            urls: Array<string>;
            video: HTMLVideoElement;
            roundZoom: boolean;
            constructor(id: string, options: VideoSourceSpecification, dispatcher: Dispatcher, eventedParent: Evented);
            load(): Promise<void>;
            /**
                * Pauses the video.
                */
            pause(): void;
            /**
                * Plays the video.
                */
            play(): void;
            /**
                * Sets playback to a timestamp, in seconds.
                */
            seek(seconds: number): void;
            /**
                * Returns the HTML `video` element.
                *
                * @returns The HTML `video` element.
                */
            getVideo(): HTMLVideoElement;
            onAdd(map: Map): void;
            /**
                * Sets the video's coordinates and re-renders the map.
                *
                * @returns `this`
                */
            prepare(): this;
            serialize(): VideoSourceSpecification;
            hasTransition(): boolean;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/source/source' {
    import { Dispatcher } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/dispatcher';
    import type { SourceSpecification } from '@maplibre/maplibre-gl-style-spec';
    import type { Event, Evented } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/evented';
    import type { Map } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/map';
    import type { Tile } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile';
    import type { OverscaledTileID, CanonicalTileID } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile_id';
    import type { CanvasSourceSpecification } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/canvas_source';
    /**
        * The `Source` interface must be implemented by each source type, including "core" types (`vector`, `raster`,
        * `video`, etc.) and all custom, third-party types.
        *
        * @event `data` - Fired with `{dataType: 'source', sourceDataType: 'metadata'}` to indicate that any necessary metadata
        * has been loaded so that it's okay to call `loadTile`; and with `{dataType: 'source', sourceDataType: 'content'}`
        * to indicate that the source data has changed, so that any current caches should be flushed.
        *
        * @group Sources
        */
    export interface Source {
            readonly type: string;
            /**
                * The id for the source. Must not be used by any existing source.
                */
            id: string;
            /**
                * The minimum zoom level for the source.
                */
            minzoom: number;
            /**
                * The maximum zoom level for the source.
                */
            maxzoom: number;
            /**
                * The tile size for the source.
                */
            tileSize: number;
            /**
                * The attribution for the source.
                */
            attribution?: string;
            /**
                * `true` if zoom levels are rounded to the nearest integer in the source data, `false` if they are floor-ed to the nearest integer.
                */
            roundZoom?: boolean;
            /**
                * `false` if tiles can be drawn outside their boundaries, `true` if they cannot.
                */
            isTileClipped?: boolean;
            tileID?: CanonicalTileID;
            /**
                * `true` if tiles should be sent back to the worker for each overzoomed zoom level, `false` if not.
                */
            reparseOverscaled?: boolean;
            vectorLayerIds?: Array<string>;
            /**
                * True if the source has transiotion, false otherwise.
                */
            hasTransition(): boolean;
            /**
                * True if the source is loaded, false otherwise.
                */
            loaded(): boolean;
            /**
                * An ability to fire an event to all the listeners, see {@link Evented}
                * @param event - The event to fire
                */
            fire(event: Event): unknown;
            /**
                * This method is called when the source is added to the map.
                * @param map - The map instance
                */
            onAdd?(map: Map): void;
            /**
                * This method is called when the source is removed from the map.
                * @param map - The map instance
                */
            onRemove?(map: Map): void;
            /**
                * This method does the heavy lifting of loading a tile.
                * In most cases it will defer the work to the relevant worker source.
                * @param tile - The tile to load
                */
            loadTile(tile: Tile): Promise<void>;
            /**
                * True is the tile is part of the source, false otherwise.
                * @param tileID - The tile ID
                */
            hasTile?(tileID: OverscaledTileID): boolean;
            /**
                * Allows to abort a tile loading.
                * @param tile - The tile to abort
                */
            abortTile?(tile: Tile): Promise<void>;
            /**
                * Allows to unload a tile.
                * @param tile - The tile to unload
                */
            unloadTile?(tile: Tile): Promise<void>;
            /**
                * @returns A plain (stringifiable) JS object representing the current state of the source.
                * Creating a source using the returned object as the `options` should result in a Source that is
                * equivalent to this one.
                */
            serialize(): any;
            /**
                * Allows to execute a prepare step before the source is used.
                */
            prepare?(): void;
    }
    /**
        * A general definition of a {@link Source} class for factory usage
        */
    export type SourceClass = {
            new (id: string, specification: SourceSpecification | CanvasSourceSpecification, dispatcher: Dispatcher, eventedParent: Evented): Source;
    };
    /**
        * Creates a tiled data source instance given an options object.
        *
        * @param id - The id for the source. Must not be used by any existing source.
        * @param specification - Source options, specific to the source type (except for `options.type`, which is always required).
        * @param source - A source definition object compliant with
        * [`maplibre-gl-style-spec`](https://maplibre.org/maplibre-style-spec/#sources) or, for a third-party source type,
        * with that type's requirements.
        * @param dispatcher - A {@link Dispatcher} instance, which can be used to send messages to the workers.
        * @returns a newly created source
        */
    export const create: (id: string, specification: SourceSpecification | CanvasSourceSpecification, dispatcher: Dispatcher, eventedParent: Evented) => Source;
    /**
        * Adds a [custom source type](#Custom Sources), making it available for use with
        * {@link Map#addSource}.
        * @param name - The name of the source type; source definition objects use this name in the `{type: ...}` field.
        * @param sourceType - A {@link SourceClass} - which is a constructor for the `Source` interface.
        * @returns a promise that is resolved when the source type is ready or rejected with an error.
        */
    export const addSourceType: (name: string, SourceType: SourceClass) => Promise<void>;
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/source/protocol_crud' {
    import { AddProtocolAction } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/config';
    export function getProtocol(url: string): AddProtocolAction;
    /**
        * Adds a custom load resource function that will be called when using a URL that starts with a custom url schema.
        * This will happen in the main thread, and workers might call it if they don't know how to handle the protocol.
        * The example below will be triggered for custom:// urls defined in the sources list in the style definitions.
        * The function passed will receive the request parameters and should return with the resulting resource,
        * for example a pbf vector tile, non-compressed, represented as ArrayBuffer.
        *
        * @param customProtocol - the protocol to hook, for example 'custom'
        * @param loadFn - the function to use when trying to fetch a tile specified by the customProtocol
        * @example
        * ```ts
        * // This will fetch a file using the fetch API (this is obviously a non interesting example...)
        * addProtocol('custom', async (params, abortController) => {
        *      const t = await fetch(`https://${params.url.split("://")[1]}`);
        *      if (t.status == 200) {
        *          const buffer = await t.arrayBuffer();
        *          return {data: buffer}
        *      } else {
        *          throw new Error(`Tile fetch error: ${t.statusText}`);
        *      }
        *  });
        * // the following is an example of a way to return an error when trying to load a tile
        * addProtocol('custom2', async (params, abortController) => {
        *      throw new Error('someErrorMessage'));
        * });
        * ```
        */
    export function addProtocol(customProtocol: string, loadFn: AddProtocolAction): void;
    /**
        * Removes a previously added protocol in the main thread.
        *
        * @param customProtocol - the custom protocol to remove registration for
        * @example
        * ```ts
        * removeProtocol('custom');
        * ```
        */
    export function removeProtocol(customProtocol: string): void;
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/control/control' {
    import type { Map } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/map';
    /**
        * A position defintion for the control to be placed, can be in one of the corners of the map.
        * When two or more controls are places in the same location they are stacked toward the center of the map.
        */
    export type ControlPosition = 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';
    /**
        * Interface for interactive controls added to the map. This is a
        * specification for implementers to model: it is not
        * an exported method or class.
        *
        * Controls must implement `onAdd` and `onRemove`, and must own an
        * element, which is often a `div` element. To use MapLibre GL JS's
        * default control styling, add the `maplibregl-ctrl` class to your control's
        * node.
        *
        * @example
        * Control implemented as ES6 class
        * ```ts
        * class HelloWorldControl {
        *     onAdd(map) {
        *         this._map = map;
        *         this._container = document.createElement('div');
        *         this._container.className = 'maplibregl-ctrl';
        *         this._container.textContent = 'Hello, world';
        *         return this._container;
        *     }
        *
        *     onRemove() {
        *         this._container.parentNode.removeChild(this._container);
        *         this._map = undefined;
        *     }
        * }
        *
        * // Control implemented as ES5 prototypical class
        * function HelloWorldControl() { }
        *
        * HelloWorldControl.prototype.onAdd = function(map) {
        *     this._map = map;
        *     this._container = document.createElement('div');
        *     this._container.className = 'maplibregl-ctrl';
        *     this._container.textContent = 'Hello, world';
        *     return this._container;
        * };
        *
        * HelloWorldControl.prototype.onRemove = function () {
        *      this._container.parentNode.removeChild(this._container);
        *      this._map = undefined;
        * };
        * ```
        */
    export interface IControl {
            /**
                * Register a control on the map and give it a chance to register event listeners
                * and resources. This method is called by {@link Map#addControl}
                * internally.
                *
                * @param map - the Map this control will be added to
                * @returns The control's container element. This should
                * be created by the control and returned by onAdd without being attached
                * to the DOM: the map will insert the control's element into the DOM
                * as necessary.
                */
            onAdd(map: Map): HTMLElement;
            /**
                * Unregister a control on the map and give it a chance to detach event listeners
                * and resources. This method is called by {@link Map#removeControl}
                * internally.
                *
                * @param map - the Map this control will be removed from
                */
            onRemove(map: Map): void;
            /**
                * Optionally provide a default position for this control. If this method
                * is implemented and {@link Map#addControl} is called without the `position`
                * parameter, the value returned by getDefaultPosition will be used as the
                * control's position.
                *
                * @returns a control position, one of the values valid in addControl.
                */
            readonly getDefaultPosition?: () => ControlPosition;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/edge_insets' {
    import Point from '@mapbox/point-geometry';
    /**
        * An `EdgeInset` object represents screen space padding applied to the edges of the viewport.
        * This shifts the apprent center or the vanishing point of the map. This is useful for adding floating UI elements
        * on top of the map and having the vanishing point shift as UI elements resize.
        *
        * @group Geography and Geometry
        */
    export class EdgeInsets {
            /**
                * @defaultValue 0
                */
            top: number;
            /**
                * @defaultValue 0
                */
            bottom: number;
            /**
                * @defaultValue 0
                */
            left: number;
            /**
                * @defaultValue 0
                */
            right: number;
            constructor(top?: number, bottom?: number, left?: number, right?: number);
            /**
                * Interpolates the inset in-place.
                * This maintains the current inset value for any inset not present in `target`.
                * @param start - interpolation start
                * @param target - interpolation target
                * @param t - interpolation step/weight
                * @returns the insets
                */
            interpolate(start: PaddingOptions | EdgeInsets, target: PaddingOptions, t: number): EdgeInsets;
            /**
                * Utility method that computes the new apprent center or vanishing point after applying insets.
                * This is in pixels and with the top left being (0.0) and +y being downwards.
                *
                * @param width - the width
                * @param height - the height
                * @returns the point
                */
            getCenter(width: number, height: number): Point;
            equals(other: PaddingOptions): boolean;
            clone(): EdgeInsets;
            /**
                * Returns the current state as json, useful when you want to have a
                * read-only representation of the inset.
                *
                * @returns state as json
                */
            toJSON(): PaddingOptions;
    }
    /**
        * Options for setting padding on calls to methods such as {@link Map#fitBounds}, {@link Map#fitScreenCoordinates}, and {@link Map#setPadding}. Adjust these options to set the amount of padding in pixels added to the edges of the canvas. Set a uniform padding on all edges or individual values for each edge. All properties of this object must be
        * non-negative integers.
        *
        * @group Geography and Geometry
        *
        * @example
        * ```ts
        * let bbox = [[-79, 43], [-73, 45]];
        * map.fitBounds(bbox, {
        *   padding: {top: 10, bottom:25, left: 15, right: 5}
        * });
        * ```
        *
        * @example
        * ```ts
        * let bbox = [[-79, 43], [-73, 45]];
        * map.fitBounds(bbox, {
        *   padding: 20
        * });
        * ```
        * @see [Fit to the bounds of a LineString](https://maplibre.org/maplibre-gl-js/docs/examples/zoomto-linestring/)
        * @see [Fit a map to a bounding box](https://maplibre.org/maplibre-gl-js/docs/examples/fitbounds/)
        */
    export type PaddingOptions = {
            /**
                * Padding in pixels from the top of the map canvas.
                */
            top: number;
            /**
                * Padding in pixels from the bottom of the map canvas.
                */
            bottom: number;
            /**
                * Padding in pixels from the left of the map canvas.
                */
            right: number;
            /**
                * Padding in pixels from the right of the map canvas.
                */
            left: number;
    };
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/events' {
    import { Event } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/evented';
    import Point from '@mapbox/point-geometry';
    import type { MapGeoJSONFeature } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/vectortile_to_geojson';
    import type { Map } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/map';
    import type { LngLat } from '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/lng_lat';
    import type { SourceSpecification } from '@maplibre/maplibre-gl-style-spec';
    /**
        * An event from the mouse relevant to a specific layer.
        *
        * @group Event Related
        */
    export type MapLayerMouseEvent = MapMouseEvent & {
            features?: MapGeoJSONFeature[];
    };
    /**
        * An event from a touch device relevat to a specific layer.
        *
        * @group Event Related
        */
    export type MapLayerTouchEvent = MapTouchEvent & {
            features?: MapGeoJSONFeature[];
    };
    /**
        * The source event data type
        */
    export type MapSourceDataType = 'content' | 'metadata' | 'visibility' | 'idle';
    /**
        * `MapLayerEventType` - a mapping between the event name and the event.
        * **Note:** These events are compatible with the optional `layerId` parameter.
        * If `layerId` is included as the second argument in {@link Map#on}, the event listener will fire only when the
        * event action contains a visible portion of the specified layer.
        * The following example can be used for all the events.
        *
        * @group Event Related
        * @example
        * ```ts
        * // Initialize the map
        * let map = new Map({ // map options });
        * // Set an event listener for a specific layer
        * map.on('the-event-name', 'poi-label', function(e) {
        *   console.log('An event has occurred on a visible portion of the poi-label layer');
        * });
        * ```
        */
    export type MapLayerEventType = {
            /**
                * Fired when a pointing device (usually a mouse) is pressed and released contains a visible portion of the specified layer.
                *
                * @see [Measure distances](https://maplibre.org/maplibre-gl-js/docs/examples/measure/)
                * @see [Center the map on a clicked symbol](https://maplibre.org/maplibre-gl-js/docs/examples/center-on-symbol/)
                */
            click: MapLayerMouseEvent;
            /**
                * Fired when a pointing device (usually a mouse) is pressed and released twice contains a visible portion of the specified layer.
                *
                * **Note:** Under normal conditions, this event will be preceded by two `click` events.
                */
            dblclick: MapLayerMouseEvent;
            /**
                * Fired when a pointing device (usually a mouse) is pressed while inside a visible portion of the specified layer.
                * @see [Create a draggable point](https://maplibre.org/maplibre-gl-js/docs/examples/drag-a-point/)
                */
            mousedown: MapLayerMouseEvent;
            /**
                * Fired when a pointing device (usually a mouse) is released while inside a visible portion of the specified layer.
                * @see [Create a draggable point](https://maplibre.org/maplibre-gl-js/docs/examples/drag-a-point/)
                */
            mouseup: MapLayerMouseEvent;
            /**
                * Fired when a pointing device (usually a mouse) is moved while the cursor is inside a visible portion of the specified layer.
                * As you move the cursor across the layer, the event will fire every time the cursor changes position within that layer.
                *
                * @see [Get coordinates of the mouse pointer](https://maplibre.org/maplibre-gl-js/docs/examples/mouse-position/)
                * @see [Highlight features under the mouse pointer](https://maplibre.org/maplibre-gl-js/docs/examples/hover-styles/)
                * @see [Display a popup on over](https://maplibre.org/maplibre-gl-js/docs/examples/popup-on-hover/)
                */
            mousemove: MapLayerMouseEvent;
            /**
                * Fired when a pointing device (usually a mouse) enters a visible portion of a specified layer from
                * outside that layer or outside the map canvas.
                *
                * @see [Center the map on a clicked symbol](https://maplibre.org/maplibre-gl-js/docs/examples/center-on-symbol/)
                * @see [Display a popup on click](https://maplibre.org/maplibre-gl-js/docs/examples/popup-on-click/)
                */
            mouseenter: MapLayerMouseEvent;
            /**
                * Fired when a pointing device (usually a mouse) leaves a visible portion of a specified layer, or leaves
                * the map canvas.
                *
                * @see [Highlight features under the mouse pointer](https://maplibre.org/maplibre-gl-js/docs/examples/hover-styles/)
                * @see [Display a popup on click](https://maplibre.org/maplibre-gl-js/docs/examples/popup-on-click/)
                */
            mouseleave: MapLayerMouseEvent;
            /**
                * Fired when a pointing device (usually a mouse) is moved inside a visible portion of the specified layer.
                *
                * @see [Get coordinates of the mouse pointer](https://maplibre.org/maplibre-gl-js/docs/examples/mouse-position/)
                * @see [Highlight features under the mouse pointer](https://maplibre.org/maplibre-gl-js/docs/examples/hover-styles/)
                * @see [Display a popup on hover](https://maplibre.org/maplibre-gl-js/docs/examples/popup-on-hover/)
                */
            mouseover: MapLayerMouseEvent;
            /**
                * Fired when a point device (usually a mouse) leaves the visible portion of the specified layer.
                */
            mouseout: MapLayerMouseEvent;
            /**
                * Fired when the right button of the mouse is clicked or the context menu key is pressed within visible portion of the specified layer.
                */
            contextmenu: MapLayerMouseEvent;
            /**
                * Fired when a [`touchstart`](https://developer.mozilla.org/en-US/docs/Web/Events/touchstart) event occurs within the visible portion of the specified layer.
                * @see [Create a draggable point](https://maplibre.org/maplibre-gl-js/docs/examples/drag-a-point/)
                */
            touchstart: MapLayerTouchEvent;
            /**
                * Fired when a [`touchend`](https://developer.mozilla.org/en-US/docs/Web/Events/touchend) event occurs within the visible portion of the specified layer.
                * @see [Create a draggable point](https://maplibre.org/maplibre-gl-js/docs/examples/drag-a-point/)
                */
            touchend: MapLayerTouchEvent;
            /**
                * Fired when a [`touchstart`](https://developer.mozilla.org/en-US/docs/Web/Events/touchstart) event occurs within the visible portion of the specified layer.
                * @see [Create a draggable point](https://maplibre.org/maplibre-gl-js/docs/examples/drag-a-point/)
                */
            touchcancel: MapLayerTouchEvent;
    };
    /**
        * `MapEventType` - a mapping between the event name and the event value.
        * These events are used with the {@link Map#on} method.
        * When using a `layerId` with {@link Map#on} method, please refer to {@link MapLayerEventType}.
        * The following example can be used for all the events.
        *
        * @group Event Related
        * @example
        * ```ts
        * // Initialize the map
        * let map = new Map({ // map options });
        * // Set an event listener
        * map.on('the-event-name', () => {
        *   console.log('An event has occurred!');
        * });
        * ```
        */
    export type MapEventType = {
            /**
                * Fired when an error occurs. This is GL JS's primary error reporting
                * mechanism. We use an event instead of `throw` to better accommodate
                * asynchronous operations. If no listeners are bound to the `error` event, the
                * error will be printed to the console.
                */
            error: ErrorEvent;
            /**
                * @event `load` Fired immediately after all necessary resources have been downloaded
                * and the first visually complete rendering of the map has occurred.
                *
                * @see [Draw GeoJSON points](https://maplibre.org/maplibre-gl-js/docs/examples/geojson-markers/)
                * @see [Add live realtime data](https://maplibre.org/maplibre-gl-js/docs/examples/live-geojson/)
                * @see [Animate a point](https://maplibre.org/maplibre-gl-js/docs/examples/animate-point-along-line/)
                */
            load: MapLibreEvent;
            /**
                * Fired after the last frame rendered before the map enters an
                * "idle" state:
                *
                * - No camera transitions are in progress
                * - All currently requested tiles have loaded
                * - All fade/transition animations have completed
                */
            idle: MapLibreEvent;
            /**
                * Fired immediately after the map has been removed with {@link Map#remove}.
                */
            remove: MapLibreEvent;
            /**
                * Fired whenever the map is drawn to the screen, as the result of
                *
                * - a change to the map's position, zoom, pitch, or bearing
                * - a change to the map's style
                * - a change to a GeoJSON source
                * - the loading of a vector tile, GeoJSON file, glyph, or sprite
                */
            render: MapLibreEvent;
            /**
                * Fired immediately after the map has been resized.
                */
            resize: MapLibreEvent;
            /**
                * Fired when the WebGL context is lost.
                */
            webglcontextlost: MapContextEvent;
            /**
                * Fired when the WebGL context is restored.
                */
            webglcontextrestored: MapContextEvent;
            /**
                * Fired when any map data (style, source, tile, etc) begins loading or
                * changing asynchronously. All `dataloading` events are followed by a `data`,
                * `dataabort` or `error` event.
                */
            dataloading: MapDataEvent;
            /**
                * Fired when any map data loads or changes. See {@link MapDataEvent} for more information.
                * @see [Display HTML clusters with custom properties](https://maplibre.org/maplibre-gl-js/docs/examples/cluster-html/)
                */
            data: MapDataEvent;
            tiledataloading: MapDataEvent;
            /**
                * Fired when one of the map's sources begins loading or changing asynchronously.
                * All `sourcedataloading` events are followed by a `sourcedata`, `sourcedataabort` or `error` event.
                */
            sourcedataloading: MapSourceDataEvent;
            /**
                * Fired when the map's style begins loading or changing asynchronously.
                * All `styledataloading` events are followed by a `styledata`
                * or `error` event.
                */
            styledataloading: MapStyleDataEvent;
            /**
                * Fired when one of the map's sources loads or changes, including if a tile belonging
                * to a source loads or changes.
                */
            sourcedata: MapSourceDataEvent;
            /**
                * Fired when the map's style loads or changes.
                */
            styledata: MapStyleDataEvent;
            /**
                * Fired when an icon or pattern needed by the style is missing. The missing image can
                * be added with {@link Map#addImage} within this event listener callback to prevent the image from
                * being skipped. This event can be used to dynamically generate icons and patterns.
                * @see [Generate and add a missing icon to the map](https://maplibre.org/maplibre-gl-js/docs/examples/add-image-missing-generated/)
                */
            styleimagemissing: MapStyleImageMissingEvent;
            /**
                * Fired when a request for one of the map's sources' tiles or data is aborted.
                */
            dataabort: MapDataEvent;
            /**
                * Fired when a request for one of the map's sources' data is aborted.
                */
            sourcedataabort: MapSourceDataEvent;
            /**
                * Fired when the user cancels a "box zoom" interaction, or when the bounding box does not meet the minimum size threshold.
                * See {@link BoxZoomHandler}.
                */
            boxzoomcancel: MapLibreZoomEvent;
            /**
                * Fired when a "box zoom" interaction starts. See {@link BoxZoomHandler}.
                */
            boxzoomstart: MapLibreZoomEvent;
            /**
                * Fired when a "box zoom" interaction ends.  See {@link BoxZoomHandler}.
                */
            boxzoomend: MapLibreZoomEvent;
            /**
                * Fired when a [`touchcancel`](https://developer.mozilla.org/en-US/docs/Web/Events/touchcancel) event occurs within the map.
                */
            touchcancel: MapTouchEvent;
            /**
                * Fired when a [`touchmove`](https://developer.mozilla.org/en-US/docs/Web/Events/touchmove) event occurs within the map.
                * @see [Create a draggable point](https://maplibre.org/maplibre-gl-js/docs/examples/drag-a-point/)
                */
            touchmove: MapTouchEvent;
            /**
                * Fired when a [`touchend`](https://developer.mozilla.org/en-US/docs/Web/Events/touchend) event occurs within the map.
                * @see [Create a draggable point](https://maplibre.org/maplibre-gl-js/docs/examples/drag-a-point/)
                */
            touchend: MapTouchEvent;
            /**
                * Fired when a [`touchstart`](https://developer.mozilla.org/en-US/docs/Web/Events/touchstart) event occurs within the map.
                * @see [Create a draggable point](https://maplibre.org/maplibre-gl-js/docs/examples/drag-a-point/)
                */
            touchstart: MapTouchEvent;
            /**
                * Fired when a pointing device (usually a mouse) is pressed and released at the same point on the map.
                *
                * @see [Measure distances](https://maplibre.org/maplibre-gl-js/docs/examples/measure/)
                * @see [Center the map on a clicked symbol](https://maplibre.org/maplibre-gl-js/docs/examples/center-on-symbol/)
                */
            click: MapMouseEvent;
            /**
                * Fired when the right button of the mouse is clicked or the context menu key is pressed within the map.
                */
            contextmenu: MapMouseEvent;
            /**
                * Fired when a pointing device (usually a mouse) is pressed and released twice at the same point on the map in rapid succession.
                *
                * **Note:** Under normal conditions, this event will be preceded by two `click` events.
                */
            dblclick: MapMouseEvent;
            /**
                * Fired when a pointing device (usually a mouse) is moved while the cursor is inside the map.
                * As you move the cursor across the map, the event will fire every time the cursor changes position within the map.
                *
                * @see [Get coordinates of the mouse pointer](https://maplibre.org/maplibre-gl-js/docs/examples/mouse-position/)
                * @see [Highlight features under the mouse pointer](https://maplibre.org/maplibre-gl-js/docs/examples/hover-styles/)
                * @see [Display a popup on over](https://maplibre.org/maplibre-gl-js/docs/examples/popup-on-hover/)
                */
            mousemove: MapMouseEvent;
            /**
                * Fired when a pointing device (usually a mouse) is released within the map.
                *
                * @see [Create a draggable point](https://maplibre.org/maplibre-gl-js/docs/examples/drag-a-point/)
                */
            mouseup: MapMouseEvent;
            /**
                * Fired when a pointing device (usually a mouse) is pressed within the map.
                *
                * @see [Create a draggable point](https://maplibre.org/maplibre-gl-js/docs/examples/drag-a-point/)
                */
            mousedown: MapMouseEvent;
            /**
                * Fired when a point device (usually a mouse) leaves the map's canvas.
                */
            mouseout: MapMouseEvent;
            /**
                * Fired when a pointing device (usually a mouse) is moved within the map.
                * As you move the cursor across a web page containing a map,
                * the event will fire each time it enters the map or any child elements.
                *
                * @see [Get coordinates of the mouse pointer](https://maplibre.org/maplibre-gl-js/docs/examples/mouse-position/)
                * @see [Highlight features under the mouse pointer](https://maplibre.org/maplibre-gl-js/docs/examples/hover-styles/)
                * @see [Display a popup on hover](https://maplibre.org/maplibre-gl-js/docs/examples/popup-on-hover/)
                */
            mouseover: MapMouseEvent;
            /**
                * Fired just before the map begins a transition from one
                * view to another, as the result of either user interaction or methods such as {@link Map#jumpTo}.
                *
                */
            movestart: MapLibreEvent<MouseEvent | TouchEvent | WheelEvent | undefined>;
            /**
                * Fired repeatedly during an animated transition from one view to
                * another, as the result of either user interaction or methods such as {@link Map#flyTo}.
                *
                * @see [Display HTML clusters with custom properties](https://maplibre.org/maplibre-gl-js/docs/examples/cluster-html/)
                */
            move: MapLibreEvent<MouseEvent | TouchEvent | WheelEvent | undefined>;
            /**
                * Fired just after the map completes a transition from one
                * view to another, as the result of either user interaction or methods such as {@link Map#jumpTo}.
                *
                * @see [Display HTML clusters with custom properties](https://maplibre.org/maplibre-gl-js/docs/examples/cluster-html/)
                */
            moveend: MapLibreEvent<MouseEvent | TouchEvent | WheelEvent | undefined>;
            /**
                * Fired just before the map begins a transition from one zoom level to another,
                * as the result of either user interaction or methods such as {@link Map#flyTo}.
                */
            zoomstart: MapLibreEvent<MouseEvent | TouchEvent | WheelEvent | undefined>;
            /**
                * Fired repeatedly during an animated transition from one zoom level to another,
                * as the result of either user interaction or methods such as {@link Map#flyTo}.
                */
            zoom: MapLibreEvent<MouseEvent | TouchEvent | WheelEvent | undefined>;
            /**
                * Fired just after the map completes a transition from one zoom level to another,
                * as the result of either user interaction or methods such as {@link Map#flyTo}.
                */
            zoomend: MapLibreEvent<MouseEvent | TouchEvent | WheelEvent | undefined>;
            /**
                * Fired when a "drag to rotate" interaction starts. See {@link DragRotateHandler}.
                */
            rotatestart: MapLibreEvent<MouseEvent | TouchEvent | undefined>;
            /**
                * Fired repeatedly during a "drag to rotate" interaction. See {@link DragRotateHandler}.
                */
            rotate: MapLibreEvent<MouseEvent | TouchEvent | undefined>;
            /**
                * Fired when a "drag to rotate" interaction ends. See {@link DragRotateHandler}.
                */
            rotateend: MapLibreEvent<MouseEvent | TouchEvent | undefined>;
            /**
                * Fired when a "drag to pan" interaction starts. See {@link DragPanHandler}.
                */
            dragstart: MapLibreEvent<MouseEvent | TouchEvent | undefined>;
            /**
                * Fired repeatedly during a "drag to pan" interaction. See {@link DragPanHandler}.
                */
            drag: MapLibreEvent<MouseEvent | TouchEvent | undefined>;
            /**
                * Fired when a "drag to pan" interaction ends. See {@link DragPanHandler}.
                * @see [Create a draggable marker](https://maplibre.org/maplibre-gl-js/docs/examples/drag-a-marker/)
                */
            dragend: MapLibreEvent<MouseEvent | TouchEvent | undefined>;
            /**
                * Fired whenever the map's pitch (tilt) begins a change as
                * the result of either user interaction or methods such as {@link Map#flyTo} .
                */
            pitchstart: MapLibreEvent<MouseEvent | TouchEvent | undefined>;
            /**
                * Fired repeatedly during the map's pitch (tilt) animation between
                * one state and another as the result of either user interaction
                * or methods such as {@link Map#flyTo}.
                */
            pitch: MapLibreEvent<MouseEvent | TouchEvent | undefined>;
            /**
                * Fired immediately after the map's pitch (tilt) finishes changing as
                * the result of either user interaction or methods such as {@link Map#flyTo}.
                */
            pitchend: MapLibreEvent<MouseEvent | TouchEvent | undefined>;
            /**
                * Fired when a [`wheel`](https://developer.mozilla.org/en-US/docs/Web/Events/wheel) event occurs within the map.
                */
            wheel: MapWheelEvent;
            /**
                * Fired when terrain is changed
                */
            terrain: MapTerrainEvent;
    };
    /**
        * The base event for MapLibre
        *
        * @group Event Related
        */
    export type MapLibreEvent<TOrig = unknown> = {
            type: keyof MapEventType | keyof MapLayerEventType;
            target: Map;
            originalEvent: TOrig;
    };
    /**
        * The style data event
        *
        * @group Event Related
        */
    export type MapStyleDataEvent = MapLibreEvent & {
            dataType: 'style';
    };
    /**
        * The source data event interface
        *
        * @group Event Related
        */
    export type MapSourceDataEvent = MapLibreEvent & {
            dataType: 'source';
            /**
                * True if the event has a `dataType` of `source` and the source has no outstanding network requests.
                */
            isSourceLoaded: boolean;
            /**
                * The [style spec representation of the source](https://maplibre.org/maplibre-style-spec/#sources) if the event has a `dataType` of `source`.
                */
            source: SourceSpecification;
            sourceId: string;
            sourceDataType: MapSourceDataType;
            /**
                * The tile being loaded or changed, if the event has a `dataType` of `source` and
                * the event is related to loading of a tile.
                */
            tile: any;
    };
    /**
        * `MapMouseEvent` is the event type for mouse-related map events.
        *
        * @group Event Related
        *
        * @example
        * ```ts
        * // The `click` event is an example of a `MapMouseEvent`.
        * // Set up an event listener on the map.
        * map.on('click', function(e) {
        *   // The event object (e) contains information like the
        *   // coordinates of the point on the map that was clicked.
        *   console.log('A click event has occurred at ' + e.lngLat);
        * });
        * ```
        */
    export class MapMouseEvent extends Event implements MapLibreEvent<MouseEvent> {
            /**
                * The event type
                */
            type: 'mousedown' | 'mouseup' | 'click' | 'dblclick' | 'mousemove' | 'mouseover' | 'mouseenter' | 'mouseleave' | 'mouseout' | 'contextmenu';
            /**
                * The `Map` object that fired the event.
                */
            target: Map;
            /**
                * The DOM event which caused the map event.
                */
            originalEvent: MouseEvent;
            /**
                * The pixel coordinates of the mouse cursor, relative to the map and measured from the top left corner.
                */
            point: Point;
            /**
                * The geographic location on the map of the mouse cursor.
                */
            lngLat: LngLat;
            /**
                * Prevents subsequent default processing of the event by the map.
                *
                * Calling this method will prevent the following default map behaviors:
                *
                *   * On `mousedown` events, the behavior of {@link DragPanHandler}
                *   * On `mousedown` events, the behavior of {@link DragRotateHandler}
                *   * On `mousedown` events, the behavior of {@link BoxZoomHandler}
                *   * On `dblclick` events, the behavior of {@link DoubleClickZoomHandler}
                *
                */
            preventDefault(): void;
            /**
                * `true` if `preventDefault` has been called.
                */
            get defaultPrevented(): boolean;
            _defaultPrevented: boolean;
            constructor(type: string, map: Map, originalEvent: MouseEvent, data?: any);
    }
    /**
        * `MapTouchEvent` is the event type for touch-related map events.
        *
        * @group Event Related
        */
    export class MapTouchEvent extends Event implements MapLibreEvent<TouchEvent> {
            /**
                * The event type.
                */
            type: 'touchstart' | 'touchmove' | 'touchend' | 'touchcancel';
            /**
                * The `Map` object that fired the event.
                */
            target: Map;
            /**
                * The DOM event which caused the map event.
                */
            originalEvent: TouchEvent;
            /**
                * The geographic location on the map of the center of the touch event points.
                */
            lngLat: LngLat;
            /**
                * The pixel coordinates of the center of the touch event points, relative to the map and measured from the top left
                * corner.
                */
            point: Point;
            /**
                * The array of pixel coordinates corresponding to a
                * [touch event's `touches`](https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent/touches) property.
                */
            points: Array<Point>;
            /**
                * The geographical locations on the map corresponding to a
                * [touch event's `touches`](https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent/touches) property.
                */
            lngLats: Array<LngLat>;
            /**
                * Prevents subsequent default processing of the event by the map.
                *
                * Calling this method will prevent the following default map behaviors:
                *
                *   * On `touchstart` events, the behavior of {@link DragPanHandler}
                *   * On `touchstart` events, the behavior of {@link TwoFingersTouchZoomRotateHandler}
                *
                */
            preventDefault(): void;
            /**
                * `true` if `preventDefault` has been called.
                */
            get defaultPrevented(): boolean;
            _defaultPrevented: boolean;
            constructor(type: string, map: Map, originalEvent: TouchEvent);
    }
    /**
        * `MapWheelEvent` is the event type for the `wheel` map event.
        *
        * @group Event Related
        */
    export class MapWheelEvent extends Event {
            /**
                * The event type.
                */
            type: 'wheel';
            /**
                * The `Map` object that fired the event.
                */
            target: Map;
            /**
                * The DOM event which caused the map event.
                */
            originalEvent: WheelEvent;
            /**
                * Prevents subsequent default processing of the event by the map.
                *
                * Calling this method will prevent the behavior of {@link ScrollZoomHandler}.
                */
            preventDefault(): void;
            /**
                * `true` if `preventDefault` has been called.
                */
            get defaultPrevented(): boolean;
            _defaultPrevented: boolean;
            /** */
            constructor(type: string, map: Map, originalEvent: WheelEvent);
    }
    /**
        * A `MapLibreZoomEvent` is the event type for the boxzoom-related map events emitted by the {@link BoxZoomHandler}.
        *
        * @group Event Related
        */
    export type MapLibreZoomEvent = {
            /**
                * The type of boxzoom event. One of `boxzoomstart`, `boxzoomend` or `boxzoomcancel`
                */
            type: 'boxzoomstart' | 'boxzoomend' | 'boxzoomcancel';
            /**
                * The `Map` instance that triggered the event
                */
            target: Map;
            /**
                * The DOM event that triggered the boxzoom event. Can be a `MouseEvent` or `KeyboardEvent`
                */
            originalEvent: MouseEvent;
    };
    /**
        * A `MapDataEvent` object is emitted with the `data`
        * and `dataloading` events. Possible values for
        * `dataType`s are:
        *
        * - `'source'`: The non-tile data associated with any source
        * - `'style'`: The [style](https://maplibre.org/maplibre-style-spec/) used by the map
        *
        * Possible values for `sourceDataType`s are:
        *
        * - `'metadata'`: indicates that any necessary source metadata has been loaded (such as TileJSON) and it is ok to start loading tiles
        * - `'content'`: indicates the source data has changed (such as when source.setData() has been called on GeoJSONSource)
        * - `'visibility'`: send when the source becomes used when at least one of its layers becomes visible in style sense (inside the layer's zoom range and with layout.visibility set to 'visible')
        * - `'idle'`: indicates that no new source data has been fetched (but the source has done loading)
        *
        * @group Event Related
        *
        * @example
        * ```ts
        * // The sourcedata event is an example of MapDataEvent.
        * // Set up an event listener on the map.
        * map.on('sourcedata', function(e) {
        *    if (e.isSourceLoaded) {
        *        // Do something when the source has finished loading
        *    }
        * });
        * ```
        */
    export type MapDataEvent = {
            /**
                * The event type.
                */
            type: string;
            /**
                * The type of data that has changed. One of `'source'`, `'style'`.
                */
            dataType: string;
            /**
                *  Included if the event has a `dataType` of `source` and the event signals that internal data has been received or changed. Possible values are `metadata`, `content`, `visibility` and `idle`.
                */
            sourceDataType: MapSourceDataType;
    };
    /**
        * The terrain event
        *
        * @group Event Related
        */
    export type MapTerrainEvent = {
            type: 'terrain';
    };
    /**
        * An event related to the web gl context
        *
        * @group Event Related
        */
    export type MapContextEvent = {
            type: 'webglcontextlost' | 'webglcontextrestored';
            originalEvent: WebGLContextEvent;
    };
    /**
        * The style image missing event
        *
        * @group Event Related
        *
        * @see [Generate and add a missing icon to the map](https://maplibre.org/maplibre-gl-js/docs/examples/add-image-missing-generated/)
        */
    export type MapStyleImageMissingEvent = MapLibreEvent & {
            type: 'styleimagemissing';
            id: string;
    };
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/box_zoom' {
    import { TransformProvider } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/transform-provider';
    import type { Map } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/map';
    import type Point from '@mapbox/point-geometry';
    import { Handler } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler_manager';
    /**
        * The `BoxZoomHandler` allows the user to zoom the map to fit within a bounding box.
        * The bounding box is defined by clicking and holding `shift` while dragging the cursor.
        *
        * @group Handlers
        */
    export class BoxZoomHandler implements Handler {
            _map: Map;
            _tr: TransformProvider;
            _el: HTMLElement;
            _container: HTMLElement;
            _enabled: boolean;
            _active: boolean;
            _startPos: Point;
            _lastPos: Point;
            _box: HTMLElement;
            _clickTolerance: number;
            /** @internal */
            constructor(map: Map, options: {
                    clickTolerance: number;
            });
            /**
                * Returns a Boolean indicating whether the "box zoom" interaction is enabled.
                *
                * @returns `true` if the "box zoom" interaction is enabled.
                */
            isEnabled(): boolean;
            /**
                * Returns a Boolean indicating whether the "box zoom" interaction is active, i.e. currently being used.
                *
                * @returns `true` if the "box zoom" interaction is active.
                */
            isActive(): boolean;
            /**
                * Enables the "box zoom" interaction.
                *
                * @example
                * ```ts
                * map.boxZoom.enable();
                * ```
                */
            enable(): void;
            /**
                * Disables the "box zoom" interaction.
                *
                * @example
                * ```ts
                * map.boxZoom.disable();
                * ```
                */
            disable(): void;
            mousedown(e: MouseEvent, point: Point): void;
            mousemoveWindow(e: MouseEvent, point: Point): void;
            mouseupWindow(e: MouseEvent, point: Point): {
                    cameraAnimation: (map: any) => any;
            };
            keydown(e: KeyboardEvent): void;
            reset(): void;
            _fireEvent(type: string, e: any): Map;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/shim/drag_rotate' {
    import type { MousePitchHandler, MouseRotateHandler } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/mouse';
    /**
        * Options object for `DragRotateHandler`.
        */
    export type DragRotateHandlerOptions = {
            /**
                * Control the map pitch in addition to the bearing
                * @defaultValue true
                */
            pitchWithRotate: boolean;
    };
    /**
        * The `DragRotateHandler` allows the user to rotate the map by clicking and
        * dragging the cursor while holding the right mouse button or `ctrl` key.
        *
        * @group Handlers
        */
    export class DragRotateHandler {
            _mouseRotate: MouseRotateHandler;
            _mousePitch: MousePitchHandler;
            _pitchWithRotate: boolean;
            /** @internal */
            constructor(options: DragRotateHandlerOptions, mouseRotate: MouseRotateHandler, mousePitch: MousePitchHandler);
            /**
                * Enables the "drag to rotate" interaction.
                *
                * @example
                * ```ts
                * map.dragRotate.enable();
                * ```
                */
            enable(): void;
            /**
                * Disables the "drag to rotate" interaction.
                *
                * @example
                * ```ts
                * map.dragRotate.disable();
                * ```
                */
            disable(): void;
            /**
                * Returns a Boolean indicating whether the "drag to rotate" interaction is enabled.
                *
                * @returns `true` if the "drag to rotate" interaction is enabled.
                */
            isEnabled(): boolean;
            /**
                * Returns a Boolean indicating whether the "drag to rotate" interaction is active, i.e. currently being used.
                *
                * @returns `true` if the "drag to rotate" interaction is active.
                */
            isActive(): boolean;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/shim/drag_pan' {
    import type { MousePanHandler } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/mouse';
    import type { TouchPanHandler } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/touch_pan';
    /**
        * A {@link DragPanHandler} options object
        */
    export type DragPanOptions = {
            /**
                * factor used to scale the drag velocity
                * @defaultValue 0
                */
            linearity?: number;
            /**
                * easing function applled to `map.panTo` when applying the drag.
                * @param t - the easing function
                * @defaultValue bezier(0, 0, 0.3, 1)
                */
            easing?: (t: number) => number;
            /**
                * the maximum value of the drag velocity.
                * @defaultValue 1400
                */
            deceleration?: number;
            /**
                * the rate at which the speed reduces after the pan ends.
                * @defaultValue 2500
                */
            maxSpeed?: number;
    };
    /**
        * The `DragPanHandler` allows the user to pan the map by clicking and dragging
        * the cursor.
        *
        * @group Handlers
        */
    export class DragPanHandler {
            _el: HTMLElement;
            _mousePan: MousePanHandler;
            _touchPan: TouchPanHandler;
            _inertiaOptions: DragPanOptions | boolean;
            /** @internal */
            constructor(el: HTMLElement, mousePan: MousePanHandler, touchPan: TouchPanHandler);
            /**
                * Enables the "drag to pan" interaction.
                *
                * @param options - Options object
                * @example
                * ```ts
                *   map.dragPan.enable();
                *   map.dragPan.enable({
                *      linearity: 0.3,
                *      easing: bezier(0, 0, 0.3, 1),
                *      maxSpeed: 1400,
                *      deceleration: 2500,
                *   });
                * ```
                */
            enable(options?: DragPanOptions | boolean): void;
            /**
                * Disables the "drag to pan" interaction.
                *
                * @example
                * ```ts
                * map.dragPan.disable();
                * ```
                */
            disable(): void;
            /**
                * Returns a Boolean indicating whether the "drag to pan" interaction is enabled.
                *
                * @returns `true` if the "drag to pan" interaction is enabled.
                */
            isEnabled(): boolean;
            /**
                * Returns a Boolean indicating whether the "drag to pan" interaction is active, i.e. currently being used.
                *
                * @returns `true` if the "drag to pan" interaction is active.
                */
            isActive(): boolean;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/scroll_zoom' {
    import { LngLat } from '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/lng_lat';
    import { TransformProvider } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/transform-provider';
    import type { Map } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/map';
    import type Point from '@mapbox/point-geometry';
    import type { AroundCenterOptions } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/two_fingers_touch';
    import { Handler } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler_manager';
    /**
        * The `ScrollZoomHandler` allows the user to zoom the map by scrolling.
        *
        * @group Handlers
        */
    export class ScrollZoomHandler implements Handler {
            _map: Map;
            _tr: TransformProvider;
            _enabled: boolean;
            _active: boolean;
            _zooming: boolean;
            _aroundCenter: boolean;
            _around: LngLat;
            _aroundPoint: Point;
            _type: 'wheel' | 'trackpad' | null;
            _lastValue: number;
            _timeout: ReturnType<typeof setTimeout>;
            _finishTimeout: ReturnType<typeof setTimeout>;
            _lastWheelEvent: any;
            _lastWheelEventTime: number;
            _startZoom: number;
            _targetZoom: number;
            _delta: number;
            _easing: (a: number) => number;
            _prevEase: {
                    start: number;
                    duration: number;
                    easing: (_: number) => number;
            };
            _frameId: boolean;
            _triggerRenderFrame: () => void;
            _defaultZoomRate: number;
            _wheelZoomRate: number;
            /** @internal */
            constructor(map: Map, triggerRenderFrame: () => void);
            /**
                * Set the zoom rate of a trackpad
                * @param zoomRate - 1/100 The rate used to scale trackpad movement to a zoom value.
                * @example
                * Speed up trackpad zoom
                * ```ts
                * map.scrollZoom.setZoomRate(1/25);
                * ```
                */
            setZoomRate(zoomRate: number): void;
            /**
                * Set the zoom rate of a mouse wheel
                * @param wheelZoomRate - 1/450 The rate used to scale mouse wheel movement to a zoom value.
                * @example
                * Slow down zoom of mouse wheel
                * ```ts
                * map.scrollZoom.setWheelZoomRate(1/600);
                * ```
                */
            setWheelZoomRate(wheelZoomRate: number): void;
            /**
                * Returns a Boolean indicating whether the "scroll to zoom" interaction is enabled.
                * @returns `true` if the "scroll to zoom" interaction is enabled.
                */
            isEnabled(): boolean;
            isActive(): boolean;
            isZooming(): boolean;
            /**
                * Enables the "scroll to zoom" interaction.
                *
                * @param options - Options object.
                * @example
                * ```ts
                * map.scrollZoom.enable();
                * map.scrollZoom.enable({ around: 'center' })
                * ```
                */
            enable(_options?: AroundCenterOptions | boolean): void;
            /**
                * Disables the "scroll to zoom" interaction.
                *
                * @example
                * ```ts
                * map.scrollZoom.disable();
                * ```
                */
            disable(): void;
            wheel(e: WheelEvent): void;
            _onTimeout: (initialEvent: MouseEvent) => void;
            _start(e: MouseEvent): void;
            renderFrame(): {
                    noInertia: boolean;
                    needsRenderFrame: boolean;
                    zoomDelta: number;
                    around: Point;
                    originalEvent: any;
            };
            _smoothOutEasing(duration: number): (t: number) => number;
            reset(): void;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/shim/two_fingers_touch' {
    import type { TwoFingersTouchZoomHandler, TwoFingersTouchRotateHandler, AroundCenterOptions } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/two_fingers_touch';
    import type { TapDragZoomHandler } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/tap_drag_zoom';
    /**
        * The `TwoFingersTouchZoomRotateHandler` allows the user to zoom and rotate the map by
        * pinching on a touchscreen.
        *
        * They can zoom with one finger by double tapping and dragging. On the second tap,
        * hold the finger down and drag up or down to zoom in or out.
        *
        * @group Handlers
        */
    export class TwoFingersTouchZoomRotateHandler {
            _el: HTMLElement;
            _touchZoom: TwoFingersTouchZoomHandler;
            _touchRotate: TwoFingersTouchRotateHandler;
            _tapDragZoom: TapDragZoomHandler;
            _rotationDisabled: boolean;
            _enabled: boolean;
            /** @internal */
            constructor(el: HTMLElement, touchZoom: TwoFingersTouchZoomHandler, touchRotate: TwoFingersTouchRotateHandler, tapDragZoom: TapDragZoomHandler);
            /**
                * Enables the "pinch to rotate and zoom" interaction.
                *
                * @param options - Options object.
                *
                * @example
                * ```ts
                * map.touchZoomRotate.enable();
                * map.touchZoomRotate.enable({ around: 'center' });
                * ```
                */
            enable(options?: AroundCenterOptions | boolean | null): void;
            /**
                * Disables the "pinch to rotate and zoom" interaction.
                *
                * @example
                * ```ts
                * map.touchZoomRotate.disable();
                * ```
                */
            disable(): void;
            /**
                * Returns a Boolean indicating whether the "pinch to rotate and zoom" interaction is enabled.
                *
                * @returns `true` if the "pinch to rotate and zoom" interaction is enabled.
                */
            isEnabled(): boolean;
            /**
                * Returns true if the handler is enabled and has detected the start of a zoom/rotate gesture.
                *
                * @returns `true` if the handler is active, `false` otherwise
                */
            isActive(): boolean;
            /**
                * Disables the "pinch to rotate" interaction, leaving the "pinch to zoom"
                * interaction enabled.
                *
                * @example
                * ```ts
                * map.touchZoomRotate.disableRotation();
                * ```
                */
            disableRotation(): void;
            /**
                * Enables the "pinch to rotate" interaction.
                *
                * @example
                * ```ts
                * map.touchZoomRotate.enable();
                * map.touchZoomRotate.enableRotation();
                * ```
                */
            enableRotation(): void;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/custom_style_layer' {
    import { StyleLayer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer';
    import type { Map } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/map';
    import { mat4 } from 'gl-matrix';
    import { LayerSpecification } from '@maplibre/maplibre-gl-style-spec';
    /**
        * @param gl - The map's gl context.
        * @param matrix - The map's camera matrix. It projects spherical mercator
        * coordinates to gl clip space coordinates. The spherical mercator coordinate `[0, 0]` represents the
        * top left corner of the mercator world and `[1, 1]` represents the bottom right corner. When
        * the `renderingMode` is `"3d"`, the z coordinate is conformal. A box with identical x, y, and z
        * lengths in mercator units would be rendered as a cube. {@link MercatorCoordinate.fromLngLat}
        * can be used to project a `LngLat` to a mercator coordinate.
        */
    type CustomRenderMethod = (gl: WebGLRenderingContext | WebGL2RenderingContext, matrix: mat4) => void;
    /**
        * Interface for custom style layers. This is a specification for
        * implementers to model: it is not an exported method or class.
        *
        * Custom layers allow a user to render directly into the map's GL context using the map's camera.
        * These layers can be added between any regular layers using {@link Map#addLayer}.
        *
        * Custom layers must have a unique `id` and must have the `type` of `"custom"`.
        * They must implement `render` and may implement `prerender`, `onAdd` and `onRemove`.
        * They can trigger rendering using {@link Map#triggerRepaint}
        * and they should appropriately handle {@link MapContextEvent} with `webglcontextlost` and `webglcontextrestored`.
        *
        * The `renderingMode` property controls whether the layer is treated as a `"2d"` or `"3d"` map layer. Use:
        *
        * - `"renderingMode": "3d"` to use the depth buffer and share it with other layers
        * - `"renderingMode": "2d"` to add a layer with no depth. If you need to use the depth buffer for a `"2d"` layer you must use an offscreen
        *   framebuffer and {@link CustomLayerInterface#prerender}
        *
        * @example
        * Custom layer implemented as ES6 class
        * ```ts
        * class NullIslandLayer {
        *     constructor() {
        *         this.id = 'null-island';
        *         this.type = 'custom';
        *         this.renderingMode = '2d';
        *     }
        *
        *     onAdd(map, gl) {
        *         const vertexSource = `
        *         uniform mat4 u_matrix;
        *         void main() {
        *             gl_Position = u_matrix * vec4(0.5, 0.5, 0.0, 1.0);
        *             gl_PointSize = 20.0;
        *         }`;
        *
        *         const fragmentSource = `
        *         void main() {
        *             fragColor = vec4(1.0, 0.0, 0.0, 1.0);
        *         }`;
        *
        *         const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        *         gl.shaderSource(vertexShader, vertexSource);
        *         gl.compileShader(vertexShader);
        *         const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        *         gl.shaderSource(fragmentShader, fragmentSource);
        *         gl.compileShader(fragmentShader);
        *
        *         this.program = gl.createProgram();
        *         gl.attachShader(this.program, vertexShader);
        *         gl.attachShader(this.program, fragmentShader);
        *         gl.linkProgram(this.program);
        *     }
        *
        *     render(gl, matrix) {
        *         gl.useProgram(this.program);
        *         gl.uniformMatrix4fv(gl.getUniformLocation(this.program, "u_matrix"), false, matrix);
        *         gl.drawArrays(gl.POINTS, 0, 1);
        *     }
        * }
        *
        * map.on('load', function() {
        *     map.addLayer(new NullIslandLayer());
        * });
        * ```
        */
    export interface CustomLayerInterface {
            /**
                * A unique layer id.
                */
            id: string;
            /**
                * The layer's type. Must be `"custom"`.
                */
            type: 'custom';
            /**
                * Either `"2d"` or `"3d"`. Defaults to `"2d"`.
                */
            renderingMode?: '2d' | '3d';
            /**
                * Called during a render frame allowing the layer to draw into the GL context.
                *
                * The layer can assume blending and depth state is set to allow the layer to properly
                * blend and clip other layers. The layer cannot make any other assumptions about the
                * current GL state.
                *
                * If the layer needs to render to a texture, it should implement the `prerender` method
                * to do this and only use the `render` method for drawing directly into the main framebuffer.
                *
                * The blend function is set to `gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA)`. This expects
                * colors to be provided in premultiplied alpha form where the `r`, `g` and `b` values are already
                * multiplied by the `a` value. If you are unable to provide colors in premultiplied form you
                * may want to change the blend function to
                * `gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA)`.
                */
            render: CustomRenderMethod;
            /**
                * Optional method called during a render frame to allow a layer to prepare resources or render into a texture.
                *
                * The layer cannot make any assumptions about the current GL state and must bind a framebuffer before rendering.
                */
            prerender?: CustomRenderMethod;
            /**
                * Optional method called when the layer has been added to the Map with {@link Map#addLayer}. This
                * gives the layer a chance to initialize gl resources and register event listeners.
                *
                * @param map - The Map this custom layer was just added to.
                * @param gl - The gl context for the map.
                */
            onAdd?(map: Map, gl: WebGLRenderingContext | WebGL2RenderingContext): void;
            /**
                * Optional method called when the layer has been removed from the Map with {@link Map#removeLayer}. This
                * gives the layer a chance to clean up gl resources and event listeners.
                *
                * @param map - The Map this custom layer was just added to.
                * @param gl - The gl context for the map.
                */
            onRemove?(map: Map, gl: WebGLRenderingContext | WebGL2RenderingContext): void;
    }
    export function validateCustomStyleLayer(layerObject: CustomLayerInterface): any[];
    export class CustomStyleLayer extends StyleLayer {
            implementation: CustomLayerInterface;
            constructor(implementation: CustomLayerInterface);
            is3D(): boolean;
            hasOffscreenPass(): boolean;
            recalculate(): void;
            updateTransitions(): void;
            hasTransition(): boolean;
            serialize(): LayerSpecification;
            onAdd: (map: Map) => void;
            onRemove: (map: Map) => void;
    }
    export {};
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/camera' {
    import { LngLat } from '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/lng_lat';
    import Point from '@mapbox/point-geometry';
    import { Evented } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/evented';
    import { Terrain } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/terrain';
    import type { Transform } from '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/transform';
    import type { LngLatLike } from '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/lng_lat';
    import type { LngLatBoundsLike } from '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/lng_lat_bounds';
    import type { TaskID } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/task_queue';
    import type { PaddingOptions } from '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/edge_insets';
    /**
        * A [Point](https://github.com/mapbox/point-geometry) or an array of two numbers representing `x` and `y` screen coordinates in pixels.
        *
        * @group Geography and Geometry
        *
        * @example
        * ```ts
        * let p1 = new Point(-77, 38); // a PointLike which is a Point
        * let p2 = [-77, 38]; // a PointLike which is an array of two numbers
        * ```
        */
    export type PointLike = Point | [number, number];
    /**
        * A helper to allow require of at least one propery
        */
    export type RequireAtLeastOne<T> = {
            [K in keyof T]-?: Required<Pick<T, K>> & Partial<Pick<T, Exclude<keyof T, K>>>;
    }[keyof T];
    /**
        * Options common to {@link Map#jumpTo}, {@link Map#easeTo}, and {@link Map#flyTo}, controlling the desired location,
        * zoom, bearing, and pitch of the camera. All properties are optional, and when a property is omitted, the current
        * camera value for that property will remain unchanged.
        *
        * @example
        * Set the map's initial perspective with CameraOptions
        * ```ts
        * let map = new Map({
        *   container: 'map',
        *   style: 'https://demotiles.maplibre.org/style.json',
        *   center: [-73.5804, 45.53483],
        *   pitch: 60,
        *   bearing: -60,
        *   zoom: 10
        * });
        * ```
        * @see [Set pitch and bearing](https://maplibre.org/maplibre-gl-js/docs/examples/set-perspective/)
        * @see [Jump to a series of locations](https://maplibre.org/maplibre-gl-js/docs/examples/jump-to/)
        * @see [Fly to a location](https://maplibre.org/maplibre-gl-js/docs/examples/flyto/)
        * @see [Display buildings in 3D](https://maplibre.org/maplibre-gl-js/docs/examples/3d-buildings/)
        */
    export type CameraOptions = CenterZoomBearing & {
            /**
                * The desired pitch in degrees. The pitch is the angle towards the horizon
                * measured in degrees with a range between 0 and 60 degrees. For example, pitch: 0 provides the appearance
                * of looking straight down at the map, while pitch: 60 tilts the user's perspective towards the horizon.
                * Increasing the pitch value is often used to display 3D objects.
                */
            pitch?: number;
            /**
                * If `zoom` is specified, `around` determines the point around which the zoom is centered.
                */
            around?: LngLatLike;
    };
    /**
        * Holds center, zoom and bearing properties
        */
    export type CenterZoomBearing = {
            /**
                * The desired center.
                */
            center?: LngLatLike;
            /**
                * The desired zoom level.
                */
            zoom?: number;
            /**
                * The desired bearing in degrees. The bearing is the compass direction that
                * is "up". For example, `bearing: 90` orients the map so that east is up.
                */
            bearing?: number;
    };
    /**
        * The options object related to the {@link Map#jumpTo} method
        */
    export type JumpToOptions = CameraOptions & {
            /**
                * Dimensions in pixels applied on each side of the viewport for shifting the vanishing point.
                */
            padding?: PaddingOptions;
    };
    /**
        * A options object for the {@link Map#cameraForBounds} method
        */
    export type CameraForBoundsOptions = CameraOptions & {
            /**
                * The amount of padding in pixels to add to the given bounds.
                */
            padding?: number | RequireAtLeastOne<PaddingOptions>;
            /**
                * The center of the given bounds relative to the map's center, measured in pixels.
                * @defaultValue [0, 0]
                */
            offset?: PointLike;
            /**
                * The maximum zoom level to allow when the camera would transition to the specified bounds.
                */
            maxZoom?: number;
    };
    /**
        * The {@link Map#flyTo} options object
        */
    export type FlyToOptions = AnimationOptions & CameraOptions & {
            /**
                * The zooming "curve" that will occur along the
                * flight path. A high value maximizes zooming for an exaggerated animation, while a low
                * value minimizes zooming for an effect closer to {@link Map#easeTo}. 1.42 is the average
                * value selected by participants in the user study discussed in
                * [van Wijk (2003)](https://www.win.tue.nl/~vanwijk/zoompan.pdf). A value of
                * `Math.pow(6, 0.25)` would be equivalent to the root mean squared average velocity. A
                * value of 1 would produce a circular motion.
                * @defaultValue 1.42
                */
            curve?: number;
            /**
                * The zero-based zoom level at the peak of the flight path. If
                * `options.curve` is specified, this option is ignored.
                */
            minZoom?: number;
            /**
                * The average speed of the animation defined in relation to
                * `options.curve`. A speed of 1.2 means that the map appears to move along the flight path
                * by 1.2 times `options.curve` screenfuls every second. A _screenful_ is the map's visible span.
                * It does not correspond to a fixed physical distance, but varies by zoom level.
                * @defaultValue 1.2
                */
            speed?: number;
            /**
                * The average speed of the animation measured in screenfuls
                * per second, assuming a linear timing curve. If `options.speed` is specified, this option is ignored.
                */
            screenSpeed?: number;
            /**
                * The animation's maximum duration, measured in milliseconds.
                * If duration exceeds maximum duration, it resets to 0.
                */
            maxDuration?: number;
            /**
                * The amount of padding in pixels to add to the given bounds.
                */
            padding?: number | RequireAtLeastOne<PaddingOptions>;
    };
    export type EaseToOptions = AnimationOptions & CameraOptions & {
            delayEndEvents?: number;
            padding?: number | RequireAtLeastOne<PaddingOptions>;
    };
    /**
        * Options for {@link Map#fitBounds} method
        */
    export type FitBoundsOptions = FlyToOptions & {
            /**
                * If `true`, the map transitions using {@link Map#easeTo}. If `false`, the map transitions using {@link Map#flyTo}.
                * See those functions and {@link AnimationOptions} for information about options available.
                * @defaultValue false
                */
            linear?: boolean;
            /**
                * The center of the given bounds relative to the map's center, measured in pixels.
                * @defaultValue [0, 0]
                */
            offset?: PointLike;
            /**
                * The maximum zoom level to allow when the map view transitions to the specified bounds.
                */
            maxZoom?: number;
    };
    /**
        * Options common to map movement methods that involve animation, such as {@link Map#panBy} and
        * {@link Map#easeTo}, controlling the duration and easing function of the animation. All properties
        * are optional.
        *
        */
    export type AnimationOptions = {
            /**
                * The animation's duration, measured in milliseconds.
                */
            duration?: number;
            /**
                * A function taking a time in the range 0..1 and returning a number where 0 is
                * the initial state and 1 is the final state.
                */
            easing?: (_: number) => number;
            /**
                * of the target center relative to real map container center at the end of animation.
                */
            offset?: PointLike;
            /**
                * If `false`, no animation will occur.
                */
            animate?: boolean;
            /**
                * If `true`, then the animation is considered essential and will not be affected by
                * [`prefers-reduced-motion`](https://developer.mozilla.org/en-US/docs/Web/CSS/\@media/prefers-reduced-motion).
                */
            essential?: boolean;
            /**
                * Default false. Needed in 3D maps to let the camera stay in a constant
                * height based on sea-level. After the animation finished the zoom-level will be recalculated in respect of
                * the distance from the camera to the center-coordinate-altitude.
                */
            freezeElevation?: boolean;
    };
    /**
        * A callback hook that allows manipulating the camera and being notified about camera updates before they happen
        */
    export type CameraUpdateTransformFunction = (next: {
            center: LngLat;
            zoom: number;
            pitch: number;
            bearing: number;
            elevation: number;
    }) => {
            center?: LngLat;
            zoom?: number;
            pitch?: number;
            bearing?: number;
            elevation?: number;
    };
    export abstract class Camera extends Evented {
            transform: Transform;
            terrain: Terrain;
            _moving: boolean;
            _zooming: boolean;
            _rotating: boolean;
            _pitching: boolean;
            _padding: boolean;
            _bearingSnap: number;
            _easeStart: number;
            _easeOptions: {
                    duration?: number;
                    easing?: (_: number) => number;
            };
            _easeId: string | void;
            _onEaseFrame: (_: number) => void;
            _onEaseEnd: (easeId?: string) => void;
            _easeFrameId: TaskID;
            /**
                * @internal
                * holds the geographical coordinate of the target
                */
            _elevationCenter: LngLat;
            /**
                * @internal
                * holds the targ altitude value, = center elevation of the target.
                * This value may changes during flight, because new terrain-tiles loads during flight.
                */
            _elevationTarget: number;
            /**
                * @internal
                * holds the start altitude value, = center elevation before animation begins
                * this value will recalculated during flight in respect of changing _elevationTarget values,
                * so the linear interpolation between start and target keeps smooth and without jumps.
                */
            _elevationStart: number;
            /**
                * @internal
                * Saves the current state of the elevation freeze - this is used during map movement to prevent "rocky" camera movement.
                */
            _elevationFreeze: boolean;
            /**
                * @internal
                * Used to track accumulated changes during continuous interaction
                */
            _requestedCameraState?: Transform;
            /**
                * A callback used to defer camera updates or apply arbitrary constraints.
                * If specified, this Camera instance can be used as a stateless component in React etc.
                */
            transformCameraUpdate: CameraUpdateTransformFunction | null;
            abstract _requestRenderFrame(a: () => void): TaskID;
            abstract _cancelRenderFrame(_: TaskID): void;
            constructor(transform: Transform, options: {
                    bearingSnap: number;
            });
            /**
                * Returns the map's geographical centerpoint.
                *
                * @returns The map's geographical centerpoint.
                * @example
                * Return a LngLat object such as `{lng: 0, lat: 0}`
                * ```ts
                * let center = map.getCenter();
                * // access longitude and latitude values directly
                * let {lng, lat} = map.getCenter();
                * ```
                */
            getCenter(): LngLat;
            /**
                * Sets the map's geographical centerpoint. Equivalent to `jumpTo({center: center})`.
                *
                * Triggers the following events: `movestart` and `moveend`.
                *
                * @param center - The centerpoint to set.
                * @param eventData - Additional properties to be added to event objects of events triggered by this method.
                * @returns `this`
                * @example
                * ```ts
                * map.setCenter([-74, 38]);
                * ```
                */
            setCenter(center: LngLatLike, eventData?: any): this;
            /**
                * Pans the map by the specified offset.
                *
                * Triggers the following events: `movestart` and `moveend`.
                *
                * @param offset - `x` and `y` coordinates by which to pan the map.
                * @param options - Options object
                * @param eventData - Additional properties to be added to event objects of events triggered by this method.
                * @returns `this`
                * @see [Navigate the map with game-like controls](https://maplibre.org/maplibre-gl-js/docs/examples/game-controls/)
                */
            panBy(offset: PointLike, options?: AnimationOptions, eventData?: any): this;
            /**
                * Pans the map to the specified location with an animated transition.
                *
                * Triggers the following events: `movestart` and `moveend`.
                *
                * @param lnglat - The location to pan the map to.
                * @param options - Options describing the destination and animation of the transition.
                * @param eventData - Additional properties to be added to event objects of events triggered by this method.
                * @returns `this`
                * @example
                * ```ts
                * map.panTo([-74, 38]);
                * // Specify that the panTo animation should last 5000 milliseconds.
                * map.panTo([-74, 38], {duration: 5000});
                * ```
                * @see [Update a feature in realtime](https://maplibre.org/maplibre-gl-js/docs/examples/live-update-feature/)
                */
            panTo(lnglat: LngLatLike, options?: AnimationOptions, eventData?: any): this;
            /**
                * Returns the map's current zoom level.
                *
                * @returns The map's current zoom level.
                * @example
                * ```ts
                * map.getZoom();
                * ```
                */
            getZoom(): number;
            /**
                * Sets the map's zoom level. Equivalent to `jumpTo({zoom: zoom})`.
                *
                * Triggers the following events: `movestart`, `move`, `moveend`, `zoomstart`, `zoom`, and `zoomend`.
                *
                * @param zoom - The zoom level to set (0-20).
                * @param eventData - Additional properties to be added to event objects of events triggered by this method.
                * @returns `this`
                * @example
                * Zoom to the zoom level 5 without an animated transition
                * ```ts
                * map.setZoom(5);
                * ```
                */
            setZoom(zoom: number, eventData?: any): this;
            /**
                * Zooms the map to the specified zoom level, with an animated transition.
                *
                * Triggers the following events: `movestart`, `move`, `moveend`, `zoomstart`, `zoom`, and `zoomend`.
                *
                * @param zoom - The zoom level to transition to.
                * @param options - Options object
                * @param eventData - Additional properties to be added to event objects of events triggered by this method.
                * @returns `this`
                * @example
                * ```ts
                * // Zoom to the zoom level 5 without an animated transition
                * map.zoomTo(5);
                * // Zoom to the zoom level 8 with an animated transition
                * map.zoomTo(8, {
                *   duration: 2000,
                *   offset: [100, 50]
                * });
                * ```
                */
            zoomTo(zoom: number, options?: AnimationOptions | null, eventData?: any): this;
            /**
                * Increases the map's zoom level by 1.
                *
                * Triggers the following events: `movestart`, `move`, `moveend`, `zoomstart`, `zoom`, and `zoomend`.
                *
                * @param options - Options object
                * @param eventData - Additional properties to be added to event objects of events triggered by this method.
                * @returns `this`
                * @example
                * Zoom the map in one level with a custom animation duration
                * ```ts
                * map.zoomIn({duration: 1000});
                * ```
                */
            zoomIn(options?: AnimationOptions, eventData?: any): this;
            /**
                * Decreases the map's zoom level by 1.
                *
                * Triggers the following events: `movestart`, `move`, `moveend`, `zoomstart`, `zoom`, and `zoomend`.
                *
                * @param options - Options object
                * @param eventData - Additional properties to be added to event objects of events triggered by this method.
                * @returns `this`
                * @example
                * Zoom the map out one level with a custom animation offset
                * ```ts
                * map.zoomOut({offset: [80, 60]});
                * ```
                */
            zoomOut(options?: AnimationOptions, eventData?: any): this;
            /**
                * Returns the map's current bearing. The bearing is the compass direction that is "up"; for example, a bearing
                * of 90° orients the map so that east is up.
                *
                * @returns The map's current bearing.
                * @see [Navigate the map with game-like controls](https://maplibre.org/maplibre-gl-js/docs/examples/game-controls/)
                */
            getBearing(): number;
            /**
                * Sets the map's bearing (rotation). The bearing is the compass direction that is "up"; for example, a bearing
                * of 90° orients the map so that east is up.
                *
                * Equivalent to `jumpTo({bearing: bearing})`.
                *
                * Triggers the following events: `movestart`, `moveend`, and `rotate`.
                *
                * @param bearing - The desired bearing.
                * @param eventData - Additional properties to be added to event objects of events triggered by this method.
                * @returns `this`
                * @example
                * Rotate the map to 90 degrees
                * ```ts
                * map.setBearing(90);
                * ```
                */
            setBearing(bearing: number, eventData?: any): this;
            /**
                * Returns the current padding applied around the map viewport.
                *
                * @returns The current padding around the map viewport.
                */
            getPadding(): PaddingOptions;
            /**
                * Sets the padding in pixels around the viewport.
                *
                * Equivalent to `jumpTo({padding: padding})`.
                *
                * Triggers the following events: `movestart` and `moveend`.
                *
                * @param padding - The desired padding.
                * @param eventData - Additional properties to be added to event objects of events triggered by this method.
                * @returns `this`
                * @example
                * Sets a left padding of 300px, and a top padding of 50px
                * ```ts
                * map.setPadding({ left: 300, top: 50 });
                * ```
                */
            setPadding(padding: PaddingOptions, eventData?: any): this;
            /**
                * Rotates the map to the specified bearing, with an animated transition. The bearing is the compass direction
                * that is "up"; for example, a bearing of 90° orients the map so that east is up.
                *
                * Triggers the following events: `movestart`, `moveend`, and `rotate`.
                *
                * @param bearing - The desired bearing.
                * @param options - Options object
                * @param eventData - Additional properties to be added to event objects of events triggered by this method.
                * @returns `this`
                */
            rotateTo(bearing: number, options?: AnimationOptions, eventData?: any): this;
            /**
                * Rotates the map so that north is up (0° bearing), with an animated transition.
                *
                * Triggers the following events: `movestart`, `moveend`, and `rotate`.
                *
                * @param options - Options object
                * @param eventData - Additional properties to be added to event objects of events triggered by this method.
                * @returns `this`
                */
            resetNorth(options?: AnimationOptions, eventData?: any): this;
            /**
                * Rotates and pitches the map so that north is up (0° bearing) and pitch is 0°, with an animated transition.
                *
                * Triggers the following events: `movestart`, `move`, `moveend`, `pitchstart`, `pitch`, `pitchend`, and `rotate`.
                *
                * @param options - Options object
                * @param eventData - Additional properties to be added to event objects of events triggered by this method.
                * @returns `this`
                */
            resetNorthPitch(options?: AnimationOptions, eventData?: any): this;
            /**
                * Snaps the map so that north is up (0° bearing), if the current bearing is close enough to it (i.e. within the
                * `bearingSnap` threshold).
                *
                * Triggers the following events: `movestart`, `moveend`, and `rotate`.
                *
                * @param options - Options object
                * @param eventData - Additional properties to be added to event objects of events triggered by this method.
                * @returns `this`
                */
            snapToNorth(options?: AnimationOptions, eventData?: any): this;
            /**
                * Returns the map's current pitch (tilt).
                *
                * @returns The map's current pitch, measured in degrees away from the plane of the screen.
                */
            getPitch(): number;
            /**
                * Sets the map's pitch (tilt). Equivalent to `jumpTo({pitch: pitch})`.
                *
                * Triggers the following events: `movestart`, `moveend`, `pitchstart`, and `pitchend`.
                *
                * @param pitch - The pitch to set, measured in degrees away from the plane of the screen (0-60).
                * @param eventData - Additional properties to be added to event objects of events triggered by this method.
                * @returns `this`
                */
            setPitch(pitch: number, eventData?: any): this;
            /**
                * @param bounds - Calculate the center for these bounds in the viewport and use
                * the highest zoom level up to and including `Map#getMaxZoom()` that fits
                * in the viewport. LngLatBounds represent a box that is always axis-aligned with bearing 0.
                * @param options - Options object
                * @returns If map is able to fit to provided bounds, returns `center`, `zoom`, and `bearing`.
                * If map is unable to fit, method will warn and return undefined.
                * @example
                * ```ts
                * let bbox = [[-79, 43], [-73, 45]];
                * let newCameraTransform = map.cameraForBounds(bbox, {
                *   padding: {top: 10, bottom:25, left: 15, right: 5}
                * });
                * ```
                */
            cameraForBounds(bounds: LngLatBoundsLike, options?: CameraForBoundsOptions): CenterZoomBearing;
            /**
                * @internal
                * Calculate the center of these two points in the viewport and use
                * the highest zoom level up to and including `Map#getMaxZoom()` that fits
                * the points in the viewport at the specified bearing.
                * @param p0 - First point
                * @param p1 - Second point
                * @param bearing - Desired map bearing at end of animation, in degrees
                * @param options - the camera options
                * @returns If map is able to fit to provided bounds, returns `center`, `zoom`, and `bearing`.
                *      If map is unable to fit, method will warn and return undefined.
                * @example
                * ```ts
                * let p0 = [-79, 43];
                * let p1 = [-73, 45];
                * let bearing = 90;
                * let newCameraTransform = map._cameraForBoxAndBearing(p0, p1, bearing, {
                *   padding: {top: 10, bottom:25, left: 15, right: 5}
                * });
                * ```
                */
            _cameraForBoxAndBearing(p0: LngLatLike, p1: LngLatLike, bearing: number, options?: CameraForBoundsOptions): CenterZoomBearing;
            /**
                * Pans and zooms the map to contain its visible area within the specified geographical bounds.
                * This function will also reset the map's bearing to 0 if bearing is nonzero.
                *
                * Triggers the following events: `movestart` and `moveend`.
                *
                * @param bounds - Center these bounds in the viewport and use the highest
                * zoom level up to and including `Map#getMaxZoom()` that fits them in the viewport.
                * @param options - Options supports all properties from {@link AnimationOptions} and {@link CameraOptions} in addition to the fields below.
                * @param eventData - Additional properties to be added to event objects of events triggered by this method.
                * @returns `this`
                * @example
                * ```ts
                * let bbox = [[-79, 43], [-73, 45]];
                * map.fitBounds(bbox, {
                *   padding: {top: 10, bottom:25, left: 15, right: 5}
                * });
                * ```
                * @see [Fit a map to a bounding box](https://maplibre.org/maplibre-gl-js/docs/examples/fitbounds/)
                */
            fitBounds(bounds: LngLatBoundsLike, options?: FitBoundsOptions, eventData?: any): this;
            /**
                * Pans, rotates and zooms the map to to fit the box made by points p0 and p1
                * once the map is rotated to the specified bearing. To zoom without rotating,
                * pass in the current map bearing.
                *
                * Triggers the following events: `movestart`, `move`, `moveend`, `zoomstart`, `zoom`, `zoomend` and `rotate`.
                *
                * @param p0 - First point on screen, in pixel coordinates
                * @param p1 - Second point on screen, in pixel coordinates
                * @param bearing - Desired map bearing at end of animation, in degrees
                * @param options - Options object
                * @param eventData - Additional properties to be added to event objects of events triggered by this method.
                * @returns `this`
                * @example
                * ```ts
                * let p0 = [220, 400];
                * let p1 = [500, 900];
                * map.fitScreenCoordinates(p0, p1, map.getBearing(), {
                *   padding: {top: 10, bottom:25, left: 15, right: 5}
                * });
                * ```
                * @see Used by {@link BoxZoomHandler}
                */
            fitScreenCoordinates(p0: PointLike, p1: PointLike, bearing: number, options?: FitBoundsOptions, eventData?: any): this;
            _fitInternal(calculatedOptions?: CenterZoomBearing, options?: FitBoundsOptions, eventData?: any): this;
            /**
                * Changes any combination of center, zoom, bearing, and pitch, without
                * an animated transition. The map will retain its current values for any
                * details not specified in `options`.
                *
                * Triggers the following events: `movestart`, `move`, `moveend`, `zoomstart`, `zoom`, `zoomend`, `pitchstart`,
                * `pitch`, `pitchend`, and `rotate`.
                *
                * @param options - Options object
                * @param eventData - Additional properties to be added to event objects of events triggered by this method.
                * @returns `this`
                * @example
                * ```ts
                * // jump to coordinates at current zoom
                * map.jumpTo({center: [0, 0]});
                * // jump with zoom, pitch, and bearing options
                * map.jumpTo({
                *   center: [0, 0],
                *   zoom: 8,
                *   pitch: 45,
                *   bearing: 90
                * });
                * ```
                * @see [Jump to a series of locations](https://maplibre.org/maplibre-gl-js/docs/examples/jump-to/)
                * @see [Update a feature in realtime](https://maplibre.org/maplibre-gl-js/docs/examples/live-update-feature/)
                */
            jumpTo(options: JumpToOptions, eventData?: any): this;
            /**
                * Calculates pitch, zoom and bearing for looking at `newCenter` with the camera position being `newCenter`
                * and returns them as {@link CameraOptions}.
                * @param from - The camera to look from
                * @param altitudeFrom - The altitude of the camera to look from
                * @param to - The center to look at
                * @param altitudeTo - Optional altitude of the center to look at. If none given the ground height will be used.
                * @returns the calculated camera options
                */
            calculateCameraOptionsFromTo(from: LngLat, altitudeFrom: number, to: LngLat, altitudeTo?: number): CameraOptions;
            /**
                * Changes any combination of `center`, `zoom`, `bearing`, `pitch`, and `padding` with an animated transition
                * between old and new values. The map will retain its current values for any
                * details not specified in `options`.
                *
                * Note: The transition will happen instantly if the user has enabled
                * the `reduced motion` accessibility feature enabled in their operating system,
                * unless `options` includes `essential: true`.
                *
                * Triggers the following events: `movestart`, `move`, `moveend`, `zoomstart`, `zoom`, `zoomend`, `pitchstart`,
                * `pitch`, `pitchend`, and `rotate`.
                *
                * @param options - Options describing the destination and animation of the transition.
                * Accepts {@link CameraOptions} and {@link AnimationOptions}.
                * @param eventData - Additional properties to be added to event objects of events triggered by this method.
                * @returns `this`
                * @see [Navigate the map with game-like controls](https://maplibre.org/maplibre-gl-js/docs/examples/game-controls/)
                */
            easeTo(options: EaseToOptions & {
                    easeId?: string;
                    noMoveStart?: boolean;
            }, eventData?: any): this;
            _prepareEase(eventData: any, noMoveStart: boolean, currently?: any): void;
            _prepareElevation(center: LngLat): void;
            _updateElevation(k: number): void;
            _finalizeElevation(): void;
            /**
                * @internal
                * Called when the camera is about to be manipulated.
                * If `transformCameraUpdate` is specified, a copy of the current transform is created to track the accumulated changes.
                * This underlying transform represents the "desired state" proposed by input handlers / animations / UI controls.
                * It may differ from the state used for rendering (`this.transform`).
                * @returns Transform to apply changes to
                */
            _getTransformForUpdate(): Transform;
            /**
                * @internal
                * Called after the camera is done being manipulated.
                * @param tr - the requested camera end state
                * Call `transformCameraUpdate` if present, and then apply the "approved" changes.
                */
            _applyUpdatedTransform(tr: Transform): void;
            _fireMoveEvents(eventData?: any): void;
            _afterEase(eventData?: any, easeId?: string): void;
            /**
                * Changes any combination of center, zoom, bearing, and pitch, animating the transition along a curve that
                * evokes flight. The animation seamlessly incorporates zooming and panning to help
                * the user maintain her bearings even after traversing a great distance.
                *
                * Note: The animation will be skipped, and this will behave equivalently to `jumpTo`
                * if the user has the `reduced motion` accessibility feature enabled in their operating system,
                * unless 'options' includes `essential: true`.
                *
                * Triggers the following events: `movestart`, `move`, `moveend`, `zoomstart`, `zoom`, `zoomend`, `pitchstart`,
                * `pitch`, `pitchend`, and `rotate`.
                *
                * @param options - Options describing the destination and animation of the transition.
                * Accepts {@link CameraOptions}, {@link AnimationOptions},
                * and the following additional options.
                * @param eventData - Additional properties to be added to event objects of events triggered by this method.
                * @returns `this`
                * @example
                * ```ts
                * // fly with default options to null island
                * map.flyTo({center: [0, 0], zoom: 9});
                * // using flyTo options
                * map.flyTo({
                *   center: [0, 0],
                *   zoom: 9,
                *   speed: 0.2,
                *   curve: 1,
                *   easing(t) {
                *     return t;
                *   }
                * });
                * ```
                * @see [Fly to a location](https://maplibre.org/maplibre-gl-js/docs/examples/flyto/)
                * @see [Slowly fly to a location](https://maplibre.org/maplibre-gl-js/docs/examples/flyto-options/)
                * @see [Fly to a location based on scroll position](https://maplibre.org/maplibre-gl-js/docs/examples/scroll-fly-to/)
                */
            flyTo(options: FlyToOptions, eventData?: any): this;
            isEasing(): boolean;
            /**
                * Stops any animated transition underway.
                *
                * @returns `this`
                */
            stop(): this;
            _stop(allowGestures?: boolean, easeId?: string): this;
            _ease(frame: (_: number) => void, finish: () => void, options: {
                    animate?: boolean;
                    duration?: number;
                    easing?: (_: number) => number;
            }): void;
            _renderFrameCallback: () => void;
            _normalizeBearing(bearing: number, currentBearing: number): number;
            _normalizeCenter(center: LngLat): void;
            /**
                * Get the elevation difference between a given point
                * and a point that is currently in the middle of the screen.
                * This method should be used for proper positioning of custom 3d objects, as explained [here](https://maplibre.org/maplibre-gl-js/docs/examples/add-3d-model-with-terrain/)
                * Returns null if terrain is not enabled.
                * This method is subject to change in Maplibre GL JS v5.
                * @param lngLatLike - [x,y] or LngLat coordinates of the location
                * @returns elevation offset in meters
                */
            queryTerrainElevation(lngLatLike: LngLatLike): number | null;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/hash' {
    import type { Map } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/map';
    /**
        * Adds the map's position to its page's location hash.
        * Passed as an option to the map object.
        *
        * @group Markers and Controls
        */
    export class Hash {
            _map: Map;
            _hashName: string;
            constructor(hashName?: string | null);
            /**
                * Map element to listen for coordinate changes
                *
                * @param map - The map object
                * @returns `this`
                */
            addTo(map: Map): this;
            /**
                * Removes hash
                *
                * @returns `this`
                */
            remove(): this;
            getHashString(mapFeedback?: boolean): string;
            _getCurrentHash: () => any;
            _onHashChange: () => boolean;
            _updateHashUnthrottled: () => void;
            /**
                * Mobile Safari doesn't allow updating the hash more than 100 times per 30 seconds.
                */
            _updateHash: () => ReturnType<typeof setTimeout>;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/cooperative_gestures' {
    import { Handler } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler_manager';
    import type { Map } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/map';
    /**
        * The {@link CooperativeGesturesHandler} options object for the gesture settings
        */
    export type GestureOptions = boolean;
    /**
        * A `CooperativeGestureHandler` is a control that adds cooperative gesture info when user tries to zoom in/out.
        *
        * @group Handlers
        *
        * @example
        * ```ts
        * const map = new Map({
        *   cooperativeGestures: true
        * });
        * ```
        * @see [Example: cooperative gestures](https://maplibre.org/maplibre-gl-js-docs/example/cooperative-gestures/)
        **/
    export class CooperativeGesturesHandler implements Handler {
            _options: GestureOptions;
            _map: Map;
            _container: HTMLElement;
            /**
                * This is the key that will allow to bypass the cooperative gesture protection
                */
            _bypassKey: 'metaKey' | 'ctrlKey';
            _enabled: boolean;
            constructor(map: Map, options: GestureOptions);
            isActive(): boolean;
            reset(): void;
            _setupUI(): void;
            _destoryUI(): void;
            enable(): void;
            disable(): void;
            isEnabled(): boolean;
            touchmove(e: TouchEvent): void;
            wheel(e: WheelEvent): void;
            _onCooperativeGesture(showNotification: boolean): void;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/shim/dblclick_zoom' {
    import type { ClickZoomHandler } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/click_zoom';
    import type { TapZoomHandler } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/tap_zoom';
    /**
        * The `DoubleClickZoomHandler` allows the user to zoom the map at a point by
        * double clicking or double tapping.
        *
        * @group Handlers
        */
    export class DoubleClickZoomHandler {
            _clickZoom: ClickZoomHandler;
            _tapZoom: TapZoomHandler;
            /** @internal */
            constructor(clickZoom: ClickZoomHandler, TapZoom: TapZoomHandler);
            /**
                * Enables the "double click to zoom" interaction.
                *
                * @example
                * ```ts
                * map.doubleClickZoom.enable();
                * ```
                */
            enable(): void;
            /**
                * Disables the "double click to zoom" interaction.
                *
                * @example
                * ```ts
                * map.doubleClickZoom.disable();
                * ```
                */
            disable(): void;
            /**
                * Returns a Boolean indicating whether the "double click to zoom" interaction is enabled.
                *
                * @returns `true` if the "double click to zoom" interaction is enabled.
                */
            isEnabled(): boolean;
            /**
                * Returns a Boolean indicating whether the "double click to zoom" interaction is active, i.e. currently being used.
                *
                * @returns `true` if the "double click to zoom" interaction is active.
                */
            isActive(): boolean;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/keyboard' {
    import { Handler } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler_manager';
    import type { Map } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/map';
    import { TransformProvider } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/transform-provider';
    /**
        * The `KeyboardHandler` allows the user to zoom, rotate, and pan the map using
        * the following keyboard shortcuts:
        *
        * - `=` / `+`: Increase the zoom level by 1.
        * - `Shift-=` / `Shift-+`: Increase the zoom level by 2.
        * - `-`: Decrease the zoom level by 1.
        * - `Shift--`: Decrease the zoom level by 2.
        * - Arrow keys: Pan by 100 pixels.
        * - `Shift+⇢`: Increase the rotation by 15 degrees.
        * - `Shift+⇠`: Decrease the rotation by 15 degrees.
        * - `Shift+⇡`: Increase the pitch by 10 degrees.
        * - `Shift+⇣`: Decrease the pitch by 10 degrees.
        *
        * @group Handlers
        */
    export class KeyboardHandler implements Handler {
            _tr: TransformProvider;
            _enabled: boolean;
            _active: boolean;
            _panStep: number;
            _bearingStep: number;
            _pitchStep: number;
            _rotationDisabled: boolean;
            /** @internal */
            constructor(map: Map);
            reset(): void;
            keydown(e: KeyboardEvent): {
                    cameraAnimation: (map: Map) => void;
            };
            /**
                * Enables the "keyboard rotate and zoom" interaction.
                *
                * @example
                * ```ts
                * map.keyboard.enable();
                * ```
                */
            enable(): void;
            /**
                * Disables the "keyboard rotate and zoom" interaction.
                *
                * @example
                * ```ts
                * map.keyboard.disable();
                * ```
                */
            disable(): void;
            /**
                * Returns a Boolean indicating whether the "keyboard rotate and zoom"
                * interaction is enabled.
                *
                * @returns `true` if the "keyboard rotate and zoom"
                * interaction is enabled.
                */
            isEnabled(): boolean;
            /**
                * Returns true if the handler is enabled and has detected the start of a
                * zoom/rotate gesture.
                *
                * @returns `true` if the handler is enabled and has detected the
                * start of a zoom/rotate gesture.
                */
            isActive(): boolean;
            /**
                * Disables the "keyboard pan/rotate" interaction, leaving the
                * "keyboard zoom" interaction enabled.
                *
                * @example
                * ```ts
                * map.keyboard.disableRotation();
                * ```
                */
            disableRotation(): void;
            /**
                * Enables the "keyboard pan/rotate" interaction.
                *
                * @example
                * ```ts
                * map.keyboard.enable();
                * map.keyboard.enableRotation();
                * ```
                */
            enableRotation(): void;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/two_fingers_touch' {
    import Point from '@mapbox/point-geometry';
    import type { Map } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/map';
    import { Handler, HandlerResult } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler_manager';
    /**
        * An options object sent to the enable function of some of the handlers
        */
    export type AroundCenterOptions = {
            /**
                * If "center" is passed, map will zoom around the center of map
                */
            around: 'center';
    };
    /**
        * The `TwoFingersTouchHandler`s allows the user to zoom, pitch and rotate the map using two fingers
        *
        */
    abstract class TwoFingersTouchHandler implements Handler {
            _enabled?: boolean;
            _active?: boolean;
            _firstTwoTouches?: [number, number];
            _vector?: Point;
            _startVector?: Point;
            _aroundCenter?: boolean;
            /** @internal */
            constructor();
            reset(): void;
            abstract _start(points: [Point, Point]): void;
            abstract _move(points: [Point, Point], pinchAround: Point | null, e: TouchEvent): HandlerResult | void;
            touchstart(e: TouchEvent, points: Array<Point>, mapTouches: Array<Touch>): void;
            touchmove(e: TouchEvent, points: Array<Point>, mapTouches: Array<Touch>): HandlerResult | void;
            touchend(e: TouchEvent, points: Array<Point>, mapTouches: Array<Touch>): void;
            touchcancel(): void;
            /**
                * Enables the "drag to pitch" interaction.
                *
                * @example
                * ```ts
                * map.touchPitch.enable();
                * ```
                */
            enable(options?: AroundCenterOptions | boolean | null): void;
            /**
                * Disables the "drag to pitch" interaction.
                *
                * @example
                * ```ts
                * map.touchPitch.disable();
                * ```
                */
            disable(): void;
            /**
                * Returns a Boolean indicating whether the "drag to pitch" interaction is enabled.
                *
                * @returns  `true` if the "drag to pitch" interaction is enabled.
                */
            isEnabled(): boolean;
            /**
                * Returns a Boolean indicating whether the "drag to pitch" interaction is active, i.e. currently being used.
                *
                * @returns `true` if the "drag to pitch" interaction is active.
                */
            isActive(): boolean;
    }
    /**
        * The `TwoFingersTouchHandler`s allows the user to zoom the map two fingers
        *
        * @group Handlers
        */
    export class TwoFingersTouchZoomHandler extends TwoFingersTouchHandler {
            _distance?: number;
            _startDistance?: number;
            reset(): void;
            _start(points: [Point, Point]): void;
            _move(points: [Point, Point], pinchAround: Point | null): HandlerResult | void;
    }
    /**
        * The `TwoFingersTouchHandler`s allows the user to rotate the map two fingers
        *
        * @group Handlers
        */
    export class TwoFingersTouchRotateHandler extends TwoFingersTouchHandler {
            _minDiameter?: number;
            reset(): void;
            _start(points: [Point, Point]): void;
            _move(points: [Point, Point], pinchAround: Point | null, _e: TouchEvent): HandlerResult | void;
            _isBelowThreshold(vector: Point): boolean;
    }
    /**
        * The `TwoFingersTouchPitchHandler` allows the user to pitch the map by dragging up and down with two fingers.
        *
        * @group Handlers
        */
    export class TwoFingersTouchPitchHandler extends TwoFingersTouchHandler {
            _valid?: boolean;
            _firstMove?: number;
            _lastPoints?: [Point, Point];
            _map: Map;
            _currentTouchCount: number;
            constructor(map: Map);
            reset(): void;
            touchstart(e: TouchEvent, points: Array<Point>, mapTouches: Array<Touch>): void;
            _start(points: [Point, Point]): void;
            _move(points: [Point, Point], center: Point | null, e: TouchEvent): HandlerResult | void;
            gestureBeginsVertically(vectorA: Point, vectorB: Point, timeStamp: number): boolean | undefined;
    }
    export {};
}

declare module '@mappedin/mappedin-js/geojson/src/systems/path/system' {
    import type { RendererState } from '@mappedin/mappedin-js/geojson/src/renderer';
    import type { RendererCore } from '@mappedin/mappedin-js/geojson/src';
    import { PubSub } from '@packages/internal/common';
    import type { CameraSystem } from '@mappedin/mappedin-js/geojson/src/systems/camera';
    /**
      * A system for drawing and controlling the visual state of paths
      */
    export class PathSystem extends PubSub<{
        'animate:path': undefined;
    }> {
        altitudeDirty: boolean;
        convertTo3DMapPosition: RendererCore['convertTo3DMapPosition'];
        getParentContainer: RendererCore['getParentContainer'];
        convertZoomLevelToAltitude: CameraSystem['convertZoomLevelToAltitude'];
        constructor(rendererState: RendererState, convertTo3DMapPosition: RendererCore['convertTo3DMapPosition'], getParentContainer: RendererCore['getParentContainer'], convertZoomLevelToAltitude: CameraSystem['convertZoomLevelToAltitude']);
        update(minZoomAltitude: number, maxZoomAltitude: number, currentZoomAltitude: number): void;
    }
}

declare module '@mappedin/mappedin-js/packages/geojson-navigator/src/navigator' {
    export * from '@mappedin/mappedin-js/packages/geojson-navigator/src/navigator/navigator';
}

declare module '@mappedin/mappedin-js/packages/geojson-navigator/src/navigator/navigator' {
    import type { Position, Feature, MultiPolygon, Polygon } from 'geojson';
    import { NavigationGraph } from '@mappedin/mappedin-js/packages/geojson-navigator/src/navigation-graph';
    import type { NodeCollection } from '@mappedin/mappedin-js/packages/geojson-navigator/src/types/node';
    import type { ObstructionCollection } from '@mappedin/mappedin-js/packages/geojson-navigator/src/types/obstruction';
    import type { SpaceCollection } from '@mappedin/mappedin-js/packages/geojson-navigator/src/types/space';
    import type { DirectionsCollection } from '@mappedin/mappedin-js/packages/geojson-navigator/src/types/directions';
    /**
        * Options for simplifying directions in the Navigator class.
        */
    export type SimplifyDirectionsOptions = {
            /**
                * Enable or disable simplifying.
                */
            enabled: boolean;
            /**
                * The radius of the buffer around the path to consider when simplifying, in meters.
                * @default 0.7
                */
            bufferRadius?: number;
    };
    /**
        * Defines the special zone for navigation operations.
        */
    export type DirectionsZone = {
            geometry: Feature<MultiPolygon | Polygon>;
            /**
                * The additional cost for navigation through the zone.
                */
            cost: number;
            /**
                *
                *  Additional property specific to the navigator based on the 'groupBy' option.
                */
            [index: string]: any;
    };
    export class Navigator {
            graph: NavigationGraph;
            /**
                * Constructs a Navigator instance to manage pathfinding with optional obstructions and grouping features.
                *
                * @param {NodeCollection} nodes - Collection of nodes for the navigation graph.
                * @param {ObstructionCollection} [obstructions] - Optional collection of obstructions that could block paths.
                * @param {SpaceCollection} [spaces] - Optional collection of spaces that could block paths.
                * @param {string} [groupBy] - Optional property name to group nodes and paths for differentiated processing.
                */
            constructor({ nodes, geojsonCollection, groupBy, multiplicativeDistanceWeightScaling, }: {
                    nodes: NodeCollection;
                    geojsonCollection?: ObstructionCollection | SpaceCollection;
                    groupBy?: string;
                    multiplicativeDistanceWeightScaling?: boolean;
            });
            /**
                * Calculates and returns a set of directions from origin nodes to destination nodes, including detailed properties.
                *
                * @param {DirectionsZone[]} zones - special zones for navigation operations.
                * @param {string[]} originIds - IDs of origin nodes.
                * @param {string[]} destinationNodeIds - IDs of destination nodes.
                * @param {string[]} [excludedNodeIds] - IDs of nodes to exclude from pathfinding.
                * @param {string[]} [disabledConnectionNodeIds] - IDs of connection nodes that are disabled (ie. act as regular nodes).
                * @param {SimplifyDirectionsOptions} [simplify] - Options to simplify the pathfinding result.
                * @returns {DirectionsCollection} A collection of directional features representing the path.
                */
            getDirections({ zones: directionsZones, originIds, destinationNodeIds, excludedNodeIds, disabledConnectionNodeIds, simplify, multiplicativeDistanceWeightScaling, }: {
                    originIds: string[];
                    destinationNodeIds: string[];
                    zones?: DirectionsZone[];
                    excludedNodeIds?: string[];
                    disabledConnectionNodeIds?: string[];
                    simplify?: SimplifyDirectionsOptions;
                    multiplicativeDistanceWeightScaling?: boolean;
            }): DirectionsCollection;
            /**
                * Calculates the approximate distance between two geographic coordinates on Earth's surface.
                *
                * This function uses the equirectangular approximation method to compute the distance, which simplifies
                * the math and speeds up calculations, but is less accurate over long distances compared to other methods
                * like the haversine formula.
                *
                * @param {Position} point1 - The first point's longitude and latitude as [longitude, latitude].
                * @param {Position} point2 - The second point's longitude and latitude as [longitude, latitude].
                * @return
                * @return {number} The approximate distance between the two points in meters.
                */
            getDistance: (point1: Position, point2: Position) => number;
            /**
                * Calculates the angle between two geographic coordinates.
                *
                * @param {Position} point1 - The first point's longitude and latitude as [longitude, latitude].
                * @param {Position} point2 - The second point's longitude and latitude as [longitude, latitude].
                * @hidden
                *
                * @return {number} The angle in radians, calculated clockwise from the north between the two points specified.
                */
            getAngle: (point1: Position, point2: Position) => number;
    }
}

declare module '@mappedin/mappedin-js/packages/geojson-navigator/src/types/node' {
    import type { Feature, FeatureCollection, Point } from 'geojson';
    /**
        * The neighboring node with associated weight.
        */
    export type NodeNeighbor = {
            id: string;
            weight: number;
    };
    /**
        * Properties specific to node features in a geospatial context.
        * Each node includes a mandatory unique identifier and supports additional custom properties.
        */
    export type NodeProperties = {
            /**
                * Unique identifier for the node.
                */
            id: string;
            /**
                * An array of neighboring nodes with associated weights.
                */
            neighbors: NodeNeighbor[];
            /**
                * Additional property specific to the navigator based on the 'groupBy' option.
                * */
            [name: string]: any;
    };
    /**
        * A GeoJSON feature collection that groups multiple nodes, each represented as a point.
        * This structure is commonly used in mapping, routing, and network analysis applications.
        */
    export type NodeCollection = FeatureCollection<Point, NodeProperties>;
    /**
        * A GeoJSON feature representing a node as a point with associated properties.
        * Nodes are critical for defining specific locations in network-based analyses, such as transportation networks,
        * utility networks, or any kind of spatial network analysis.
        */
    export type NodeFeature = Feature<Point, NodeProperties>;
}

declare module '@mappedin/mappedin-js/packages/geojson-navigator/src/types/obstruction' {
    import type { LineString, Polygon, Feature } from 'geojson';
    import type { ObstructionProperties, ObstructionCollection } from '@mappedin/mvf';
    /**
      * A GeoJSON feature representing an obstruction, which can be either a line string or a polygon.
      * This type is crucial for mapping and managing areas that impede or restrict movement, such as barriers or restricted zones.
      *
      */
    export type ObstructionFeature = Feature<LineString | Polygon, ObstructionProperties>;
    export { ObstructionCollection, ObstructionProperties };
}

declare module '@mappedin/mappedin-js/packages/geojson-navigator/src/types/directions' {
    import type { Feature, FeatureCollection, Point } from 'geojson';
    import type { Edge } from '@mappedin/mappedin-js/packages/geojson-navigator/src/edge';
    /**
        * Properties specific to directional features in a navigation context.
        * Includes an identifier, optional angle and distance, and allows for any additional properties.
        */
    export type DirectionProperties = {
            /**
                * Unique identifier for the direction.
                */
            id: string;
            /**
                * An angle between this point and the destination, in radians.
                */
            angle?: number;
            /**
                * Distance to the next point, in meters.
                */
            distance?: number;
            /**
                * Group id which the direction belongs to (e.g. floor, building, etc).
                * It's based on the groupBy property of the navigator.
                */
            groupBy?: string;
            destination?: string;
            edges: Edge[];
    };
    /**
        * A GeoJSON feature representing a point with properties tailored for navigation directions.
        */
    export type DirectionFeature = Feature<Point, DirectionProperties>;
    /**
        * A GeoJSON feature collection that groups multiple directional features, often used to represent a route or path.
        */
    export type DirectionsCollection = FeatureCollection<Point, DirectionProperties>;
}

declare module '@mappedin/mappedin-js/packages/geojson-navigator/src/types/coordinate' {
    import type { Feature, Point } from 'geojson';
    /**
        * Properties specific to node features in a geospatial context.
        * Each node includes a mandatory unique identifier and supports additional custom properties.
        */
    export type CoordinateProperties = {
            /**
                * Additional property specific to the navigator based on the 'groupBy' option.
                * */
            [name: string]: any;
    };
    /**
        * A GeoJSON feature representing a coordinate as a point with associated properties.
        */
    export type CoordinateFeature = Feature<Point, CoordinateProperties>;
}

declare module '@mappedin/mappedin-js/geojson/src/systems/interactions/tap-controller' {
    export enum TapType {
        onefinger = 0,
        twofinger = 1
    }
    export class Tap {
        type: TapType;
        event: PointerEvent;
        constructor(event: PointerEvent);
        get timestamp(): number;
    }
    export class TapsController {
        add(tap: Tap): void;
        get lastPointerDown(): Tap | undefined;
        get isSingleTapWithTwoFingers(): boolean;
        get isSingleTapWithOneFinger(): boolean;
        get isDoubleTapWithOneFinger(): boolean;
        get isSingleTap(): boolean;
        get isDoubleTap(): boolean;
        discardOutsideOfWaitWindow(timestamp: number): void;
        flush(): void;
        get _taps(): Tap[];
        destroy(): void;
    }
}

declare module '@mappedin/mappedin-js/geojson/src/systems/camera/helpers' {
    export * from '@mappedin/mappedin-js/geojson/src/systems/camera/helpers/input-set';
    export * from '@mappedin/mappedin-js/geojson/src/systems/camera/helpers/touch-anchor';
    export * from '@mappedin/mappedin-js/geojson/src/systems/camera/helpers/utils';
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/util/request_manager' {
    import type { RequestParameters } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/ajax';
    /**
        * A type of MapLibre resource.
        */
    export const enum ResourceType {
            Glyphs = "Glyphs",
            Image = "Image",
            Source = "Source",
            SpriteImage = "SpriteImage",
            SpriteJSON = "SpriteJSON",
            Style = "Style",
            Tile = "Tile",
            Unknown = "Unknown"
    }
    /**
        * This function is used to tranform a request.
        * It is used just before executing the relevant request.
        */
    export type RequestTransformFunction = (url: string, resourceType?: ResourceType) => RequestParameters | undefined;
    export class RequestManager {
            _transformRequestFn: RequestTransformFunction;
            constructor(transformRequestFn?: RequestTransformFunction);
            transformRequest(url: string, type: ResourceType): RequestParameters;
            normalizeSpriteURL(url: string, format: string, extension: string): string;
            setTransformRequest(transformRequest: RequestTransformFunction): void;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/render/painter' {
    import { mat4 } from 'gl-matrix';
    import { SourceCache } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/source_cache';
    import { SegmentVector } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/segment';
    import { ProgramConfiguration } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/program_configuration';
    import { CrossTileSymbolIndex } from '@mappedin/mappedin-js/packages/outdoor-context-v4/symbol/cross_tile_symbol_index';
    import { Program } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/program';
    import { Context } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/context';
    import { DepthMode } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/depth_mode';
    import { StencilMode } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/stencil_mode';
    import { ColorMode } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/color_mode';
    import { Texture } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/texture';
    import { OverscaledTileID } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile_id';
    import type { Transform } from '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/transform';
    import type { Tile } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile';
    import type { Style } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style';
    import type { StyleLayer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer';
    import type { CrossFaded } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/properties';
    import type { LineAtlas } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/line_atlas';
    import type { ImageManager } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/image_manager';
    import type { GlyphManager } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/glyph_manager';
    import type { VertexBuffer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/vertex_buffer';
    import type { IndexBuffer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/index_buffer';
    import type { DepthRangeType, DepthMaskType, DepthFuncType } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/types';
    import type { ResolvedImage } from '@maplibre/maplibre-gl-style-spec';
    import { RenderToTexture } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/render_to_texture';
    export type RenderPass = 'offscreen' | 'opaque' | 'translucent';
    type PainterOptions = {
            showOverdrawInspector: boolean;
            showTileBoundaries: boolean;
            showPadding: boolean;
            rotating: boolean;
            zooming: boolean;
            moving: boolean;
            fadeDuration: number;
    };
    /**
        * @internal
        * Initialize a new painter object.
        */
    export class Painter {
            context: Context;
            transform: Transform;
            renderToTexture: RenderToTexture;
            _tileTextures: {
                    [_: number]: Array<Texture>;
            };
            numSublayers: number;
            depthEpsilon: number;
            emptyProgramConfiguration: ProgramConfiguration;
            width: number;
            height: number;
            pixelRatio: number;
            tileExtentBuffer: VertexBuffer;
            tileExtentSegments: SegmentVector;
            debugBuffer: VertexBuffer;
            debugSegments: SegmentVector;
            rasterBoundsBuffer: VertexBuffer;
            rasterBoundsSegments: SegmentVector;
            viewportBuffer: VertexBuffer;
            viewportSegments: SegmentVector;
            quadTriangleIndexBuffer: IndexBuffer;
            tileBorderIndexBuffer: IndexBuffer;
            _tileClippingMaskIDs: {
                    [_: string]: number;
            };
            stencilClearMode: StencilMode;
            style: Style;
            options: PainterOptions;
            lineAtlas: LineAtlas;
            imageManager: ImageManager;
            glyphManager: GlyphManager;
            depthRangeFor3D: DepthRangeType;
            opaquePassCutoff: number;
            renderPass: RenderPass;
            currentLayer: number;
            currentStencilSource: string;
            nextStencilID: number;
            id: string;
            _showOverdrawInspector: boolean;
            cache: {
                    [_: string]: Program<any>;
            };
            crossTileSymbolIndex: CrossTileSymbolIndex;
            symbolFadeChange: number;
            debugOverlayTexture: Texture;
            debugOverlayCanvas: HTMLCanvasElement;
            terrainFacilitator: {
                    dirty: boolean;
                    matrix: mat4;
                    renderTime: number;
            };
            constructor(gl: WebGLRenderingContext | WebGL2RenderingContext, transform: Transform);
            resize(width: number, height: number, pixelRatio: number): void;
            setup(): void;
            clearStencil(): void;
            _renderTileClippingMasks(layer: StyleLayer, tileIDs: Array<OverscaledTileID>): void;
            stencilModeFor3D(): StencilMode;
            stencilModeForClipping(tileID: OverscaledTileID): StencilMode;
            stencilConfigForOverlap(tileIDs: Array<OverscaledTileID>): [
                    {
                            [_: number]: Readonly<StencilMode>;
                    },
                    Array<OverscaledTileID>
            ];
            colorModeForRenderPass(): Readonly<ColorMode>;
            depthModeForSublayer(n: number, mask: DepthMaskType, func?: DepthFuncType | null): Readonly<DepthMode>;
            opaquePassEnabledForLayer(): boolean;
            render(style: Style, options: PainterOptions): void;
            /**
                * Update the depth and coords framebuffers, if the contents of those frame buffers is out of date.
                * If requireExact is false, then the contents of those frame buffers is not updated if it is close
                * to accurate (that is, the camera has not moved much since it was updated last).
                */
            maybeDrawDepthAndCoords(requireExact: boolean): void;
            renderLayer(painter: Painter, sourceCache: SourceCache, layer: StyleLayer, coords: Array<OverscaledTileID>): void;
            /**
                * Transform a matrix to incorporate the *-translate and *-translate-anchor properties into it.
                * @param inViewportPixelUnitsUnits - True when the units accepted by the matrix are in viewport pixels instead of tile units.
                * @returns matrix
                */
            translatePosMatrix(matrix: mat4, tile: Tile, translate: [number, number], translateAnchor: 'map' | 'viewport', inViewportPixelUnitsUnits?: boolean): mat4;
            saveTileTexture(texture: Texture): void;
            getTileTexture(size: number): Texture;
            /**
                * Checks whether a pattern image is needed, and if it is, whether it is not loaded.
                *
                * @returns true if a needed image is missing and rendering needs to be skipped.
                */
            isPatternMissing(image?: CrossFaded<ResolvedImage> | null): boolean;
            useProgram(name: string, programConfiguration?: ProgramConfiguration | null): Program<any>;
            setCustomLayerDefaults(): void;
            setBaseState(): void;
            initDebugOverlayCanvas(): void;
            destroy(): void;
            overLimit(): boolean;
    }
    export {};
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler_manager' {
    import { Event } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/evented';
    import { Map, CompleteMapOptions } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/map';
    import { HandlerInertia } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler_inertia';
    import Point from '@mapbox/point-geometry';
    /**
        * Handlers interpret dom events and return camera changes that should be
        * applied to the map (`HandlerResult`s). The camera changes are all deltas.
        * The handler itself should have no knowledge of the map's current state.
        * This makes it easier to merge multiple results and keeps handlers simpler.
        * For example, if there is a mousedown and mousemove, the mousePan handler
        * would return a `panDelta` on the mousemove.
        */
    export interface Handler {
            enable(): void;
            disable(): void;
            isEnabled(): boolean;
            /**
                * This is used to indicate if the handler is currently active or not.
                * In case a handler is active, it will block other handlers from gettting the relevant events.
                * There is an allow list of handlers that can be active at the same time, which is configured when adding a handler.
                */
            isActive(): boolean;
            /**
                * `reset` can be called by the manager at any time and must reset everything to it's original state
                */
            reset(): void;
            readonly touchstart?: (e: TouchEvent, points: Array<Point>, mapTouches: Array<Touch>) => HandlerResult | void;
            readonly touchmove?: (e: TouchEvent, points: Array<Point>, mapTouches: Array<Touch>) => HandlerResult | void;
            readonly touchmoveWindow?: (e: TouchEvent, points: Array<Point>, mapTouches: Array<Touch>) => HandlerResult | void;
            readonly touchend?: (e: TouchEvent, points: Array<Point>, mapTouches: Array<Touch>) => HandlerResult | void;
            readonly touchcancel?: (e: TouchEvent, points: Array<Point>, mapTouches: Array<Touch>) => HandlerResult | void;
            readonly mousedown?: (e: MouseEvent, point: Point) => HandlerResult | void;
            readonly mousemove?: (e: MouseEvent, point: Point) => HandlerResult | void;
            readonly mousemoveWindow?: (e: MouseEvent, point: Point) => HandlerResult | void;
            readonly mouseup?: (e: MouseEvent, point: Point) => HandlerResult | void;
            readonly mouseupWindow?: (e: MouseEvent, point: Point) => HandlerResult | void;
            readonly dblclick?: (e: MouseEvent, point: Point) => HandlerResult | void;
            readonly contextmenu?: (e: MouseEvent) => HandlerResult | void;
            readonly wheel?: (e: WheelEvent, point: Point) => HandlerResult | void;
            readonly keydown?: (e: KeyboardEvent) => HandlerResult | void;
            readonly keyup?: (e: KeyboardEvent) => HandlerResult | void;
            /**
                * `renderFrame` is the only non-dom event. It is called during render
                * frames and can be used to smooth camera changes (see scroll handler).
                */
            readonly renderFrame?: () => HandlerResult | void;
    }
    /**
        * All handler methods that are called with events can optionally return a `HandlerResult`.
        */
    export type HandlerResult = {
            panDelta?: Point;
            zoomDelta?: number;
            bearingDelta?: number;
            pitchDelta?: number;
            /**
                * the point to not move when changing the camera
                */
            around?: Point | null;
            /**
                * same as above, except for pinch actions, which are given higher priority
                */
            pinchAround?: Point | null;
            /**
                * A method that can fire a one-off easing by directly changing the map's camera.
                */
            cameraAnimation?: (map: Map) => any;
            /**
                * The last three properties are needed by only one handler: scrollzoom.
                * The DOM event to be used as the `originalEvent` on any camera change events.
                */
            originalEvent?: Event;
            /**
                * Makes the manager trigger a frame, allowing the handler to return multiple results over time (see scrollzoom).
                */
            needsRenderFrame?: boolean;
            /**
                * The camera changes won't get recorded for inertial zooming.
                */
            noInertia?: boolean;
    };
    export type EventInProgress = {
            handlerName: string;
            originalEvent: Event;
    };
    export type EventsInProgress = {
            zoom?: EventInProgress;
            pitch?: EventInProgress;
            rotate?: EventInProgress;
            drag?: EventInProgress;
    };
    export class HandlerManager {
            _map: Map;
            _el: HTMLElement;
            _handlers: Array<{
                    handlerName: string;
                    handler: Handler;
                    allowed: Array<string>;
            }>;
            _eventsInProgress: EventsInProgress;
            _frameId: number;
            _inertia: HandlerInertia;
            _bearingSnap: number;
            _handlersById: {
                    [x: string]: Handler;
            };
            _updatingCamera: boolean;
            _changes: Array<[HandlerResult, EventsInProgress, {
                    [handlerName: string]: Event;
            }]>;
            _terrainMovement: boolean;
            _zoom: {
                    handlerName: string;
            };
            _previousActiveHandlers: {
                    [x: string]: Handler;
            };
            _listeners: Array<[
                    Window | Document | HTMLElement,
                    string,
                    ({
                            passive?: boolean;
                            capture?: boolean;
                    } | undefined)
            ]>;
            constructor(map: Map, options: CompleteMapOptions);
            destroy(): void;
            _addDefaultHandlers(options: CompleteMapOptions): void;
            _add(handlerName: string, handler: Handler, allowed?: Array<string>): void;
            stop(allowEndAnimation: boolean): void;
            isActive(): boolean;
            isZooming(): boolean;
            isRotating(): boolean;
            isMoving(): boolean;
            _blockedByActive(activeHandlers: {
                    [x: string]: Handler;
            }, allowed: Array<string>, myName: string): boolean;
            handleWindowEvent: (e: {
                    type: "mousemove" | "mouseup" | "touchmove";
            }) => void;
            _getMapTouches(touches: TouchList): TouchList;
            handleEvent: (e: Event, eventName?: keyof Handler) => void;
            mergeHandlerResult(mergedHandlerResult: HandlerResult, eventsInProgress: EventsInProgress, handlerResult: HandlerResult, name: string, e?: UIEvent): void;
            _applyChanges(): void;
            _updateMapTransform(combinedResult: HandlerResult, combinedEventsInProgress: EventsInProgress, deactivatedHandlers: {
                    [handlerName: string]: Event;
            }): void;
            _fireEvents(newEventsInProgress: EventsInProgress, deactivatedHandlers: {
                    [handlerName: string]: Event;
            }, allowEndAnimation: boolean): void;
            _fireEvent(type: string, e?: Event): void;
            _requestFrame(): number;
            _triggerRenderFrame(): void;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/util/task_queue' {
    export type TaskID = number;
    type Task = {
        callback: (timeStamp: number) => void;
        id: TaskID;
        cancelled: boolean;
    };
    export class TaskQueue {
        _queue: Array<Task>;
        _id: TaskID;
        _cleared: boolean;
        _currentlyRunning: Array<Task> | false;
        constructor();
        add(callback: (timeStamp: number) => void): TaskID;
        remove(id: TaskID): void;
        run(timeStamp?: number): void;
        clear(): void;
    }
    export {};
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer' {
    import { Evented } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/evented';
    import { Layout, Transitionable, Transitioning, Properties } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/properties';
    import type { Bucket } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/bucket';
    import type Point from '@mapbox/point-geometry';
    import type { FeatureFilter, FeatureState, LayerSpecification, FilterSpecification } from '@maplibre/maplibre-gl-style-spec';
    import type { TransitionParameters, PropertyValue } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/properties';
    import { EvaluationParameters } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/evaluation_parameters';
    import type { CrossfadeParameters } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/evaluation_parameters';
    import type { Transform } from '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/transform';
    import type { CustomLayerInterface } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/custom_style_layer';
    import type { Map } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/map';
    import type { StyleSetterOptions } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style';
    import { mat4 } from 'gl-matrix';
    import type { VectorTileFeature } from '@mapbox/vector-tile';
    /**
      * A base class for style layers
      */
    export abstract class StyleLayer extends Evented {
        id: string;
        metadata: unknown;
        type: LayerSpecification['type'] | CustomLayerInterface['type'];
        source: string;
        sourceLayer: string;
        minzoom: number;
        maxzoom: number;
        filter: FilterSpecification | void;
        visibility: 'visible' | 'none' | void;
        _crossfadeParameters: CrossfadeParameters;
        _unevaluatedLayout: Layout<any>;
        readonly layout: unknown;
        _transitionablePaint: Transitionable<any>;
        _transitioningPaint: Transitioning<any>;
        readonly paint: unknown;
        _featureFilter: FeatureFilter;
        readonly onAdd: (map: Map) => void;
        readonly onRemove: (map: Map) => void;
        queryRadius?(bucket: Bucket): number;
        queryIntersectsFeature?(queryGeometry: Array<Point>, feature: VectorTileFeature, featureState: FeatureState, geometry: Array<Array<Point>>, zoom: number, transform: Transform, pixelsToTileUnits: number, pixelPosMatrix: mat4): boolean | number;
        constructor(layer: LayerSpecification | CustomLayerInterface, properties: Readonly<{
            layout?: Properties<any>;
            paint?: Properties<any>;
        }>);
        getCrossfadeParameters(): CrossfadeParameters;
        getLayoutProperty(name: string): any;
        setLayoutProperty(name: string, value: any, options?: StyleSetterOptions): void;
        getPaintProperty(name: string): unknown;
        setPaintProperty(name: string, value: unknown, options?: StyleSetterOptions): boolean;
        _handleSpecialPaintPropertyUpdate(_: string): void;
        _handleOverridablePaintPropertyUpdate<T, R>(name: string, oldValue: PropertyValue<T, R>, newValue: PropertyValue<T, R>): boolean;
        isHidden(zoom: number): boolean;
        updateTransitions(parameters: TransitionParameters): void;
        hasTransition(): boolean;
        recalculate(parameters: EvaluationParameters, availableImages: Array<string>): void;
        serialize(): LayerSpecification;
        _validate(validate: Function, key: string, name: string, value: unknown, options?: StyleSetterOptions): boolean;
        is3D(): boolean;
        isTileClipped(): boolean;
        hasOffscreenPass(): boolean;
        resize(): void;
        isStateDependent(): boolean;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/default_locale' {
    export const defaultLocale: {
        'AttributionControl.ToggleAttribution': string;
        'AttributionControl.MapFeedback': string;
        'FullscreenControl.Enter': string;
        'FullscreenControl.Exit': string;
        'GeolocateControl.FindMyLocation': string;
        'GeolocateControl.LocationNotAvailable': string;
        'LogoControl.Title': string;
        'NavigationControl.ResetBearing': string;
        'NavigationControl.ZoomIn': string;
        'NavigationControl.ZoomOut': string;
        'ScaleControl.Feet': string;
        'ScaleControl.Meters': string;
        'ScaleControl.Kilometers': string;
        'ScaleControl.Miles': string;
        'ScaleControl.NauticalMiles': string;
        'TerrainControl.Enable': string;
        'TerrainControl.Disable': string;
        'CooperativeGesturesHandler.WindowsHelpText': string;
        'CooperativeGesturesHandler.MacHelpText': string;
        'CooperativeGesturesHandler.MobileHelpText': string;
    };
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_image' {
    import { RGBAImage } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/image';
    import type { Map } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/map';
    export type SpriteJSON = {
            [id: string]: StyleImageMetadata & {
                    width: number;
                    height: number;
                    x: number;
                    y: number;
            };
    };
    /**
        * The sprite data
        */
    export type SpriteOnDemandStyleImage = {
            width: number;
            height: number;
            x: number;
            y: number;
            context: CanvasRenderingContext2D;
    };
    /**
        * The style's image metadata
        */
    export type StyleImageData = {
            data: RGBAImage;
            version?: number;
            hasRenderCallback?: boolean;
            userImage?: StyleImageInterface;
            spriteData?: SpriteOnDemandStyleImage;
    };
    /**
        * The style's image metadata
        */
    export type StyleImageMetadata = {
            /**
                * The ratio of pixels in the image to physical pixels on the screen
                */
            pixelRatio: number;
            /**
                * Whether the image should be interpreted as an SDF image
                */
            sdf: boolean;
            /**
                * If `icon-text-fit` is used in a layer with this image, this option defines the part(s) of the image that can be stretched horizontally.
                */
            stretchX?: Array<[number, number]>;
            /**
                * If `icon-text-fit` is used in a layer with this image, this option defines the part(s) of the image that can be stretched vertically.
                */
            stretchY?: Array<[number, number]>;
            /**
                * If `icon-text-fit` is used in a layer with this image, this option defines the part of the image that can be covered by the content in `text-field`.
                */
            content?: [number, number, number, number];
    };
    /**
        * the style's image, including data and metedata
        */
    export type StyleImage = StyleImageData & StyleImageMetadata;
    /**
        * Interface for dynamically generated style images. This is a specification for
        * implementers to model: it is not an exported method or class.
        *
        * Images implementing this interface can be redrawn for every frame. They can be used to animate
        * icons and patterns or make them respond to user input. Style images can implement a
        * {@link StyleImageInterface#render} method. The method is called every frame and
        * can be used to update the image.
        *
        * @see [Add an animated icon to the map.](https://maplibre.org/maplibre-gl-js/docs/examples/add-image-animated/)
        *
        * @example
        * ```ts
        * let flashingSquare = {
        *     width: 64,
        *     height: 64,
        *     data: new Uint8Array(64 * 64 * 4),
        *
        *     onAdd: function(map) {
        *         this.map = map;
        *     },
        *
        *     render: function() {
        *         // keep repainting while the icon is on the map
        *         this.map.triggerRepaint();
        *
        *         // alternate between black and white based on the time
        *         let value = Math.round(Date.now() / 1000) % 2 === 0  ? 255 : 0;
        *
        *         // check if image needs to be changed
        *         if (value !== this.previousValue) {
        *             this.previousValue = value;
        *
        *             let bytesPerPixel = 4;
        *             for (let x = 0; x < this.width; x++) {
        *                 for (let y = 0; y < this.height; y++) {
        *                     let offset = (y * this.width + x) * bytesPerPixel;
        *                     this.data[offset + 0] = value;
        *                     this.data[offset + 1] = value;
        *                     this.data[offset + 2] = value;
        *                     this.data[offset + 3] = 255;
        *                 }
        *             }
        *
        *             // return true to indicate that the image changed
        *             return true;
        *         }
        *     }
        *  }
        *
        *  map.addImage('flashing_square', flashingSquare);
        * ```
        */
    export interface StyleImageInterface {
            width: number;
            height: number;
            data: Uint8Array | Uint8ClampedArray;
            /**
                * This method is called once before every frame where the icon will be used.
                * The method can optionally update the image's `data` member with a new image.
                *
                * If the method updates the image it must return `true` to commit the change.
                * If the method returns `false` or nothing the image is assumed to not have changed.
                *
                * If updates are infrequent it maybe easier to use {@link Map#updateImage} to update
                * the image instead of implementing this method.
                *
                * @returns `true` if this method updated the image. `false` if the image was not changed.
                */
            render?: () => boolean;
            /**
                * Optional method called when the layer has been added to the Map with {@link Map#addImage}.
                *
                * @param map - The Map this custom layer was just added to.
                */
            onAdd?: (map: Map, id: string) => void;
            /**
                * Optional method called when the icon is removed from the map with {@link Map#removeImage}.
                * This gives the image a chance to clean up resources and event listeners.
                */
            onRemove?: () => void;
    }
    export function renderStyleImage(image: StyleImage): boolean;
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/util/vectortile_to_geojson' {
    import type { VectorTileFeature } from '@mapbox/vector-tile';
    import type { LayerSpecification } from '@maplibre/maplibre-gl-style-spec';
    /**
        * A helper for type to omit a property from a type
        */
    type DistributiveKeys<T> = T extends T ? keyof T : never;
    /**
        * A helper for type to omit a property from a type
        */
    type DistributiveOmit<T, K extends DistributiveKeys<T>> = T extends unknown ? Omit<T, K> : never;
    /**
        * An extended geojson feature used by the events to return data to the listener
        */
    export type MapGeoJSONFeature = GeoJSONFeature & {
            layer: DistributiveOmit<LayerSpecification, 'source'> & {
                    source: string;
            };
            source: string;
            sourceLayer?: string;
            state: {
                    [key: string]: any;
            };
    };
    /**
        * A geojson feature
        */
    export class GeoJSONFeature {
            type: 'Feature';
            _geometry: GeoJSON.Geometry;
            properties: {
                    [name: string]: any;
            };
            id: number | string | undefined;
            _vectorTileFeature: VectorTileFeature;
            constructor(vectorTileFeature: VectorTileFeature, z: number, x: number, y: number, id: string | number | undefined);
            get geometry(): GeoJSON.Geometry;
            set geometry(g: GeoJSON.Geometry);
            toJSON(): any;
    }
    export {};
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/source/query_features' {
    import type { SourceCache } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/source_cache';
    import type { StyleLayer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer';
    import type { CollisionIndex } from '@mappedin/mappedin-js/packages/outdoor-context-v4/symbol/collision_index';
    import type { Transform } from '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/transform';
    import type { RetainedQueryData } from '@mappedin/mappedin-js/packages/outdoor-context-v4/symbol/placement';
    import type { FilterSpecification } from '@maplibre/maplibre-gl-style-spec';
    import type { MapGeoJSONFeature } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/vectortile_to_geojson';
    import type Point from '@mapbox/point-geometry';
    /**
        * Options to pass to query the map for the rendered features
        */
    export type QueryRenderedFeaturesOptions = {
            /**
                * An array of [style layer IDs](https://maplibre.org/maplibre-style-spec/#layer-id) for the query to inspect.
                * Only features within these layers will be returned. If this parameter is undefined, all layers will be checked.
                */
            layers?: Array<string>;
            /**
                * A [filter](https://maplibre.org/maplibre-style-spec/layers/#filter) to limit query results.
                */
            filter?: FilterSpecification;
            /**
                * An array of string representing the available images
                */
            availableImages?: Array<string>;
            /**
                * Whether to check if the [options.filter] conforms to the MapLibre Style Specification. Disabling validation is a performance optimization that should only be used if you have previously validated the values you will be passing to this function.
                */
            validate?: boolean;
    };
    /**
        * The options object related to the {@link Map#querySourceFeatures} method
        */
    export type QuerySourceFeatureOptions = {
            /**
                * The name of the source layer to query. *For vector tile sources, this parameter is required.* For GeoJSON sources, it is ignored.
                */
            sourceLayer?: string;
            /**
                * A [filter](https://maplibre.org/maplibre-style-spec/layers/#filter)
                * to limit query results.
                */
            filter?: FilterSpecification;
            /**
                * Whether to check if the [parameters.filter] conforms to the MapLibre Style Specification. Disabling validation is a performance optimization that should only be used if you have previously validated the values you will be passing to this function.
                * @defaultValue true
                */
            validate?: boolean;
    };
    export function queryRenderedFeatures(sourceCache: SourceCache, styleLayers: {
            [_: string]: StyleLayer;
    }, serializedLayers: {
            [_: string]: any;
    }, queryGeometry: Array<Point>, params: QueryRenderedFeaturesOptions, transform: Transform): {
            [key: string]: Array<{
                    featureIndex: number;
                    feature: MapGeoJSONFeature;
            }>;
    };
    export function queryRenderedSymbols(styleLayers: {
            [_: string]: StyleLayer;
    }, serializedLayers: {
            [_: string]: StyleLayer;
    }, sourceCaches: {
            [_: string]: SourceCache;
    }, queryGeometry: Array<Point>, params: QueryRenderedFeaturesOptions, collisionIndex: CollisionIndex, retainedQueryData: {
            [_: number]: RetainedQueryData;
    }): {};
    export function querySourceFeatures(sourceCache: SourceCache, params: QuerySourceFeatureOptions): any[];
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/mouse' {
    import { DragMoveHandler, DragPanResult, DragRotateResult, DragPitchResult } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/drag_handler';
    /**
        * `MousePanHandler` allows the user to pan the map by clicking and dragging
        */
    export interface MousePanHandler extends DragMoveHandler<DragPanResult, MouseEvent> {
    }
    /**
        * `MouseRotateHandler` allows the user to rotate the map by clicking and dragging
        */
    export interface MouseRotateHandler extends DragMoveHandler<DragRotateResult, MouseEvent> {
    }
    /**
        * `MousePitchHandler` allows the user to zoom the map by pitching
        */
    export interface MousePitchHandler extends DragMoveHandler<DragPitchResult, MouseEvent> {
    }
    export const generateMousePanHandler: ({ enable, clickTolerance, }: {
            clickTolerance: number;
            enable?: boolean;
    }) => MousePanHandler;
    export const generateMouseRotationHandler: ({ enable, clickTolerance, bearingDegreesPerPixelMoved, }: {
            clickTolerance: number;
            bearingDegreesPerPixelMoved?: number;
            enable?: boolean;
    }) => MouseRotateHandler;
    export const generateMousePitchHandler: ({ enable, clickTolerance, pitchDegreesPerPixelMoved, }: {
            clickTolerance: number;
            pitchDegreesPerPixelMoved?: number;
            enable?: boolean;
    }) => MousePitchHandler;
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/one_finger_touch_drag' {
    import { DragMoveHandler, DragRotateResult, DragPitchResult } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/drag_handler';
    export interface OneFingerTouchRotateHandler extends DragMoveHandler<DragRotateResult, TouchEvent> {
    }
    export interface OneFingerTouchPitchHandler extends DragMoveHandler<DragPitchResult, TouchEvent> {
    }
    export const generateOneFingerTouchRotationHandler: ({ enable, clickTolerance, bearingDegreesPerPixelMoved, }: {
        clickTolerance: number;
        bearingDegreesPerPixelMoved?: number;
        enable?: boolean;
    }) => OneFingerTouchRotateHandler;
    export const generateOneFingerTouchPitchHandler: ({ enable, clickTolerance, pitchDegreesPerPixelMoved, }: {
        clickTolerance: number;
        pitchDegreesPerPixelMoved?: number;
        enable?: boolean;
    }) => OneFingerTouchPitchHandler;
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/anchor' {
    /**
      * Where to position the anchor.
      * Used by a popup and a marker.
      */
    export type PositionAnchor = 'center' | 'top' | 'bottom' | 'left' | 'right' | 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';
    export const anchorTranslate: {
        [_ in PositionAnchor]: string;
    };
    export function applyAnchorClass(element: HTMLElement, anchor: PositionAnchor, prefix: string): void;
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/render/image_manager' {
    import { Evented } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/evented';
    import { RGBAImage } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/image';
    import { ImagePosition } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/image_atlas';
    import { Texture } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/texture';
    import type { StyleImage } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_image';
    import type { Context } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/context';
    import type { PotpackBox } from 'potpack';
    import type { GetImagesResponse } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/actor_messages';
    type Pattern = {
            bin: PotpackBox;
            position: ImagePosition;
    };
    /**
        * ImageManager does three things:
        *
        * 1. Tracks requests for icon images from tile workers and sends responses when the requests are fulfilled.
        * 2. Builds a texture atlas for pattern images.
        * 3. Rerenders renderable images once per frame
        *
        * These are disparate responsibilities and should eventually be handled by different classes. When we implement
        * data-driven support for `*-pattern`, we'll likely use per-bucket pattern atlases, and that would be a good time
        * to refactor this.
        */
    export class ImageManager extends Evented {
            images: {
                    [_: string]: StyleImage;
            };
            updatedImages: {
                    [_: string]: boolean;
            };
            callbackDispatchedThisFrame: {
                    [_: string]: boolean;
            };
            loaded: boolean;
            /**
                * This is used to track requests for images that are not yet available. When the image is loaded,
                * the requestors will be notified.
                */
            requestors: Array<{
                    ids: Array<string>;
                    promiseResolve: (value: GetImagesResponse) => void;
            }>;
            patterns: {
                    [_: string]: Pattern;
            };
            atlasImage: RGBAImage;
            atlasTexture: Texture;
            dirty: boolean;
            constructor();
            isLoaded(): boolean;
            setLoaded(loaded: boolean): void;
            getImage(id: string): StyleImage;
            addImage(id: string, image: StyleImage): void;
            _validate(id: string, image: StyleImage): boolean;
            _validateStretch(stretch: Array<[number, number]>, size: number): boolean;
            _validateContent(content: [number, number, number, number], image: StyleImage): boolean;
            updateImage(id: string, image: StyleImage, validate?: boolean): void;
            removeImage(id: string): void;
            listImages(): Array<string>;
            getImages(ids: Array<string>): Promise<GetImagesResponse>;
            _getImagesForIds(ids: Array<string>): GetImagesResponse;
            getPixelSize(): {
                    width: number;
                    height: number;
            };
            getPattern(id: string): ImagePosition;
            bind(context: Context): void;
            _updatePatternAtlas(): void;
            beginFrame(): void;
            dispatchRenderCallbacks(ids: Array<string>): void;
    }
    export {};
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/render/glyph_manager' {
    import { loadGlyphRange } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/load_glyph_range';
    import TinySDF from '@mapbox/tiny-sdf';
    import type { StyleGlyph } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_glyph';
    import type { RequestManager } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/request_manager';
    import type { GetGlyphsResponse } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/actor_messages';
    type Entry = {
        glyphs: {
            [id: number]: StyleGlyph | null;
        };
        requests: {
            [range: number]: Promise<{
                [_: number]: StyleGlyph | null;
            }>;
        };
        ranges: {
            [range: number]: boolean | null;
        };
        tinySDF?: TinySDF;
    };
    export class GlyphManager {
        requestManager: RequestManager;
        localIdeographFontFamily: string | false;
        entries: {
            [stack: string]: Entry;
        };
        url: string;
        static loadGlyphRange: typeof loadGlyphRange;
        static TinySDF: typeof TinySDF;
        constructor(requestManager: RequestManager, localIdeographFontFamily?: string | false);
        setURL(url?: string | null): void;
        getGlyphs(glyphs: {
            [stack: string]: Array<number>;
        }): Promise<GetGlyphsResponse>;
        _getAndCacheGlyphsPromise(stack: string, id: number): Promise<{
            stack: string;
            id: number;
            glyph: StyleGlyph;
        }>;
        _doesCharSupportLocalGlyph(id: number): boolean;
        _tinySDF(entry: Entry, stack: string, id: number): StyleGlyph;
    }
    export {};
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/style/light' {
    import { Color } from '@maplibre/maplibre-gl-style-spec';
    import { Evented } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/evented';
    import type { StylePropertySpecification, LightSpecification } from '@maplibre/maplibre-gl-style-spec';
    import type { EvaluationParameters } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/evaluation_parameters';
    import type { StyleSetterOptions } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style';
    import { Transitionable, Transitioning, PossiblyEvaluated, DataConstantProperty } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/properties';
    import type { Property, PropertyValue, TransitionParameters } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/properties';
    type LightPosition = {
        x: number;
        y: number;
        z: number;
    };
    class LightPositionProperty implements Property<[number, number, number], LightPosition> {
        specification: StylePropertySpecification;
        constructor();
        possiblyEvaluate(value: PropertyValue<[number, number, number], LightPosition>, parameters: EvaluationParameters): LightPosition;
        interpolate(a: LightPosition, b: LightPosition, t: number): LightPosition;
    }
    type Props = {
        anchor: DataConstantProperty<'map' | 'viewport'>;
        position: LightPositionProperty;
        color: DataConstantProperty<Color>;
        intensity: DataConstantProperty<number>;
    };
    type PropsPossiblyEvaluated = {
        anchor: 'map' | 'viewport';
        position: LightPosition;
        color: Color;
        intensity: number;
    };
    export class Light extends Evented {
        _transitionable: Transitionable<Props>;
        _transitioning: Transitioning<Props>;
        properties: PossiblyEvaluated<Props, PropsPossiblyEvaluated>;
        constructor(lightOptions?: LightSpecification);
        getLight(): LightSpecification;
        setLight(light?: LightSpecification, options?: StyleSetterOptions): void;
        updateTransitions(parameters: TransitionParameters): void;
        hasTransition(): boolean;
        recalculate(parameters: EvaluationParameters): void;
        _validate(validate: Function, value: unknown, options?: {
            validate?: boolean;
        }): boolean;
    }
    export {};
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/render/line_atlas' {
    import type { Context } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/context';
    /**
        * A dash entry
        */
    type DashEntry = {
            y: number;
            height: number;
            width: number;
    };
    /**
        * @internal
        * A LineAtlas lets us reuse rendered dashed lines
        * by writing many of them to a texture and then fetching their positions
        * using {@link LineAtlas#getDash}.
        *
        * @param width - the width
        * @param height - the height
        */
    export class LineAtlas {
            width: number;
            height: number;
            nextRow: number;
            bytes: number;
            data: Uint8Array;
            dashEntry: {
                    [_: string]: DashEntry;
            };
            dirty: boolean;
            texture: WebGLTexture;
            constructor(width: number, height: number);
            /**
                * Get or create a dash line pattern.
                *
                * @param dasharray - the key (represented by numbers) to get the dash texture
                * @param round - whether to add circle caps in between dash segments
                * @returns position of dash texture in {@link DashEntry}
                */
            getDash(dasharray: Array<number>, round: boolean): DashEntry;
            getDashRanges(dasharray: Array<number>, lineAtlasWidth: number, stretch: number): any[];
            addRoundDash(ranges: any, stretch: number, n: number): void;
            addRegularDash(ranges: any): void;
            addDash(dasharray: Array<number>, round: boolean): DashEntry;
            bind(context: Context): void;
    }
    export {};
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/util/dispatcher' {
    import { Actor, MessageHandler } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/actor';
    import type { WorkerPool } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/worker_pool';
    import type { RequestResponseMessageMap } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/actor_messages';
    import { MessageType } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/actor_messages';
    /**
        * Responsible for sending messages from a {@link Source} to an associated
        * {@link WorkerSource}.
        */
    export class Dispatcher {
            workerPool: WorkerPool;
            actors: Array<Actor>;
            currentActor: number;
            id: string | number;
            constructor(workerPool: WorkerPool, mapId: string | number);
            /**
                * Broadcast a message to all Workers.
                */
            broadcast<T extends MessageType>(type: T, data: RequestResponseMessageMap[T][0]): Promise<RequestResponseMessageMap[T][1][]>;
            /**
                * Acquires an actor to dispatch messages to. The actors are distributed in round-robin fashion.
                * @returns An actor object backed by a web worker for processing messages.
                */
            getActor(): Actor;
            remove(mapRemoved?: boolean): void;
            registerMessageHandler<T extends MessageType>(type: T, handler: MessageHandler<T>): void;
    }
    export function getGlobalDispatcher(): Dispatcher;
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/source/source_cache' {
    import { Tile } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile';
    import { Evented } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/evented';
    import { TileCache } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile_cache';
    import { Context } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/context';
    import Point from '@mapbox/point-geometry';
    import { OverscaledTileID } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile_id';
    import { SourceFeatureState } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/source_state';
    import type { Source } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/source';
    import type { Map } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/map';
    import type { Style } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style';
    import type { Dispatcher } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/dispatcher';
    import type { Transform } from '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/transform';
    import type { TileState } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile';
    import type { SourceSpecification } from '@maplibre/maplibre-gl-style-spec';
    import { Terrain } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/terrain';
    /**
        * @internal
        * `SourceCache` is responsible for
        *
        *  - creating an instance of `Source`
        *  - forwarding events from `Source`
        *  - caching tiles loaded from an instance of `Source`
        *  - loading the tiles needed to render a given viewport
        *  - unloading the cached tiles not needed to render a given viewport
        */
    export class SourceCache extends Evented {
            id: string;
            dispatcher: Dispatcher;
            map: Map;
            style: Style;
            _source: Source;
            /**
                * @internal
                * signifies that the TileJSON is loaded if applicable.
                * if the source type does not come with a TileJSON, the flag signifies the
                * source data has loaded (i.e geojson has been tiled on the worker and is ready)
                */
            _sourceLoaded: boolean;
            _sourceErrored: boolean;
            _tiles: {
                    [_: string]: Tile;
            };
            _prevLng: number;
            _cache: TileCache;
            _timers: {
                    [_ in any]: ReturnType<typeof setTimeout>;
            };
            _cacheTimers: {
                    [_ in any]: ReturnType<typeof setTimeout>;
            };
            _maxTileCacheSize: number;
            _maxTileCacheZoomLevels: number;
            _paused: boolean;
            _shouldReloadOnResume: boolean;
            _coveredTiles: {
                    [_: string]: boolean;
            };
            transform: Transform;
            terrain: Terrain;
            used: boolean;
            usedForTerrain: boolean;
            tileSize: number;
            _state: SourceFeatureState;
            _loadedParentTiles: {
                    [_: string]: Tile;
            };
            _didEmitContent: boolean;
            _updated: boolean;
            static maxUnderzooming: number;
            static maxOverzooming: number;
            constructor(id: string, options: SourceSpecification, dispatcher: Dispatcher);
            onAdd(map: Map): void;
            onRemove(map: Map): void;
            /**
                * Return true if no tile data is pending, tiles will not change unless
                * an additional API call is received.
                */
            loaded(): boolean;
            getSource(): Source;
            pause(): void;
            resume(): void;
            _loadTile(tile: Tile, id: string, state: TileState): Promise<void>;
            _unloadTile(tile: Tile): void;
            _abortTile(tile: Tile): void;
            serialize(): any;
            prepare(context: Context): void;
            /**
                * Return all tile ids ordered with z-order, and cast to numbers
                */
            getIds(): Array<string>;
            getRenderableIds(symbolLayer?: boolean): Array<string>;
            hasRenderableParent(tileID: OverscaledTileID): boolean;
            _isIdRenderable(id: string, symbolLayer?: boolean): boolean;
            reload(): void;
            _reloadTile(id: string, state: TileState): Promise<void>;
            _tileLoaded(tile: Tile, id: string, previousState: TileState): void;
            /**
                * For raster terrain source, backfill DEM to eliminate visible tile boundaries
                */
            _backfillDEM(tile: Tile): void;
            /**
                * Get a specific tile by TileID
                */
            getTile(tileID: OverscaledTileID): Tile;
            /**
                * Get a specific tile by id
                */
            getTileByID(id: string): Tile;
            /**
                * For a given set of tiles, retain children that are loaded and have a zoom
                * between `zoom` (exclusive) and `maxCoveringZoom` (inclusive)
                */
            _retainLoadedChildren(idealTiles: {
                    [_ in any]: OverscaledTileID;
            }, zoom: number, maxCoveringZoom: number, retain: {
                    [_ in any]: OverscaledTileID;
            }): void;
            /**
                * Find a loaded parent of the given tile (up to minCoveringZoom)
                */
            findLoadedParent(tileID: OverscaledTileID, minCoveringZoom: number): Tile;
            _getLoadedTile(tileID: OverscaledTileID): Tile;
            /**
                * Resizes the tile cache based on the current viewport's size
                * or the maxTileCacheSize option passed during map creation
                *
                * Larger viewports use more tiles and need larger caches. Larger viewports
                * are more likely to be found on devices with more memory and on pages where
                * the map is more important.
                */
            updateCacheSize(transform: Transform): void;
            handleWrapJump(lng: number): void;
            /**
                * Removes tiles that are outside the viewport and adds new tiles that
                * are inside the viewport.
                */
            update(transform: Transform, terrain?: Terrain): void;
            releaseSymbolFadeTiles(): void;
            _updateRetainedTiles(idealTileIDs: Array<OverscaledTileID>, zoom: number): {
                    [_: string]: OverscaledTileID;
            };
            _updateLoadedParentTileCache(): void;
            /**
                * Add a tile, given its coordinate, to the pyramid.
                */
            _addTile(tileID: OverscaledTileID): Tile;
            _setTileReloadTimer(id: string, tile: Tile): void;
            /**
                * Remove a tile, given its id, from the pyramid
                */
            _removeTile(id: string): void;
            /**
                * Remove all tiles from this pyramid
                */
            clearTiles(): void;
            /**
                * Search through our current tiles and attempt to find the tiles that
                * cover the given bounds.
                * @param pointQueryGeometry - coordinates of the corners of bounding rectangle
                * @returns result items have `{tile, minX, maxX, minY, maxY}`, where min/max bounding values are the given bounds transformed in into the coordinate space of this tile.
                */
            tilesIn(pointQueryGeometry: Array<Point>, maxPitchScaleFactor: number, has3DLayer: boolean): any[];
            getVisibleCoordinates(symbolLayer?: boolean): Array<OverscaledTileID>;
            hasTransition(): boolean;
            /**
                * Set the value of a particular state for a feature
                */
            setFeatureState(sourceLayer: string, featureId: number | string, state: any): void;
            /**
                * Resets the value of a particular state key for a feature
                */
            removeFeatureState(sourceLayer?: string, featureId?: number | string, key?: string): void;
            /**
                * Get the entire state object for a feature
                */
            getFeatureState(sourceLayer: string, featureId: number | string): import("@maplibre/maplibre-gl-style-spec").FeatureState;
            /**
                * Sets the set of keys that the tile depends on. This allows tiles to
                * be reloaded when their dependencies change.
                */
            setDependencies(tileKey: string, namespace: string, dependencies: Array<string>): void;
            /**
                * Reloads all tiles that depend on the given keys.
                */
            reloadTilesForDependencies(namespaces: Array<string>, keys: Array<string>): void;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/style/pauseable_placement' {
    import { Placement } from '@mappedin/mappedin-js/packages/outdoor-context-v4/symbol/placement';
    import type { Transform } from '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/transform';
    import type { StyleLayer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer';
    import type { SymbolStyleLayer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/symbol_style_layer';
    import type { Tile } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile';
    import type { BucketPart } from '@mappedin/mappedin-js/packages/outdoor-context-v4/symbol/placement';
    import { Terrain } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/terrain';
    class LayerPlacement {
        _sortAcrossTiles: boolean;
        _currentTileIndex: number;
        _currentPartIndex: number;
        _seenCrossTileIDs: {
            [k in string | number]: boolean;
        };
        _bucketParts: Array<BucketPart>;
        constructor(styleLayer: SymbolStyleLayer);
        continuePlacement(tiles: Array<Tile>, placement: Placement, showCollisionBoxes: boolean, styleLayer: StyleLayer, shouldPausePlacement: () => boolean): boolean;
    }
    export class PauseablePlacement {
        placement: Placement;
        _done: boolean;
        _currentPlacementIndex: number;
        _forceFullPlacement: boolean;
        _showCollisionBoxes: boolean;
        _inProgressLayer: LayerPlacement;
        constructor(transform: Transform, terrain: Terrain, order: Array<string>, forceFullPlacement: boolean, showCollisionBoxes: boolean, fadeDuration: number, crossSourceCollisions: boolean, prevPlacement?: Placement);
        isDone(): boolean;
        continuePlacement(order: Array<string>, layers: {
            [_: string]: StyleLayer;
        }, layerTiles: {
            [_: string]: Array<Tile>;
        }): void;
        commit(now: number): Placement;
    }
    export {};
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/style/zoom_history' {
    export class ZoomHistory {
        lastZoom: number;
        lastFloorZoom: number;
        lastIntegerZoom: number;
        lastIntegerZoomTime: number;
        first: boolean;
        constructor();
        update(z: number, now: number): boolean;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/symbol/cross_tile_symbol_index' {
    import KDBush from 'kdbush';
    import { SymbolInstanceArray } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/array_types.g';
    import type { SymbolInstance } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/array_types.g';
    import type { OverscaledTileID } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile_id';
    import type { SymbolBucket } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/bucket/symbol_bucket';
    import type { StyleLayer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer';
    import type { Tile } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile';
    export const KDBUSH_THRESHHOLD = 128;
    interface SymbolsByKeyEntry {
        index?: KDBush;
        positions?: {
            x: number;
            y: number;
        }[];
        crossTileIDs: number[];
    }
    class TileLayerIndex {
        tileID: OverscaledTileID;
        bucketInstanceId: number;
        _symbolsByKey: Record<number, SymbolsByKeyEntry>;
        constructor(tileID: OverscaledTileID, symbolInstances: SymbolInstanceArray, bucketInstanceId: number);
        getScaledCoordinates(symbolInstance: SymbolInstance, childTileID: OverscaledTileID): {
            x: number;
            y: number;
        };
        findMatches(symbolInstances: SymbolInstanceArray, newTileID: OverscaledTileID, zoomCrossTileIDs: {
            [crossTileID: number]: boolean;
        }): void;
        getCrossTileIDsLists(): number[][];
    }
    class CrossTileIDs {
        maxCrossTileID: number;
        constructor();
        generate(): number;
    }
    class CrossTileSymbolLayerIndex {
        indexes: {
            [zoom in string | number]: {
                [tileId in string | number]: TileLayerIndex;
            };
        };
        usedCrossTileIDs: {
            [zoom in string | number]: {
                [crossTileID: number]: boolean;
            };
        };
        lng: number;
        constructor();
        handleWrapJump(lng: number): void;
        addBucket(tileID: OverscaledTileID, bucket: SymbolBucket, crossTileIDs: CrossTileIDs): boolean;
        removeBucketCrossTileIDs(zoom: string | number, removedBucket: TileLayerIndex): void;
        removeStaleBuckets(currentIDs: {
            [k in string | number]: boolean;
        }): boolean;
    }
    export class CrossTileSymbolIndex {
        layerIndexes: {
            [layerId: string]: CrossTileSymbolLayerIndex;
        };
        crossTileIDs: CrossTileIDs;
        maxBucketInstanceId: number;
        bucketsInCurrentPlacement: {
            [_: number]: boolean;
        };
        constructor();
        addLayer(styleLayer: StyleLayer, tiles: Array<Tile>, lng: number): boolean;
        pruneUnusedLayers(usedLayers: Array<string>): void;
    }
    export {};
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/transform' {
    import { LngLat } from '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/lng_lat';
    import { LngLatBounds } from '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/lng_lat_bounds';
    import { MercatorCoordinate } from '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/mercator_coordinate';
    import Point from '@mapbox/point-geometry';
    import { mat4, mat2 } from 'gl-matrix';
    import { EdgeInsets } from '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/edge_insets';
    import { UnwrappedTileID, OverscaledTileID, CanonicalTileID } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile_id';
    import type { PaddingOptions } from '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/edge_insets';
    import { Terrain } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/terrain';
    export const MAX_VALID_LATITUDE = 85.051129;
    /**
        * @internal
        * A single transform, generally used for a single tile to be
        * scaled, rotated, and zoomed.
        */
    export class Transform {
            tileSize: number;
            tileZoom: number;
            lngRange: [number, number];
            latRange: [number, number];
            scale: number;
            width: number;
            height: number;
            angle: number;
            rotationMatrix: mat2;
            pixelsToGLUnits: [number, number];
            cameraToCenterDistance: number;
            mercatorMatrix: mat4;
            projMatrix: mat4;
            invProjMatrix: mat4;
            alignedProjMatrix: mat4;
            pixelMatrix: mat4;
            pixelMatrix3D: mat4;
            pixelMatrixInverse: mat4;
            glCoordMatrix: mat4;
            labelPlaneMatrix: mat4;
            minElevationForCurrentTile: number;
            _fov: number;
            _pitch: number;
            _zoom: number;
            _unmodified: boolean;
            _renderWorldCopies: boolean;
            _minZoom: number;
            _maxZoom: number;
            _minPitch: number;
            _maxPitch: number;
            _center: LngLat;
            _elevation: number;
            _pixelPerMeter: number;
            _edgeInsets: EdgeInsets;
            _constraining: boolean;
            _posMatrixCache: {
                    [_: string]: mat4;
            };
            _alignedPosMatrixCache: {
                    [_: string]: mat4;
            };
            constructor(minZoom?: number, maxZoom?: number, minPitch?: number, maxPitch?: number, renderWorldCopies?: boolean);
            clone(): Transform;
            apply(that: Transform): void;
            get minZoom(): number;
            set minZoom(zoom: number);
            get maxZoom(): number;
            set maxZoom(zoom: number);
            get minPitch(): number;
            set minPitch(pitch: number);
            get maxPitch(): number;
            set maxPitch(pitch: number);
            get renderWorldCopies(): boolean;
            set renderWorldCopies(renderWorldCopies: boolean);
            get worldSize(): number;
            get centerOffset(): Point;
            get size(): Point;
            get bearing(): number;
            set bearing(bearing: number);
            get pitch(): number;
            set pitch(pitch: number);
            get fov(): number;
            set fov(fov: number);
            get zoom(): number;
            set zoom(zoom: number);
            get center(): LngLat;
            set center(center: LngLat);
            /**
                * Elevation at current center point, meters above sea level
                */
            get elevation(): number;
            set elevation(elevation: number);
            get padding(): PaddingOptions;
            set padding(padding: PaddingOptions);
            /**
                * The center of the screen in pixels with the top-left corner being (0,0)
                * and +y axis pointing downwards. This accounts for padding.
                */
            get centerPoint(): Point;
            /**
                * Returns if the padding params match
                *
                * @param padding - the padding to check against
                * @returns true if they are equal, false otherwise
                */
            isPaddingEqual(padding: PaddingOptions): boolean;
            /**
                * Helper method to update edge-insets in place
                *
                * @param start - the starting padding
                * @param target - the target padding
                * @param t - the step/weight
                */
            interpolatePadding(start: PaddingOptions, target: PaddingOptions, t: number): void;
            /**
                * Return a zoom level that will cover all tiles the transform
                * @param options - the options
                * @returns zoom level An integer zoom level at which all tiles will be visible.
                */
            coveringZoomLevel(options: {
                    /**
                        * Target zoom level. If true, the value will be rounded to the closest integer. Otherwise the value will be floored.
                        */
                    roundZoom?: boolean;
                    /**
                        * Tile size, expressed in screen pixels.
                        */
                    tileSize: number;
            }): number;
            /**
                * Return any "wrapped" copies of a given tile coordinate that are visible
                * in the current view.
                */
            getVisibleUnwrappedCoordinates(tileID: CanonicalTileID): UnwrappedTileID[];
            /**
                * Return all coordinates that could cover this transform for a covering
                * zoom level.
                * @param options - the options
                * @returns OverscaledTileIDs
                */
            coveringTiles(options: {
                    tileSize: number;
                    minzoom?: number;
                    maxzoom?: number;
                    roundZoom?: boolean;
                    reparseOverscaled?: boolean;
                    renderWorldCopies?: boolean;
                    terrain?: Terrain;
            }): Array<OverscaledTileID>;
            resize(width: number, height: number): void;
            get unmodified(): boolean;
            zoomScale(zoom: number): number;
            scaleZoom(scale: number): number;
            /**
                * Convert from LngLat to world coordinates (Mercator coordinates scaled by 512)
                * @param lnglat - the lngLat
                * @returns Point
                */
            project(lnglat: LngLat): Point;
            /**
                * Convert from world coordinates ([0, 512],[0, 512]) to LngLat ([-180, 180], [-90, 90])
                * @param point - world coordinate
                * @returns LngLat
                */
            unproject(point: Point): LngLat;
            get point(): Point;
            /**
                * get the camera position in LngLat and altitudes in meter
                * @returns An object with lngLat & altitude.
                */
            getCameraPosition(): {
                    lngLat: LngLat;
                    altitude: number;
            };
            /**
                * This method works in combination with freezeElevation activated.
                * freezeElevtion is enabled during map-panning because during this the camera should sit in constant height.
                * After panning finished, call this method to recalculate the zoomlevel for the current camera-height in current terrain.
                * @param terrain - the terrain
                */
            recalculateZoom(terrain: Terrain): void;
            setLocationAtPoint(lnglat: LngLat, point: Point): void;
            /**
                * Given a LngLat location, return the screen point that corresponds to it
                * @param lnglat - location
                * @param terrain - optional terrain
                * @returns screen point
                */
            locationPoint(lnglat: LngLat, terrain?: Terrain): Point;
            /**
                * Given a point on screen, return its lnglat
                * @param p - screen point
                * @param terrain - optional terrain
                * @returns lnglat location
                */
            pointLocation(p: Point, terrain?: Terrain): LngLat;
            /**
                * Given a geographical lnglat, return an unrounded
                * coordinate that represents it at low zoom level.
                * @param lnglat - the location
                * @returns The mercator coordinate
                */
            locationCoordinate(lnglat: LngLat): MercatorCoordinate;
            /**
                * Given a Coordinate, return its geographical position.
                * @param coord - mercator coordinates
                * @returns lng and lat
                */
            coordinateLocation(coord: MercatorCoordinate): LngLat;
            /**
                * Given a Point, return its mercator coordinate.
                * @param p - the point
                * @param terrain - optional terrain
                * @returns lnglat
                */
            pointCoordinate(p: Point, terrain?: Terrain): MercatorCoordinate;
            /**
                * Given a coordinate, return the screen point that corresponds to it
                * @param coord - the coordinates
                * @param elevation - the elevation
                * @param pixelMatrix - the pixel matrix
                * @returns screen point
                */
            coordinatePoint(coord: MercatorCoordinate, elevation?: number, pixelMatrix?: mat4): Point;
            /**
                * Returns the map's geographical bounds. When the bearing or pitch is non-zero, the visible region is not
                * an axis-aligned rectangle, and the result is the smallest bounds that encompasses the visible region.
                * @returns Returns a {@link LngLatBounds} object describing the map's geographical bounds.
                */
            getBounds(): LngLatBounds;
            /**
                * Returns the maximum geographical bounds the map is constrained to, or `null` if none set.
                * @returns max bounds
                */
            getMaxBounds(): LngLatBounds | null;
            /**
                * Calculate pixel height of the visible horizon in relation to map-center (e.g. height/2),
                * multiplied by a static factor to simulate the earth-radius.
                * The calculated value is the horizontal line from the camera-height to sea-level.
                * @returns Horizon above center in pixels.
                */
            getHorizon(): number;
            /**
                * Sets or clears the map's geographical constraints.
                * @param bounds - A {@link LngLatBounds} object describing the new geographic boundaries of the map.
                */
            setMaxBounds(bounds?: LngLatBounds | null): void;
            /**
                * Calculate the posMatrix that, given a tile coordinate, would be used to display the tile on a map.
                * @param unwrappedTileID - the tile ID
                */
            calculatePosMatrix(unwrappedTileID: UnwrappedTileID, aligned?: boolean): mat4;
            customLayerMatrix(): mat4;
            /**
                * Get center lngLat and zoom to ensure that
                * 1) everything beyond the bounds is excluded
                * 2) a given lngLat is as near the center as possible
                * Bounds are those set by maxBounds or North & South "Poles" and, if only 1 globe is displayed, antimeridian.
                */
            getConstrained(lngLat: LngLat, zoom: number): {
                    center: LngLat;
                    zoom: number;
            };
            _constrain(): void;
            _calcMatrices(): void;
            maxPitchScaleFactor(): number;
            /**
                * The camera looks at the map from a 3D (lng, lat, altitude) location. Let's use `cameraLocation`
                * as the name for the location under the camera and on the surface of the earth (lng, lat, 0).
                * `cameraPoint` is the projected position of the `cameraLocation`.
                *
                * This point is useful to us because only fill-extrusions that are between `cameraPoint` and
                * the query point on the surface of the earth can extend and intersect the query.
                *
                * When the map is not pitched the `cameraPoint` is equivalent to the center of the map because
                * the camera is right above the center of the map.
                */
            getCameraPoint(): Point;
            /**
                * When the map is pitched, some of the 3D features that intersect a query will not intersect
                * the query at the surface of the earth. Instead the feature may be closer and only intersect
                * the query because it extrudes into the air.
                * @param queryGeometry - For point queries, the line from the query point to the "camera point",
                * for other geometries, the envelope of the query geometry and the "camera point"
                * @returns a geometry that includes all of the original query as well as all possible ares of the
                * screen where the *base* of a visible extrusion could be.
                *
                */
            getCameraQueryGeometry(queryGeometry: Array<Point>): Array<Point>;
            /**
                * Return the distance to the camera in clip space from a LngLat.
                * This can be compared to the value from the depth buffer (terrain.depthAtPoint)
                * to determine whether a point is occluded.
                * @param lngLat - the point
                * @param elevation - the point's elevation
                * @returns depth value in clip space (between 0 and 1)
                */
            lngLatToCameraDepth(lngLat: LngLat, elevation: number): number;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/style/evaluation_parameters' {
    import { ZoomHistory } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/zoom_history';
    import type { TransitionSpecification } from '@maplibre/maplibre-gl-style-spec';
    export type CrossfadeParameters = {
        fromScale: number;
        toScale: number;
        t: number;
    };
    /**
      * @internal
      * A parameter that can be evaluated to a value
      */
    export class EvaluationParameters {
        zoom: number;
        now: number;
        fadeDuration: number;
        zoomHistory: ZoomHistory;
        transition: TransitionSpecification;
        constructor(zoom: number, options?: any);
        isSupportedScript(str: string): boolean;
        crossFadingFactor(): number;
        getCrossfadeParameters(): CrossfadeParameters;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/symbol/placement' {
    import { CollisionIndex } from '@mappedin/mappedin-js/packages/outdoor-context-v4/symbol/collision_index';
    import type { FeatureKey } from '@mappedin/mappedin-js/packages/outdoor-context-v4/symbol/collision_index';
    import { mat4 } from 'gl-matrix';
    import Point from '@mapbox/point-geometry';
    import type { Transform } from '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/transform';
    import type { StyleLayer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer';
    import { PossiblyEvaluated } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/properties';
    import type { SymbolLayoutProps, SymbolLayoutPropsPossiblyEvaluated } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/symbol_style_layer_properties.g';
    import { OverlapMode } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/overlap_mode';
    import type { Tile } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile';
    import { SymbolBucket, SingleCollisionBox } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/bucket/symbol_bucket';
    import type { CollisionBoxArray, SymbolInstance, TextAnchorOffset } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/array_types.g';
    import type { FeatureIndex } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/feature_index';
    import type { OverscaledTileID } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile_id';
    import { Terrain } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/terrain';
    import { TextAnchor } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/variable_text_anchor';
    class OpacityState {
        opacity: number;
        placed: boolean;
        constructor(prevState: OpacityState, increment: number, placed: boolean, skipFade?: boolean | null);
        isHidden(): boolean;
    }
    class JointOpacityState {
        text: OpacityState;
        icon: OpacityState;
        constructor(prevState: JointOpacityState, increment: number, placedText: boolean, placedIcon: boolean, skipFade?: boolean | null);
        isHidden(): boolean;
    }
    class JointPlacement {
        text: boolean;
        icon: boolean;
        skipFade: boolean;
        constructor(text: boolean, icon: boolean, skipFade: boolean);
    }
    class CollisionCircleArray {
        invProjMatrix: mat4;
        viewportMatrix: mat4;
        circles: Array<number>;
        constructor();
    }
    export class RetainedQueryData {
        bucketInstanceId: number;
        featureIndex: FeatureIndex;
        sourceLayerIndex: number;
        bucketIndex: number;
        tileID: OverscaledTileID;
        featureSortOrder: Array<number>;
        constructor(bucketInstanceId: number, featureIndex: FeatureIndex, sourceLayerIndex: number, bucketIndex: number, tileID: OverscaledTileID);
    }
    type CollisionGroup = {
        ID: number;
        predicate?: (key: FeatureKey) => boolean;
    };
    class CollisionGroups {
        collisionGroups: {
            [groupName: string]: CollisionGroup;
        };
        maxGroupID: number;
        crossSourceCollisions: boolean;
        constructor(crossSourceCollisions: boolean);
        get(sourceID: string): CollisionGroup;
    }
    export type VariableOffset = {
        textOffset: [number, number];
        width: number;
        height: number;
        anchor: TextAnchor;
        textBoxScale: number;
        prevAnchor?: TextAnchor;
    };
    type TileLayerParameters = {
        bucket: SymbolBucket;
        layout: PossiblyEvaluated<SymbolLayoutProps, SymbolLayoutPropsPossiblyEvaluated>;
        posMatrix: mat4;
        textLabelPlaneMatrix: mat4;
        labelToScreenMatrix: mat4;
        scale: number;
        textPixelRatio: number;
        holdingForFade: boolean;
        collisionBoxArray: CollisionBoxArray;
        partiallyEvaluatedTextSize: {
            uSize: number;
            uSizeT: number;
        };
        collisionGroup: CollisionGroup;
    };
    export type BucketPart = {
        sortKey?: number | void;
        symbolInstanceStart: number;
        symbolInstanceEnd: number;
        parameters: TileLayerParameters;
    };
    export type CrossTileID = string | number;
    export class Placement {
        transform: Transform;
        terrain: Terrain;
        collisionIndex: CollisionIndex;
        placements: {
            [_ in CrossTileID]: JointPlacement;
        };
        opacities: {
            [_ in CrossTileID]: JointOpacityState;
        };
        variableOffsets: {
            [_ in CrossTileID]: VariableOffset;
        };
        placedOrientations: {
            [_ in CrossTileID]: number;
        };
        commitTime: number;
        prevZoomAdjustment: number;
        lastPlacementChangeTime: number;
        stale: boolean;
        fadeDuration: number;
        retainedQueryData: {
            [_: number]: RetainedQueryData;
        };
        collisionGroups: CollisionGroups;
        prevPlacement: Placement;
        zoomAtLastRecencyCheck: number;
        collisionCircleArrays: {
            [k in any]: CollisionCircleArray;
        };
        constructor(transform: Transform, terrain: Terrain, fadeDuration: number, crossSourceCollisions: boolean, prevPlacement?: Placement);
        getBucketParts(results: Array<BucketPart>, styleLayer: StyleLayer, tile: Tile, sortAcrossTiles: boolean): void;
        attemptAnchorPlacement(textAnchorOffset: TextAnchorOffset, textBox: SingleCollisionBox, width: number, height: number, textBoxScale: number, rotateWithMap: boolean, pitchWithMap: boolean, textPixelRatio: number, posMatrix: mat4, collisionGroup: CollisionGroup, textOverlapMode: OverlapMode, symbolInstance: SymbolInstance, bucket: SymbolBucket, orientation: number, iconBox?: SingleCollisionBox | null, getElevation?: (x: number, y: number) => number): {
            shift: Point;
            placedGlyphBoxes: {
                box: Array<number>;
                offscreen: boolean;
            };
        };
        placeLayerBucketPart(bucketPart: BucketPart, seenCrossTileIDs: {
            [k in string | number]: boolean;
        }, showCollisionBoxes: boolean): void;
        markUsedJustification(bucket: SymbolBucket, placedAnchor: TextAnchor, symbolInstance: SymbolInstance, orientation: number): void;
        markUsedOrientation(bucket: SymbolBucket, orientation: number, symbolInstance: SymbolInstance): void;
        commit(now: number): void;
        updateLayerOpacities(styleLayer: StyleLayer, tiles: Array<Tile>): void;
        updateBucketOpacities(bucket: SymbolBucket, seenCrossTileIDs: {
            [k in string | number]: boolean;
        }, collisionBoxArray?: CollisionBoxArray | null): void;
        symbolFadeChange(now: number): number;
        zoomAdjustment(zoom: number): number;
        hasTransitions(now: number): boolean;
        stillRecent(now: number, zoom: number): boolean;
        setStale(): void;
    }
    export {};
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/style/validate_style' {
    import type { Evented } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/evented';
    type ValidationError = {
        message: string;
        line: number;
        identifier?: string;
    };
    export type Validator = (a: any) => ReadonlyArray<ValidationError>;
    type ValidateStyle = {
        source: Validator;
        sprite: Validator;
        glyphs: Validator;
        layer: Validator;
        light: Validator;
        terrain: Validator;
        filter: Validator;
        paintProperty: Validator;
        layoutProperty: Validator;
        (b: any, a?: any | null): ReadonlyArray<ValidationError>;
    };
    export const validateStyle: ValidateStyle;
    export const validateSource: Validator;
    export const validateLight: Validator;
    export const validateTerrain: Validator;
    export const validateFilter: Validator;
    export const validatePaintProperty: Validator;
    export const validateLayoutProperty: Validator;
    export function emitValidationErrors(emitter: Evented, errors?: ReadonlyArray<{
        message: string;
        identifier?: string;
    }> | null): boolean;
    export {};
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/util/actor_messages' {
    import type { LoadGeoJSONParameters } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/geojson_worker_source';
    import type { TileParameters, WorkerDEMTileParameters, WorkerTileParameters, WorkerTileResult } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/worker_source';
    import type { DEMData } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/dem_data';
    import type { StyleImage } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_image';
    import type { StyleGlyph } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_glyph';
    import type { PluginState } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/rtl_text_plugin_status';
    import type { LayerSpecification } from '@maplibre/maplibre-gl-style-spec';
    import type { OverscaledTileID } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile_id';
    import type { GetResourceResponse, RequestParameters } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/ajax';
    /**
        * The parameters needed in order to get information about the cluster
        */
    export type ClusterIDAndSource = {
            type: 'geojson';
            clusterId: number;
            source: string;
    };
    /**
        * Parameters needed to get the leaves of a cluster
        */
    export type GetClusterLeavesParams = ClusterIDAndSource & {
            limit: number;
            offset: number;
    };
    /**
        * The result of the call to load a geojson source
        */
    export type GeoJSONWorkerSourceLoadDataResult = {
            resourceTiming?: {
                    [_: string]: Array<PerformanceResourceTiming>;
            };
            abandoned?: boolean;
    };
    /**
        * Parameters needed to remove a source
        */
    export type RemoveSourceParams = {
            source: string;
            type: string;
    };
    /**
        * Parameters needed to update the layers
        */
    export type UpdateLayersParamaeters = {
            layers: Array<LayerSpecification>;
            removedIds: Array<string>;
    };
    /**
        * Parameters needed to get the images
        */
    export type GetImagesParamerters = {
            icons: Array<string>;
            source: string;
            tileID: OverscaledTileID;
            type: string;
    };
    /**
        * Parameters needed to get the glyphs
        */
    export type GetGlyphsParamerters = {
            type: string;
            stacks: {
                    [_: string]: Array<number>;
            };
            source: string;
            tileID: OverscaledTileID;
    };
    /**
        * A response object returned when requesting glyphs
        */
    export type GetGlyphsResponse = {
            [stack: string]: {
                    [id: number]: StyleGlyph;
            };
    };
    /**
        * A response object returned when requesting images
        */
    export type GetImagesResponse = {
            [_: string]: StyleImage;
    };
    /**
        * All the possible message types that can be sent to and from the worker
        */
    export const enum MessageType {
            loadDEMTile = "LDT",
            getClusterExpansionZoom = "GCEZ",
            getClusterChildren = "GCC",
            getClusterLeaves = "GCL",
            loadData = "LD",
            loadTile = "LT",
            reloadTile = "RT",
            getGlyphs = "GG",
            getImages = "GI",
            setImages = "SI",
            setLayers = "SL",
            updateLayers = "UL",
            syncRTLPluginState = "SRPS",
            setReferrer = "SR",
            removeSource = "RS",
            removeMap = "RM",
            importScript = "IS",
            removeTile = "RMT",
            abortTile = "AT",
            removeDEMTile = "RDT",
            getResource = "GR"
    }
    /**
        * This is basically a mapping between all the calls that are made to and from the workers.
        * The key is the event name, the first parameter is the event input type, and the last parameter is the output type.
        */
    export type RequestResponseMessageMap = {
            [MessageType.loadDEMTile]: [WorkerDEMTileParameters, DEMData];
            [MessageType.getClusterExpansionZoom]: [ClusterIDAndSource, number];
            [MessageType.getClusterChildren]: [ClusterIDAndSource, Array<GeoJSON.Feature>];
            [MessageType.getClusterLeaves]: [GetClusterLeavesParams, Array<GeoJSON.Feature>];
            [MessageType.loadData]: [LoadGeoJSONParameters, GeoJSONWorkerSourceLoadDataResult];
            [MessageType.loadTile]: [WorkerTileParameters, WorkerTileResult];
            [MessageType.reloadTile]: [WorkerTileParameters, WorkerTileResult];
            [MessageType.getGlyphs]: [GetGlyphsParamerters, GetGlyphsResponse];
            [MessageType.getImages]: [GetImagesParamerters, GetImagesResponse];
            [MessageType.setImages]: [string[], void];
            [MessageType.setLayers]: [Array<LayerSpecification>, void];
            [MessageType.updateLayers]: [UpdateLayersParamaeters, void];
            [MessageType.syncRTLPluginState]: [PluginState, PluginState];
            [MessageType.setReferrer]: [string, void];
            [MessageType.removeSource]: [RemoveSourceParams, void];
            [MessageType.removeMap]: [undefined, void];
            [MessageType.importScript]: [string, void];
            [MessageType.removeTile]: [TileParameters, void];
            [MessageType.abortTile]: [TileParameters, void];
            [MessageType.removeDEMTile]: [TileParameters, void];
            [MessageType.getResource]: [RequestParameters, GetResourceResponse<any>];
    };
    /**
        * The message to be sent by the actor
        */
    export type ActorMessage<T extends MessageType> = {
            type: T;
            data: RequestResponseMessageMap[T][0];
            targetMapId?: string | number | null;
            mustQueue?: boolean;
            sourceMapId?: string | number | null;
    };
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile' {
    import '../data/feature_index';
    import type { FeatureIndex } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/feature_index';
    import { GeoJSONFeature } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/vectortile_to_geojson';
    import { CollisionBoxArray } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/array_types.g';
    import { Texture } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/texture';
    import { SourceFeatureState } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/source_state';
    import type { Bucket } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/bucket';
    import type { StyleLayer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer';
    import type { WorkerTileResult } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/worker_source';
    import type { Actor } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/actor';
    import type { DEMData } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/dem_data';
    import type { AlphaImage } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/image';
    import type { ImageAtlas } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/image_atlas';
    import type { ImageManager } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/image_manager';
    import type { Context } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/context';
    import type { OverscaledTileID } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile_id';
    import type { Framebuffer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/framebuffer';
    import type { Transform } from '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/transform';
    import type { LayerFeatureStates } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/source_state';
    import type { FilterSpecification } from '@maplibre/maplibre-gl-style-spec';
    import type Point from '@mapbox/point-geometry';
    import { mat4 } from 'gl-matrix';
    import type { VectorTileLayer } from '@mapbox/vector-tile';
    import { ExpiryData } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/ajax';
    /**
        * The tile's state, can be:
        *
        * - `loading` Tile data is in the process of loading.
        * - `loaded` Tile data has been loaded. Tile can be rendered.
        * - `reloading` Tile data has been loaded and is being updated. Tile can be rendered.
        * - `unloaded` Tile data has been deleted.
        * - `errored` Tile data was not loaded because of an error.
        * - `expired` Tile data was previously loaded, but has expired per its HTTP headers and is in the process of refreshing.
        */
    export type TileState = 'loading' | 'loaded' | 'reloading' | 'unloaded' | 'errored' | 'expired';
    /**
        * A tile object is the combination of a Coordinate, which defines
        * its place, as well as a unique ID and data tracking for its content
        */
    export class Tile {
            tileID: OverscaledTileID;
            uid: number;
            uses: number;
            tileSize: number;
            buckets: {
                    [_: string]: Bucket;
            };
            latestFeatureIndex: FeatureIndex;
            latestRawTileData: ArrayBuffer;
            imageAtlas: ImageAtlas;
            imageAtlasTexture: Texture;
            glyphAtlasImage: AlphaImage;
            glyphAtlasTexture: Texture;
            expirationTime: any;
            expiredRequestCount: number;
            state: TileState;
            timeAdded: number;
            fadeEndTime: number;
            collisionBoxArray: CollisionBoxArray;
            redoWhenDone: boolean;
            showCollisionBoxes: boolean;
            placementSource: any;
            actor: Actor;
            vtLayers: {
                    [_: string]: VectorTileLayer;
            };
            neighboringTiles: any;
            dem: DEMData;
            demMatrix: mat4;
            aborted: boolean;
            needsHillshadePrepare: boolean;
            needsTerrainPrepare: boolean;
            abortController: AbortController;
            texture: any;
            fbo: Framebuffer;
            demTexture: Texture;
            refreshedUponExpiration: boolean;
            reloadPromise: {
                    resolve: () => void;
                    reject: () => void;
            };
            resourceTiming: Array<PerformanceResourceTiming>;
            queryPadding: number;
            symbolFadeHoldUntil: number;
            hasSymbolBuckets: boolean;
            hasRTLText: boolean;
            dependencies: any;
            rtt: Array<{
                    id: number;
                    stamp: number;
            }>;
            rttCoords: {
                    [_: string]: string;
            };
            /**
                * @param tileID - the tile ID
                * @param size - The tile size
                */
            constructor(tileID: OverscaledTileID, size: number);
            registerFadeDuration(duration: number): void;
            wasRequested(): boolean;
            clearTextures(painter: any): void;
            /**
                * Given a data object with a 'buffers' property, load it into
                * this tile's elementGroups and buffers properties and set loaded
                * to true. If the data is null, like in the case of an empty
                * GeoJSON tile, no-op but still set loaded to true.
                * @param data - The data from the worker
                * @param painter - the painter
                * @param justReloaded - `true` to just reload
                */
            loadVectorData(data: WorkerTileResult, painter: any, justReloaded?: boolean | null): void;
            /**
                * Release any data or WebGL resources referenced by this tile.
                */
            unloadVectorData(): void;
            getBucket(layer: StyleLayer): Bucket;
            upload(context: Context): void;
            prepare(imageManager: ImageManager): void;
            queryRenderedFeatures(layers: {
                    [_: string]: StyleLayer;
            }, serializedLayers: {
                    [_: string]: any;
            }, sourceFeatureState: SourceFeatureState, queryGeometry: Array<Point>, cameraQueryGeometry: Array<Point>, scale: number, params: {
                    filter: FilterSpecification;
                    layers: Array<string>;
                    availableImages: Array<string>;
            }, transform: Transform, maxPitchScaleFactor: number, pixelPosMatrix: mat4): {
                    [_: string]: Array<{
                            featureIndex: number;
                            feature: GeoJSONFeature;
                    }>;
            };
            querySourceFeatures(result: Array<GeoJSONFeature>, params?: {
                    sourceLayer?: string;
                    filter?: FilterSpecification;
                    validate?: boolean;
            }): void;
            hasData(): boolean;
            patternsLoaded(): boolean;
            setExpiryData(data: ExpiryData): void;
            getExpiryTimeout(): number;
            setFeatureState(states: LayerFeatureStates, painter: any): void;
            holdingForFade(): boolean;
            symbolFadeFinished(): boolean;
            clearFadeHold(): void;
            setHoldDuration(duration: number): void;
            setDependencies(namespace: string, dependencies: Array<string>): void;
            hasDependency(namespaces: Array<string>, keys: Array<string>): boolean;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/util/actor' {
    import { Subscription } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/util';
    import { Serialized } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/web_worker_transfer';
    import { ThrottledInvoker } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/throttled_invoker';
    import { MessageType, type ActorMessage, type RequestResponseMessageMap } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/actor_messages';
    /**
        * An interface to be sent to the actor in order for it to allow communication between the worker and the main thread
        */
    export interface ActorTarget {
            addEventListener: typeof window.addEventListener;
            removeEventListener: typeof window.removeEventListener;
            postMessage: typeof window.postMessage;
            terminate?: () => void;
    }
    /**
        * This is used to define the parameters of the message that is sent to the worker and back
        */
    type MessageData = {
            id: string;
            type: MessageType | '<cancel>' | '<response>';
            origin: string;
            data?: Serialized;
            targetMapId?: string | number | null;
            mustQueue?: boolean;
            error?: Serialized | null;
            sourceMapId: string | number | null;
    };
    type ResolveReject = {
            resolve: (value?: RequestResponseMessageMap[MessageType][1]) => void;
            reject: (reason?: Error) => void;
    };
    /**
        * This interface allowing to substitute only the sendAsync method of the Actor class.
        */
    export interface IActor {
            sendAsync<T extends MessageType>(message: ActorMessage<T>, abortController?: AbortController): Promise<RequestResponseMessageMap[T][1]>;
    }
    export type MessageHandler<T extends MessageType> = (mapId: string | number, params: RequestResponseMessageMap[T][0], abortController?: AbortController) => Promise<RequestResponseMessageMap[T][1]>;
    /**
        * An implementation of the [Actor design pattern](http://en.wikipedia.org/wiki/Actor_model)
        * that maintains the relationship between asynchronous tasks and the objects
        * that spin them off - in this case, tasks like parsing parts of styles,
        * owned by the styles
        */
    export class Actor implements IActor {
            target: ActorTarget;
            mapId: string | number | null;
            resolveRejects: {
                    [x: string]: ResolveReject;
            };
            name: string;
            tasks: {
                    [x: string]: MessageData;
            };
            taskQueue: Array<string>;
            abortControllers: {
                    [x: number | string]: AbortController;
            };
            invoker: ThrottledInvoker;
            globalScope: ActorTarget;
            messageHandlers: {
                    [x in MessageType]?: MessageHandler<MessageType>;
            };
            subscription: Subscription;
            /**
                * @param target - The target
                * @param mapId - A unique identifier for the Map instance using this Actor.
                */
            constructor(target: ActorTarget, mapId?: string | number);
            registerMessageHandler<T extends MessageType>(type: T, handler: MessageHandler<T>): void;
            /**
                * Sends a message from a main-thread map to a Worker or from a Worker back to
                * a main-thread map instance.
                * @param message - the message to send
                * @param abortController - an optional AbortController to abort the request
                * @returns a promise that will be resolved with the response data
                */
            sendAsync<T extends MessageType>(message: ActorMessage<T>, abortController?: AbortController): Promise<RequestResponseMessageMap[T][1]>;
            receive(message: {
                    data: MessageData;
            }): void;
            process(): void;
            processTask(id: string, task: MessageData): Promise<void>;
            completeTask(id: string, err: Error, data?: RequestResponseMessageMap[MessageType][1]): void;
            remove(): void;
    }
    export {};
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/source/geojson_source_diff' {
    /**
        * A way to indentify a feature, either by string or by number
        */
    export type GeoJSONFeatureId = number | string;
    /**
        * The geojson source diff object
        */
    export type GeoJSONSourceDiff = {
            /**
                * When set to `true` it will remove all features
                */
            removeAll?: boolean;
            /**
                * An array of features IDs to remove
                */
            remove?: Array<GeoJSONFeatureId>;
            /**
                * An array of features to add
                */
            add?: Array<GeoJSON.Feature>;
            /**
                * An array of update objects
                */
            update?: Array<GeoJSONFeatureDiff>;
    };
    /**
        * A geojson feature diff object
        */
    export type GeoJSONFeatureDiff = {
            /**
                * The feature ID
                */
            id: GeoJSONFeatureId;
            /**
                * If it's a new geometry, place it here
                */
            newGeometry?: GeoJSON.Geometry;
            /**
                * Setting to `true` will remove all preperties
                */
            removeAllProperties?: boolean;
            /**
                * The properties keys to remove
                */
            removeProperties?: Array<string>;
            /**
                * The properties to add or update along side their values
                */
            addOrUpdateProperties?: Array<{
                    key: string;
                    value: any;
            }>;
    };
    export type UpdateableGeoJSON = GeoJSON.Feature | GeoJSON.FeatureCollection | undefined;
    export function isUpdateableGeoJSON(data: GeoJSON.GeoJSON | undefined, promoteId?: string): data is UpdateableGeoJSON;
    export function toUpdateable(data: UpdateableGeoJSON, promoteId?: string): Map<any, any>;
    export function applySourceDiff(updateable: Map<GeoJSONFeatureId, GeoJSON.Feature>, diff: GeoJSONSourceDiff, promoteId?: string): void;
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/source/geojson_worker_source' {
    import Supercluster, { type Options as SuperclusterOptions, type ClusterProperties } from 'supercluster';
    import geojsonvt, { type Options as GeoJSONVTOptions } from 'geojson-vt';
    import { VectorTileWorkerSource } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/vector_tile_worker_source';
    import type { WorkerTileParameters, WorkerTileResult } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/worker_source';
    import type { LoadVectorTileResult } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/vector_tile_worker_source';
    import type { RequestParameters } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/ajax';
    import { type GeoJSONSourceDiff } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/geojson_source_diff';
    import type { ClusterIDAndSource, GeoJSONWorkerSourceLoadDataResult, RemoveSourceParams } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/actor_messages';
    /**
        * The geojson worker options that can be passed to the worker
        */
    export type GeoJSONWorkerOptions = {
            source?: string;
            cluster?: boolean;
            geojsonVtOptions?: GeoJSONVTOptions;
            superclusterOptions?: SuperclusterOptions<any, any>;
            clusterProperties?: ClusterProperties;
            filter?: Array<unknown>;
            promoteId?: string;
            collectResourceTiming?: boolean;
    };
    /**
        * Parameters needed to load a geojson to the wokrer
        */
    export type LoadGeoJSONParameters = GeoJSONWorkerOptions & {
            type: 'geojson';
            request?: RequestParameters;
            /**
                * Literal GeoJSON data. Must be provided if `request.url` is not.
                */
            data?: string;
            dataDiff?: GeoJSONSourceDiff;
    };
    export type LoadGeoJSON = (params: LoadGeoJSONParameters, abortController: AbortController) => Promise<GeoJSON.GeoJSON>;
    type GeoJSONIndex = ReturnType<typeof geojsonvt> | Supercluster;
    /**
        * The {@link WorkerSource} implementation that supports {@link GeoJSONSource}.
        * This class is designed to be easily reused to support custom source types
        * for data formats that can be parsed/converted into an in-memory GeoJSON
        * representation. To do so, create it with
        * `new GeoJSONWorkerSource(actor, layerIndex, customLoadGeoJSONFunction)`.
        * For a full example, see [mapbox-gl-topojson](https://github.com/developmentseed/mapbox-gl-topojson).
        */
    export class GeoJSONWorkerSource extends VectorTileWorkerSource {
            _pendingRequest: AbortController;
            _geoJSONIndex: GeoJSONIndex;
            _dataUpdateable: Map<any, any>;
            loadVectorTile(params: WorkerTileParameters, _abortController: AbortController): Promise<LoadVectorTileResult | null>;
            /**
                * Fetches (if appropriate), parses, and index geojson data into tiles. This
                * preparatory method must be called before {@link GeoJSONWorkerSource#loadTile}
                * can correctly serve up tiles.
                *
                * Defers to {@link GeoJSONWorkerSource#loadGeoJSON} for the fetching/parsing,
                *
                * When a `loadData` request comes in while a previous one is being processed,
                * the previous one is aborted.
                *
                * @param params - the parameters
                * @returns a promise that resolves when the data is loaded and parsed into a GeoJSON object
                */
            loadData(params: LoadGeoJSONParameters): Promise<GeoJSONWorkerSourceLoadDataResult>;
            /**
                * Implements {@link WorkerSource#reloadTile}.
                *
                * If the tile is loaded, uses the implementation in VectorTileWorkerSource.
                * Otherwise, such as after a setData() call, we load the tile fresh.
                *
                * @param params - the parameters
                * @returns A promise that resolves when the tile is reloaded
                */
            reloadTile(params: WorkerTileParameters): Promise<WorkerTileResult>;
            /**
                * Fetch and parse GeoJSON according to the given params.
                *
                * GeoJSON is loaded and parsed from `params.url` if it exists, or else
                * expected as a literal (string or object) `params.data`.
                *
                * @param params - the parameters
                * @param abortController - the abort controller that allows aborting this operation
                * @returns a promise that resolves when the data is loaded
                */
            loadGeoJSON(params: LoadGeoJSONParameters, abortController: AbortController): Promise<GeoJSON.GeoJSON>;
            removeSource(_params: RemoveSourceParams): Promise<void>;
            getClusterExpansionZoom(params: ClusterIDAndSource): number;
            getClusterChildren(params: ClusterIDAndSource): Array<GeoJSON.Feature>;
            getClusterLeaves(params: {
                    clusterId: number;
                    limit: number;
                    offset: number;
            }): Array<GeoJSON.Feature>;
    }
    export {};
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile_id' {
    import Point from '@mapbox/point-geometry';
    import { MercatorCoordinate } from '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/mercator_coordinate';
    import { mat4 } from 'gl-matrix';
    import { ICanonicalTileID, IMercatorCoordinate } from '@maplibre/maplibre-gl-style-spec';
    /**
        * A canonical way to define a tile ID
        */
    export class CanonicalTileID implements ICanonicalTileID {
            z: number;
            x: number;
            y: number;
            key: string;
            constructor(z: number, x: number, y: number);
            equals(id: ICanonicalTileID): boolean;
            url(urls: Array<string>, pixelRatio: number, scheme?: string | null): string;
            isChildOf(parent: ICanonicalTileID): boolean;
            getTilePoint(coord: IMercatorCoordinate): Point;
            toString(): string;
    }
    /**
        * @internal
        * An unwrapped tile identifier
        */
    export class UnwrappedTileID {
            wrap: number;
            canonical: CanonicalTileID;
            key: string;
            constructor(wrap: number, canonical: CanonicalTileID);
    }
    /**
        * An overscaled tile identifier
        */
    export class OverscaledTileID {
            overscaledZ: number;
            wrap: number;
            canonical: CanonicalTileID;
            key: string;
            posMatrix: mat4;
            constructor(overscaledZ: number, wrap: number, z: number, x: number, y: number);
            clone(): OverscaledTileID;
            equals(id: OverscaledTileID): boolean;
            scaledTo(targetZ: number): OverscaledTileID;
            calculateScaledKey(targetZ: number, withWrap: boolean): string;
            isChildOf(parent: OverscaledTileID): boolean;
            children(sourceMaxZoom: number): OverscaledTileID[];
            isLessThan(rhs: OverscaledTileID): boolean;
            wrapped(): OverscaledTileID;
            unwrapTo(wrap: number): OverscaledTileID;
            overscaleFactor(): number;
            toUnwrapped(): UnwrappedTileID;
            toString(): string;
            getTilePoint(coord: MercatorCoordinate): Point;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/data/array_types.g' {
    import { Struct, StructArray } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/struct_array';
    import Point from '@mapbox/point-geometry';
    /**
        * @internal
        * Implementation of the StructArray layout:
        * [0]: Int16[2]
        *
        */
    class StructArrayLayout2i4 extends StructArray {
            uint8: Uint8Array;
            int16: Int16Array;
            _refreshViews(): void;
            emplaceBack(v0: number, v1: number): number;
            emplace(i: number, v0: number, v1: number): number;
    }
    /**
        * @internal
        * Implementation of the StructArray layout:
        * [0]: Int16[3]
        *
        */
    class StructArrayLayout3i6 extends StructArray {
            uint8: Uint8Array;
            int16: Int16Array;
            _refreshViews(): void;
            emplaceBack(v0: number, v1: number, v2: number): number;
            emplace(i: number, v0: number, v1: number, v2: number): number;
    }
    /**
        * @internal
        * Implementation of the StructArray layout:
        * [0]: Int16[4]
        *
        */
    class StructArrayLayout4i8 extends StructArray {
            uint8: Uint8Array;
            int16: Int16Array;
            _refreshViews(): void;
            emplaceBack(v0: number, v1: number, v2: number, v3: number): number;
            emplace(i: number, v0: number, v1: number, v2: number, v3: number): number;
    }
    /**
        * @internal
        * Implementation of the StructArray layout:
        * [0]: Int16[2]
        * [4]: Int16[4]
        *
        */
    class StructArrayLayout2i4i12 extends StructArray {
            uint8: Uint8Array;
            int16: Int16Array;
            _refreshViews(): void;
            emplaceBack(v0: number, v1: number, v2: number, v3: number, v4: number, v5: number): number;
            emplace(i: number, v0: number, v1: number, v2: number, v3: number, v4: number, v5: number): number;
    }
    /**
        * @internal
        * Implementation of the StructArray layout:
        * [0]: Int16[2]
        * [4]: Uint8[4]
        *
        */
    class StructArrayLayout2i4ub8 extends StructArray {
            uint8: Uint8Array;
            int16: Int16Array;
            _refreshViews(): void;
            emplaceBack(v0: number, v1: number, v2: number, v3: number, v4: number, v5: number): number;
            emplace(i: number, v0: number, v1: number, v2: number, v3: number, v4: number, v5: number): number;
    }
    /**
        * @internal
        * Implementation of the StructArray layout:
        * [0]: Float32[2]
        *
        */
    class StructArrayLayout2f8 extends StructArray {
            uint8: Uint8Array;
            float32: Float32Array;
            _refreshViews(): void;
            emplaceBack(v0: number, v1: number): number;
            emplace(i: number, v0: number, v1: number): number;
    }
    /**
        * @internal
        * Implementation of the StructArray layout:
        * [0]: Uint16[10]
        *
        */
    class StructArrayLayout10ui20 extends StructArray {
            uint8: Uint8Array;
            uint16: Uint16Array;
            _refreshViews(): void;
            emplaceBack(v0: number, v1: number, v2: number, v3: number, v4: number, v5: number, v6: number, v7: number, v8: number, v9: number): number;
            emplace(i: number, v0: number, v1: number, v2: number, v3: number, v4: number, v5: number, v6: number, v7: number, v8: number, v9: number): number;
    }
    /**
        * @internal
        * Implementation of the StructArray layout:
        * [0]: Int16[4]
        * [8]: Uint16[4]
        * [16]: Int16[4]
        *
        */
    class StructArrayLayout4i4ui4i24 extends StructArray {
            uint8: Uint8Array;
            int16: Int16Array;
            uint16: Uint16Array;
            _refreshViews(): void;
            emplaceBack(v0: number, v1: number, v2: number, v3: number, v4: number, v5: number, v6: number, v7: number, v8: number, v9: number, v10: number, v11: number): number;
            emplace(i: number, v0: number, v1: number, v2: number, v3: number, v4: number, v5: number, v6: number, v7: number, v8: number, v9: number, v10: number, v11: number): number;
    }
    /**
        * @internal
        * Implementation of the StructArray layout:
        * [0]: Float32[3]
        *
        */
    class StructArrayLayout3f12 extends StructArray {
            uint8: Uint8Array;
            float32: Float32Array;
            _refreshViews(): void;
            emplaceBack(v0: number, v1: number, v2: number): number;
            emplace(i: number, v0: number, v1: number, v2: number): number;
    }
    /**
        * @internal
        * Implementation of the StructArray layout:
        * [0]: Uint32[1]
        *
        */
    class StructArrayLayout1ul4 extends StructArray {
            uint8: Uint8Array;
            uint32: Uint32Array;
            _refreshViews(): void;
            emplaceBack(v0: number): number;
            emplace(i: number, v0: number): number;
    }
    /**
        * @internal
        * Implementation of the StructArray layout:
        * [0]: Int16[6]
        * [12]: Uint32[1]
        * [16]: Uint16[2]
        *
        */
    class StructArrayLayout6i1ul2ui20 extends StructArray {
            uint8: Uint8Array;
            int16: Int16Array;
            uint32: Uint32Array;
            uint16: Uint16Array;
            _refreshViews(): void;
            emplaceBack(v0: number, v1: number, v2: number, v3: number, v4: number, v5: number, v6: number, v7: number, v8: number): number;
            emplace(i: number, v0: number, v1: number, v2: number, v3: number, v4: number, v5: number, v6: number, v7: number, v8: number): number;
    }
    /**
        * @internal
        * Implementation of the StructArray layout:
        * [0]: Int16[2]
        * [4]: Int16[2]
        * [8]: Int16[2]
        *
        */
    class StructArrayLayout2i2i2i12 extends StructArray {
            uint8: Uint8Array;
            int16: Int16Array;
            _refreshViews(): void;
            emplaceBack(v0: number, v1: number, v2: number, v3: number, v4: number, v5: number): number;
            emplace(i: number, v0: number, v1: number, v2: number, v3: number, v4: number, v5: number): number;
    }
    /**
        * @internal
        * Implementation of the StructArray layout:
        * [0]: Float32[2]
        * [8]: Float32[1]
        * [12]: Int16[2]
        *
        */
    class StructArrayLayout2f1f2i16 extends StructArray {
            uint8: Uint8Array;
            float32: Float32Array;
            int16: Int16Array;
            _refreshViews(): void;
            emplaceBack(v0: number, v1: number, v2: number, v3: number, v4: number): number;
            emplace(i: number, v0: number, v1: number, v2: number, v3: number, v4: number): number;
    }
    /**
        * @internal
        * Implementation of the StructArray layout:
        * [0]: Uint8[2]
        * [4]: Float32[2]
        *
        */
    class StructArrayLayout2ub2f12 extends StructArray {
            uint8: Uint8Array;
            float32: Float32Array;
            _refreshViews(): void;
            emplaceBack(v0: number, v1: number, v2: number, v3: number): number;
            emplace(i: number, v0: number, v1: number, v2: number, v3: number): number;
    }
    /**
        * @internal
        * Implementation of the StructArray layout:
        * [0]: Uint16[3]
        *
        */
    class StructArrayLayout3ui6 extends StructArray {
            uint8: Uint8Array;
            uint16: Uint16Array;
            _refreshViews(): void;
            emplaceBack(v0: number, v1: number, v2: number): number;
            emplace(i: number, v0: number, v1: number, v2: number): number;
    }
    /**
        * @internal
        * Implementation of the StructArray layout:
        * [0]: Int16[2]
        * [4]: Uint16[2]
        * [8]: Uint32[3]
        * [20]: Uint16[3]
        * [28]: Float32[2]
        * [36]: Uint8[3]
        * [40]: Uint32[1]
        * [44]: Int16[1]
        *
        */
    class StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48 extends StructArray {
            uint8: Uint8Array;
            int16: Int16Array;
            uint16: Uint16Array;
            uint32: Uint32Array;
            float32: Float32Array;
            _refreshViews(): void;
            emplaceBack(v0: number, v1: number, v2: number, v3: number, v4: number, v5: number, v6: number, v7: number, v8: number, v9: number, v10: number, v11: number, v12: number, v13: number, v14: number, v15: number, v16: number): number;
            emplace(i: number, v0: number, v1: number, v2: number, v3: number, v4: number, v5: number, v6: number, v7: number, v8: number, v9: number, v10: number, v11: number, v12: number, v13: number, v14: number, v15: number, v16: number): number;
    }
    /**
        * @internal
        * Implementation of the StructArray layout:
        * [0]: Int16[8]
        * [16]: Uint16[15]
        * [48]: Uint32[1]
        * [52]: Float32[2]
        * [60]: Uint16[2]
        *
        */
    class StructArrayLayout8i15ui1ul2f2ui64 extends StructArray {
            uint8: Uint8Array;
            int16: Int16Array;
            uint16: Uint16Array;
            uint32: Uint32Array;
            float32: Float32Array;
            _refreshViews(): void;
            emplaceBack(v0: number, v1: number, v2: number, v3: number, v4: number, v5: number, v6: number, v7: number, v8: number, v9: number, v10: number, v11: number, v12: number, v13: number, v14: number, v15: number, v16: number, v17: number, v18: number, v19: number, v20: number, v21: number, v22: number, v23: number, v24: number, v25: number, v26: number, v27: number): number;
            emplace(i: number, v0: number, v1: number, v2: number, v3: number, v4: number, v5: number, v6: number, v7: number, v8: number, v9: number, v10: number, v11: number, v12: number, v13: number, v14: number, v15: number, v16: number, v17: number, v18: number, v19: number, v20: number, v21: number, v22: number, v23: number, v24: number, v25: number, v26: number, v27: number): number;
    }
    /**
        * @internal
        * Implementation of the StructArray layout:
        * [0]: Float32[1]
        *
        */
    class StructArrayLayout1f4 extends StructArray {
            uint8: Uint8Array;
            float32: Float32Array;
            _refreshViews(): void;
            emplaceBack(v0: number): number;
            emplace(i: number, v0: number): number;
    }
    /**
        * @internal
        * Implementation of the StructArray layout:
        * [0]: Uint16[1]
        * [4]: Float32[2]
        *
        */
    class StructArrayLayout1ui2f12 extends StructArray {
            uint8: Uint8Array;
            uint16: Uint16Array;
            float32: Float32Array;
            _refreshViews(): void;
            emplaceBack(v0: number, v1: number, v2: number): number;
            emplace(i: number, v0: number, v1: number, v2: number): number;
    }
    /**
        * @internal
        * Implementation of the StructArray layout:
        * [0]: Uint32[1]
        * [4]: Uint16[2]
        *
        */
    class StructArrayLayout1ul2ui8 extends StructArray {
            uint8: Uint8Array;
            uint32: Uint32Array;
            uint16: Uint16Array;
            _refreshViews(): void;
            emplaceBack(v0: number, v1: number, v2: number): number;
            emplace(i: number, v0: number, v1: number, v2: number): number;
    }
    /**
        * @internal
        * Implementation of the StructArray layout:
        * [0]: Uint16[2]
        *
        */
    class StructArrayLayout2ui4 extends StructArray {
            uint8: Uint8Array;
            uint16: Uint16Array;
            _refreshViews(): void;
            emplaceBack(v0: number, v1: number): number;
            emplace(i: number, v0: number, v1: number): number;
    }
    /**
        * @internal
        * Implementation of the StructArray layout:
        * [0]: Uint16[1]
        *
        */
    class StructArrayLayout1ui2 extends StructArray {
            uint8: Uint8Array;
            uint16: Uint16Array;
            _refreshViews(): void;
            emplaceBack(v0: number): number;
            emplace(i: number, v0: number): number;
    }
    /**
        * @internal
        * Implementation of the StructArray layout:
        * [0]: Float32[4]
        *
        */
    class StructArrayLayout4f16 extends StructArray {
            uint8: Uint8Array;
            float32: Float32Array;
            _refreshViews(): void;
            emplaceBack(v0: number, v1: number, v2: number, v3: number): number;
            emplace(i: number, v0: number, v1: number, v2: number, v3: number): number;
    }
    /** @internal */
    class CollisionBoxStruct extends Struct {
            _structArray: CollisionBoxArray;
            get anchorPointX(): number;
            get anchorPointY(): number;
            get x1(): number;
            get y1(): number;
            get x2(): number;
            get y2(): number;
            get featureIndex(): number;
            get sourceLayerIndex(): number;
            get bucketIndex(): number;
            get anchorPoint(): Point;
    }
    export type CollisionBox = CollisionBoxStruct;
    /** @internal */
    export class CollisionBoxArray extends StructArrayLayout6i1ul2ui20 {
            /**
                * Return the CollisionBoxStruct at the given location in the array.
                * @param index The index of the element.
                */
            get(index: number): CollisionBoxStruct;
    }
    /** @internal */
    class PlacedSymbolStruct extends Struct {
            _structArray: PlacedSymbolArray;
            get anchorX(): number;
            get anchorY(): number;
            get glyphStartIndex(): number;
            get numGlyphs(): number;
            get vertexStartIndex(): number;
            get lineStartIndex(): number;
            get lineLength(): number;
            get segment(): number;
            get lowerSize(): number;
            get upperSize(): number;
            get lineOffsetX(): number;
            get lineOffsetY(): number;
            get writingMode(): number;
            get placedOrientation(): number;
            set placedOrientation(x: number);
            get hidden(): number;
            set hidden(x: number);
            get crossTileID(): number;
            set crossTileID(x: number);
            get associatedIconIndex(): number;
    }
    export type PlacedSymbol = PlacedSymbolStruct;
    /** @internal */
    export class PlacedSymbolArray extends StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48 {
            /**
                * Return the PlacedSymbolStruct at the given location in the array.
                * @param index The index of the element.
                */
            get(index: number): PlacedSymbolStruct;
    }
    /** @internal */
    class SymbolInstanceStruct extends Struct {
            _structArray: SymbolInstanceArray;
            get anchorX(): number;
            get anchorY(): number;
            get rightJustifiedTextSymbolIndex(): number;
            get centerJustifiedTextSymbolIndex(): number;
            get leftJustifiedTextSymbolIndex(): number;
            get verticalPlacedTextSymbolIndex(): number;
            get placedIconSymbolIndex(): number;
            get verticalPlacedIconSymbolIndex(): number;
            get key(): number;
            get textBoxStartIndex(): number;
            get textBoxEndIndex(): number;
            get verticalTextBoxStartIndex(): number;
            get verticalTextBoxEndIndex(): number;
            get iconBoxStartIndex(): number;
            get iconBoxEndIndex(): number;
            get verticalIconBoxStartIndex(): number;
            get verticalIconBoxEndIndex(): number;
            get featureIndex(): number;
            get numHorizontalGlyphVertices(): number;
            get numVerticalGlyphVertices(): number;
            get numIconVertices(): number;
            get numVerticalIconVertices(): number;
            get useRuntimeCollisionCircles(): number;
            get crossTileID(): number;
            set crossTileID(x: number);
            get textBoxScale(): number;
            get collisionCircleDiameter(): number;
            get textAnchorOffsetStartIndex(): number;
            get textAnchorOffsetEndIndex(): number;
    }
    export type SymbolInstance = SymbolInstanceStruct;
    /** @internal */
    export class SymbolInstanceArray extends StructArrayLayout8i15ui1ul2f2ui64 {
            /**
                * Return the SymbolInstanceStruct at the given location in the array.
                * @param index The index of the element.
                */
            get(index: number): SymbolInstanceStruct;
    }
    /** @internal */
    export class GlyphOffsetArray extends StructArrayLayout1f4 {
            getoffsetX(index: number): number;
    }
    /** @internal */
    export class SymbolLineVertexArray extends StructArrayLayout3i6 {
            getx(index: number): number;
            gety(index: number): number;
            gettileUnitDistanceFromAnchor(index: number): number;
    }
    /** @internal */
    class TextAnchorOffsetStruct extends Struct {
            _structArray: TextAnchorOffsetArray;
            get textAnchor(): number;
            get textOffset0(): number;
            get textOffset1(): number;
    }
    export type TextAnchorOffset = TextAnchorOffsetStruct;
    /** @internal */
    export class TextAnchorOffsetArray extends StructArrayLayout1ui2f12 {
            /**
                * Return the TextAnchorOffsetStruct at the given location in the array.
                * @param index The index of the element.
                */
            get(index: number): TextAnchorOffsetStruct;
    }
    /** @internal */
    class FeatureIndexStruct extends Struct {
            _structArray: FeatureIndexArray;
            get featureIndex(): number;
            get sourceLayerIndex(): number;
            get bucketIndex(): number;
    }
    export type FeatureIndex = FeatureIndexStruct;
    /** @internal */
    export class FeatureIndexArray extends StructArrayLayout1ul2ui8 {
            /**
                * Return the FeatureIndexStruct at the given location in the array.
                * @param index The index of the element.
                */
            get(index: number): FeatureIndexStruct;
    }
    export class PosArray extends StructArrayLayout2i4 {
    }
    export class Pos3dArray extends StructArrayLayout3i6 {
    }
    export class RasterBoundsArray extends StructArrayLayout4i8 {
    }
    export class CircleLayoutArray extends StructArrayLayout2i4 {
    }
    export class FillLayoutArray extends StructArrayLayout2i4 {
    }
    export class FillExtrusionLayoutArray extends StructArrayLayout2i4i12 {
    }
    export class HeatmapLayoutArray extends StructArrayLayout2i4 {
    }
    export class LineLayoutArray extends StructArrayLayout2i4ub8 {
    }
    export class LineExtLayoutArray extends StructArrayLayout2f8 {
    }
    export class PatternLayoutArray extends StructArrayLayout10ui20 {
    }
    export class SymbolLayoutArray extends StructArrayLayout4i4ui4i24 {
    }
    export class SymbolDynamicLayoutArray extends StructArrayLayout3f12 {
    }
    export class SymbolOpacityArray extends StructArrayLayout1ul4 {
    }
    export class CollisionBoxLayoutArray extends StructArrayLayout2i2i2i12 {
    }
    export class CollisionCircleLayoutArray extends StructArrayLayout2f1f2i16 {
    }
    export class CollisionVertexArray extends StructArrayLayout2ub2f12 {
    }
    export class QuadTriangleArray extends StructArrayLayout3ui6 {
    }
    export class TriangleIndexArray extends StructArrayLayout3ui6 {
    }
    export class LineIndexArray extends StructArrayLayout2ui4 {
    }
    export class LineStripIndexArray extends StructArrayLayout1ui2 {
    }
    export { StructArrayLayout2i4, StructArrayLayout3i6, StructArrayLayout4i8, StructArrayLayout2i4i12, StructArrayLayout2i4ub8, StructArrayLayout2f8, StructArrayLayout10ui20, StructArrayLayout4i4ui4i24, StructArrayLayout3f12, StructArrayLayout1ul4, StructArrayLayout6i1ul2ui20, StructArrayLayout2i2i2i12, StructArrayLayout2f1f2i16, StructArrayLayout2ub2f12, StructArrayLayout3ui6, StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48, StructArrayLayout8i15ui1ul2f2ui64, StructArrayLayout1f4, StructArrayLayout1ui2f12, StructArrayLayout1ul2ui8, StructArrayLayout2ui4, StructArrayLayout1ui2, StructArrayLayout4f16, };
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/data/segment' {
    import type { VertexArrayObject } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/vertex_array_object';
    import type { StructArray } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/struct_array';
    /**
        * @internal
        * A single segment of a vector
        */
    export type Segment = {
            sortKey?: number;
            vertexOffset: number;
            primitiveOffset: number;
            vertexLength: number;
            primitiveLength: number;
            vaos: {
                    [_: string]: VertexArrayObject;
            };
    };
    /**
        * @internal
        * Used for calculations on vector segments
        */
    export class SegmentVector {
            static MAX_VERTEX_ARRAY_LENGTH: number;
            segments: Array<Segment>;
            constructor(segments?: Array<Segment>);
            prepareSegment(numVertices: number, layoutVertexArray: StructArray, indexArray: StructArray, sortKey?: number): Segment;
            get(): Segment[];
            destroy(): void;
            static simpleSegment(vertexOffset: number, primitiveOffset: number, vertexLength: number, primitiveLength: number): SegmentVector;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/render/texture' {
    import type { Context } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/context';
    import type { RGBAImage, AlphaImage } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/image';
    export type TextureFormat = WebGLRenderingContextBase['RGBA'] | WebGLRenderingContextBase['ALPHA'];
    export type TextureFilter = WebGLRenderingContextBase['LINEAR'] | WebGLRenderingContextBase['LINEAR_MIPMAP_NEAREST'] | WebGLRenderingContextBase['NEAREST'];
    export type TextureWrap = WebGLRenderingContextBase['REPEAT'] | WebGLRenderingContextBase['CLAMP_TO_EDGE'] | WebGLRenderingContextBase['MIRRORED_REPEAT'];
    type EmptyImage = {
        width: number;
        height: number;
        data: null;
    };
    type DataTextureImage = RGBAImage | AlphaImage | EmptyImage;
    export type TextureImage = TexImageSource | DataTextureImage;
    /**
      * @internal
      * A `Texture` GL related object
      */
    export class Texture {
        context: Context;
        size: [number, number];
        texture: WebGLTexture;
        format: TextureFormat;
        filter: TextureFilter;
        wrap: TextureWrap;
        useMipmap: boolean;
        constructor(context: Context, image: TextureImage, format: TextureFormat, options?: {
            premultiply?: boolean;
            useMipmap?: boolean;
        } | null);
        update(image: TextureImage, options?: {
            premultiply?: boolean;
            useMipmap?: boolean;
        } | null, position?: {
            x: number;
            y: number;
        }): void;
        bind(filter: TextureFilter, wrap: TextureWrap, minFilter?: TextureFilter | null): void;
        isSizePowerOfTwo(): boolean;
        destroy(): void;
    }
    export {};
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/vertex_buffer' {
    import type { StructArray, StructArrayMember } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/struct_array';
    import type { Program } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/program';
    import type { Context } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/context';
    /**
        * @internal
        * The `VertexBuffer` class turns a `StructArray` into a WebGL buffer. Each member of the StructArray's
        * Struct type is converted to a WebGL attribute.
        */
    export class VertexBuffer {
            length: number;
            attributes: ReadonlyArray<StructArrayMember>;
            itemSize: number;
            dynamicDraw: boolean;
            context: Context;
            buffer: WebGLBuffer;
            /**
                * @param dynamicDraw - Whether this buffer will be repeatedly updated.
                */
            constructor(context: Context, array: StructArray, attributes: ReadonlyArray<StructArrayMember>, dynamicDraw?: boolean);
            bind(): void;
            updateData(array: StructArray): void;
            enableAttributes(gl: WebGLRenderingContext | WebGL2RenderingContext, program: Program<any>): void;
            /**
                * Set the attribute pointers in a WebGL context
                * @param gl - The WebGL context
                * @param program - The active WebGL program
                * @param vertexOffset - Index of the starting vertex of the segment
                */
            setVertexAttribPointers(gl: WebGLRenderingContext | WebGL2RenderingContext, program: Program<any>, vertexOffset?: number | null): void;
            /**
                * Destroy the GL buffer bound to the given WebGL context
                */
            destroy(): void;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/data/dem_data' {
    import { RGBAImage } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/image';
    /**
        * The possible DEM encoding types
        */
    export type DEMEncoding = 'mapbox' | 'terrarium' | 'custom';
    /**
        * DEMData is a data structure for decoding, backfilling, and storing elevation data for processing in the hillshade shaders
        * data can be populated either from a pngraw image tile or from serliazed data sent back from a worker. When data is initially
        * loaded from a image tile, we decode the pixel values using the appropriate decoding formula, but we store the
        * elevation data as an Int32 value. we add 65536 (2^16) to eliminate negative values and enable the use of
        * integer overflow when creating the texture used in the hillshadePrepare step.
        *
        * DEMData also handles the backfilling of data from a tile's neighboring tiles. This is necessary because we use a pixel's 8
        * surrounding pixel values to compute the slope at that pixel, and we cannot accurately calculate the slope at pixels on a
        * tile's edge without backfilling from neighboring tiles.
        */
    export class DEMData {
            uid: string | number;
            data: Uint32Array;
            stride: number;
            dim: number;
            min: number;
            max: number;
            redFactor: number;
            greenFactor: number;
            blueFactor: number;
            baseShift: number;
            /**
                * Constructs a `DEMData` object
                * @param uid - the tile's unique id
                * @param data - RGBAImage data has uniform 1px padding on all sides: square tile edge size defines stride
            // and dim is calculated as stride - 2.
                * @param encoding - the encoding type of the data
                * @param redFactor - the red channel factor used to unpack the data, used for `custom` encoding only
                * @param greenFactor - the green channel factor used to unpack the data, used for `custom` encoding only
                * @param blueFactor - the blue channel factor used to unpack the data, used for `custom` encoding only
                * @param baseShift - the base shift used to unpack the data, used for `custom` encoding only
                */
            constructor(uid: string | number, data: RGBAImage | ImageData, encoding: DEMEncoding, redFactor?: number, greenFactor?: number, blueFactor?: number, baseShift?: number);
            get(x: number, y: number): number;
            getUnpackVector(): number[];
            _idx(x: number, y: number): number;
            unpack(r: number, g: number, b: number): number;
            getPixels(): RGBAImage;
            backfillBorder(borderTile: DEMData, dx: number, dy: number): void;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/util/image' {
    export type Size = {
            width: number;
            height: number;
    };
    type Point2D = {
            x: number;
            y: number;
    };
    /**
        * An image with alpha color value
        */
    export class AlphaImage {
            width: number;
            height: number;
            data: Uint8Array;
            constructor(size: Size, data?: Uint8Array | Uint8ClampedArray);
            resize(size: Size): void;
            clone(): AlphaImage;
            static copy(srcImg: AlphaImage, dstImg: AlphaImage, srcPt: Point2D, dstPt: Point2D, size: Size): void;
    }
    /**
        * An object to store image data not premultiplied, because ImageData is not premultiplied.
        * UNPACK_PREMULTIPLY_ALPHA_WEBGL must be used when uploading to a texture.
        */
    export class RGBAImage {
            width: number;
            height: number;
            /**
                * data must be a Uint8Array instead of Uint8ClampedArray because texImage2D does not support Uint8ClampedArray in all browsers.
                */
            data: Uint8Array;
            constructor(size: Size, data?: Uint8Array | Uint8ClampedArray);
            resize(size: Size): void;
            replace(data: Uint8Array | Uint8ClampedArray, copy?: boolean): void;
            clone(): RGBAImage;
            static copy(srcImg: RGBAImage | ImageData, dstImg: RGBAImage, srcPt: Point2D, dstPt: Point2D, size: Size): void;
    }
    export {};
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile_bounds' {
    import { LngLatBounds, LngLatBoundsLike } from '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/lng_lat_bounds';
    import type { CanonicalTileID } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile_id';
    export class TileBounds {
        bounds: LngLatBounds;
        minzoom: number;
        maxzoom: number;
        constructor(bounds: [number, number, number, number], minzoom?: number | null, maxzoom?: number | null);
        validateBounds(bounds: [number, number, number, number]): LngLatBoundsLike;
        contains(tileID: CanonicalTileID): boolean;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/transform-provider' {
    import type { Map } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/map';
    import type { PointLike } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/camera';
    import type { Transform } from '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/transform';
    import { LngLat } from '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/lng_lat';
    /**
      * @internal
      * Shared utilities for the Handler classes to access the correct camera state.
      * If Camera.transformCameraUpdate is specified, the "desired state" of camera may differ from the state used for rendering.
      * The handlers need the "desired state" to track accumulated changes.
      */
    export class TransformProvider {
        _map: Map;
        constructor(map: Map);
        get transform(): Transform;
        get center(): {
            lng: number;
            lat: number;
        };
        get zoom(): number;
        get pitch(): number;
        get bearing(): number;
        unproject(point: PointLike): LngLat;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/touch_pan' {
    import Point from '@mapbox/point-geometry';
    import { Handler } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler_manager';
    import type { Map } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/map';
    /**
      * A `TouchPanHandler` allows the user to pan the map using touch gestures.
      */
    export class TouchPanHandler implements Handler {
        _enabled: boolean;
        _active: boolean;
        _touches: {
            [k in string | number]: Point;
        };
        _clickTolerance: number;
        _sum: Point;
        _map: Map;
        constructor(options: {
            clickTolerance: number;
        }, map: Map);
        reset(): void;
        minTouchs(): 1 | 2;
        touchstart(e: TouchEvent, points: Array<Point>, mapTouches: Array<Touch>): {
            around: Point;
            panDelta: Point;
        };
        touchmove(e: TouchEvent, points: Array<Point>, mapTouches: Array<Touch>): {
            around: Point;
            panDelta: Point;
        };
        touchend(e: TouchEvent, points: Array<Point>, mapTouches: Array<Touch>): void;
        touchcancel(): void;
        _calculateTransform(e: TouchEvent, points: Array<Point>, mapTouches: Array<Touch>): {
            around: Point;
            panDelta: Point;
        };
        enable(): void;
        disable(): void;
        isEnabled(): boolean;
        isActive(): boolean;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/tap_drag_zoom' {
    import { Handler } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler_manager';
    import { TapRecognizer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/tap_recognizer';
    import type Point from '@mapbox/point-geometry';
    /**
      * A `TapDragZoomHandler` allows the user to zoom the map at a point by double tapping. It also allows the user pan the map by dragging.
      */
    export class TapDragZoomHandler implements Handler {
        _enabled: boolean;
        _active: boolean;
        _swipePoint: Point;
        _swipeTouch: number;
        _tapTime: number;
        _tapPoint: Point;
        _tap: TapRecognizer;
        constructor();
        reset(): void;
        touchstart(e: TouchEvent, points: Array<Point>, mapTouches: Array<Touch>): void;
        touchmove(e: TouchEvent, points: Array<Point>, mapTouches: Array<Touch>): {
            zoomDelta: number;
        };
        touchend(e: TouchEvent, points: Array<Point>, mapTouches: Array<Touch>): void;
        touchcancel(): void;
        enable(): void;
        disable(): void;
        isEnabled(): boolean;
        isActive(): boolean;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/render/terrain' {
    import { Tile } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile';
    import { mat4 } from 'gl-matrix';
    import { OverscaledTileID } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile_id';
    import { SegmentVector } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/segment';
    import { VertexBuffer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/vertex_buffer';
    import { IndexBuffer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/index_buffer';
    import { Painter } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/painter';
    import { Texture } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/texture';
    import type { Framebuffer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/framebuffer';
    import Point from '@mapbox/point-geometry';
    import { MercatorCoordinate } from '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/mercator_coordinate';
    import { TerrainSourceCache } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/terrain_source_cache';
    import { SourceCache } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/source_cache';
    import type { TerrainSpecification } from '@maplibre/maplibre-gl-style-spec';
    import { LngLat } from '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/lng_lat';
    /**
        * @internal
        * A terrain GPU related object
        */
    export type TerrainData = {
            u_depth: number;
            u_terrain: number;
            u_terrain_dim: number;
            u_terrain_matrix: mat4;
            u_terrain_unpack: number[];
            u_terrain_exaggeration: number;
            texture: WebGLTexture;
            depthTexture: WebGLTexture;
            tile: Tile;
    };
    /**
        * @internal
        * A terrain mesh object
        */
    export type TerrainMesh = {
            indexBuffer: IndexBuffer;
            vertexBuffer: VertexBuffer;
            segments: SegmentVector;
    };
    /**
        * @internal
        * This is the main class which handles most of the 3D Terrain logic. It has the following topics:
        *    1) loads raster-dem tiles via the internal sourceCache this.sourceCache
        *    2) creates a depth-framebuffer, which is used to calculate the visibility of coordinates
        *    3) creates a coords-framebuffer, which is used the get to tile-coordinate for a screen-pixel
        *    4) stores all render-to-texture tiles in the this.sourceCache._tiles
        *    5) calculates the elevation for a specific tile-coordinate
        *    6) creates a terrain-mesh
        *
        *    A note about the GPU resource-usage:
        *    Framebuffers:
        *       - one for the depth & coords framebuffer with the size of the map-div.
        *       - one for rendering a tile to texture with the size of tileSize (= 512x512).
        *    Textures:
        *       - one texture for an empty raster-dem tile with size 1x1
        *       - one texture for an empty depth-buffer, when terrain is disabled with size 1x1
        *       - one texture for an each loaded raster-dem with size of the source.tileSize
        *       - one texture for the coords-framebuffer with the size of the map-div.
        *       - one texture for the depth-framebuffer with the size of the map-div.
        *       - one texture for the encoded tile-coords with the size 2*tileSize (=1024x1024)
        *       - finally for each render-to-texture tile (= this._tiles) a set of textures
        *         for each render stack (The stack-concept is documented in painter.ts).
        *         Normally there exists 1-3 Textures per tile, depending on the stylesheet.
        *         Each Textures has the size 2*tileSize (= 1024x1024). Also there exists a
        *         cache of the last 150 newest rendered tiles.
        *
        */
    export class Terrain {
            /**
                * The style this terrain corresponds to
                */
            painter: Painter;
            /**
                * the sourcecache this terrain is based on
                */
            sourceCache: TerrainSourceCache;
            /**
                * the TerrainSpecification object passed to this instance
                */
            options: TerrainSpecification;
            /**
                * define the meshSize per tile.
                */
            meshSize: number;
            /**
                * multiplicator for the elevation. Used to make terrain more "extreme".
                */
            exaggeration: number;
            /**
                * to not see pixels in the render-to-texture tiles it is good to render them bigger
                * this number is the multiplicator (must be a power of 2) for the current tileSize.
                * So to get good results with not too much memory footprint a value of 2 should be fine.
                */
            qualityFactor: number;
            /**
                * holds the framebuffer object in size of the screen to render the coords & depth into a texture.
                */
            _fbo: Framebuffer;
            _fboCoordsTexture: Texture;
            _fboDepthTexture: Texture;
            _emptyDepthTexture: Texture;
            /**
                * GL Objects for the terrain-mesh
                * The mesh is a regular mesh, which has the advantage that it can be reused for all tiles.
                */
            _mesh: TerrainMesh;
            /**
                * coords index contains a list of tileID.keys. This index is used to identify
                * the tile via the alpha-cannel in the coords-texture.
                * As the alpha-channel has 1 Byte a max of 255 tiles can rendered without an error.
                */
            coordsIndex: Array<string>;
            /**
                * tile-coords encoded in the rgb channel, _coordsIndex is in the alpha-channel.
                */
            _coordsTexture: Texture;
            /**
                * accuracy of the coords. 2 * tileSize should be enough.
                */
            _coordsTextureSize: number;
            /**
                * variables for an empty dem texture, which is used while the raster-dem tile is loading.
                */
            _emptyDemUnpack: number[];
            _emptyDemTexture: Texture;
            _emptyDemMatrix: mat4;
            /**
                * as of overzooming of raster-dem tiles in high zoomlevels, this cache contains
                * matrices to transform from vector-tile coords to raster-dem-tile coords.
                */
            _demMatrixCache: {
                    [_: string]: {
                            matrix: mat4;
                            coord: OverscaledTileID;
                    };
            };
            constructor(painter: Painter, sourceCache: SourceCache, options: TerrainSpecification);
            /**
                * get the elevation-value from original dem-data for a given tile-coordinate
                * @param tileID - the tile to get elevation for
                * @param x - between 0 .. EXTENT
                * @param y - between 0 .. EXTENT
                * @param extent - optional, default 8192
                * @returns the elevation
                */
            getDEMElevation(tileID: OverscaledTileID, x: number, y: number, extent?: number): number;
            /**
                * Get the elevation for given {@link LngLat} in respect of exaggeration.
                * @param lnglat - the location
                * @param zoom - the zoom
                * @returns the elevation
                */
            getElevationForLngLatZoom(lnglat: LngLat, zoom: number): number;
            /**
                * Get the elevation for given coordinate in respect of exaggeration.
                * @param tileID - the tile id
                * @param x - between 0 .. EXTENT
                * @param y - between 0 .. EXTENT
                * @param extent - optional, default 8192
                * @returns the elevation
                */
            getElevation(tileID: OverscaledTileID, x: number, y: number, extent?: number): number;
            /**
                * returns a Terrain Object for a tile. Unless the tile corresponds to data (e.g. tile is loading), return a flat dem object
                * @param tileID - the tile to get the terrain for
                * @returns the terrain data to use in the program
                */
            getTerrainData(tileID: OverscaledTileID): TerrainData;
            /**
                * get a framebuffer as big as the map-div, which will be used to render depth & coords into a texture
                * @param texture - the texture
                * @returns the frame buffer
                */
            getFramebuffer(texture: string): Framebuffer;
            /**
                * create coords texture, needed to grab coordinates from canvas
                * encode coords coordinate into 4 bytes:
                *   - 8 lower bits for x
                *   - 8 lower bits for y
                *   - 4 higher bits for x
                *   - 4 higher bits for y
                *   - 8 bits for coordsIndex (1 .. 255) (= number of terraintile), is later setted in draw_terrain uniform value
                * @returns the texture
                */
            getCoordsTexture(): Texture;
            /**
                * Reads a pixel from the coords-framebuffer and translate this to mercator.
                * @param p - Screen-Coordinate
                * @returns mercator coordinate for a screen pixel
                */
            pointCoordinate(p: Point): MercatorCoordinate;
            /**
                * Reads the depth value from the depth-framebuffer at a given screen pixel
                * @param p - Screen coordinate
                * @returns depth value in clip space (between 0 and 1)
                */
            depthAtPoint(p: Point): number;
            /**
                * create a regular mesh which will be used by all terrain-tiles
                * @returns the created regular mesh
                */
            getTerrainMesh(): TerrainMesh;
            /**
                * Calculates a height of the frame around the terrain-mesh to avoid stiching between
                * tile boundaries in different zoomlevels.
                * @param zoom - current zoomlevel
                * @returns the elevation delta in meters
                */
            getMeshFrameDelta(zoom: number): number;
            getMinTileElevationForLngLatZoom(lnglat: LngLat, zoom: number): number;
            /**
                * Get the minimum and maximum elevation contained in a tile. This includes any
                * exaggeration included in the terrain.
                *
                * @param tileID - ID of the tile to be used as a source for the min/max elevation
                * @returns the minimum and maximum elevation found in the tile, including the terrain's
                * exaggeration
                */
            getMinMaxElevation(tileID: OverscaledTileID): {
                    minElevation: number | null;
                    maxElevation: number | null;
            };
            _getOverscaledTileIDFromLngLatZoom(lnglat: LngLat, zoom: number): {
                    tileID: OverscaledTileID;
                    mercatorX: number;
                    mercatorY: number;
            };
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/click_zoom' {
    import type Point from '@mapbox/point-geometry';
    import type { Map } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/map';
    import { TransformProvider } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/transform-provider';
    import { Handler } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler_manager';
    /**
      * The `ClickZoomHandler` allows the user to zoom the map at a point by double clicking
      * It is used by other handlers
      */
    export class ClickZoomHandler implements Handler {
        _tr: TransformProvider;
        _enabled: boolean;
        _active: boolean;
        /** @internal */
        constructor(map: Map);
        reset(): void;
        dblclick(e: MouseEvent, point: Point): {
            cameraAnimation: (map: Map) => void;
        };
        enable(): void;
        disable(): void;
        isEnabled(): boolean;
        isActive(): boolean;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/tap_zoom' {
    import { TapRecognizer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/tap_recognizer';
    import type Point from '@mapbox/point-geometry';
    import type { Map } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/map';
    import { TransformProvider } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/transform-provider';
    import { Handler } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler_manager';
    /**
      * A `TapZoomHandler` allows the user to zoom the map at a point by double tapping
      */
    export class TapZoomHandler implements Handler {
        _tr: TransformProvider;
        _enabled: boolean;
        _active: boolean;
        _zoomIn: TapRecognizer;
        _zoomOut: TapRecognizer;
        constructor(map: Map);
        reset(): void;
        touchstart(e: TouchEvent, points: Array<Point>, mapTouches: Array<Touch>): void;
        touchmove(e: TouchEvent, points: Array<Point>, mapTouches: Array<Touch>): void;
        touchend(e: TouchEvent, points: Array<Point>, mapTouches: Array<Touch>): {
            cameraAnimation: (map: Map) => Map;
        };
        touchcancel(): void;
        enable(): void;
        disable(): void;
        isEnabled(): boolean;
        isActive(): boolean;
    }
}

declare module '@mappedin/mappedin-js/packages/geojson-navigator/src/navigation-graph' {
    export * from '@mappedin/mappedin-js/packages/geojson-navigator/src/navigation-graph/navigation-graph';
}

declare module '@mappedin/mappedin-js/packages/geojson-navigator/src/types/space' {
    import type { LineString, Polygon, Point, Feature } from 'geojson';
    import type { SpaceProperties, SpaceCollection } from '@mappedin/mvf';
    /**
      * A GeoJSON feature representing a space, which can be either a line string or a polygon.
      * This type is crucial for mapping and managing areas that impede or restrict movement, such as barriers or restricted zones.
      *
      */
    export type SpaceFeature = Feature<LineString | Polygon | Point, SpaceProperties>;
    export { SpaceCollection, SpaceProperties };
}

declare module '@mappedin/mappedin-js/packages/geojson-navigator/src/edge' {
    export * from '@mappedin/mappedin-js/packages/geojson-navigator/src/edge/edge';
}

declare module '@mappedin/mappedin-js/geojson/src/systems/camera/helpers/input-set' {
    import type { Vector2 } from 'three';
    class InputSet {
        input1: Vector2;
        input2: Vector2;
        lastAngle: number;
        lastDistance: number;
        totalDistance: number;
        first: Vector2;
        second: Vector2;
        constructor(input1: Vector2, input2: Vector2);
        update(input1: Vector2, input2: Vector2): void;
    }
    export { InputSet };
}

declare module '@mappedin/mappedin-js/geojson/src/systems/camera/helpers/touch-anchor' {
    import type { Vector3, Camera, Object3D, Matrix4 } from 'three';
    import { Vector2, Raycaster } from 'three';
    /**
        * Represents a touch event anchored to a point along the z=0 plane.
        */
    class TouchAnchor {
            touch: Vector2;
            camera: Camera;
            cameraPlane: Object3D;
            viewCoordinate: {
                    x: number;
                    y: number;
            };
            snapHolderMatrix: Matrix4;
            snapCamera: Camera;
            cameraPosition?: Vector3;
            raycaster?: Raycaster;
            worldCoordinate?: Vector3 | null;
            snapshotted: boolean;
            constructor(touch: Vector2, camera: Camera, cameraPlane: Object3D);
            /**
                * Calculate and set the world position of this touch anchor.
                */
            snapshotCameraState(): void;
            /**
                * Update anchor state with a new camera and coordinate.
                */
            updateAnchorState(camera: Camera, coord: {
                    x: number;
                    y: number;
            }): void;
            /**
                * Set the current screen touch coordinate for this anchor.
                */
            updateViewCoordinate(coord: {
                    x: number;
                    y: number;
            }): void;
            /**
                * Find the world position for the current touch position using the original camera matrices.
                */
            reUnproject(): Vector3 | undefined;
    }
    export { TouchAnchor };
}

declare module '@mappedin/mappedin-js/geojson/src/systems/camera/helpers/utils' {
    import { Vector2 } from 'three';
    export const differenceBetweenAngles: (a: number, b: number) => number;
    export const getTouchPos: (touch: Touch, origin: {
        offsetLeft: number;
        offsetTop: number;
    }) => Vector2;
    export const angle: (first: Vector2, second: Vector2) => number;
    export const distance: (first: Vector2, second: Vector2) => number;
    export const average: (first: Vector2, second: Vector2) => Vector2;
    export const getScrollDelta: (event: MouseEvent | WheelEvent) => number;
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/data/program_configuration' {
    import { PossiblyEvaluatedPropertyValue } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/properties';
    import { FeaturePositionMap } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/feature_position_map';
    import { Uniform } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/uniform_binding';
    import type { UniformLocations } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/uniform_binding';
    import type { CanonicalTileID } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile_id';
    import type { Context } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/context';
    import type { TypedStyleLayer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/typed_style_layer';
    import type { CrossfadeParameters } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/evaluation_parameters';
    import type { VertexBuffer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/vertex_buffer';
    import type { ImagePosition } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/image_atlas';
    import type { Feature, FeatureState, GlobalProperties, FormattedSection } from '@maplibre/maplibre-gl-style-spec';
    import type { FeatureStates } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/source_state';
    import type { VectorTileLayer } from '@mapbox/vector-tile';
    export type BinderUniform = {
            name: string;
            property: string;
            binding: Uniform<any>;
    };
    /**
        *  `Binder` is the interface definition for the strategies for constructing,
        *  uploading, and binding paint property data as GLSL attributes. Most style-
        *  spec properties have a 1:1 relationship to shader attribute/uniforms, but
        *  some require multiple values per feature to be passed to the GPU, and in
        *  those cases we bind multiple attributes/uniforms.
        *
        *  It has three implementations, one for each of the three strategies we use:
        *
        *  * For _constant_ properties -- those whose value is a constant, or the constant
        *    result of evaluating a camera expression at a particular camera position -- we
        *    don't need a vertex attribute buffer, and instead use a uniform.
        *  * For data expressions, we use a vertex buffer with a single attribute value,
        *    the evaluated result of the source function for the given feature.
        *  * For composite expressions, we use a vertex buffer with two attributes: min and
        *    max values covering the range of zooms at which we expect the tile to be
        *    displayed. These values are calculated by evaluating the composite expression for
        *    the given feature at strategically chosen zoom levels. In addition to this
        *    attribute data, we also use a uniform value which the shader uses to interpolate
        *    between the min and max value at the final displayed zoom level. The use of a
        *    uniform allows us to cheaply update the value on every frame.
        *
        *  Note that the shader source varies depending on whether we're using a uniform or
        *  attribute. We dynamically compile shaders at runtime to accommodate this.
        */
    interface AttributeBinder {
            populatePaintArray(length: number, feature: Feature, imagePositions: {
                    [_: string]: ImagePosition;
            }, canonical?: CanonicalTileID, formattedSection?: FormattedSection): void;
            updatePaintArray(start: number, length: number, feature: Feature, featureState: FeatureState, imagePositions: {
                    [_: string]: ImagePosition;
            }): void;
            upload(a: Context): void;
            destroy(): void;
    }
    interface UniformBinder {
            uniformNames: Array<string>;
            setUniform(uniform: Uniform<any>, globals: GlobalProperties, currentValue: PossiblyEvaluatedPropertyValue<any>, uniformName: string): void;
            getBinding(context: Context, location: WebGLUniformLocation, name: string): Partial<Uniform<any>>;
    }
    /**
        * @internal
        * ProgramConfiguration contains the logic for binding style layer properties and tile
        * layer feature data into GL program uniforms and vertex attributes.
        *
        * Non-data-driven property values are bound to shader uniforms. Data-driven property
        * values are bound to vertex attributes. In order to support a uniform GLSL syntax over
        * both, [Mapbox GL Shaders](https://github.com/mapbox/mapbox-gl-shaders) defines a `#pragma`
        * abstraction, which ProgramConfiguration is responsible for implementing. At runtime,
        * it examines the attributes of a particular layer, combines this with fixed knowledge
        * about how layers of the particular type are implemented, and determines which uniforms
        * and vertex attributes will be required. It can then substitute the appropriate text
        * into the shader source code, create and link a program, and bind the uniforms and
        * vertex attributes in preparation for drawing.
        *
        * When a vector tile is parsed, this same configuration information is used to
        * populate the attribute buffers needed for data-driven styling using the zoom
        * level and feature property data.
        */
    export class ProgramConfiguration {
            binders: {
                    [_: string]: AttributeBinder | UniformBinder;
            };
            cacheKey: string;
            _buffers: Array<VertexBuffer>;
            constructor(layer: TypedStyleLayer, zoom: number, filterProperties: (_: string) => boolean);
            getMaxValue(property: string): number;
            populatePaintArrays(newLength: number, feature: Feature, imagePositions: {
                    [_: string]: ImagePosition;
            }, canonical?: CanonicalTileID, formattedSection?: FormattedSection): void;
            setConstantPatternPositions(posTo: ImagePosition, posFrom: ImagePosition): void;
            updatePaintArrays(featureStates: FeatureStates, featureMap: FeaturePositionMap, vtLayer: VectorTileLayer, layer: TypedStyleLayer, imagePositions: {
                    [_: string]: ImagePosition;
            }): boolean;
            defines(): Array<string>;
            getBinderAttributes(): Array<string>;
            getBinderUniforms(): Array<string>;
            getPaintVertexBuffers(): Array<VertexBuffer>;
            getUniforms(context: Context, locations: UniformLocations): Array<BinderUniform>;
            setUniforms(context: Context, binderUniforms: Array<BinderUniform>, properties: any, globals: GlobalProperties): void;
            updatePaintBuffers(crossfade?: CrossfadeParameters): void;
            upload(context: Context): void;
            destroy(): void;
    }
    export class ProgramConfigurationSet<Layer extends TypedStyleLayer> {
            programConfigurations: {
                    [_: string]: ProgramConfiguration;
            };
            needsUpload: boolean;
            _featureMap: FeaturePositionMap;
            _bufferOffset: number;
            constructor(layers: ReadonlyArray<Layer>, zoom: number, filterProperties?: (_: string) => boolean);
            populatePaintArrays(length: number, feature: Feature, index: number, imagePositions: {
                    [_: string]: ImagePosition;
            }, canonical: CanonicalTileID, formattedSection?: FormattedSection): void;
            updatePaintArrays(featureStates: FeatureStates, vtLayer: VectorTileLayer, layers: ReadonlyArray<TypedStyleLayer>, imagePositions: {
                    [_: string]: ImagePosition;
            }): void;
            get(layerId: string): ProgramConfiguration;
            upload(context: Context): void;
            destroy(): void;
    }
    export {};
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/render/program' {
    import { ProgramConfiguration } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/program_configuration';
    import { Context } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/context';
    import type { SegmentVector } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/segment';
    import type { VertexBuffer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/vertex_buffer';
    import type { IndexBuffer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/index_buffer';
    import type { DepthMode } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/depth_mode';
    import type { StencilMode } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/stencil_mode';
    import type { ColorMode } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/color_mode';
    import type { CullFaceMode } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/cull_face_mode';
    import type { UniformBindings, UniformValues, UniformLocations } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/uniform_binding';
    import type { BinderUniform } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/program_configuration';
    import { TerrainPreludeUniformsType } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/program/terrain_program';
    import type { TerrainData } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/terrain';
    import { Terrain } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/terrain';
    export type DrawMode = WebGLRenderingContextBase['LINES'] | WebGLRenderingContextBase['TRIANGLES'] | WebGL2RenderingContext['LINE_STRIP'];
    /**
      * @internal
      * A webgl program to execute in the GPU space
      */
    export class Program<Us extends UniformBindings> {
        program: WebGLProgram;
        attributes: {
            [_: string]: number;
        };
        numAttributes: number;
        fixedUniforms: Us;
        terrainUniforms: TerrainPreludeUniformsType;
        binderUniforms: Array<BinderUniform>;
        failedToCreate: boolean;
        constructor(context: Context, source: {
            fragmentSource: string;
            vertexSource: string;
            staticAttributes: Array<string>;
            staticUniforms: Array<string>;
        }, configuration: ProgramConfiguration, fixedUniforms: (b: Context, a: UniformLocations) => Us, showOverdrawInspector: boolean, terrain: Terrain);
        draw(context: Context, drawMode: DrawMode, depthMode: Readonly<DepthMode>, stencilMode: Readonly<StencilMode>, colorMode: Readonly<ColorMode>, cullFaceMode: Readonly<CullFaceMode>, uniformValues: UniformValues<Us>, terrain: TerrainData, layerID: string, layoutVertexBuffer: VertexBuffer, indexBuffer: IndexBuffer, segments: SegmentVector, currentProperties?: any, zoom?: number | null, configuration?: ProgramConfiguration | null, dynamicLayoutBuffer?: VertexBuffer | null, dynamicLayoutBuffer2?: VertexBuffer | null, dynamicLayoutBuffer3?: VertexBuffer | null): void;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/context' {
    import { IndexBuffer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/index_buffer';
    import { VertexBuffer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/vertex_buffer';
    import { Framebuffer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/framebuffer';
    import { DepthMode } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/depth_mode';
    import { StencilMode } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/stencil_mode';
    import { ColorMode } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/color_mode';
    import { CullFaceMode } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/cull_face_mode';
    import { ClearColor, ClearDepth, ClearStencil, ColorMask, DepthMask, StencilMask, StencilFunc, StencilOp, StencilTest, DepthRange, DepthTest, DepthFunc, Blend, BlendFunc, BlendColor, BlendEquation, CullFace, CullFaceSide, FrontFace, ProgramValue, ActiveTextureUnit, Viewport, BindFramebuffer, BindRenderbuffer, BindTexture, BindVertexBuffer, BindElementBuffer, BindVertexArray, PixelStoreUnpack, PixelStoreUnpackPremultiplyAlpha, PixelStoreUnpackFlipY } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/value';
    import type { TriangleIndexArray, LineIndexArray, LineStripIndexArray } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/index_array_type';
    import type { StructArray, StructArrayMember } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/struct_array';
    import type { Color } from '@maplibre/maplibre-gl-style-spec';
    type ClearArgs = {
        color?: Color;
        depth?: number;
        stencil?: number;
    };
    /**
      * @internal
      * A webgl wrapper class to allow injection, mocking and abstaction
      */
    export class Context {
        gl: WebGLRenderingContext | WebGL2RenderingContext;
        currentNumAttributes: number;
        maxTextureSize: number;
        clearColor: ClearColor;
        clearDepth: ClearDepth;
        clearStencil: ClearStencil;
        colorMask: ColorMask;
        depthMask: DepthMask;
        stencilMask: StencilMask;
        stencilFunc: StencilFunc;
        stencilOp: StencilOp;
        stencilTest: StencilTest;
        depthRange: DepthRange;
        depthTest: DepthTest;
        depthFunc: DepthFunc;
        blend: Blend;
        blendFunc: BlendFunc;
        blendColor: BlendColor;
        blendEquation: BlendEquation;
        cullFace: CullFace;
        cullFaceSide: CullFaceSide;
        frontFace: FrontFace;
        program: ProgramValue;
        activeTexture: ActiveTextureUnit;
        viewport: Viewport;
        bindFramebuffer: BindFramebuffer;
        bindRenderbuffer: BindRenderbuffer;
        bindTexture: BindTexture;
        bindVertexBuffer: BindVertexBuffer;
        bindElementBuffer: BindElementBuffer;
        bindVertexArray: BindVertexArray;
        pixelStoreUnpack: PixelStoreUnpack;
        pixelStoreUnpackPremultiplyAlpha: PixelStoreUnpackPremultiplyAlpha;
        pixelStoreUnpackFlipY: PixelStoreUnpackFlipY;
        extTextureFilterAnisotropic: EXT_texture_filter_anisotropic | null;
        extTextureFilterAnisotropicMax?: GLfloat;
        HALF_FLOAT?: GLenum;
        RGBA16F?: GLenum;
        RGB16F?: GLenum;
        constructor(gl: WebGLRenderingContext | WebGL2RenderingContext);
        setDefault(): void;
        setDirty(): void;
        createIndexBuffer(array: TriangleIndexArray | LineIndexArray | LineStripIndexArray, dynamicDraw?: boolean): IndexBuffer;
        createVertexBuffer(array: StructArray, attributes: ReadonlyArray<StructArrayMember>, dynamicDraw?: boolean): VertexBuffer;
        createRenderbuffer(storageFormat: number, width: number, height: number): WebGLRenderbuffer;
        createFramebuffer(width: number, height: number, hasDepth: boolean, hasStencil: boolean): Framebuffer;
        clear({ color, depth, stencil }: ClearArgs): void;
        setCullFace(cullFaceMode: Readonly<CullFaceMode>): void;
        setDepthMode(depthMode: Readonly<DepthMode>): void;
        setStencilMode(stencilMode: Readonly<StencilMode>): void;
        setColorMode(colorMode: Readonly<ColorMode>): void;
        createVertexArray(): WebGLVertexArrayObject | undefined;
        deleteVertexArray(x: WebGLVertexArrayObject | undefined): void;
        unbindVAO(): void;
    }
    export {};
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/depth_mode' {
    import type { DepthFuncType, DepthMaskType, DepthRangeType } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/types';
    export class DepthMode {
        func: DepthFuncType;
        mask: DepthMaskType;
        range: DepthRangeType;
        static ReadOnly: boolean;
        static ReadWrite: boolean;
        constructor(depthFunc: DepthFuncType, depthMask: DepthMaskType, depthRange: DepthRangeType);
        static disabled: Readonly<DepthMode>;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/stencil_mode' {
    import type { StencilOpConstant, StencilTestGL } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/types';
    export class StencilMode {
        test: StencilTestGL;
        ref: number;
        mask: number;
        fail: StencilOpConstant;
        depthFail: StencilOpConstant;
        pass: StencilOpConstant;
        constructor(test: StencilTestGL, ref: number, mask: number, fail: StencilOpConstant, depthFail: StencilOpConstant, pass: StencilOpConstant);
        static disabled: Readonly<StencilMode>;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/color_mode' {
    import { Color } from '@maplibre/maplibre-gl-style-spec';
    import type { BlendFuncType, ColorMaskType } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/types';
    export class ColorMode {
        blendFunction: BlendFuncType;
        blendColor: Color;
        mask: ColorMaskType;
        constructor(blendFunction: BlendFuncType, blendColor: Color, mask: ColorMaskType);
        static Replace: BlendFuncType;
        static disabled: Readonly<ColorMode>;
        static unblended: Readonly<ColorMode>;
        static alphaBlended: Readonly<ColorMode>;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/style/properties' {
    import { Color, StylePropertySpecification, Feature, FeatureState, StylePropertyExpression, SourceExpression, CompositeExpression, TransitionSpecification, PropertyValueSpecification } from '@maplibre/maplibre-gl-style-spec';
    import { EvaluationParameters } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/evaluation_parameters';
    import { CanonicalTileID } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile_id';
    type TimePoint = number;
    /**
        * A from-to type
        */
    export type CrossFaded<T> = {
            to: T;
            from: T;
    };
    /**
        * @internal
        *  Implementations of the `Property` interface:
        *
        *  * Hold metadata about a property that's independent of any specific value: stuff like the type of the value,
        *    the default value, etc. This comes from the style specification JSON.
        *  * Define behavior that needs to be polymorphic across different properties: "possibly evaluating"
        *    an input value (see below), and interpolating between two possibly-evaluted values.
        *
        *  The type `T` is the fully-evaluated value type (e.g. `number`, `string`, `Color`).
        *  The type `R` is the intermediate "possibly evaluated" value type. See below.
        *
        *  There are two main implementations of the interface -- one for properties that allow data-driven values,
        *  and one for properties that don't. There are a few "special case" implementations as well: one for properties
        *  which cross-fade between two values rather than interpolating, one for `heatmap-color` and `line-gradient`,
        *  and one for `light-position`.
        */
    export interface Property<T, R> {
            specification: StylePropertySpecification;
            possiblyEvaluate(value: PropertyValue<T, R>, parameters: EvaluationParameters, canonical?: CanonicalTileID, availableImages?: Array<string>): R;
            interpolate(a: R, b: R, t: number): R;
    }
    /**
        * @internal
        *  `PropertyValue` represents the value part of a property key-value unit. It's used to represent both
        *  paint and layout property values, and regardless of whether or not their property supports data-driven
        *  expressions.
        *
        *  `PropertyValue` stores the raw input value as seen in a style or a runtime styling API call, i.e. one of the
        *  following:
        *
        *    * A constant value of the type appropriate for the property
        *    * A function which produces a value of that type (but functions are quasi-deprecated in favor of expressions)
        *    * An expression which produces a value of that type
        *    * "undefined"/"not present", in which case the property is assumed to take on its default value.
        *
        *  In addition to storing the original input value, `PropertyValue` also stores a normalized representation,
        *  effectively treating functions as if they are expressions, and constant or default values as if they are
        *  (constant) expressions.
        */
    export class PropertyValue<T, R> {
            property: Property<T, R>;
            value: PropertyValueSpecification<T> | void;
            expression: StylePropertyExpression;
            constructor(property: Property<T, R>, value: PropertyValueSpecification<T> | void);
            isDataDriven(): boolean;
            possiblyEvaluate(parameters: EvaluationParameters, canonical?: CanonicalTileID, availableImages?: Array<string>): R;
    }
    export type TransitionParameters = {
            now: TimePoint;
            transition: TransitionSpecification;
    };
    /**
        * @internal
        * Paint properties are _transitionable_: they can change in a fluid manner, interpolating or cross-fading between
        * old and new value. The duration of the transition, and the delay before it begins, is configurable.
        *
        * `TransitionablePropertyValue` is a compositional class that stores both the property value and that transition
        * configuration.
        *
        * A `TransitionablePropertyValue` can calculate the next step in the evaluation chain for paint property values:
        * `TransitioningPropertyValue`.
        */
    class TransitionablePropertyValue<T, R> {
            property: Property<T, R>;
            value: PropertyValue<T, R>;
            transition: TransitionSpecification | void;
            constructor(property: Property<T, R>);
            transitioned(parameters: TransitionParameters, prior: TransitioningPropertyValue<T, R>): TransitioningPropertyValue<T, R>;
            untransitioned(): TransitioningPropertyValue<T, R>;
    }
    /**
        * @internal
        * `Transitionable` stores a map of all (property name, `TransitionablePropertyValue`) pairs for paint properties of a
        * given layer type. It can calculate the `TransitioningPropertyValue`s for all of them at once, producing a
        * `Transitioning` instance for the same set of properties.
        */
    export class Transitionable<Props> {
            _properties: Properties<Props>;
            _values: {
                    [K in keyof Props]: TransitionablePropertyValue<any, unknown>;
            };
            constructor(properties: Properties<Props>);
            getValue<S extends keyof Props, T>(name: S): PropertyValueSpecification<T> | void;
            setValue<S extends keyof Props, T>(name: S, value: PropertyValueSpecification<T> | void): void;
            getTransition<S extends keyof Props>(name: S): TransitionSpecification | void;
            setTransition<S extends keyof Props>(name: S, value: TransitionSpecification | void): void;
            serialize(): any;
            transitioned(parameters: TransitionParameters, prior: Transitioning<Props>): Transitioning<Props>;
            untransitioned(): Transitioning<Props>;
    }
    /**
        * @internal
        * `TransitioningPropertyValue` implements the first of two intermediate steps in the evaluation chain of a paint
        * property value. In this step, transitions between old and new values are handled: as long as the transition is in
        * progress, `TransitioningPropertyValue` maintains a reference to the prior value, and interpolates between it and
        * the new value based on the current time and the configured transition duration and delay. The product is the next
        * step in the evaluation chain: the "possibly evaluated" result type `R`. See below for more on this concept.
        */
    class TransitioningPropertyValue<T, R> {
            property: Property<T, R>;
            value: PropertyValue<T, R>;
            prior: TransitioningPropertyValue<T, R>;
            begin: TimePoint;
            end: TimePoint;
            constructor(property: Property<T, R>, value: PropertyValue<T, R>, prior: TransitioningPropertyValue<T, R>, transition: TransitionSpecification, now: TimePoint);
            possiblyEvaluate(parameters: EvaluationParameters, canonical: CanonicalTileID, availableImages: Array<string>): R;
    }
    /**
        * @internal
        * `Transitioning` stores a map of all (property name, `TransitioningPropertyValue`) pairs for paint properties of a
        * given layer type. It can calculate the possibly-evaluated values for all of them at once, producing a
        * `PossiblyEvaluated` instance for the same set of properties.
        */
    export class Transitioning<Props> {
            _properties: Properties<Props>;
            _values: {
                    [K in keyof Props]: PossiblyEvaluatedPropertyValue<unknown>;
            };
            constructor(properties: Properties<Props>);
            possiblyEvaluate(parameters: EvaluationParameters, canonical?: CanonicalTileID, availableImages?: Array<string>): PossiblyEvaluated<Props, any>;
            hasTransition(): boolean;
    }
    /**
        * Because layout properties are not transitionable, they have a simpler representation and evaluation chain than
        * paint properties: `PropertyValue`s are possibly evaluated, producing possibly evaluated values, which are then
        * fully evaluated.
        *
        * `Layout` stores a map of all (property name, `PropertyValue`) pairs for layout properties of a
        * given layer type. It can calculate the possibly-evaluated values for all of them at once, producing a
        * `PossiblyEvaluated` instance for the same set of properties.
        */
    export class Layout<Props> {
            _properties: Properties<Props>;
            _values: {
                    [K in keyof Props]: PropertyValue<any, PossiblyEvaluatedPropertyValue<any>>;
            };
            constructor(properties: Properties<Props>);
            hasValue<S extends keyof Props>(name: S): boolean;
            getValue<S extends keyof Props>(name: S): any;
            setValue<S extends keyof Props>(name: S, value: any): void;
            serialize(): any;
            possiblyEvaluate(parameters: EvaluationParameters, canonical?: CanonicalTileID, availableImages?: Array<string>): PossiblyEvaluated<Props, any>;
    }
    /**
        * "Possibly evaluated value" is an intermediate stage in the evaluation chain for both paint and layout property
        * values. The purpose of this stage is to optimize away unnecessary recalculations for data-driven properties. Code
        * which uses data-driven property values must assume that the value is dependent on feature data, and request that it
        * be evaluated for each feature. But when that property value is in fact a constant or camera function, the calculation
        * will not actually depend on the feature, and we can benefit from returning the prior result of having done the
        * evaluation once, ahead of time, in an intermediate step whose inputs are just the value and "global" parameters
        * such as current zoom level.
        *
        * `PossiblyEvaluatedValue` represents the three possible outcomes of this step: if the input value was a constant or
        * camera expression, then the "possibly evaluated" result is a constant value. Otherwise, the input value was either
        * a source or composite expression, and we must defer final evaluation until supplied a feature. We separate
        * the source and composite cases because they are handled differently when generating GL attributes, buffers, and
        * uniforms.
        *
        * Note that `PossiblyEvaluatedValue` (and `PossiblyEvaluatedPropertyValue`, below) are _not_ used for properties that
        * do not allow data-driven values. For such properties, we know that the "possibly evaluated" result is always a constant
        * scalar value. See below.
        */
    type PossiblyEvaluatedValue<T> = {
            kind: 'constant';
            value: T;
    } | SourceExpression | CompositeExpression;
    /**
        * @internal
        * `PossiblyEvaluatedPropertyValue` is used for data-driven paint and layout property values. It holds a
        * `PossiblyEvaluatedValue` and the `GlobalProperties` that were used to generate it. You're not allowed to supply
        * a different set of `GlobalProperties` when performing the final evaluation because they would be ignored in the
        * case where the input value was a constant or camera function.
        */
    export class PossiblyEvaluatedPropertyValue<T> {
            property: DataDrivenProperty<T>;
            value: PossiblyEvaluatedValue<T>;
            parameters: EvaluationParameters;
            constructor(property: DataDrivenProperty<T>, value: PossiblyEvaluatedValue<T>, parameters: EvaluationParameters);
            isConstant(): boolean;
            constantOr(value: T): T;
            evaluate(feature: Feature, featureState: FeatureState, canonical?: CanonicalTileID, availableImages?: Array<string>): T;
    }
    /**
        * @internal
        * `PossiblyEvaluated` stores a map of all (property name, `R`) pairs for paint or layout properties of a
        * given layer type.
        */
    export class PossiblyEvaluated<Props, PossibleEvaluatedProps> {
            _properties: Properties<Props>;
            _values: PossibleEvaluatedProps;
            constructor(properties: Properties<Props>);
            get<S extends keyof PossibleEvaluatedProps>(name: S): PossibleEvaluatedProps[S];
    }
    /**
        * @internal
        * An implementation of `Property` for properties that do not permit data-driven (source or composite) expressions.
        * This restriction allows us to declare statically that the result of possibly evaluating this kind of property
        * is in fact always the scalar type `T`, and can be used without further evaluating the value on a per-feature basis.
        */
    export class DataConstantProperty<T> implements Property<T, T> {
            specification: StylePropertySpecification;
            constructor(specification: StylePropertySpecification);
            possiblyEvaluate(value: PropertyValue<T, T>, parameters: EvaluationParameters): T;
            interpolate(a: T, b: T, t: number): T;
    }
    /**
        * @internal
        * An implementation of `Property` for properties that permit data-driven (source or composite) expressions.
        * The result of possibly evaluating this kind of property is `PossiblyEvaluatedPropertyValue<T>`; obtaining
        * a scalar value `T` requires further evaluation on a per-feature basis.
        */
    export class DataDrivenProperty<T> implements Property<T, PossiblyEvaluatedPropertyValue<T>> {
            specification: StylePropertySpecification;
            overrides: any;
            constructor(specification: StylePropertySpecification, overrides?: any);
            possiblyEvaluate(value: PropertyValue<T, PossiblyEvaluatedPropertyValue<T>>, parameters: EvaluationParameters, canonical?: CanonicalTileID, availableImages?: Array<string>): PossiblyEvaluatedPropertyValue<T>;
            interpolate(a: PossiblyEvaluatedPropertyValue<T>, b: PossiblyEvaluatedPropertyValue<T>, t: number): PossiblyEvaluatedPropertyValue<T>;
            evaluate(value: PossiblyEvaluatedValue<T>, parameters: EvaluationParameters, feature: Feature, featureState: FeatureState, canonical?: CanonicalTileID, availableImages?: Array<string>): T;
    }
    /**
        * @internal
        * An implementation of `Property` for  data driven `line-pattern` which are transitioned by cross-fading
        * rather than interpolation.
        */
    export class CrossFadedDataDrivenProperty<T> extends DataDrivenProperty<CrossFaded<T>> {
            possiblyEvaluate(value: PropertyValue<CrossFaded<T>, PossiblyEvaluatedPropertyValue<CrossFaded<T>>>, parameters: EvaluationParameters, canonical?: CanonicalTileID, availableImages?: Array<string>): PossiblyEvaluatedPropertyValue<CrossFaded<T>>;
            evaluate(value: PossiblyEvaluatedValue<CrossFaded<T>>, globals: EvaluationParameters, feature: Feature, featureState: FeatureState, canonical?: CanonicalTileID, availableImages?: Array<string>): CrossFaded<T>;
            _calculate(min: T, mid: T, max: T, parameters: EvaluationParameters): CrossFaded<T>;
            interpolate(a: PossiblyEvaluatedPropertyValue<CrossFaded<T>>): PossiblyEvaluatedPropertyValue<CrossFaded<T>>;
    }
    /**
        * @internal
        * An implementation of `Property` for `*-pattern` and `line-dasharray`, which are transitioned by cross-fading
        * rather than interpolation.
        */
    export class CrossFadedProperty<T> implements Property<T, CrossFaded<T>> {
            specification: StylePropertySpecification;
            constructor(specification: StylePropertySpecification);
            possiblyEvaluate(value: PropertyValue<T, CrossFaded<T>>, parameters: EvaluationParameters, canonical?: CanonicalTileID, availableImages?: Array<string>): CrossFaded<T>;
            _calculate(min: T, mid: T, max: T, parameters: EvaluationParameters): CrossFaded<T>;
            interpolate(a?: CrossFaded<T> | null): CrossFaded<T>;
    }
    /**
        * @internal
        * An implementation of `Property` for `heatmap-color` and `line-gradient`. Interpolation is a no-op, and
        * evaluation returns a boolean value in order to indicate its presence, but the real
        * evaluation happens in StyleLayer classes.
        */
    export class ColorRampProperty implements Property<Color, boolean> {
            specification: StylePropertySpecification;
            constructor(specification: StylePropertySpecification);
            possiblyEvaluate(value: PropertyValue<Color, boolean>, parameters: EvaluationParameters, canonical?: CanonicalTileID, availableImages?: Array<string>): boolean;
            interpolate(): boolean;
    }
    /**
        * @internal
        * `Properties` holds objects containing default values for the layout or paint property set of a given
        * layer type. These objects are immutable, and they are used as the prototypes for the `_values` members of
        * `Transitionable`, `Transitioning`, `Layout`, and `PossiblyEvaluated`. This allows these classes to avoid
        * doing work in the common case where a property has no explicit value set and should be considered to take
        * on the default value: using `for (const property of Object.keys(this._values))`, they can iterate over
        * only the _own_ properties of `_values`, skipping repeated calculation of transitions and possible/final
        * evaluations for defaults, the result of which will always be the same.
        */
    export class Properties<Props> {
            properties: Props;
            defaultPropertyValues: {
                    [K in keyof Props]: PropertyValue<unknown, any>;
            };
            defaultTransitionablePropertyValues: {
                    [K in keyof Props]: TransitionablePropertyValue<unknown, unknown>;
            };
            defaultTransitioningPropertyValues: {
                    [K in keyof Props]: TransitioningPropertyValue<unknown, unknown>;
            };
            defaultPossiblyEvaluatedValues: {
                    [K in keyof Props]: PossiblyEvaluatedPropertyValue<unknown>;
            };
            overridableProperties: Array<string>;
            constructor(properties: Props);
    }
    export {};
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/index_buffer' {
    import type { StructArray } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/struct_array';
    import type { TriangleIndexArray, LineIndexArray, LineStripIndexArray } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/index_array_type';
    import type { Context } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/context';
    /**
      * @internal
      * an index buffer class
      */
    export class IndexBuffer {
        context: Context;
        buffer: WebGLBuffer;
        dynamicDraw: boolean;
        constructor(context: Context, array: TriangleIndexArray | LineIndexArray | LineStripIndexArray, dynamicDraw?: boolean);
        bind(): void;
        updateData(array: StructArray): void;
        destroy(): void;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/types' {
    type BlendFuncConstant = WebGLRenderingContextBase['ZERO'] | WebGLRenderingContextBase['ONE'] | WebGLRenderingContextBase['SRC_COLOR'] | WebGLRenderingContextBase['ONE_MINUS_SRC_COLOR'] | WebGLRenderingContextBase['DST_COLOR'] | WebGLRenderingContextBase['ONE_MINUS_DST_COLOR'] | WebGLRenderingContextBase['SRC_ALPHA'] | WebGLRenderingContextBase['ONE_MINUS_SRC_ALPHA'] | WebGLRenderingContextBase['DST_ALPHA'] | WebGLRenderingContextBase['ONE_MINUS_DST_ALPHA'] | WebGLRenderingContextBase['CONSTANT_COLOR'] | WebGLRenderingContextBase['ONE_MINUS_CONSTANT_COLOR'] | WebGLRenderingContextBase['CONSTANT_ALPHA'] | WebGLRenderingContextBase['ONE_MINUS_CONSTANT_ALPHA'] | WebGLRenderingContextBase['BLEND_COLOR'];
    export type BlendFuncType = [BlendFuncConstant, BlendFuncConstant];
    export type BlendEquationType = WebGLRenderingContextBase['FUNC_ADD'] | WebGLRenderingContextBase['FUNC_SUBTRACT'] | WebGLRenderingContextBase['FUNC_REVERSE_SUBTRACT'];
    export type ColorMaskType = [boolean, boolean, boolean, boolean];
    export type CompareFuncType = WebGLRenderingContextBase['NEVER'] | WebGLRenderingContextBase['LESS'] | WebGLRenderingContextBase['EQUAL'] | WebGLRenderingContextBase['LEQUAL'] | WebGLRenderingContextBase['GREATER'] | WebGLRenderingContextBase['NOTEQUAL'] | WebGLRenderingContextBase['GEQUAL'] | WebGLRenderingContextBase['ALWAYS'];
    export type DepthMaskType = boolean;
    export type DepthRangeType = [number, number];
    export type DepthFuncType = CompareFuncType;
    export type StencilFuncType = {
        func: CompareFuncType;
        ref: number;
        mask: number;
    };
    export type StencilOpConstant = WebGLRenderingContextBase['KEEP'] | WebGLRenderingContextBase['ZERO'] | WebGLRenderingContextBase['REPLACE'] | WebGLRenderingContextBase['INCR'] | WebGLRenderingContextBase['INCR_WRAP'] | WebGLRenderingContextBase['DECR'] | WebGLRenderingContextBase['DECR_WRAP'] | WebGLRenderingContextBase['INVERT'];
    export type StencilOpType = [StencilOpConstant, StencilOpConstant, StencilOpConstant];
    export type TextureUnitType = number;
    export type ViewportType = [number, number, number, number];
    export type StencilTestGL = {
        func: WebGLRenderingContextBase['NEVER'];
        mask: 0;
    } | {
        func: WebGLRenderingContextBase['LESS'];
        mask: number;
    } | {
        func: WebGLRenderingContextBase['EQUAL'];
        mask: number;
    } | {
        func: WebGLRenderingContextBase['LEQUAL'];
        mask: number;
    } | {
        func: WebGLRenderingContextBase['GREATER'];
        mask: number;
    } | {
        func: WebGLRenderingContextBase['NOTEQUAL'];
        mask: number;
    } | {
        func: WebGLRenderingContextBase['GEQUAL'];
        mask: number;
    } | {
        func: WebGLRenderingContextBase['ALWAYS'];
        mask: 0;
    };
    export type CullFaceModeType = WebGLRenderingContextBase['FRONT'] | WebGLRenderingContextBase['BACK'] | WebGLRenderingContextBase['FRONT_AND_BACK'];
    export type FrontFaceType = WebGLRenderingContextBase['CW'] | WebGLRenderingContextBase['CCW'];
    export {};
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/render/render_to_texture' {
    import { Painter } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/painter';
    import { Tile } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile';
    import { OverscaledTileID } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile_id';
    import { Style } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style';
    import { Terrain } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/terrain';
    import { RenderPool } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/render_pool';
    import { Texture } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/texture';
    import type { StyleLayer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer';
    /**
        * @internal
        * A helper class to help define what should be rendered to texture and how
        */
    export class RenderToTexture {
            painter: Painter;
            terrain: Terrain;
            pool: RenderPool;
            /**
                * coordsDescendingInv contains a list of all tiles which should be rendered for one render-to-texture tile
                * e.g. render 4 raster-tiles with size 256px to the 512px render-to-texture tile
                */
            _coordsDescendingInv: {
                    [_: string]: {
                            [_: string]: Array<OverscaledTileID>;
                    };
            };
            /**
                * create a string representation of all to tiles rendered to render-to-texture tiles
                * this string representation is used to check if tile should be re-rendered.
                */
            _coordsDescendingInvStr: {
                    [_: string]: {
                            [_: string]: string;
                    };
            };
            /**
                * store for render-stacks
                * a render stack is a set of layers which should be rendered into one texture
                * every stylesheet can have multiple stacks. A new stack is created if layers which should
                * not rendered to texture sit inbetween layers which should rendered to texture. e.g. hillshading or symbols
                */
            _stacks: Array<Array<string>>;
            /**
                * remember the previous processed layer to check if a new stack is needed
                */
            _prevType: string;
            /**
                * a list of tiles that can potentially rendered
                */
            _renderableTiles: Array<Tile>;
            /**
                * a list of tiles that should be rendered to screen in the next render-call
                */
            _rttTiles: Array<Tile>;
            /**
                * a list of all layer-ids which should be rendered
                */
            _renderableLayerIds: Array<string>;
            constructor(painter: Painter, terrain: Terrain);
            destruct(): void;
            getTexture(tile: Tile): Texture;
            prepareForRender(style: Style, zoom: number): void;
            /**
                * due that switching textures is relatively slow, the render
                * layer-by-layer context is not practicable. To bypass this problem
                * this lines of code stack all layers and later render all at once.
                * Because of the stylesheet possibility to mixing render-to-texture layers
                * and 'live'-layers (f.e. symbols) it is necessary to create more stacks. For example
                * a symbol-layer is in between of fill-layers.
                * @param layer - the layer to render
                * @returns if true layer is rendered to texture, otherwise false
                */
            renderLayer(layer: StyleLayer): boolean;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler_inertia' {
    import type { Map } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/map';
    import type { DragPanOptions } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/shim/drag_pan';
    export type InertiaOptions = {
        linearity: number;
        easing: (t: number) => number;
        deceleration: number;
        maxSpeed: number;
    };
    export class HandlerInertia {
        _map: Map;
        _inertiaBuffer: Array<{
            time: number;
            settings: any;
        }>;
        constructor(map: Map);
        clear(): void;
        record(settings: any): void;
        _drainInertiaBuffer(): void;
        _onMoveEnd(panInertiaOptions?: DragPanOptions | boolean): any;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/data/bucket' {
    import type { CollisionBoxArray } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/array_types.g';
    import type { Style } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style';
    import type { TypedStyleLayer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/typed_style_layer';
    import type { FeatureIndex } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/feature_index';
    import type { Context } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/context';
    import type { FeatureStates } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/source_state';
    import type { ImagePosition } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/image_atlas';
    import type { CanonicalTileID } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile_id';
    import type { VectorTileFeature, VectorTileLayer } from '@mapbox/vector-tile';
    import Point from '@mapbox/point-geometry';
    export type BucketParameters<Layer extends TypedStyleLayer> = {
            index: number;
            layers: Array<Layer>;
            zoom: number;
            pixelRatio: number;
            overscaling: number;
            collisionBoxArray: CollisionBoxArray;
            sourceLayerIndex: number;
            sourceID: string;
    };
    export type PopulateParameters = {
            featureIndex: FeatureIndex;
            iconDependencies: {};
            patternDependencies: {};
            glyphDependencies: {};
            availableImages: Array<string>;
    };
    export type IndexedFeature = {
            feature: VectorTileFeature;
            id: number | string;
            index: number;
            sourceLayerIndex: number;
    };
    export type BucketFeature = {
            index: number;
            sourceLayerIndex: number;
            geometry: Array<Array<Point>>;
            properties: any;
            type: 0 | 1 | 2 | 3;
            id?: any;
            readonly patterns: {
                    [_: string]: {
                            min: string;
                            mid: string;
                            max: string;
                    };
            };
            sortKey?: number;
    };
    /**
        * The `Bucket` interface is the single point of knowledge about turning vector
        * tiles into WebGL buffers.
        *
        * `Bucket` is an abstract interface. An implementation exists for each style layer type.
        * Create a bucket via the `StyleLayer#createBucket` method.
        *
        * The concrete bucket types, using layout options from the style layer,
        * transform feature geometries into vertex and index data for use by the
        * vertex shader.  They also (via `ProgramConfiguration`) use feature
        * properties and the zoom level to populate the attributes needed for
        * data-driven styling.
        *
        * Buckets are designed to be built on a worker thread and then serialized and
        * transferred back to the main thread for rendering.  On the worker side, a
        * bucket's vertex, index, and attribute data is stored in `bucket.arrays: ArrayGroup`.
        * When a bucket's data is serialized and sent back to the main thread,
        * is gets deserialized (using `new Bucket(serializedBucketData)`, with
        * the array data now stored in `bucket.buffers: BufferGroup`. BufferGroups
        * hold the same data as ArrayGroups, but are tuned for consumption by WebGL.
        */
    export interface Bucket {
            layerIds: Array<string>;
            hasPattern: boolean;
            readonly layers: Array<any>;
            readonly stateDependentLayers: Array<any>;
            readonly stateDependentLayerIds: Array<string>;
            populate(features: Array<IndexedFeature>, options: PopulateParameters, canonical: CanonicalTileID): void;
            update(states: FeatureStates, vtLayer: VectorTileLayer, imagePositions: {
                    [_: string]: ImagePosition;
            }): void;
            isEmpty(): boolean;
            upload(context: Context): void;
            uploadPending(): boolean;
            /**
                * Release the WebGL resources associated with the buffers. Note that because
                * buckets are shared between layers having the same layout properties, they
                * must be destroyed in groups (all buckets for a tile, or all symbol buckets).
                */
            destroy(): void;
    }
    export function deserialize(input: Array<Bucket>, style: Style): {
            [_: string]: Bucket;
    };
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/symbol/collision_index' {
    import Point from '@mapbox/point-geometry';
    import { GridIndex } from '@mappedin/mappedin-js/packages/outdoor-context-v4/symbol/grid_index';
    import { mat4 } from 'gl-matrix';
    import type { Transform } from '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/transform';
    import type { SingleCollisionBox } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/bucket/symbol_bucket';
    import type { GlyphOffsetArray, SymbolLineVertexArray } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/array_types.g';
    import type { OverlapMode } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/overlap_mode';
    export type FeatureKey = {
            bucketInstanceId: number;
            featureIndex: number;
            collisionGroupID: number;
            overlapMode: OverlapMode;
    };
    /**
        * @internal
        * A collision index used to prevent symbols from overlapping. It keep tracks of
        * where previous symbols have been placed and is used to check if a new
        * symbol overlaps with any previously added symbols.
        *
        * There are two steps to insertion: first placeCollisionBox/Circles checks if
        * there's room for a symbol, then insertCollisionBox/Circles actually puts the
        * symbol in the index. The two step process allows paired symbols to be inserted
        * together even if they overlap.
        */
    export class CollisionIndex {
            grid: GridIndex<FeatureKey>;
            ignoredGrid: GridIndex<FeatureKey>;
            transform: Transform;
            pitchfactor: number;
            screenRightBoundary: number;
            screenBottomBoundary: number;
            gridRightBoundary: number;
            gridBottomBoundary: number;
            perspectiveRatioCutoff: number;
            constructor(transform: Transform, grid?: GridIndex<FeatureKey>, ignoredGrid?: GridIndex<FeatureKey>);
            placeCollisionBox(collisionBox: SingleCollisionBox, overlapMode: OverlapMode, textPixelRatio: number, posMatrix: mat4, collisionGroupPredicate?: (key: FeatureKey) => boolean, getElevation?: (x: number, y: number) => number): {
                    box: Array<number>;
                    offscreen: boolean;
            };
            placeCollisionCircles(overlapMode: OverlapMode, symbol: any, lineVertexArray: SymbolLineVertexArray, glyphOffsetArray: GlyphOffsetArray, fontSize: number, posMatrix: mat4, labelPlaneMatrix: mat4, labelToScreenMatrix: mat4, showCollisionCircles: boolean, pitchWithMap: boolean, collisionGroupPredicate: (key: FeatureKey) => boolean, circlePixelDiameter: number, textPixelPadding: number, getElevation: (x: number, y: number) => number): {
                    circles: Array<number>;
                    offscreen: boolean;
                    collisionDetected: boolean;
            };
            /**
                * Because the geometries in the CollisionIndex are an approximation of the shape of
                * symbols on the map, we use the CollisionIndex to look up the symbol part of
                * `queryRenderedFeatures`.
                */
            queryRenderedSymbols(viewportQueryGeometry: Array<Point>): {};
            insertCollisionBox(collisionBox: Array<number>, overlapMode: OverlapMode, ignorePlacement: boolean, bucketInstanceId: number, featureIndex: number, collisionGroupID: number): void;
            insertCollisionCircles(collisionCircles: Array<number>, overlapMode: OverlapMode, ignorePlacement: boolean, bucketInstanceId: number, featureIndex: number, collisionGroupID: number): void;
            projectAndGetPerspectiveRatio(posMatrix: mat4, x: number, y: number, getElevation?: (x: number, y: number) => number): {
                    point: Point;
                    perspectiveRatio: number;
            };
            isOffscreen(x1: number, y1: number, x2: number, y2: number): boolean;
            isInsideGrid(x1: number, y1: number, x2: number, y2: number): boolean;
            getViewportMatrix(): mat4;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/drag_handler' {
    import type Point from '@mapbox/point-geometry';
    import { DragMoveStateManager } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/drag_move_state_manager';
    import { Handler } from '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler_manager';
    interface DragMovementResult {
            bearingDelta?: number;
            pitchDelta?: number;
            around?: Point;
            panDelta?: Point;
    }
    export interface DragPanResult extends DragMovementResult {
            around: Point;
            panDelta: Point;
    }
    export interface DragRotateResult extends DragMovementResult {
            bearingDelta: number;
    }
    export interface DragPitchResult extends DragMovementResult {
            pitchDelta: number;
    }
    type DragMoveFunction<T extends DragMovementResult> = (lastPoint: Point, point: Point) => T;
    export interface DragMoveHandler<T extends DragMovementResult, E extends Event> extends Handler {
            dragStart: (e: E, point: Point) => void;
            dragMove: (e: E, point: Point) => T | void;
            dragEnd: (e: E) => void;
            getClickTolerance: () => number;
    }
    export type DragMoveHandlerOptions<T, E extends Event> = {
            /**
                * If the movement is shorter than this value, consider it a click.
                */
            clickTolerance: number;
            /**
                * The move function to run on a valid movement.
                */
            move: DragMoveFunction<T>;
            /**
                * A class used to manage the state of the drag event - start, checking valid moves, end. See the class documentation for more details.
                */
            moveStateManager: DragMoveStateManager<E>;
            /**
                * A method used to assign the dragStart, dragMove, and dragEnd methods to the relevant event handlers, as well as assigning the contextmenu handler
                * @param handler - the handler
                */
            assignEvents: (handler: DragMoveHandler<T, E>) => void;
            /**
                * Should the move start on the "start" event, or should it start on the first valid move.
                */
            activateOnStart?: boolean;
            /**
                * If true, handler will be enabled during construction
                */
            enable?: boolean;
    };
    /**
        * A generic class to create handlers for drag events, from both mouse and touch events.
        */
    export class DragHandler<T extends DragMovementResult, E extends Event> implements DragMoveHandler<T, E> {
            contextmenu?: Handler['contextmenu'];
            mousedown?: Handler['mousedown'];
            mousemoveWindow?: Handler['mousemoveWindow'];
            mouseup?: Handler['mouseup'];
            touchstart?: Handler['touchstart'];
            touchmoveWindow?: Handler['touchmoveWindow'];
            touchend?: Handler['touchend'];
            _clickTolerance: number;
            _moveFunction: DragMoveFunction<T>;
            _activateOnStart: boolean;
            _active: boolean;
            _enabled: boolean;
            _moved: boolean;
            _lastPoint: Point | null;
            _moveStateManager: DragMoveStateManager<E>;
            constructor(options: DragMoveHandlerOptions<T, E>);
            reset(e?: E): void;
            _move(...params: Parameters<DragMoveFunction<T>>): T;
            dragStart(e: E, point: Point): any;
            dragStart(e: E, point: Point[]): any;
            dragMove(e: E, point: Point): any;
            dragMove(e: E, point: Point[]): any;
            dragEnd(e: E): void;
            enable(): void;
            disable(): void;
            isEnabled(): boolean;
            isActive(): boolean;
            getClickTolerance(): number;
    }
    export {};
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/render/image_atlas' {
    import { RGBAImage } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/image';
    import type { StyleImage } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_image';
    import type { ImageManager } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/image_manager';
    import type { Texture } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/texture';
    import type { Rect } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/glyph_atlas';
    import type { GetImagesResponse } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/actor_messages';
    const IMAGE_PADDING: number;
    export { IMAGE_PADDING };
    export class ImagePosition {
        paddedRect: Rect;
        pixelRatio: number;
        version: number;
        stretchY: Array<[number, number]>;
        stretchX: Array<[number, number]>;
        content: [number, number, number, number];
        constructor(paddedRect: Rect, { pixelRatio, version, stretchX, stretchY, content }: StyleImage);
        get tl(): [number, number];
        get br(): [number, number];
        get tlbr(): Array<number>;
        get displaySize(): [number, number];
    }
    /**
      * A class holding all the images
      */
    export class ImageAtlas {
        image: RGBAImage;
        iconPositions: {
            [_: string]: ImagePosition;
        };
        patternPositions: {
            [_: string]: ImagePosition;
        };
        haveRenderCallbacks: Array<string>;
        uploaded: boolean;
        constructor(icons: GetImagesResponse, patterns: GetImagesResponse);
        addImages(images: {
            [_: string]: StyleImage;
        }, positions: {
            [_: string]: ImagePosition;
        }, bins: Array<Rect>): void;
        patchUpdatedImages(imageManager: ImageManager, texture: Texture): void;
        patchUpdatedImage(position: ImagePosition, image: StyleImage, texture: Texture): void;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/style/load_glyph_range' {
    import type { StyleGlyph } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_glyph';
    import type { RequestManager } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/request_manager';
    export function loadGlyphRange(fontstack: string, range: number, urlTemplate: string, requestManager: RequestManager): Promise<{
        [_: number]: StyleGlyph | null;
    }>;
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_glyph' {
    import type { AlphaImage } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/image';
    /**
        * Some metices related to a glyph
        */
    export type GlyphMetrics = {
            width: number;
            height: number;
            left: number;
            top: number;
            advance: number;
            /**
                * isDoubleResolution = true for 48px textures
                */
            isDoubleResolution?: boolean;
    };
    /**
        * A style glyph type
        */
    export type StyleGlyph = {
            id: number;
            bitmap: AlphaImage;
            metrics: GlyphMetrics;
    };
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/util/worker_pool' {
    import { ActorTarget } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/actor';
    export const PRELOAD_POOL_ID = "maplibre_preloaded_worker_pool";
    /**
      * Constructs a worker pool.
      */
    export class WorkerPool {
        static workerCount: number;
        active: {
            [_ in number | string]: boolean;
        };
        workers: Array<ActorTarget>;
        constructor();
        acquire(mapId: number | string): Array<ActorTarget>;
        release(mapId: number | string): void;
        isPreloaded(): boolean;
        numActive(): number;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile_cache' {
    import { OverscaledTileID } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile_id';
    import type { Tile } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile';
    /**
        * @internal
        * A [least-recently-used cache](http://en.wikipedia.org/wiki/Cache_algorithms)
        * with hash lookup made possible by keeping a list of keys in parallel to
        * an array of dictionary of values
        */
    export class TileCache {
            max: number;
            data: {
                    [key: string]: Array<{
                            value: Tile;
                            timeout: ReturnType<typeof setTimeout>;
                    }>;
            };
            order: Array<string>;
            onRemove: (element: Tile) => void;
            /**
                * @param max - number of permitted values
                * @param onRemove - callback called with items when they expire
                */
            constructor(max: number, onRemove: (element: Tile) => void);
            /**
                * Clear the cache
                *
                * @returns this cache
                */
            reset(): this;
            /**
                * Add a key, value combination to the cache, trimming its size if this pushes
                * it over max length.
                *
                * @param tileID - lookup key for the item
                * @param data - tile data
                *
                * @returns this cache
                */
            add(tileID: OverscaledTileID, data: Tile, expiryTimeout: number | void): this;
            /**
                * Determine whether the value attached to `key` is present
                *
                * @param tileID - the key to be looked-up
                * @returns whether the cache has this value
                */
            has(tileID: OverscaledTileID): boolean;
            /**
                * Get the value attached to a specific key and remove data from cache.
                * If the key is not found, returns `null`
                *
                * @param tileID - the key to look up
                * @returns the tile data, or null if it isn't found
                */
            getAndRemove(tileID: OverscaledTileID): Tile;
            _getAndRemoveByKey(key: string): Tile;
            getByKey(key: string): Tile;
            /**
                * Get the value attached to a specific key without removing data
                * from the cache. If the key is not found, returns `null`
                *
                * @param tileID - the key to look up
                * @returns the tile data, or null if it isn't found
                */
            get(tileID: OverscaledTileID): Tile;
            /**
                * Remove a key/value combination from the cache.
                *
                * @param tileID - the key for the pair to delete
                * @param value - If a value is provided, remove that exact version of the value.
                * @returns this cache
                */
            remove(tileID: OverscaledTileID, value?: {
                    value: Tile;
                    timeout: ReturnType<typeof setTimeout>;
            }): this;
            /**
                * Change the max size of the cache.
                *
                * @param max - the max size of the cache
                * @returns this cache
                */
            setMaxSize(max: number): TileCache;
            /**
                * Remove entries that do not pass a filter function. Used for removing
                * stale tiles from the cache.
                *
                * @param filterFn - Determines whether the tile is filtered. If the supplied function returns false, the tile will be filtered out.
                */
            filter(filterFn: (tile: Tile) => boolean): void;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/source/source_state' {
    import { Tile } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile';
    import type { FeatureState } from '@maplibre/maplibre-gl-style-spec';
    export type FeatureStates = {
        [featureId: string]: FeatureState;
    };
    export type LayerFeatureStates = {
        [layer: string]: FeatureStates;
    };
    /**
      * @internal
      * SourceFeatureState manages the state and pending changes
      * to features in a source, separated by source layer.
      * stateChanges and deletedStates batch all changes to the tile (updates and removes, respectively)
      * between coalesce() events. addFeatureState() and removeFeatureState() also update their counterpart's
      * list of changes, such that coalesce() can apply the proper state changes while agnostic to the order of operations.
      * In deletedStates, all null's denote complete removal of state at that scope
      */
    export class SourceFeatureState {
        state: LayerFeatureStates;
        stateChanges: LayerFeatureStates;
        deletedStates: {};
        constructor();
        updateState(sourceLayer: string, featureId: number | string, newState: any): void;
        removeFeatureState(sourceLayer: string, featureId?: number | string, key?: string): void;
        getState(sourceLayer: string, featureId: number | string): FeatureState;
        initializeTileState(tile: Tile, painter: any): void;
        coalesceChanges(tiles: {
            [_ in any]: Tile;
        }, painter: any): void;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/symbol_style_layer' {
    import { StyleLayer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer';
    import { SymbolBucket, SymbolFeature } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/bucket/symbol_bucket';
    import { SymbolLayoutPropsPossiblyEvaluated, SymbolPaintPropsPossiblyEvaluated } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/symbol_style_layer_properties.g';
    import { Transitionable, Transitioning, Layout, PossiblyEvaluated, PropertyValue } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/properties';
    import type { BucketParameters } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/bucket';
    import type { SymbolLayoutProps, SymbolPaintProps } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/symbol_style_layer_properties.g';
    import type { EvaluationParameters } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/evaluation_parameters';
    import type { Feature, LayerSpecification } from '@maplibre/maplibre-gl-style-spec';
    import type { CanonicalTileID } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile_id';
    export class SymbolStyleLayer extends StyleLayer {
        _unevaluatedLayout: Layout<SymbolLayoutProps>;
        layout: PossiblyEvaluated<SymbolLayoutProps, SymbolLayoutPropsPossiblyEvaluated>;
        _transitionablePaint: Transitionable<SymbolPaintProps>;
        _transitioningPaint: Transitioning<SymbolPaintProps>;
        paint: PossiblyEvaluated<SymbolPaintProps, SymbolPaintPropsPossiblyEvaluated>;
        constructor(layer: LayerSpecification);
        recalculate(parameters: EvaluationParameters, availableImages: Array<string>): void;
        getValueAndResolveTokens(name: any, feature: Feature, canonical: CanonicalTileID, availableImages: Array<string>): any;
        createBucket(parameters: BucketParameters<any>): SymbolBucket;
        queryRadius(): number;
        queryIntersectsFeature(): boolean;
        _setPaintOverrides(): void;
        _handleOverridablePaintPropertyUpdate<T, R>(name: string, oldValue: PropertyValue<T, R>, newValue: PropertyValue<T, R>): boolean;
        static hasPaintOverride(layout: PossiblyEvaluated<SymbolLayoutProps, SymbolLayoutPropsPossiblyEvaluated>, propertyName: string): boolean;
    }
    export type SymbolPadding = [number, number, number, number];
    export function getIconPadding(layout: PossiblyEvaluated<SymbolLayoutProps, SymbolLayoutPropsPossiblyEvaluated>, feature: SymbolFeature, canonical: CanonicalTileID, pixelRatio?: number): SymbolPadding;
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/data/bucket/symbol_bucket' {
    import { SymbolLayoutArray, SymbolDynamicLayoutArray, SymbolOpacityArray, CollisionVertexArray, PlacedSymbolArray, SymbolInstanceArray, GlyphOffsetArray, SymbolLineVertexArray, TextAnchorOffsetArray } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/array_types.g';
    import Point from '@mapbox/point-geometry';
    import { SegmentVector } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/segment';
    import { ProgramConfigurationSet } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/program_configuration';
    import { TriangleIndexArray, LineIndexArray } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/index_array_type';
    import { WritingMode } from '@mappedin/mappedin-js/packages/outdoor-context-v4/symbol/shaping';
    import { Anchor } from '@mappedin/mappedin-js/packages/outdoor-context-v4/symbol/anchor';
    import { Formatted, ResolvedImage } from '@maplibre/maplibre-gl-style-spec';
    import { mat4 } from 'gl-matrix';
    import type { CanonicalTileID } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile_id';
    import type { Bucket, BucketParameters, IndexedFeature, PopulateParameters } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/bucket';
    import type { CollisionBoxArray, SymbolInstance } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/array_types.g';
    import type { StructArray, StructArrayMember } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/struct_array';
    import type { SymbolStyleLayer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/symbol_style_layer';
    import type { Context } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/context';
    import type { IndexBuffer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/index_buffer';
    import type { VertexBuffer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/vertex_buffer';
    import type { SymbolQuad } from '@mappedin/mappedin-js/packages/outdoor-context-v4/symbol/quads';
    import type { SizeData } from '@mappedin/mappedin-js/packages/outdoor-context-v4/symbol/symbol_size';
    import type { FeatureStates } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/source_state';
    import type { ImagePosition } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/image_atlas';
    import type { VectorTileLayer } from '@mapbox/vector-tile';
    export type SingleCollisionBox = {
        x1: number;
        y1: number;
        x2: number;
        y2: number;
        anchorPointX: number;
        anchorPointY: number;
    };
    export type CollisionArrays = {
        textBox?: SingleCollisionBox;
        verticalTextBox?: SingleCollisionBox;
        iconBox?: SingleCollisionBox;
        verticalIconBox?: SingleCollisionBox;
        textFeatureIndex?: number;
        verticalTextFeatureIndex?: number;
        iconFeatureIndex?: number;
        verticalIconFeatureIndex?: number;
    };
    export type SymbolFeature = {
        sortKey: number | void;
        text: Formatted | void;
        icon: ResolvedImage;
        index: number;
        sourceLayerIndex: number;
        geometry: Array<Array<Point>>;
        properties: any;
        type: 'Unknown' | 'Point' | 'LineString' | 'Polygon';
        id?: any;
    };
    export type SortKeyRange = {
        sortKey: number;
        symbolInstanceStart: number;
        symbolInstanceEnd: number;
    };
    function addDynamicAttributes(dynamicLayoutVertexArray: StructArray, p: Point, angle: number): void;
    export class SymbolBuffers {
        layoutVertexArray: SymbolLayoutArray;
        layoutVertexBuffer: VertexBuffer;
        indexArray: TriangleIndexArray;
        indexBuffer: IndexBuffer;
        programConfigurations: ProgramConfigurationSet<SymbolStyleLayer>;
        segments: SegmentVector;
        dynamicLayoutVertexArray: SymbolDynamicLayoutArray;
        dynamicLayoutVertexBuffer: VertexBuffer;
        opacityVertexArray: SymbolOpacityArray;
        opacityVertexBuffer: VertexBuffer;
        hasVisibleVertices: boolean;
        collisionVertexArray: CollisionVertexArray;
        collisionVertexBuffer: VertexBuffer;
        placedSymbolArray: PlacedSymbolArray;
        constructor(programConfigurations: ProgramConfigurationSet<SymbolStyleLayer>);
        isEmpty(): boolean;
        upload(context: Context, dynamicIndexBuffer: boolean, upload?: boolean, update?: boolean): void;
        destroy(): void;
    }
    class CollisionBuffers {
        layoutVertexArray: StructArray;
        layoutAttributes: Array<StructArrayMember>;
        layoutVertexBuffer: VertexBuffer;
        indexArray: TriangleIndexArray | LineIndexArray;
        indexBuffer: IndexBuffer;
        segments: SegmentVector;
        collisionVertexArray: CollisionVertexArray;
        collisionVertexBuffer: VertexBuffer;
        constructor(LayoutArray: {
            new (...args: any): StructArray;
        }, layoutAttributes: Array<StructArrayMember>, IndexArray: {
            new (...args: any): TriangleIndexArray | LineIndexArray;
        });
        upload(context: Context): void;
        destroy(): void;
    }
    /**
      * @internal
      * Unlike other buckets, which simply implement #addFeature with type-specific
      * logic for (essentially) triangulating feature geometries, SymbolBucket
      * requires specialized behavior:
      *
      * 1. WorkerTile#parse(), the logical owner of the bucket creation process,
      *    calls SymbolBucket#populate(), which resolves text and icon tokens on
      *    each feature, adds each glyphs and symbols needed to the passed-in
      *    collections options.glyphDependencies and options.iconDependencies, and
      *    stores the feature data for use in subsequent step (this.features).
      *
      * 2. WorkerTile asynchronously requests from the main thread all of the glyphs
      *    and icons needed (by this bucket and any others). When glyphs and icons
      *    have been received, the WorkerTile creates a CollisionIndex and invokes:
      *
      * 3. performSymbolLayout(bucket, stacks, icons) perform texts shaping and
      *    layout on a Symbol Bucket. This step populates:
      *      `this.symbolInstances`: metadata on generated symbols
      *      `this.collisionBoxArray`: collision data for use by foreground
      *      `this.text`: SymbolBuffers for text symbols
      *      `this.icons`: SymbolBuffers for icons
      *      `this.iconCollisionBox`: Debug SymbolBuffers for icon collision boxes
      *      `this.textCollisionBox`: Debug SymbolBuffers for text collision boxes
      *    The results are sent to the foreground for rendering
      *
      * 4. placement.ts is run on the foreground,
      *    and uses the CollisionIndex along with current camera settings to determine
      *    which symbols can actually show on the map. Collided symbols are hidden
      *    using a dynamic "OpacityVertexArray".
      */
    export class SymbolBucket implements Bucket {
        static MAX_GLYPHS: number;
        static addDynamicAttributes: typeof addDynamicAttributes;
        collisionBoxArray: CollisionBoxArray;
        zoom: number;
        overscaling: number;
        layers: Array<SymbolStyleLayer>;
        layerIds: Array<string>;
        stateDependentLayers: Array<SymbolStyleLayer>;
        stateDependentLayerIds: Array<string>;
        index: number;
        sdfIcons: boolean;
        iconsInText: boolean;
        iconsNeedLinear: boolean;
        bucketInstanceId: number;
        justReloaded: boolean;
        hasPattern: boolean;
        textSizeData: SizeData;
        iconSizeData: SizeData;
        glyphOffsetArray: GlyphOffsetArray;
        lineVertexArray: SymbolLineVertexArray;
        features: Array<SymbolFeature>;
        symbolInstances: SymbolInstanceArray;
        textAnchorOffsets: TextAnchorOffsetArray;
        collisionArrays: Array<CollisionArrays>;
        sortKeyRanges: Array<SortKeyRange>;
        pixelRatio: number;
        tilePixelRatio: number;
        compareText: {
            [_: string]: Array<Point>;
        };
        fadeStartTime: number;
        sortFeaturesByKey: boolean;
        sortFeaturesByY: boolean;
        canOverlap: boolean;
        sortedAngle: number;
        featureSortOrder: Array<number>;
        collisionCircleArray: Array<number>;
        placementInvProjMatrix: mat4;
        placementViewportMatrix: mat4;
        text: SymbolBuffers;
        icon: SymbolBuffers;
        textCollisionBox: CollisionBuffers;
        iconCollisionBox: CollisionBuffers;
        uploaded: boolean;
        sourceLayerIndex: number;
        sourceID: string;
        symbolInstanceIndexes: Array<number>;
        writingModes: WritingMode[];
        allowVerticalPlacement: boolean;
        hasRTLText: boolean;
        constructor(options: BucketParameters<SymbolStyleLayer>);
        createArrays(): void;
        populate(features: Array<IndexedFeature>, options: PopulateParameters, canonical: CanonicalTileID): void;
        update(states: FeatureStates, vtLayer: VectorTileLayer, imagePositions: {
            [_: string]: ImagePosition;
        }): void;
        isEmpty(): boolean;
        uploadPending(): boolean;
        upload(context: Context): void;
        destroyDebugData(): void;
        destroy(): void;
        addToLineVertexArray(anchor: Anchor, line: any): {
            lineStartIndex: number;
            lineLength: number;
        };
        addSymbols(arrays: SymbolBuffers, quads: Array<SymbolQuad>, sizeVertex: any, lineOffset: [number, number], alongLine: boolean, feature: SymbolFeature, writingMode: WritingMode, labelAnchor: Anchor, lineStartIndex: number, lineLength: number, associatedIconIndex: number, canonical: CanonicalTileID): void;
        _addCollisionDebugVertex(layoutVertexArray: StructArray, collisionVertexArray: StructArray, point: Point, anchorX: number, anchorY: number, extrude: Point): any;
        addCollisionDebugVertices(x1: number, y1: number, x2: number, y2: number, arrays: CollisionBuffers, boxAnchorPoint: Point, symbolInstance: SymbolInstance): void;
        addDebugCollisionBoxes(startIndex: number, endIndex: number, symbolInstance: SymbolInstance, isText: boolean): void;
        generateCollisionDebugBuffers(): void;
        _deserializeCollisionBoxesForSymbol(collisionBoxArray: CollisionBoxArray, textStartIndex: number, textEndIndex: number, verticalTextStartIndex: number, verticalTextEndIndex: number, iconStartIndex: number, iconEndIndex: number, verticalIconStartIndex: number, verticalIconEndIndex: number): CollisionArrays;
        deserializeCollisionBoxes(collisionBoxArray: CollisionBoxArray): void;
        hasTextData(): boolean;
        hasIconData(): boolean;
        hasDebugData(): CollisionBuffers;
        hasTextCollisionBoxData(): boolean;
        hasIconCollisionBoxData(): boolean;
        addIndicesForPlacedSymbol(iconOrText: SymbolBuffers, placedSymbolIndex: number): void;
        getSortedSymbolIndexes(angle: number): any[];
        addToSortKeyRanges(symbolInstanceIndex: number, sortKey: number): void;
        sortFeatures(angle: number): void;
    }
    export { addDynamicAttributes };
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/symbol_style_layer_properties.g' {
    import { Properties, DataConstantProperty, DataDrivenProperty, PossiblyEvaluatedPropertyValue } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/properties';
    import type { Color, Formatted, Padding, ResolvedImage, VariableAnchorOffsetCollection } from '@maplibre/maplibre-gl-style-spec';
    export type SymbolLayoutProps = {
        'symbol-placement': DataConstantProperty<'point' | 'line' | 'line-center'>;
        'symbol-spacing': DataConstantProperty<number>;
        'symbol-avoid-edges': DataConstantProperty<boolean>;
        'symbol-sort-key': DataDrivenProperty<number>;
        'symbol-z-order': DataConstantProperty<'auto' | 'viewport-y' | 'source'>;
        'icon-allow-overlap': DataConstantProperty<boolean>;
        'icon-overlap': DataConstantProperty<'never' | 'always' | 'cooperative'>;
        'icon-ignore-placement': DataConstantProperty<boolean>;
        'icon-optional': DataConstantProperty<boolean>;
        'icon-rotation-alignment': DataConstantProperty<'map' | 'viewport' | 'auto'>;
        'icon-size': DataDrivenProperty<number>;
        'icon-text-fit': DataConstantProperty<'none' | 'width' | 'height' | 'both'>;
        'icon-text-fit-padding': DataConstantProperty<[number, number, number, number]>;
        'icon-image': DataDrivenProperty<ResolvedImage>;
        'icon-rotate': DataDrivenProperty<number>;
        'icon-padding': DataDrivenProperty<Padding>;
        'icon-keep-upright': DataConstantProperty<boolean>;
        'icon-offset': DataDrivenProperty<[number, number]>;
        'icon-anchor': DataDrivenProperty<'center' | 'left' | 'right' | 'top' | 'bottom' | 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right'>;
        'icon-pitch-alignment': DataConstantProperty<'map' | 'viewport' | 'auto'>;
        'text-pitch-alignment': DataConstantProperty<'map' | 'viewport' | 'auto'>;
        'text-rotation-alignment': DataConstantProperty<'map' | 'viewport' | 'viewport-glyph' | 'auto'>;
        'text-field': DataDrivenProperty<Formatted>;
        'text-font': DataDrivenProperty<Array<string>>;
        'text-size': DataDrivenProperty<number>;
        'text-max-width': DataDrivenProperty<number>;
        'text-line-height': DataConstantProperty<number>;
        'text-letter-spacing': DataDrivenProperty<number>;
        'text-justify': DataDrivenProperty<'auto' | 'left' | 'center' | 'right'>;
        'text-radial-offset': DataDrivenProperty<number>;
        'text-variable-anchor': DataConstantProperty<Array<'center' | 'left' | 'right' | 'top' | 'bottom' | 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right'>>;
        'text-variable-anchor-offset': DataDrivenProperty<VariableAnchorOffsetCollection>;
        'text-anchor': DataDrivenProperty<'center' | 'left' | 'right' | 'top' | 'bottom' | 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right'>;
        'text-max-angle': DataConstantProperty<number>;
        'text-writing-mode': DataConstantProperty<Array<'horizontal' | 'vertical'>>;
        'text-rotate': DataDrivenProperty<number>;
        'text-padding': DataConstantProperty<number>;
        'text-keep-upright': DataConstantProperty<boolean>;
        'text-transform': DataDrivenProperty<'none' | 'uppercase' | 'lowercase'>;
        'text-offset': DataDrivenProperty<[number, number]>;
        'text-allow-overlap': DataConstantProperty<boolean>;
        'text-overlap': DataConstantProperty<'never' | 'always' | 'cooperative'>;
        'text-ignore-placement': DataConstantProperty<boolean>;
        'text-optional': DataConstantProperty<boolean>;
    };
    export type SymbolLayoutPropsPossiblyEvaluated = {
        'symbol-placement': 'point' | 'line' | 'line-center';
        'symbol-spacing': number;
        'symbol-avoid-edges': boolean;
        'symbol-sort-key': PossiblyEvaluatedPropertyValue<number>;
        'symbol-z-order': 'auto' | 'viewport-y' | 'source';
        'icon-allow-overlap': boolean;
        'icon-overlap': 'never' | 'always' | 'cooperative';
        'icon-ignore-placement': boolean;
        'icon-optional': boolean;
        'icon-rotation-alignment': 'map' | 'viewport' | 'auto';
        'icon-size': PossiblyEvaluatedPropertyValue<number>;
        'icon-text-fit': 'none' | 'width' | 'height' | 'both';
        'icon-text-fit-padding': [number, number, number, number];
        'icon-image': PossiblyEvaluatedPropertyValue<ResolvedImage>;
        'icon-rotate': PossiblyEvaluatedPropertyValue<number>;
        'icon-padding': PossiblyEvaluatedPropertyValue<Padding>;
        'icon-keep-upright': boolean;
        'icon-offset': PossiblyEvaluatedPropertyValue<[number, number]>;
        'icon-anchor': PossiblyEvaluatedPropertyValue<'center' | 'left' | 'right' | 'top' | 'bottom' | 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right'>;
        'icon-pitch-alignment': 'map' | 'viewport' | 'auto';
        'text-pitch-alignment': 'map' | 'viewport' | 'auto';
        'text-rotation-alignment': 'map' | 'viewport' | 'viewport-glyph' | 'auto';
        'text-field': PossiblyEvaluatedPropertyValue<Formatted>;
        'text-font': PossiblyEvaluatedPropertyValue<Array<string>>;
        'text-size': PossiblyEvaluatedPropertyValue<number>;
        'text-max-width': PossiblyEvaluatedPropertyValue<number>;
        'text-line-height': number;
        'text-letter-spacing': PossiblyEvaluatedPropertyValue<number>;
        'text-justify': PossiblyEvaluatedPropertyValue<'auto' | 'left' | 'center' | 'right'>;
        'text-radial-offset': PossiblyEvaluatedPropertyValue<number>;
        'text-variable-anchor': Array<'center' | 'left' | 'right' | 'top' | 'bottom' | 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right'>;
        'text-variable-anchor-offset': PossiblyEvaluatedPropertyValue<VariableAnchorOffsetCollection>;
        'text-anchor': PossiblyEvaluatedPropertyValue<'center' | 'left' | 'right' | 'top' | 'bottom' | 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right'>;
        'text-max-angle': number;
        'text-writing-mode': Array<'horizontal' | 'vertical'>;
        'text-rotate': PossiblyEvaluatedPropertyValue<number>;
        'text-padding': number;
        'text-keep-upright': boolean;
        'text-transform': PossiblyEvaluatedPropertyValue<'none' | 'uppercase' | 'lowercase'>;
        'text-offset': PossiblyEvaluatedPropertyValue<[number, number]>;
        'text-allow-overlap': boolean;
        'text-overlap': 'never' | 'always' | 'cooperative';
        'text-ignore-placement': boolean;
        'text-optional': boolean;
    };
    export type SymbolPaintProps = {
        'icon-opacity': DataDrivenProperty<number>;
        'icon-color': DataDrivenProperty<Color>;
        'icon-halo-color': DataDrivenProperty<Color>;
        'icon-halo-width': DataDrivenProperty<number>;
        'icon-halo-blur': DataDrivenProperty<number>;
        'icon-translate': DataConstantProperty<[number, number]>;
        'icon-translate-anchor': DataConstantProperty<'map' | 'viewport'>;
        'text-opacity': DataDrivenProperty<number>;
        'text-color': DataDrivenProperty<Color>;
        'text-halo-color': DataDrivenProperty<Color>;
        'text-halo-width': DataDrivenProperty<number>;
        'text-halo-blur': DataDrivenProperty<number>;
        'text-translate': DataConstantProperty<[number, number]>;
        'text-translate-anchor': DataConstantProperty<'map' | 'viewport'>;
    };
    export type SymbolPaintPropsPossiblyEvaluated = {
        'icon-opacity': PossiblyEvaluatedPropertyValue<number>;
        'icon-color': PossiblyEvaluatedPropertyValue<Color>;
        'icon-halo-color': PossiblyEvaluatedPropertyValue<Color>;
        'icon-halo-width': PossiblyEvaluatedPropertyValue<number>;
        'icon-halo-blur': PossiblyEvaluatedPropertyValue<number>;
        'icon-translate': [number, number];
        'icon-translate-anchor': 'map' | 'viewport';
        'text-opacity': PossiblyEvaluatedPropertyValue<number>;
        'text-color': PossiblyEvaluatedPropertyValue<Color>;
        'text-halo-color': PossiblyEvaluatedPropertyValue<Color>;
        'text-halo-width': PossiblyEvaluatedPropertyValue<number>;
        'text-halo-blur': PossiblyEvaluatedPropertyValue<number>;
        'text-translate': [number, number];
        'text-translate-anchor': 'map' | 'viewport';
    };
    const _default: {
        readonly paint: Properties<SymbolPaintProps>;
        readonly layout: Properties<SymbolLayoutProps>;
    };
    export default _default;
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/overlap_mode' {
    import { SymbolLayoutPropsPossiblyEvaluated } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/symbol_style_layer_properties.g';
    import type { SymbolLayoutProps } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/symbol_style_layer_properties.g';
    import { PossiblyEvaluated } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/properties';
    /**
      * The overlap mode for properties like `icon-overlap`and `text-overlap`
      */
    export type OverlapMode = 'never' | 'always' | 'cooperative';
    export function getOverlapMode(layout: PossiblyEvaluated<SymbolLayoutProps, SymbolLayoutPropsPossiblyEvaluated>, overlapProp: 'icon-overlap', allowOverlapProp: 'icon-allow-overlap'): OverlapMode;
    export function getOverlapMode(layout: PossiblyEvaluated<SymbolLayoutProps, SymbolLayoutPropsPossiblyEvaluated>, overlapProp: 'text-overlap', allowOverlapProp: 'text-allow-overlap'): OverlapMode;
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/data/feature_index' {
    import Point from '@mapbox/point-geometry';
    import { TransferableGridIndex } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/transferable_grid_index';
    import { DictionaryCoder } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/dictionary_coder';
    import { GeoJSONFeature } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/vectortile_to_geojson';
    import { OverscaledTileID } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile_id';
    import { SourceFeatureState } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/source_state';
    import { FeatureIndexArray } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/array_types.g';
    import { mat4 } from 'gl-matrix';
    import type { StyleLayer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer';
    import type { FeatureFilter, FilterSpecification, PromoteIdSpecification } from '@maplibre/maplibre-gl-style-spec';
    import type { Transform } from '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/transform';
    import type { VectorTileFeature, VectorTileLayer } from '@mapbox/vector-tile';
    type QueryParameters = {
        scale: number;
        pixelPosMatrix: mat4;
        transform: Transform;
        tileSize: number;
        queryGeometry: Array<Point>;
        cameraQueryGeometry: Array<Point>;
        queryPadding: number;
        params: {
            filter: FilterSpecification;
            layers: Array<string>;
            availableImages: Array<string>;
        };
    };
    /**
      * An in memory index class to allow fast interaction with features
      */
    export class FeatureIndex {
        tileID: OverscaledTileID;
        x: number;
        y: number;
        z: number;
        grid: TransferableGridIndex;
        grid3D: TransferableGridIndex;
        featureIndexArray: FeatureIndexArray;
        promoteId?: PromoteIdSpecification;
        rawTileData: ArrayBuffer;
        bucketLayerIDs: Array<Array<string>>;
        vtLayers: {
            [_: string]: VectorTileLayer;
        };
        sourceLayerCoder: DictionaryCoder;
        constructor(tileID: OverscaledTileID, promoteId?: PromoteIdSpecification | null);
        insert(feature: VectorTileFeature, geometry: Array<Array<Point>>, featureIndex: number, sourceLayerIndex: number, bucketIndex: number, is3D?: boolean): void;
        loadVTLayers(): {
            [_: string]: VectorTileLayer;
        };
        query(args: QueryParameters, styleLayers: {
            [_: string]: StyleLayer;
        }, serializedLayers: {
            [_: string]: any;
        }, sourceFeatureState: SourceFeatureState): {
            [_: string]: Array<{
                featureIndex: number;
                feature: GeoJSONFeature;
            }>;
        };
        loadMatchingFeature(result: {
            [_: string]: Array<{
                featureIndex: number;
                feature: GeoJSONFeature;
                intersectionZ?: boolean | number;
            }>;
        }, bucketIndex: number, sourceLayerIndex: number, featureIndex: number, filter: FeatureFilter, filterLayerIDs: Array<string>, availableImages: Array<string>, styleLayers: {
            [_: string]: StyleLayer;
        }, serializedLayers: {
            [_: string]: any;
        }, sourceFeatureState?: SourceFeatureState, intersectionTest?: (feature: VectorTileFeature, styleLayer: StyleLayer, featureState: any, id: string | number | void) => boolean | number): void;
        lookupSymbolFeatures(symbolFeatureIndexes: Array<number>, serializedLayers: {
            [_: string]: StyleLayer;
        }, bucketIndex: number, sourceLayerIndex: number, filterSpec: FilterSpecification, filterLayerIDs: Array<string>, availableImages: Array<string>, styleLayers: {
            [_: string]: StyleLayer;
        }): {};
        hasLayer(id: string): boolean;
        getId(feature: VectorTileFeature, sourceLayerId: string): string | number;
    }
    export {};
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/variable_text_anchor' {
    import { VariableAnchorOffsetCollection } from '@maplibre/maplibre-gl-style-spec';
    import { SymbolFeature } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/bucket/symbol_bucket';
    import { CanonicalTileID } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile_id';
    import { SymbolStyleLayer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/symbol_style_layer';
    export enum TextAnchorEnum {
        'center' = 1,
        'left' = 2,
        'right' = 3,
        'top' = 4,
        'bottom' = 5,
        'top-left' = 6,
        'top-right' = 7,
        'bottom-left' = 8,
        'bottom-right' = 9
    }
    export type TextAnchor = keyof typeof TextAnchorEnum;
    export const INVALID_TEXT_OFFSET: number;
    export function evaluateVariableOffset(anchor: TextAnchor, offset: [number, number]): [number, number];
    export function getTextVariableAnchorOffset(layer: SymbolStyleLayer, feature: SymbolFeature, canonical: CanonicalTileID): VariableAnchorOffsetCollection | null;
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/source/worker_source' {
    import type { ExpiryData, RequestParameters } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/ajax';
    import type { RGBAImage, AlphaImage } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/image';
    import type { GlyphPositions } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/glyph_atlas';
    import type { ImageAtlas } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/image_atlas';
    import type { OverscaledTileID } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile_id';
    import type { Bucket } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/bucket';
    import type { FeatureIndex } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/feature_index';
    import type { CollisionBoxArray } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/array_types.g';
    import type { DEMEncoding } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/dem_data';
    import type { StyleGlyph } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_glyph';
    import type { StyleImage } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_image';
    import type { PromoteIdSpecification } from '@maplibre/maplibre-gl-style-spec';
    import type { RemoveSourceParams } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/actor_messages';
    import type { IActor } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/actor';
    import type { StyleLayerIndex } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer_index';
    /**
        * Parameters to identify a tile
        */
    export type TileParameters = {
            type: string;
            source: string;
            uid: string | number;
    };
    /**
        * Parameters that are send when requesting to load a tile to the worker
        */
    export type WorkerTileParameters = TileParameters & {
            tileID: OverscaledTileID;
            request?: RequestParameters;
            zoom: number;
            maxZoom?: number;
            tileSize: number;
            promoteId: PromoteIdSpecification;
            pixelRatio: number;
            showCollisionBoxes: boolean;
            collectResourceTiming?: boolean;
            returnDependencies?: boolean;
    };
    /**
        * The paremeters needed in order to load a DEM tile
        */
    export type WorkerDEMTileParameters = TileParameters & {
            rawImageData: RGBAImage | ImageBitmap | ImageData;
            encoding: DEMEncoding;
            redFactor: number;
            greenFactor: number;
            blueFactor: number;
            baseShift: number;
    };
    /**
        * The worker tile's result type
        */
    export type WorkerTileResult = ExpiryData & {
            buckets: Array<Bucket>;
            imageAtlas: ImageAtlas;
            glyphAtlasImage: AlphaImage;
            featureIndex: FeatureIndex;
            collisionBoxArray: CollisionBoxArray;
            rawTileData?: ArrayBuffer;
            resourceTiming?: Array<PerformanceResourceTiming>;
            glyphMap?: {
                    [_: string]: {
                            [_: number]: StyleGlyph;
                    };
            } | null;
            iconMap?: {
                    [_: string]: StyleImage;
            } | null;
            glyphPositions?: GlyphPositions | null;
    };
    /**
        * This is how the @see {@link WorkerSource} constructor should look like.
        */
    export interface WorkerSourceConstructor {
            new (actor: IActor, layerIndex: StyleLayerIndex, availableImages: Array<string>): WorkerSource;
    }
    /**
        * `WorkerSource` should be implemented by custom source types to provide code that can be run on the WebWorkers.
        * Each of the methods has a relevant event that triggers it from the main thread with the relevant parameters.
        * @see {@link Map#addSourceType}
        */
    export interface WorkerSource {
            availableImages: Array<string>;
            /**
                * Loads a tile from the given params and parse it into buckets ready to send
                * back to the main thread for rendering.  Should call the callback with:
                * `{ buckets, featureIndex, collisionIndex, rawTileData}`.
                */
            loadTile(params: WorkerTileParameters): Promise<WorkerTileResult>;
            /**
                * Re-parses a tile that has already been loaded.  Yields the same data as
                * {@link WorkerSource#loadTile}.
                */
            reloadTile(params: WorkerTileParameters): Promise<WorkerTileResult>;
            /**
                * Aborts loading a tile that is in progress.
                */
            abortTile(params: TileParameters): Promise<void>;
            /**
                * Removes this tile from any local caches.
                */
            removeTile(params: TileParameters): Promise<void>;
            /**
                * Tells the WorkerSource to abort in-progress tasks and release resources.
                * The foreground Source is responsible for ensuring that 'removeSource' is
                * the last message sent to the WorkerSource.
                */
            removeSource?: (params: RemoveSourceParams) => Promise<void>;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/source/rtl_text_plugin_status' {
    /**
        * The possible option of the plugin's status
        *
        * `unavailable`: Not loaded.
        *
        * `deferred`: The plugin URL has been specified, but loading has been deferred.
        *
        * `requested`: at least one tile needs RTL to render, but the plugin has not been set
        *
        * `loading`: RTL is in the process of being loaded by worker.
        *
        * `loaded`: The plugin is now loaded
        *
        *  `error`: The plugin failed to load
        */
    export type RTLPluginStatus = 'unavailable' | 'deferred' | 'requested' | 'loading' | 'loaded' | 'error';
    /**
        * The RTL plugin state
        */
    export type PluginState = {
            pluginStatus: RTLPluginStatus;
            pluginURL: string;
    };
    export const RTLPluginLoadedEventName = "RTLPluginLoaded";
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/framebuffer' {
    import { ColorAttachment, DepthAttachment } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/value';
    import type { Context } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/context';
    /**
      * @internal
      * A framebuffer holder object
      */
    export class Framebuffer {
        context: Context;
        width: number;
        height: number;
        framebuffer: WebGLFramebuffer;
        colorAttachment: ColorAttachment;
        depthAttachment: DepthAttachment;
        constructor(context: Context, width: number, height: number, hasDepth: boolean, hasStencil: boolean);
        destroy(): void;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/util/util' {
    import Point from '@mapbox/point-geometry';
    import type { WorkerGlobalScopeInterface } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/web_worker';
    /**
        * Given a value `t` that varies between 0 and 1, return
        * an interpolation function that eases between 0 and 1 in a pleasing
        * cubic in-out fashion.
        */
    export function easeCubicInOut(t: number): number;
    /**
        * Given given (x, y), (x1, y1) control points for a bezier curve,
        * return a function that interpolates along that curve.
        *
        * @param p1x - control point 1 x coordinate
        * @param p1y - control point 1 y coordinate
        * @param p2x - control point 2 x coordinate
        * @param p2y - control point 2 y coordinate
        */
    export function bezier(p1x: number, p1y: number, p2x: number, p2y: number): (t: number) => number;
    /**
        * A default bezier-curve powered easing function with
        * control points (0.25, 0.1) and (0.25, 1)
        */
    export const defaultEasing: (t: number) => number;
    /**
        * constrain n to the given range via min + max
        *
        * @param n - value
        * @param min - the minimum value to be returned
        * @param max - the maximum value to be returned
        * @returns the clamped value
        */
    export function clamp(n: number, min: number, max: number): number;
    /**
        * constrain n to the given range, excluding the minimum, via modular arithmetic
        *
        * @param n - value
        * @param min - the minimum value to be returned, exclusive
        * @param max - the maximum value to be returned, inclusive
        * @returns constrained number
        */
    export function wrap(n: number, min: number, max: number): number;
    /**
        * Compute the difference between the keys in one object and the keys
        * in another object.
        *
        * @returns keys difference
        */
    export function keysDifference<S, T>(obj: {
            [key: string]: S;
    }, other: {
            [key: string]: T;
    }): Array<string>;
    /**
        * Given a destination object and optionally many source objects,
        * copy all properties from the source objects into the destination.
        * The last source object given overrides properties from previous
        * source objects.
        *
        * @param dest - destination object
        * @param sources - sources from which properties are pulled
        */
    export function extend<T extends {}, U>(dest: T, source: U): T & U;
    export function extend<T extends {}, U, V>(dest: T, source1: U, source2: V): T & U & V;
    export function extend<T extends {}, U, V, W>(dest: T, source1: U, source2: V, source3: W): T & U & V & W;
    export function extend(dest: object, ...sources: Array<any>): any;
    type KeysOfUnion<T> = T extends T ? keyof T : never;
    /**
        * Given an object and a number of properties as strings, return version
        * of that object with only those properties.
        *
        * @param src - the object
        * @param properties - an array of property names chosen
        * to appear on the resulting object.
        * @returns object with limited properties.
        * @example
        * ```ts
        * let foo = { name: 'Charlie', age: 10 };
        * let justName = pick(foo, ['name']); // justName = { name: 'Charlie' }
        * ```
        */
    export function pick<T extends object>(src: T, properties: Array<KeysOfUnion<T>>): Partial<T>;
    /**
        * Return a unique numeric id, starting at 1 and incrementing with
        * each call.
        *
        * @returns unique numeric id.
        */
    export function uniqueId(): number;
    /**
        * Return whether a given value is a power of two
        */
    export function isPowerOfTwo(value: number): boolean;
    /**
        * Return the next power of two, or the input value if already a power of two
        */
    export function nextPowerOfTwo(value: number): number;
    /**
        * Create an object by mapping all the values of an existing object while
        * preserving their keys.
        */
    export function mapObject(input: any, iterator: Function, context?: any): any;
    /**
        * Create an object by filtering out values of an existing object.
        */
    export function filterObject(input: any, iterator: Function, context?: any): any;
    /**
        * Deeply compares two object literals.
        * @param a - first object literal to be compared
        * @param b - second object literal to be compared
        * @returns true if the two object literals are deeply equal, false otherwise
        */
    export function deepEqual(a?: unknown | null, b?: unknown | null): boolean;
    /**
        * Deeply clones two objects.
        */
    export function clone<T>(input: T): T;
    /**
        * Check if two arrays have at least one common element.
        */
    export function arraysIntersect<T>(a: Array<T>, b: Array<T>): boolean;
    export function warnOnce(message: string): void;
    /**
        * Indicates if the provided Points are in a counter clockwise (true) or clockwise (false) order
        *
        * @returns true for a counter clockwise set of points
        */
    export function isCounterClockwise(a: Point, b: Point, c: Point): boolean;
    /**
        * For two lines a and b in 2d space, defined by any two points along the lines,
        * find the intersection point, or return null if the lines are parallel
        *
        * @param a1 - First point on line a
        * @param a2 - Second point on line a
        * @param b1 - First point on line b
        * @param b2 - Second point on line b
        *
        * @returns the intersection point of the two lines or null if they are parallel
        */
    export function findLineIntersection(a1: Point, a2: Point, b1: Point, b2: Point): Point | null;
    /**
        * Returns the signed area for the polygon ring.  Positive areas are exterior rings and
        * have a clockwise winding.  Negative areas are interior rings and have a counter clockwise
        * ordering.
        *
        * @param ring - Exterior or interior ring
        */
    export function calculateSignedArea(ring: Array<Point>): number;
    /**
        * Detects closed polygons, first + last point are equal
        *
        * @param points - array of points
        * @returns `true` if the points are a closed polygon
        */
    export function isClosedPolygon(points: Array<Point>): boolean;
    /**
        * Converts spherical coordinates to cartesian coordinates.
        *
        * @param spherical - Spherical coordinates, in [radial, azimuthal, polar]
        * @returns cartesian coordinates in [x, y, z]
        */
    export function sphericalToCartesian([r, azimuthal, polar]: [number, number, number]): {
            x: number;
            y: number;
            z: number;
    };
    /**
        *  Returns true if the when run in the web-worker context.
        *
        * @returns `true` if the when run in the web-worker context.
        */
    export function isWorker(self: any): self is WorkerGlobalScopeInterface;
    /**
        * Parses data from 'Cache-Control' headers.
        *
        * @param cacheControl - Value of 'Cache-Control' header
        * @returns object containing parsed header info.
        */
    export function parseCacheControl(cacheControl: string): any;
    /**
        * Returns true when run in WebKit derived browsers.
        * This is used as a workaround for a memory leak in Safari caused by using Transferable objects to
        * transfer data between WebWorkers and the main thread.
        * https://github.com/mapbox/mapbox-gl-js/issues/8771
        *
        * This should be removed once the underlying Safari issue is fixed.
        *
        * @param scope - Since this function is used both on the main thread and WebWorker context,
        *      let the calling scope pass in the global scope object.
        * @returns `true` when run in WebKit derived browsers.
        */
    export function isSafari(scope: any): boolean;
    export function storageAvailable(type: string): boolean;
    export function b64EncodeUnicode(str: string): string;
    export function b64DecodeUnicode(str: string): string;
    export function isImageBitmap(image: any): image is ImageBitmap;
    /**
        * Converts an ArrayBuffer to an ImageBitmap.
        *
        * Used mostly for testing purposes only, because mocking libs don't know how to work with ArrayBuffers, but work
        * perfectly fine with ImageBitmaps. Might also be used for environments (other than testing) not supporting
        * ArrayBuffers.
        *
        * @param data - Data to convert
        * @returns - A  promise resolved when the conversion is finished
        */
    export const arrayBufferToImageBitmap: (data: ArrayBuffer) => Promise<ImageBitmap>;
    /**
        * Converts an ArrayBuffer to an HTMLImageElement.
        *
        * Used mostly for testing purposes only, because mocking libs don't know how to work with ArrayBuffers, but work
        * perfectly fine with ImageBitmaps. Might also be used for environments (other than testing) not supporting
        * ArrayBuffers.
        *
        * @param data - Data to convert
        * @returns - A promise resolved when the conversion is finished
        */
    export const arrayBufferToImage: (data: ArrayBuffer) => Promise<HTMLImageElement>;
    /**
        * Reads pixels from an ImageBitmap/Image/canvas using webcodec VideoFrame API.
        *
        * @param data - image, imagebitmap, or canvas to parse
        * @param x - top-left x coordinate to read from the image
        * @param y - top-left y coordinate to read from the image
        * @param width - width of the rectangle to read from the image
        * @param height - height of the rectangle to read from the image
        * @returns a promise containing the parsed RGBA pixel values of the image, or the error if an error occurred
        */
    export function readImageUsingVideoFrame(image: HTMLImageElement | HTMLCanvasElement | ImageBitmap | OffscreenCanvas, x: number, y: number, width: number, height: number): Promise<Uint8ClampedArray>;
    /**
        * Reads pixels from an ImageBitmap/Image/canvas using OffscreenCanvas
        *
        * @param data - image, imagebitmap, or canvas to parse
        * @param x - top-left x coordinate to read from the image
        * @param y - top-left y coordinate to read from the image
        * @param width - width of the rectangle to read from the image
        * @param height - height of the rectangle to read from the image
        * @returns a promise containing the parsed RGBA pixel values of the image, or the error if an error occurred
        */
    export function readImageDataUsingOffscreenCanvas(imgBitmap: HTMLImageElement | HTMLCanvasElement | ImageBitmap | OffscreenCanvas, x: number, y: number, width: number, height: number): Uint8ClampedArray;
    /**
        * Reads RGBA pixels from an preferring OffscreenCanvas, but falling back to VideoFrame if supported and
        * the browser is mangling OffscreenCanvas getImageData results.
        *
        * @param data - image, imagebitmap, or canvas to parse
        * @param x - top-left x coordinate to read from the image
        * @param y - top-left y coordinate to read from the image
        * @param width - width of the rectangle to read from the image
        * @param height - height of the rectangle to read from the image
        * @returns a promise containing the parsed RGBA pixel values of the image
        */
    export function getImageData(image: HTMLImageElement | HTMLCanvasElement | ImageBitmap | OffscreenCanvas, x: number, y: number, width: number, height: number): Promise<Uint8ClampedArray>;
    export interface Subscription {
            unsubscribe(): void;
    }
    export interface Subscriber {
            addEventListener: typeof window.addEventListener;
            removeEventListener: typeof window.removeEventListener;
    }
    /**
        * This method is used in order to register an event listener using a lambda function.
        * The return value will allow unsubscribing from the event, without the need to store the method reference.
        * @param target - The target
        * @param message - The message
        * @param listener - The listener
        * @param options - The options
        * @returns a subscription object that can be used to unsubscribe from the event
        */
    export function subscribe(target: Subscriber, message: keyof WindowEventMap, listener: (...args: any) => void, options: boolean | AddEventListenerOptions): Subscription;
    /**
        * This method converts degrees to radians.
        * The return value is the radian value.
        * @param degrees - The number of degrees
        * @returns radians
        */
    export function degreesToRadians(degrees: number): number;
    export {};
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/util/web_worker_transfer' {
    /**
        * A class that is serizlized to and json, that can be constructed back to the original class in the worker or in the main thread
        */
    type SerializedObject<S extends Serialized = any> = {
            [_: string]: S;
    };
    /**
        * All the possible values that can be serialized and sent to and from the worker
        */
    export type Serialized = null | void | boolean | number | string | Boolean | Number | String | Date | RegExp | ArrayBuffer | ArrayBufferView | ImageData | ImageBitmap | Blob | Array<Serialized> | SerializedObject;
    /**
        * Register options
        */
    type RegisterOptions<T> = {
            /**
                * List of properties to omit from serialization (e.g., cached/computed properties)
                */
            omit?: ReadonlyArray<keyof T>;
            /**
                * List of properties that should be serialized by a simple shallow copy, rather than by a recursive call to serialize().
                */
            shallow?: ReadonlyArray<keyof T>;
    };
    /**
        * Register the given class as serializable.
        *
        * @param options - the registration options
        */
    export function register<T extends any>(name: string, klass: {
            new (...args: any): T;
    }, options?: RegisterOptions<T>): void;
    /**
        * Serialize the given object for transfer to or from a web worker.
        *
        * For non-builtin types, recursively serialize each property (possibly
        * omitting certain properties - see register()), and package the result along
        * with the constructor's `name` so that the appropriate constructor can be
        * looked up in `deserialize()`.
        *
        * If a `transferables` array is provided, add any transferable objects (i.e.,
        * any ArrayBuffers or ArrayBuffer views) to the list. (If a copy is needed,
        * this should happen in the client code, before using serialize().)
        */
    export function serialize(input: unknown, transferables?: Array<Transferable> | null): Serialized;
    export function deserialize(input: Serialized): unknown;
    export {};
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/util/throttled_invoker' {
    /**
      * Invokes the wrapped function in a non-blocking way when trigger() is called.
      * Invocation requests are ignored until the function was actually invoked.
      */
    export class ThrottledInvoker {
        _channel: MessageChannel;
        _triggered: boolean;
        _methodToThrottle: Function;
        constructor(methodToThrottle: Function);
        trigger(): void;
        remove(): void;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/source/vector_tile_worker_source' {
    import { ExpiryData } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/ajax';
    import { WorkerTile } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/worker_tile';
    import type { WorkerSource, WorkerTileParameters, TileParameters, WorkerTileResult } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/worker_source';
    import type { IActor } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/actor';
    import type { StyleLayerIndex } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer_index';
    import type { VectorTile } from '@mapbox/vector-tile';
    export type LoadVectorTileResult = {
            vectorTile: VectorTile;
            rawData: ArrayBuffer;
            resourceTiming?: Array<PerformanceResourceTiming>;
    } & ExpiryData;
    type FetchingState = {
            rawTileData: ArrayBuffer;
            cacheControl: ExpiryData;
            resourceTiming: any;
    };
    export type AbortVectorData = () => void;
    export type LoadVectorData = (params: WorkerTileParameters, abortController: AbortController) => Promise<LoadVectorTileResult | null>;
    /**
        * The {@link WorkerSource} implementation that supports {@link VectorTileSource}.
        * This class is designed to be easily reused to support custom source types
        * for data formats that can be parsed/converted into an in-memory VectorTile
        * representation. To do so, override its `loadVectorTile` method.
        */
    export class VectorTileWorkerSource implements WorkerSource {
            actor: IActor;
            layerIndex: StyleLayerIndex;
            availableImages: Array<string>;
            fetching: {
                    [_: string]: FetchingState;
            };
            loading: {
                    [_: string]: WorkerTile;
            };
            loaded: {
                    [_: string]: WorkerTile;
            };
            /**
                * @param loadVectorData - Optional method for custom loading of a VectorTile
                * object based on parameters passed from the main-thread Source. See
                * {@link VectorTileWorkerSource#loadTile}. The default implementation simply
                * loads the pbf at `params.url`.
                */
            constructor(actor: IActor, layerIndex: StyleLayerIndex, availableImages: Array<string>);
            /**
                * Loads a vector tile
                */
            loadVectorTile(params: WorkerTileParameters, abortController: AbortController): Promise<LoadVectorTileResult>;
            /**
                * Implements {@link WorkerSource#loadTile}. Delegates to
                * {@link VectorTileWorkerSource#loadVectorData} (which by default expects
                * a `params.url` property) for fetching and producing a VectorTile object.
                */
            loadTile(params: WorkerTileParameters): Promise<WorkerTileResult | null>;
            /**
                * Implements {@link WorkerSource#reloadTile}.
                */
            reloadTile(params: WorkerTileParameters): Promise<WorkerTileResult>;
            /**
                * Implements {@link WorkerSource#abortTile}.
                */
            abortTile(params: TileParameters): Promise<void>;
            /**
                * Implements {@link WorkerSource#removeTile}.
                */
            removeTile(params: TileParameters): Promise<void>;
    }
    export {};
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/util/struct_array' {
    /**
        * @internal
        * A view type size
        */
    const viewTypes: {
            Int8: Int8ArrayConstructor;
            Uint8: Uint8ArrayConstructor;
            Int16: Int16ArrayConstructor;
            Uint16: Uint16ArrayConstructor;
            Int32: Int32ArrayConstructor;
            Uint32: Uint32ArrayConstructor;
            Float32: Float32ArrayConstructor;
    };
    /**
        * @internal
        * A view type size
        */
    export type ViewType = keyof typeof viewTypes;
    /** @internal */
    class Struct {
            _pos1: number;
            _pos2: number;
            _pos4: number;
            _pos8: number;
            readonly _structArray: StructArray;
            size: number;
            /**
                * @param structArray - The StructArray the struct is stored in
                * @param index - The index of the struct in the StructArray.
                */
            constructor(structArray: StructArray, index: number);
    }
    /**
        * @internal
        * A struct array memeber
        */
    export type StructArrayMember = {
            name: string;
            type: ViewType;
            components: number;
            offset: number;
    };
    export type StructArrayLayout = {
            members: Array<StructArrayMember>;
            size: number;
            alignment: number;
    };
    /**
        * An array that can be desialized
        */
    export type SerializedStructArray = {
            length: number;
            arrayBuffer: ArrayBuffer;
    };
    /**
        * @internal
        * `StructArray` provides an abstraction over `ArrayBuffer` and `TypedArray`
        * making it behave like an array of typed structs.
        *
        * Conceptually, a StructArray is comprised of elements, i.e., instances of its
        * associated struct type. Each particular struct type, together with an
        * alignment size, determines the memory layout of a StructArray whose elements
        * are of that type.  Thus, for each such layout that we need, we have
        * a corresponding StructArrayLayout class, inheriting from StructArray and
        * implementing `emplaceBack()` and `_refreshViews()`.
        *
        * In some cases, where we need to access particular elements of a StructArray,
        * we implement a more specific subclass that inherits from one of the
        * StructArrayLayouts and adds a `get(i): T` accessor that returns a structured
        * object whose properties are proxies into the underlying memory space for the
        * i-th element.  This affords the convience of working with (seemingly) plain
        * Javascript objects without the overhead of serializing/deserializing them
        * into ArrayBuffers for efficient web worker transfer.
        */
    abstract class StructArray {
            capacity: number;
            length: number;
            isTransferred: boolean;
            arrayBuffer: ArrayBuffer;
            uint8: Uint8Array;
            members: Array<StructArrayMember>;
            bytesPerElement: number;
            abstract emplaceBack(...v: number[]): any;
            abstract emplace(i: number, ...v: number[]): any;
            constructor();
            /**
                * Serialize a StructArray instance.  Serializes both the raw data and the
                * metadata needed to reconstruct the StructArray base class during
                * deserialization.
                */
            static serialize(array: StructArray, transferables?: Array<Transferable>): SerializedStructArray;
            static deserialize(input: SerializedStructArray): any;
            /**
                * Resize the array to discard unused capacity.
                */
            _trim(): void;
            /**
                * Resets the length of the array to 0 without de-allocating capcacity.
                */
            clear(): void;
            /**
                * Resize the array.
                * If `n` is greater than the current length then additional elements with undefined values are added.
                * If `n` is less than the current length then the array will be reduced to the first `n` elements.
                * @param n - The new size of the array.
                */
            resize(n: number): void;
            /**
                * Indicate a planned increase in size, so that any necessary allocation may
                * be done once, ahead of time.
                * @param n - The expected size of the array.
                */
            reserve(n: number): void;
            /**
                * Create TypedArray views for the current ArrayBuffer.
                */
            _refreshViews(): void;
    }
    /**
        * Given a list of member fields, create a full StructArrayLayout, in
        * particular calculating the correct byte offset for each field.  This data
        * is used at build time to generate StructArrayLayout_*#emplaceBack() and
        * other accessors, and at runtime for binding vertex buffer attributes.
        */
    function createLayout(members: Array<{
            name: string;
            type: ViewType;
            readonly components?: number;
    }>, alignment?: number): StructArrayLayout;
    export { StructArray, Struct, viewTypes, createLayout };
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/render/vertex_array_object' {
    import type { Program } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/program';
    import type { VertexBuffer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/vertex_buffer';
    import type { IndexBuffer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/index_buffer';
    import type { Context } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/context';
    /**
      * @internal
      * A vertex array object used to pass data to the webgl code
      */
    export class VertexArrayObject {
        context: Context;
        boundProgram: Program<any>;
        boundLayoutVertexBuffer: VertexBuffer;
        boundPaintVertexBuffers: Array<VertexBuffer>;
        boundIndexBuffer: IndexBuffer;
        boundVertexOffset: number;
        boundDynamicVertexBuffer: VertexBuffer;
        boundDynamicVertexBuffer2: VertexBuffer;
        boundDynamicVertexBuffer3: VertexBuffer;
        vao: any;
        constructor();
        bind(context: Context, program: Program<any>, layoutVertexBuffer: VertexBuffer, paintVertexBuffers: Array<VertexBuffer>, indexBuffer?: IndexBuffer | null, vertexOffset?: number | null, dynamicVertexBuffer?: VertexBuffer | null, dynamicVertexBuffer2?: VertexBuffer | null, dynamicVertexBuffer3?: VertexBuffer | null): void;
        freshBind(program: Program<any>, layoutVertexBuffer: VertexBuffer, paintVertexBuffers: Array<VertexBuffer>, indexBuffer?: IndexBuffer | null, vertexOffset?: number | null, dynamicVertexBuffer?: VertexBuffer | null, dynamicVertexBuffer2?: VertexBuffer | null, dynamicVertexBuffer3?: VertexBuffer | null): void;
        destroy(): void;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/tap_recognizer' {
    import Point from '@mapbox/point-geometry';
    export const MAX_TAP_INTERVAL = 500;
    export const MAX_DIST = 30;
    export class SingleTapRecognizer {
        numTouches: number;
        centroid: Point;
        startTime: number;
        aborted: boolean;
        touches: {
            [k in number | string]: Point;
        };
        constructor(options: {
            numTouches: number;
        });
        reset(): void;
        touchstart(e: TouchEvent, points: Array<Point>, mapTouches: Array<Touch>): void;
        touchmove(e: TouchEvent, points: Array<Point>, mapTouches: Array<Touch>): void;
        touchend(e: TouchEvent, points: Array<Point>, mapTouches: Array<Touch>): Point;
    }
    export class TapRecognizer {
        singleTap: SingleTapRecognizer;
        numTaps: number;
        lastTime: number;
        lastTap: Point;
        count: number;
        constructor(options: {
            numTaps: number;
            numTouches: number;
        });
        reset(): void;
        touchstart(e: TouchEvent, points: Array<Point>, mapTouches: Array<Touch>): void;
        touchmove(e: TouchEvent, points: Array<Point>, mapTouches: Array<Touch>): void;
        touchend(e: TouchEvent, points: Array<Point>, mapTouches: Array<Touch>): Point;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/source/terrain_source_cache' {
    import { OverscaledTileID } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile_id';
    import { Tile } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile';
    import { Evented } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/evented';
    import type { Transform } from '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/transform';
    import type { SourceCache } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/source_cache';
    import { Terrain } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/terrain';
    /**
        * @internal
        * This class is a helper for the Terrain-class, it:
        *   - loads raster-dem tiles
        *   - manages all renderToTexture tiles.
        *   - caches previous rendered tiles.
        *   - finds all necessary renderToTexture tiles for a OverscaledTileID area
        *   - finds the corresponding raster-dem tile for OverscaledTileID
        */
    export class TerrainSourceCache extends Evented {
            /**
                * source-cache for the raster-dem source.
                */
            sourceCache: SourceCache;
            /**
                * stores all render-to-texture tiles.
                */
            _tiles: {
                    [_: string]: Tile;
            };
            /**
                * contains a list of tileID-keys for the current scene. (only for performance)
                */
            _renderableTilesKeys: Array<string>;
            /**
                * raster-dem-tile for a TileID cache.
                */
            _sourceTileCache: {
                    [_: string]: string;
            };
            /**
                * minimum zoomlevel to render the terrain.
                */
            minzoom: number;
            /**
                * maximum zoomlevel to render the terrain.
                */
            maxzoom: number;
            /**
                * render-to-texture tileSize in scene.
                */
            tileSize: number;
            /**
                * raster-dem tiles will load for performance the actualZoom - deltaZoom zoom-level.
                */
            deltaZoom: number;
            constructor(sourceCache: SourceCache);
            destruct(): void;
            /**
                * Load Terrain Tiles, create internal render-to-texture tiles, free GPU memory.
                * @param transform - the operation to do
                * @param terrain - the terrain
                */
            update(transform: Transform, terrain: Terrain): void;
            /**
                * Free render to texture cache
                * @param tileID - optional, free only corresponding to tileID.
                */
            freeRtt(tileID?: OverscaledTileID): void;
            /**
                * get a list of tiles, which are loaded and should be rendered in the current scene
                * @returns the renderable tiles
                */
            getRenderableTiles(): Array<Tile>;
            /**
                * get terrain tile by the TileID key
                * @param id - the tile id
                * @returns the tile
                */
            getTileByID(id: string): Tile;
            /**
                * Searches for the corresponding current renderable terrain-tiles
                * @param tileID - the tile to look for
                * @returns the tiles that were found
                */
            getTerrainCoords(tileID: OverscaledTileID): Record<string, OverscaledTileID>;
            /**
                * find the covering raster-dem tile
                * @param tileID - the tile to look for
                * @param searchForDEM - Optinal parameter to search for (parent) souretiles with loaded dem.
                * @returns the tile
                */
            getSourceTile(tileID: OverscaledTileID, searchForDEM?: boolean): Tile;
            /**
                * get a list of tiles, loaded after a specific time. This is used to update depth & coords framebuffers.
                * @param time - the time
                * @returns the relevant tiles
                */
            tilesAfterTime(time?: number): Array<Tile>;
    }
}

declare module '@mappedin/mappedin-js/packages/geojson-navigator/src/navigation-graph/navigation-graph' {
    import { Edge } from '@mappedin/mappedin-js/packages/geojson-navigator/src/edge';
    import type { NodeCollection, NodeFeature } from '@mappedin/mappedin-js/packages/geojson-navigator/src/types/node';
    import type { DirectionsZone } from '@mappedin/mappedin-js/packages/geojson-navigator/src/navigator';
    /**
        * Represents a navigation graph for pathfinding operations, holding nodes and edges with utilities to perform routing.
        * @see {@link https://mappedin.atlassian.net/wiki/spaces/SDK/pages/234487854/A+Search+Algorithm+in+Navigation+Graph}
        * @hidden
        */
    export class NavigationGraph {
            #private;
            readonly edges: {
                    [propName: string]: Edge[];
            };
            readonly nodesById: {
                    [propName: string]: NodeFeature;
            };
            readonly nodesByGroup: Map<string, NodeFeature[]>;
            constructor({ nodes, groupBy, multiplicativeDistanceWeightScaling, }: {
                    nodes: NodeCollection;
                    groupBy: string;
                    multiplicativeDistanceWeightScaling?: boolean;
            });
            /**
                * Calculates the shortest Euclidean distance from the origin node to any of the destination nodes.
                *
                * @param {NodeFeature} origin - The origin node.
                * @param {NodeFeature[]} destinations - An array of destination nodes.
                * @returns {number} The shortest Euclidean distance.
                */
            getShortestEuclideanDistance(origin: NodeFeature, destinations: NodeFeature[]): number;
            /**
                * Performs A* pathfinding from specified origins to destinations, considering optional constraints like accessibility.
                *
                * @param {string[]} originIds - Array of origin node IDs.
                * @param {string[]} destinationNodeIds - Array of destination node IDs.
                * @param {Set<string>} [excludedNodeIds] - Optional set of node IDs to exclude from pathfinding.
                * @param {Set<string>} [disabledConnectionNodeIds] - Optional set of connection node IDs that are disabled (ie. act as regular nodes).
                * @returns {Edge[]} An array of edges representing the shortest path, or an empty array if no path is found.
                */
            aStar({ originIds, destinationNodeIds, excludedNodeIds, disabledConnectionNodeIds, zones, }: {
                    originIds: string[];
                    destinationNodeIds: string[];
                    zones: DirectionsZone[];
                    excludedNodeIds?: Set<string>;
                    disabledConnectionNodeIds?: Set<string>;
            }): Edge[];
    }
}

declare module '@mappedin/mappedin-js/packages/geojson-navigator/src/edge/edge' {
    import type { NodeFeature } from '@mappedin/mappedin-js/packages/geojson-navigator/src/types/node';
    /**
        * Represents an edge in a graph, containing data about its endpoints and metrics like distance and angle.
        * @hidden
        */
    export class Edge {
            /** The originating node of the edge */
            origin: NodeFeature;
            /** The destination node of the edge */
            destination: NodeFeature;
            /** The distance between the origin and the destination nodes */
            distance: number;
            /** The angle of the edge with respect to some reference, in degrees */
            angle: number;
            /** A composite weight of the edge, combining distance and a custom path weight */
            weight: number;
            /**
                * Constructs a new Edge instance.
                * @param {NodeFeature} origin - The originating node of the edge.
                * @param {NodeFeature} destination - The destination node of the edge.
                * @param {number} [distance=0] - The physical distance between the origin and destination.
                * @param {number} [angle=0] - The angle of the edge in degrees.
                * @param {number} [pathWeight=0] - An additional weight factor for the path.
                */
            constructor({ origin, destination, distance, angle, pathWeight, multiplicativeDistanceWeightScaling, }: {
                    origin: NodeFeature;
                    destination: NodeFeature;
                    distance?: number;
                    angle?: number;
                    pathWeight?: number;
                    multiplicativeDistanceWeightScaling?: boolean;
            });
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/data/feature_position_map' {
    type SerializedFeaturePositionMap = {
        ids: Float64Array;
        positions: Uint32Array;
    };
    type FeaturePosition = {
        index: number;
        start: number;
        end: number;
    };
    export class FeaturePositionMap {
        ids: Array<number>;
        positions: Array<number>;
        indexed: boolean;
        constructor();
        add(id: unknown, index: number, start: number, end: number): void;
        getPositions(id: unknown): Array<FeaturePosition>;
        static serialize(map: FeaturePositionMap, transferables: Array<ArrayBuffer>): SerializedFeaturePositionMap;
        static deserialize(obj: SerializedFeaturePositionMap): FeaturePositionMap;
    }
    export {};
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/render/uniform_binding' {
    import { Color } from '@maplibre/maplibre-gl-style-spec';
    import type { Context } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/context';
    import { mat4, vec2, vec3, vec4 } from 'gl-matrix';
    type $ObjMap<T extends {}, F extends (v: any) => any> = {
            [K in keyof T]: F extends (v: T[K]) => infer R ? R : never;
    };
    export type UniformValues<Us extends {}> = $ObjMap<Us, <V>(u: Uniform<V>) => V>;
    export type UniformLocations = {
            [_: string]: WebGLUniformLocation;
    };
    /**
        * @internal
        * A base uniform abstract class
        */
    abstract class Uniform<T> {
            gl: WebGLRenderingContext | WebGL2RenderingContext;
            location: WebGLUniformLocation;
            current: T;
            constructor(context: Context, location: WebGLUniformLocation);
            abstract set(v: T): void;
    }
    class Uniform1i extends Uniform<number> {
            constructor(context: Context, location: WebGLUniformLocation);
            set(v: number): void;
    }
    class Uniform1f extends Uniform<number> {
            constructor(context: Context, location: WebGLUniformLocation);
            set(v: number): void;
    }
    class Uniform2f extends Uniform<vec2> {
            constructor(context: Context, location: WebGLUniformLocation);
            set(v: vec2): void;
    }
    class Uniform3f extends Uniform<vec3> {
            constructor(context: Context, location: WebGLUniformLocation);
            set(v: vec3): void;
    }
    class Uniform4f extends Uniform<vec4> {
            constructor(context: Context, location: WebGLUniformLocation);
            set(v: vec4): void;
    }
    class UniformColor extends Uniform<Color> {
            constructor(context: Context, location: WebGLUniformLocation);
            set(v: Color): void;
    }
    class UniformMatrix4f extends Uniform<mat4> {
            constructor(context: Context, location: WebGLUniformLocation);
            set(v: mat4): void;
    }
    export { Uniform, Uniform1i, Uniform1f, Uniform2f, Uniform3f, Uniform4f, UniformColor, UniformMatrix4f };
    /**
        * @internal
        * A uniform bindings
        */
    export type UniformBindings = {
            [_: string]: Uniform<any>;
    };
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/typed_style_layer' {
    import type { CircleStyleLayer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/circle_style_layer';
    import type { FillStyleLayer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/fill_style_layer';
    import type { FillExtrusionStyleLayer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/fill_extrusion_style_layer';
    import type { HeatmapStyleLayer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/heatmap_style_layer';
    import type { HillshadeStyleLayer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/hillshade_style_layer';
    import type { LineStyleLayer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/line_style_layer';
    import type { SymbolStyleLayer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/symbol_style_layer';
    export type TypedStyleLayer = CircleStyleLayer | FillStyleLayer | FillExtrusionStyleLayer | HeatmapStyleLayer | HillshadeStyleLayer | LineStyleLayer | SymbolStyleLayer;
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/cull_face_mode' {
    import type { CullFaceModeType, FrontFaceType } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/types';
    export class CullFaceMode {
        enable: boolean;
        mode: CullFaceModeType;
        frontFace: FrontFaceType;
        constructor(enable: boolean, mode: CullFaceModeType, frontFace: FrontFaceType);
        static disabled: Readonly<CullFaceMode>;
        static backCCW: Readonly<CullFaceMode>;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/render/program/terrain_program' {
    import { Uniform1i, Uniform1f, Uniform4f, UniformMatrix4f } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/uniform_binding';
    import type { Context } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/context';
    import type { UniformValues, UniformLocations } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/uniform_binding';
    import { mat4 } from 'gl-matrix';
    export type TerrainPreludeUniformsType = {
        u_depth: Uniform1i;
        u_terrain: Uniform1i;
        u_terrain_dim: Uniform1f;
        u_terrain_matrix: UniformMatrix4f;
        u_terrain_unpack: Uniform4f;
        u_terrain_exaggeration: Uniform1f;
    };
    export type TerrainUniformsType = {
        u_matrix: UniformMatrix4f;
        u_texture: Uniform1i;
        u_ele_delta: Uniform1f;
    };
    export type TerrainDepthUniformsType = {
        u_matrix: UniformMatrix4f;
        u_ele_delta: Uniform1f;
    };
    export type TerrainCoordsUniformsType = {
        u_matrix: UniformMatrix4f;
        u_texture: Uniform1i;
        u_terrain_coords_id: Uniform1f;
        u_ele_delta: Uniform1f;
    };
    const terrainPreludeUniforms: (context: Context, locations: UniformLocations) => TerrainPreludeUniformsType;
    const terrainUniforms: (context: Context, locations: UniformLocations) => TerrainUniformsType;
    const terrainDepthUniforms: (context: Context, locations: UniformLocations) => TerrainDepthUniformsType;
    const terrainCoordsUniforms: (context: Context, locations: UniformLocations) => TerrainCoordsUniformsType;
    const terrainUniformValues: (matrix: mat4, eleDelta: number) => UniformValues<TerrainUniformsType>;
    const terrainDepthUniformValues: (matrix: mat4, eleDelta: number) => UniformValues<TerrainDepthUniformsType>;
    const terrainCoordsUniformValues: (matrix: mat4, coordsId: number, eleDelta: number) => UniformValues<TerrainCoordsUniformsType>;
    export { terrainUniforms, terrainDepthUniforms, terrainCoordsUniforms, terrainPreludeUniforms, terrainUniformValues, terrainDepthUniformValues, terrainCoordsUniformValues, };
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/value' {
    import { Color } from '@maplibre/maplibre-gl-style-spec';
    import type { Context } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/context';
    import type { BlendFuncType, BlendEquationType, ColorMaskType, DepthRangeType, DepthMaskType, StencilFuncType, StencilOpType, DepthFuncType, TextureUnitType, ViewportType, CullFaceModeType, FrontFaceType } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/types';
    export interface IValue<T> {
        current: T;
        default: T;
        dirty: boolean;
        get(): T;
        setDefault(): void;
        set(value: T): void;
    }
    class BaseValue<T> implements IValue<T> {
        gl: WebGLRenderingContext | WebGL2RenderingContext;
        current: T;
        default: T;
        dirty: boolean;
        constructor(context: Context);
        get(): T;
        set(value: T): void;
        getDefault(): T;
        setDefault(): void;
    }
    export class ClearColor extends BaseValue<Color> {
        getDefault(): Color;
        set(v: Color): void;
    }
    export class ClearDepth extends BaseValue<number> {
        getDefault(): number;
        set(v: number): void;
    }
    export class ClearStencil extends BaseValue<number> {
        getDefault(): number;
        set(v: number): void;
    }
    export class ColorMask extends BaseValue<ColorMaskType> {
        getDefault(): ColorMaskType;
        set(v: ColorMaskType): void;
    }
    export class DepthMask extends BaseValue<DepthMaskType> {
        getDefault(): DepthMaskType;
        set(v: DepthMaskType): void;
    }
    export class StencilMask extends BaseValue<number> {
        getDefault(): number;
        set(v: number): void;
    }
    export class StencilFunc extends BaseValue<StencilFuncType> {
        getDefault(): StencilFuncType;
        set(v: StencilFuncType): void;
    }
    export class StencilOp extends BaseValue<StencilOpType> {
        getDefault(): StencilOpType;
        set(v: StencilOpType): void;
    }
    export class StencilTest extends BaseValue<boolean> {
        getDefault(): boolean;
        set(v: boolean): void;
    }
    export class DepthRange extends BaseValue<DepthRangeType> {
        getDefault(): DepthRangeType;
        set(v: DepthRangeType): void;
    }
    export class DepthTest extends BaseValue<boolean> {
        getDefault(): boolean;
        set(v: boolean): void;
    }
    export class DepthFunc extends BaseValue<DepthFuncType> {
        getDefault(): DepthFuncType;
        set(v: DepthFuncType): void;
    }
    export class Blend extends BaseValue<boolean> {
        getDefault(): boolean;
        set(v: boolean): void;
    }
    export class BlendFunc extends BaseValue<BlendFuncType> {
        getDefault(): BlendFuncType;
        set(v: BlendFuncType): void;
    }
    export class BlendColor extends BaseValue<Color> {
        getDefault(): Color;
        set(v: Color): void;
    }
    export class BlendEquation extends BaseValue<BlendEquationType> {
        getDefault(): BlendEquationType;
        set(v: BlendEquationType): void;
    }
    export class CullFace extends BaseValue<boolean> {
        getDefault(): boolean;
        set(v: boolean): void;
    }
    export class CullFaceSide extends BaseValue<CullFaceModeType> {
        getDefault(): CullFaceModeType;
        set(v: CullFaceModeType): void;
    }
    export class FrontFace extends BaseValue<FrontFaceType> {
        getDefault(): FrontFaceType;
        set(v: FrontFaceType): void;
    }
    export class ProgramValue extends BaseValue<WebGLProgram> {
        getDefault(): WebGLProgram;
        set(v?: WebGLProgram | null): void;
    }
    export class ActiveTextureUnit extends BaseValue<TextureUnitType> {
        getDefault(): TextureUnitType;
        set(v: TextureUnitType): void;
    }
    export class Viewport extends BaseValue<ViewportType> {
        getDefault(): ViewportType;
        set(v: ViewportType): void;
    }
    export class BindFramebuffer extends BaseValue<WebGLFramebuffer> {
        getDefault(): WebGLFramebuffer;
        set(v?: WebGLFramebuffer | null): void;
    }
    export class BindRenderbuffer extends BaseValue<WebGLRenderbuffer> {
        getDefault(): WebGLRenderbuffer;
        set(v?: WebGLRenderbuffer | null): void;
    }
    export class BindTexture extends BaseValue<WebGLTexture> {
        getDefault(): WebGLTexture;
        set(v?: WebGLTexture | null): void;
    }
    export class BindVertexBuffer extends BaseValue<WebGLBuffer> {
        getDefault(): WebGLBuffer;
        set(v?: WebGLBuffer | null): void;
    }
    export class BindElementBuffer extends BaseValue<WebGLBuffer> {
        getDefault(): WebGLBuffer;
        set(v?: WebGLBuffer | null): void;
    }
    export class BindVertexArray extends BaseValue<WebGLVertexArrayObject | null> {
        getDefault(): WebGLVertexArrayObject | null;
        set(v: WebGLVertexArrayObject | null): void;
    }
    export class PixelStoreUnpack extends BaseValue<number> {
        getDefault(): number;
        set(v: number): void;
    }
    export class PixelStoreUnpackPremultiplyAlpha extends BaseValue<boolean> {
        getDefault(): boolean;
        set(v: boolean): void;
    }
    export class PixelStoreUnpackFlipY extends BaseValue<boolean> {
        getDefault(): boolean;
        set(v: boolean): void;
    }
    class FramebufferAttachment<T> extends BaseValue<T> {
        parent: WebGLFramebuffer;
        context: Context;
        constructor(context: Context, parent: WebGLFramebuffer);
        getDefault(): any;
    }
    export class ColorAttachment extends FramebufferAttachment<WebGLTexture> {
        setDirty(): void;
        set(v?: WebGLTexture | null): void;
    }
    export class DepthAttachment extends FramebufferAttachment<WebGLRenderbuffer> {
        set(v?: WebGLRenderbuffer | null): void;
    }
    export class DepthStencilAttachment extends FramebufferAttachment<WebGLRenderbuffer> {
        set(v?: WebGLRenderbuffer | null): void;
    }
    export {};
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/data/index_array_type' {
    import { LineIndexArray, TriangleIndexArray, LineStripIndexArray } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/array_types.g';
    /**
      * An index array stores Uint16 indices of vertexes in a corresponding vertex array. We use
      * three kinds of index arrays: arrays storing groups of three indices, forming triangles;
      * arrays storing pairs of indices, forming line segments; and arrays storing single indices,
      * forming a line strip.
      */
    export { LineIndexArray, TriangleIndexArray, LineStripIndexArray };
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/render_pool' {
    import { Texture } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/texture';
    import { Context } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/context';
    import { Framebuffer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/framebuffer';
    export type PoolObject = {
            id: number;
            fbo: Framebuffer;
            texture: Texture;
            stamp: number;
            inUse: boolean;
    };
    /**
        * @internal
        * `RenderPool` is a resource pool for textures and framebuffers
        */
    export class RenderPool {
            constructor(_context: Context, _size: number, _tileSize: number);
            destruct(): void;
            getObjectForId(id: number): PoolObject;
            useObject(obj: PoolObject): void;
            stampObject(obj: PoolObject): void;
            getOrCreateFreeObject(): PoolObject;
            freeObject(obj: PoolObject): void;
            freeAllObjects(): void;
            isFull(): boolean;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/symbol/grid_index' {
    import type { OverlapMode } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/overlap_mode';
    type QueryResult<T> = {
            key: T;
            x1: number;
            y1: number;
            x2: number;
            y2: number;
    };
    /**
        * A key for the grid
        */
    export type GridKey = {
            overlapMode?: OverlapMode;
    };
    /**
        * @internal
        * GridIndex is a data structure for testing the intersection of
        * circles and rectangles in a 2d plane.
        * It is optimized for rapid insertion and querying.
        * GridIndex splits the plane into a set of "cells" and keeps track
        * of which geometries intersect with each cell. At query time,
        * full geometry comparisons are only done for items that share
        * at least one cell. As long as the geometries are relatively
        * uniformly distributed across the plane, this greatly reduces
        * the number of comparisons necessary.
        */
    export class GridIndex<T extends GridKey> {
            circleKeys: Array<T>;
            boxKeys: Array<T>;
            boxCells: Array<Array<number>>;
            circleCells: Array<Array<number>>;
            bboxes: Array<number>;
            circles: Array<number>;
            xCellCount: number;
            yCellCount: number;
            width: number;
            height: number;
            xScale: number;
            yScale: number;
            boxUid: number;
            circleUid: number;
            constructor(width: number, height: number, cellSize: number);
            keysLength(): number;
            insert(key: T, x1: number, y1: number, x2: number, y2: number): void;
            insertCircle(key: T, x: number, y: number, radius: number): void;
            query(x1: number, y1: number, x2: number, y2: number): Array<QueryResult<T>>;
            hitTest(x1: number, y1: number, x2: number, y2: number, overlapMode: OverlapMode, predicate?: (key: T) => boolean): boolean;
            hitTestCircle(x: number, y: number, radius: number, overlapMode: OverlapMode, predicate?: (key: T) => boolean): boolean;
    }
    export {};
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/ui/handler/drag_move_state_manager' {
    export interface DragMoveStateManager<E extends Event> {
        startMove: (e: E) => void;
        endMove: (e?: E) => void;
        isValidStartEvent: (e: E) => boolean;
        isValidMoveEvent: (e: E) => boolean;
        isValidEndEvent: (e?: E) => boolean;
    }
    export class MouseMoveStateManager implements DragMoveStateManager<MouseEvent> {
        _eventButton: number | undefined;
        _correctEvent: (e: MouseEvent) => boolean;
        constructor(options: {
            checkCorrectEvent: (e: MouseEvent) => boolean;
        });
        startMove(e: MouseEvent): void;
        endMove(_e?: MouseEvent): void;
        isValidStartEvent(e: MouseEvent): boolean;
        isValidMoveEvent(e: MouseEvent): boolean;
        isValidEndEvent(e: MouseEvent): boolean;
    }
    export class OneFingerTouchMoveStateManager implements DragMoveStateManager<TouchEvent> {
        _firstTouch: number | undefined;
        constructor();
        _isOneFingerTouch(e: TouchEvent): boolean;
        _isSameTouchEvent(e: TouchEvent): boolean;
        startMove(e: TouchEvent): void;
        endMove(_e?: TouchEvent): void;
        isValidStartEvent(e: TouchEvent): boolean;
        isValidMoveEvent(e: TouchEvent): boolean;
        isValidEndEvent(e: TouchEvent): boolean;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/render/glyph_atlas' {
    import { AlphaImage } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/image';
    import type { GlyphMetrics } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_glyph';
    import type { GetGlyphsResponse } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/actor_messages';
    /**
        * A rectangle type with postion, width and height.
        */
    export type Rect = {
            x: number;
            y: number;
            w: number;
            h: number;
    };
    /**
        * The glyph's position
        */
    export type GlyphPosition = {
            rect: Rect;
            metrics: GlyphMetrics;
    };
    /**
        * The glyphs' positions
        */
    export type GlyphPositions = {
            [_: string]: {
                    [_: number]: GlyphPosition;
            };
    };
    export class GlyphAtlas {
            image: AlphaImage;
            positions: GlyphPositions;
            constructor(stacks: GetGlyphsResponse);
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/symbol/shaping' {
    import type { StyleGlyph, GlyphMetrics } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_glyph';
    import type { ImagePosition } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/image_atlas';
    import type { Rect, GlyphPosition } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/glyph_atlas';
    import { Formatted } from '@maplibre/maplibre-gl-style-spec';
    enum WritingMode {
        none = 0,
        horizontal = 1,
        vertical = 2,
        horizontalOnly = 3
    }
    const SHAPING_DEFAULT_OFFSET = -17;
    export { shapeText, shapeIcon, fitIconToText, getAnchorAlignment, WritingMode, SHAPING_DEFAULT_OFFSET };
    export type PositionedGlyph = {
        glyph: number;
        imageName: string | null;
        x: number;
        y: number;
        vertical: boolean;
        scale: number;
        fontStack: string;
        sectionIndex: number;
        metrics: GlyphMetrics;
        rect: Rect | null;
    };
    export type PositionedLine = {
        positionedGlyphs: Array<PositionedGlyph>;
        lineOffset: number;
    };
    export type Shaping = {
        positionedLines: Array<PositionedLine>;
        top: number;
        bottom: number;
        left: number;
        right: number;
        writingMode: WritingMode.horizontal | WritingMode.vertical;
        text: string;
        iconsInText: boolean;
        verticalizable: boolean;
    };
    export type SymbolAnchor = 'center' | 'left' | 'right' | 'top' | 'bottom' | 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';
    export type TextJustify = 'left' | 'center' | 'right';
    function shapeText(text: Formatted, glyphMap: {
        [_: string]: {
            [_: number]: StyleGlyph;
        };
    }, glyphPositions: {
        [_: string]: {
            [_: number]: GlyphPosition;
        };
    }, imagePositions: {
        [_: string]: ImagePosition;
    }, defaultFontStack: string, maxWidth: number, lineHeight: number, textAnchor: SymbolAnchor, textJustify: TextJustify, spacing: number, translate: [number, number], writingMode: WritingMode.horizontal | WritingMode.vertical, allowVerticalPlacement: boolean, symbolPlacement: string, layoutTextSize: number, layoutTextSizeThisZoom: number): Shaping | false;
    function getAnchorAlignment(anchor: SymbolAnchor): {
        horizontalAlign: number;
        verticalAlign: number;
    };
    export type PositionedIcon = {
        image: ImagePosition;
        top: number;
        bottom: number;
        left: number;
        right: number;
        collisionPadding?: [number, number, number, number];
    };
    function shapeIcon(image: ImagePosition, iconOffset: [number, number], iconAnchor: SymbolAnchor): PositionedIcon;
    function fitIconToText(shapedIcon: PositionedIcon, shapedText: Shaping, textFit: string, padding: [number, number, number, number], iconOffset: [number, number], fontScale: number): PositionedIcon;
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/symbol/anchor' {
    import Point from '@mapbox/point-geometry';
    export class Anchor extends Point {
        angle: any;
        segment?: number;
        constructor(x: number, y: number, angle: number, segment?: number);
        clone(): Anchor;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/symbol/quads' {
    import Point from '@mapbox/point-geometry';
    import type { Anchor } from '@mappedin/mappedin-js/packages/outdoor-context-v4/symbol/anchor';
    import type { PositionedIcon, Shaping } from '@mappedin/mappedin-js/packages/outdoor-context-v4/symbol/shaping';
    import type { SymbolStyleLayer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/symbol_style_layer';
    import type { Feature } from '@maplibre/maplibre-gl-style-spec';
    import type { StyleImage } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_image';
    /**
        * A textured quad for rendering a single icon or glyph.
        *
        * The zoom range the glyph can be shown is defined by minScale and maxScale.
        *
        * @param tl - The offset of the top left corner from the anchor.
        * @param tr - The offset of the top right corner from the anchor.
        * @param bl - The offset of the bottom left corner from the anchor.
        * @param br - The offset of the bottom right corner from the anchor.
        * @param tex - The texture coordinates.
        */
    export type SymbolQuad = {
            tl: Point;
            tr: Point;
            bl: Point;
            br: Point;
            tex: {
                    x: number;
                    y: number;
                    w: number;
                    h: number;
            };
            pixelOffsetTL: Point;
            pixelOffsetBR: Point;
            writingMode: any | void;
            glyphOffset: [number, number];
            sectionIndex: number;
            isSDF: boolean;
            minFontScaleX: number;
            minFontScaleY: number;
    };
    /**
        * Create the quads used for rendering an icon.
        */
    export function getIconQuads(shapedIcon: PositionedIcon, iconRotate: number, isSDFIcon: boolean, hasIconTextFit: boolean): Array<SymbolQuad>;
    /**
        * Create the quads used for rendering a text label.
        */
    export function getGlyphQuads(anchor: Anchor, shaping: Shaping, textOffset: [number, number], layer: SymbolStyleLayer, alongLine: boolean, feature: Feature, imageMap: {
            [_: string]: StyleImage;
    }, allowVerticalPlacement: boolean): Array<SymbolQuad>;
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/symbol/symbol_size' {
    import type { PropertyValue, PossiblyEvaluatedPropertyValue } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/properties';
    import type { InterpolationType } from '@maplibre/maplibre-gl-style-spec';
    const MAX_GLYPH_ICON_SIZE = 255;
    const SIZE_PACK_FACTOR = 128;
    const MAX_PACKED_SIZE: number;
    export { getSizeData, evaluateSizeForFeature, evaluateSizeForZoom, SIZE_PACK_FACTOR, MAX_GLYPH_ICON_SIZE, MAX_PACKED_SIZE, };
    export type SizeData = {
        kind: 'constant';
        layoutSize: number;
    } | {
        kind: 'source';
    } | {
        kind: 'camera';
        minZoom: number;
        maxZoom: number;
        minSize: number;
        maxSize: number;
        interpolationType: InterpolationType;
    } | {
        kind: 'composite';
        minZoom: number;
        maxZoom: number;
        interpolationType: InterpolationType;
    };
    export type EvaluatedZoomSize = {
        uSizeT: number;
        uSize: number;
    };
    function getSizeData(tileZoom: number, value: PropertyValue<number, PossiblyEvaluatedPropertyValue<number>>): SizeData;
    function evaluateSizeForFeature(sizeData: SizeData, { uSize, uSizeT, }: {
        uSize: number;
        uSizeT: number;
    }, { lowerSize, upperSize, }: {
        lowerSize: number;
        upperSize: number;
    }): number;
    function evaluateSizeForZoom(sizeData: SizeData, zoom: number): EvaluatedZoomSize;
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/util/transferable_grid_index' {
    export type SerializedGrid = {
        buffer: ArrayBuffer;
    };
    export class TransferableGridIndex {
        cells: number[][];
        arrayBuffer: ArrayBuffer;
        d: number;
        keys: number[];
        bboxes: number[];
        n: number;
        extent: number;
        padding: number;
        scale: any;
        uid: number;
        min: number;
        max: number;
        constructor(extent: number | ArrayBuffer, n?: number, padding?: number);
        insert(key: number, x1: number, y1: number, x2: number, y2: number): void;
        _insertReadonly(): void;
        _insertCell(x1: number, y1: number, x2: number, y2: number, cellIndex: number, uid: number): void;
        query(x1: number, y1: number, x2: number, y2: number, intersectionTest?: Function): number[];
        _queryCell(x1: number, y1: number, x2: number, y2: number, cellIndex: number, result: any, seenUids: any, intersectionTest: Function): void;
        _forEachCell(x1: number, y1: number, x2: number, y2: number, fn: Function, arg1: any, arg2: any, intersectionTest: any): void;
        _convertFromCellCoord(x: any): number;
        _convertToCellCoord(x: any): number;
        toArrayBuffer(): ArrayBuffer;
        static serialize(grid: TransferableGridIndex, transferables?: Array<Transferable>): SerializedGrid;
        static deserialize(serialized: SerializedGrid): TransferableGridIndex;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/util/dictionary_coder' {
    export class DictionaryCoder {
        _stringToNumber: {
            [_: string]: number;
        };
        _numberToString: Array<string>;
        constructor(strings: Array<string>);
        encode(string: string): number;
        decode(n: number): string;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer_index' {
    import { StyleLayer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer';
    import type { TypedStyleLayer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/typed_style_layer';
    import type { LayerSpecification } from '@maplibre/maplibre-gl-style-spec';
    export type LayerConfigs = {
        [_: string]: LayerSpecification;
    };
    export type Family<Layer extends TypedStyleLayer> = Array<Layer>;
    export class StyleLayerIndex {
        familiesBySource: {
            [source: string]: {
                [sourceLayer: string]: Array<Family<any>>;
            };
        };
        keyCache: {
            [source: string]: string;
        };
        _layerConfigs: LayerConfigs;
        _layers: {
            [_: string]: StyleLayer;
        };
        constructor(layerConfigs?: Array<LayerSpecification> | null);
        replace(layerConfigs: Array<LayerSpecification>): void;
        update(layerConfigs: Array<LayerSpecification>, removedIds: Array<string>): void;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/util/web_worker' {
    import { AddProtocolAction } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/config';
    import type { default as MaplibreWorker } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/worker';
    export interface WorkerGlobalScopeInterface {
        importScripts(...urls: Array<string>): void;
        registerWorkerSource: (sourceName: string, sourceConstrucor: any) => void;
        registerRTLTextPlugin: (_: any) => void;
        addProtocol: (customProtocol: string, loadFn: AddProtocolAction) => void;
        removeProtocol: (customProtocol: string) => void;
        worker: MaplibreWorker;
    }
    export function workerFactory(): Worker;
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/source/worker_tile' {
    import { CollisionBoxArray } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/array_types.g';
    import { OverscaledTileID } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile_id';
    import type { IActor } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/actor';
    import type { StyleLayerIndex } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer_index';
    import type { WorkerTileParameters, WorkerTileResult } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/worker_source';
    import type { PromoteIdSpecification } from '@maplibre/maplibre-gl-style-spec';
    import type { VectorTile } from '@mapbox/vector-tile';
    export class WorkerTile {
        tileID: OverscaledTileID;
        uid: string | number;
        zoom: number;
        pixelRatio: number;
        tileSize: number;
        source: string;
        promoteId: PromoteIdSpecification;
        overscaling: number;
        showCollisionBoxes: boolean;
        collectResourceTiming: boolean;
        returnDependencies: boolean;
        status: 'parsing' | 'done';
        data: VectorTile;
        collisionBoxArray: CollisionBoxArray;
        abort: AbortController;
        vectorTile: VectorTile;
        inFlightDependencies: AbortController[];
        constructor(params: WorkerTileParameters);
        parse(data: VectorTile, layerIndex: StyleLayerIndex, availableImages: Array<string>, actor: IActor): Promise<WorkerTileResult>;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/circle_style_layer' {
    import { StyleLayer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer';
    import { CircleBucket } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/bucket/circle_bucket';
    import { CircleLayoutPropsPossiblyEvaluated, CirclePaintPropsPossiblyEvaluated } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/circle_style_layer_properties.g';
    import { Transitionable, Transitioning, Layout, PossiblyEvaluated } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/properties';
    import { mat4 } from 'gl-matrix';
    import Point from '@mapbox/point-geometry';
    import type { FeatureState, LayerSpecification } from '@maplibre/maplibre-gl-style-spec';
    import type { Transform } from '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/transform';
    import type { Bucket, BucketParameters } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/bucket';
    import type { CircleLayoutProps, CirclePaintProps } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/circle_style_layer_properties.g';
    import type { VectorTileFeature } from '@mapbox/vector-tile';
    /**
      * A style layer that defines a circle
      */
    export class CircleStyleLayer extends StyleLayer {
        _unevaluatedLayout: Layout<CircleLayoutProps>;
        layout: PossiblyEvaluated<CircleLayoutProps, CircleLayoutPropsPossiblyEvaluated>;
        _transitionablePaint: Transitionable<CirclePaintProps>;
        _transitioningPaint: Transitioning<CirclePaintProps>;
        paint: PossiblyEvaluated<CirclePaintProps, CirclePaintPropsPossiblyEvaluated>;
        constructor(layer: LayerSpecification);
        createBucket(parameters: BucketParameters<any>): CircleBucket<any>;
        queryRadius(bucket: Bucket): number;
        queryIntersectsFeature(queryGeometry: Array<Point>, feature: VectorTileFeature, featureState: FeatureState, geometry: Array<Array<Point>>, zoom: number, transform: Transform, pixelsToTileUnits: number, pixelPosMatrix: mat4): boolean;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/fill_style_layer' {
    import { StyleLayer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer';
    import { FillBucket } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/bucket/fill_bucket';
    import { FillLayoutPropsPossiblyEvaluated, FillPaintPropsPossiblyEvaluated } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/fill_style_layer_properties.g';
    import { Transitionable, Transitioning, Layout, PossiblyEvaluated } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/properties';
    import type { FeatureState, LayerSpecification } from '@maplibre/maplibre-gl-style-spec';
    import type { BucketParameters } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/bucket';
    import type Point from '@mapbox/point-geometry';
    import type { FillLayoutProps, FillPaintProps } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/fill_style_layer_properties.g';
    import type { EvaluationParameters } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/evaluation_parameters';
    import type { Transform } from '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/transform';
    import type { VectorTileFeature } from '@mapbox/vector-tile';
    export class FillStyleLayer extends StyleLayer {
        _unevaluatedLayout: Layout<FillLayoutProps>;
        layout: PossiblyEvaluated<FillLayoutProps, FillLayoutPropsPossiblyEvaluated>;
        _transitionablePaint: Transitionable<FillPaintProps>;
        _transitioningPaint: Transitioning<FillPaintProps>;
        paint: PossiblyEvaluated<FillPaintProps, FillPaintPropsPossiblyEvaluated>;
        constructor(layer: LayerSpecification);
        recalculate(parameters: EvaluationParameters, availableImages: Array<string>): void;
        createBucket(parameters: BucketParameters<any>): FillBucket;
        queryRadius(): number;
        queryIntersectsFeature(queryGeometry: Array<Point>, feature: VectorTileFeature, featureState: FeatureState, geometry: Array<Array<Point>>, zoom: number, transform: Transform, pixelsToTileUnits: number): boolean;
        isTileClipped(): boolean;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/fill_extrusion_style_layer' {
    import { StyleLayer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer';
    import { FillExtrusionBucket } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/bucket/fill_extrusion_bucket';
    import { FillExtrusionPaintPropsPossiblyEvaluated } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/fill_extrusion_style_layer_properties.g';
    import { Transitionable, Transitioning, PossiblyEvaluated } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/properties';
    import { mat4 } from 'gl-matrix';
    import Point from '@mapbox/point-geometry';
    import type { FeatureState, LayerSpecification } from '@maplibre/maplibre-gl-style-spec';
    import type { BucketParameters } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/bucket';
    import type { FillExtrusionPaintProps } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/fill_extrusion_style_layer_properties.g';
    import type { Transform } from '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/transform';
    import type { VectorTileFeature } from '@mapbox/vector-tile';
    export class Point3D extends Point {
        z: number;
    }
    export class FillExtrusionStyleLayer extends StyleLayer {
        _transitionablePaint: Transitionable<FillExtrusionPaintProps>;
        _transitioningPaint: Transitioning<FillExtrusionPaintProps>;
        paint: PossiblyEvaluated<FillExtrusionPaintProps, FillExtrusionPaintPropsPossiblyEvaluated>;
        constructor(layer: LayerSpecification);
        createBucket(parameters: BucketParameters<FillExtrusionStyleLayer>): FillExtrusionBucket;
        queryRadius(): number;
        is3D(): boolean;
        queryIntersectsFeature(queryGeometry: Array<Point>, feature: VectorTileFeature, featureState: FeatureState, geometry: Array<Array<Point>>, zoom: number, transform: Transform, pixelsToTileUnits: number, pixelPosMatrix: mat4): boolean | number;
    }
    export function getIntersectionDistance(projectedQueryGeometry: Array<Point3D>, projectedFace: Array<Point3D>): number;
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/heatmap_style_layer' {
    import { StyleLayer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer';
    import { HeatmapBucket } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/bucket/heatmap_bucket';
    import { RGBAImage } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/image';
    import { HeatmapPaintPropsPossiblyEvaluated } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/heatmap_style_layer_properties.g';
    import { Transitionable, Transitioning, PossiblyEvaluated } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/properties';
    import type { Texture } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/texture';
    import type { Framebuffer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/framebuffer';
    import type { HeatmapPaintProps } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/heatmap_style_layer_properties.g';
    import type { LayerSpecification } from '@maplibre/maplibre-gl-style-spec';
    /**
      * A style layer that defines a heatmap
      */
    export class HeatmapStyleLayer extends StyleLayer {
        heatmapFbo: Framebuffer;
        colorRamp: RGBAImage;
        colorRampTexture: Texture;
        _transitionablePaint: Transitionable<HeatmapPaintProps>;
        _transitioningPaint: Transitioning<HeatmapPaintProps>;
        paint: PossiblyEvaluated<HeatmapPaintProps, HeatmapPaintPropsPossiblyEvaluated>;
        createBucket(options: any): HeatmapBucket;
        constructor(layer: LayerSpecification);
        _handleSpecialPaintPropertyUpdate(name: string): void;
        _updateColorRamp(): void;
        resize(): void;
        queryRadius(): number;
        queryIntersectsFeature(): boolean;
        hasOffscreenPass(): boolean;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/hillshade_style_layer' {
    import { StyleLayer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer';
    import { HillshadePaintPropsPossiblyEvaluated } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/hillshade_style_layer_properties.g';
    import { Transitionable, Transitioning, PossiblyEvaluated } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/properties';
    import type { HillshadePaintProps } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/hillshade_style_layer_properties.g';
    import type { LayerSpecification } from '@maplibre/maplibre-gl-style-spec';
    export class HillshadeStyleLayer extends StyleLayer {
        _transitionablePaint: Transitionable<HillshadePaintProps>;
        _transitioningPaint: Transitioning<HillshadePaintProps>;
        paint: PossiblyEvaluated<HillshadePaintProps, HillshadePaintPropsPossiblyEvaluated>;
        constructor(layer: LayerSpecification);
        hasOffscreenPass(): boolean;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/line_style_layer' {
    import Point from '@mapbox/point-geometry';
    import { StyleLayer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer';
    import { LineBucket } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/bucket/line_bucket';
    import { LineLayoutPropsPossiblyEvaluated, LinePaintPropsPossiblyEvaluated } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/line_style_layer_properties.g';
    import { EvaluationParameters } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/evaluation_parameters';
    import { Transitionable, Transitioning, Layout, PossiblyEvaluated, DataDrivenProperty } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/properties';
    import type { FeatureState, LayerSpecification } from '@maplibre/maplibre-gl-style-spec';
    import type { Bucket, BucketParameters } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/bucket';
    import type { LineLayoutProps, LinePaintProps } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/line_style_layer_properties.g';
    import type { Transform } from '@mappedin/mappedin-js/packages/outdoor-context-v4/geo/transform';
    import type { VectorTileFeature } from '@mapbox/vector-tile';
    export class LineFloorwidthProperty extends DataDrivenProperty<number> {
        useIntegerZoom: true;
        possiblyEvaluate(value: any, parameters: any): import("../properties").PossiblyEvaluatedPropertyValue<number>;
        evaluate(value: any, globals: any, feature: any, featureState: any): number;
    }
    export class LineStyleLayer extends StyleLayer {
        _unevaluatedLayout: Layout<LineLayoutProps>;
        layout: PossiblyEvaluated<LineLayoutProps, LineLayoutPropsPossiblyEvaluated>;
        gradientVersion: number;
        stepInterpolant: boolean;
        _transitionablePaint: Transitionable<LinePaintProps>;
        _transitioningPaint: Transitioning<LinePaintProps>;
        paint: PossiblyEvaluated<LinePaintProps, LinePaintPropsPossiblyEvaluated>;
        constructor(layer: LayerSpecification);
        _handleSpecialPaintPropertyUpdate(name: string): void;
        gradientExpression(): import("@maplibre/maplibre-gl-style-spec").StylePropertyExpression;
        recalculate(parameters: EvaluationParameters, availableImages: Array<string>): void;
        createBucket(parameters: BucketParameters<any>): LineBucket;
        queryRadius(bucket: Bucket): number;
        queryIntersectsFeature(queryGeometry: Array<Point>, feature: VectorTileFeature, featureState: FeatureState, geometry: Array<Array<Point>>, zoom: number, transform: Transform, pixelsToTileUnits: number): boolean;
        isTileClipped(): boolean;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/source/worker' {
    import { Actor, ActorTarget } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/actor';
    import { StyleLayerIndex } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer_index';
    import { RasterDEMTileWorkerSource } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/raster_dem_tile_worker_source';
    import type { WorkerSource, WorkerSourceConstructor } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/worker_source';
    import type { WorkerGlobalScopeInterface } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/web_worker';
    /**
        * The Worker class responsidble for background thread related execution
        */
    export default class Worker {
            self: WorkerGlobalScopeInterface & ActorTarget;
            actor: Actor;
            layerIndexes: {
                    [_: string]: StyleLayerIndex;
            };
            availableImages: {
                    [_: string]: Array<string>;
            };
            externalWorkerSourceTypes: {
                    [_: string]: WorkerSourceConstructor;
            };
            /**
                * This holds a cache for the already created worker source instances.
                * The cache is build with the following hierarchy:
                * [mapId][sourceType][sourceName]: worker source instance
                * sourceType can be 'vector' for example
                */
            workerSources: {
                    [_: string]: {
                            [_: string]: {
                                    [_: string]: WorkerSource;
                            };
                    };
            };
            /**
                * This holds a cache for the already created DEM worker source instances.
                * The cache is build with the following hierarchy:
                * [mapId][sourceType]: DEM worker source instance
                * sourceType can be 'raster-dem' for example
                */
            demWorkerSources: {
                    [_: string]: {
                            [_: string]: RasterDEMTileWorkerSource;
                    };
            };
            referrer: string;
            constructor(self: WorkerGlobalScopeInterface & ActorTarget);
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/data/bucket/circle_bucket' {
    import { CircleLayoutArray } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/array_types.g';
    import { SegmentVector } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/segment';
    import { ProgramConfigurationSet } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/program_configuration';
    import { TriangleIndexArray } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/index_array_type';
    import type { CanonicalTileID } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile_id';
    import type { Bucket, BucketParameters, BucketFeature, IndexedFeature, PopulateParameters } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/bucket';
    import type { CircleStyleLayer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/circle_style_layer';
    import type { HeatmapStyleLayer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/heatmap_style_layer';
    import type { Context } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/context';
    import type { IndexBuffer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/index_buffer';
    import type { VertexBuffer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/vertex_buffer';
    import type Point from '@mapbox/point-geometry';
    import type { FeatureStates } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/source_state';
    import type { ImagePosition } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/image_atlas';
    import type { VectorTileLayer } from '@mapbox/vector-tile';
    /**
      * @internal
      * Circles are represented by two triangles.
      *
      * Each corner has a pos that is the center of the circle and an extrusion
      * vector that is where it points.
      */
    export class CircleBucket<Layer extends CircleStyleLayer | HeatmapStyleLayer> implements Bucket {
        index: number;
        zoom: number;
        overscaling: number;
        layerIds: Array<string>;
        layers: Array<Layer>;
        stateDependentLayers: Array<Layer>;
        stateDependentLayerIds: Array<string>;
        layoutVertexArray: CircleLayoutArray;
        layoutVertexBuffer: VertexBuffer;
        indexArray: TriangleIndexArray;
        indexBuffer: IndexBuffer;
        hasPattern: boolean;
        programConfigurations: ProgramConfigurationSet<Layer>;
        segments: SegmentVector;
        uploaded: boolean;
        constructor(options: BucketParameters<Layer>);
        populate(features: Array<IndexedFeature>, options: PopulateParameters, canonical: CanonicalTileID): void;
        update(states: FeatureStates, vtLayer: VectorTileLayer, imagePositions: {
            [_: string]: ImagePosition;
        }): void;
        isEmpty(): boolean;
        uploadPending(): boolean;
        upload(context: Context): void;
        destroy(): void;
        addFeature(feature: BucketFeature, geometry: Array<Array<Point>>, index: number, canonical: CanonicalTileID): void;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/circle_style_layer_properties.g' {
    import { Properties, DataConstantProperty, DataDrivenProperty, PossiblyEvaluatedPropertyValue } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/properties';
    import type { Color } from '@maplibre/maplibre-gl-style-spec';
    export type CircleLayoutProps = {
        'circle-sort-key': DataDrivenProperty<number>;
    };
    export type CircleLayoutPropsPossiblyEvaluated = {
        'circle-sort-key': PossiblyEvaluatedPropertyValue<number>;
    };
    export type CirclePaintProps = {
        'circle-radius': DataDrivenProperty<number>;
        'circle-color': DataDrivenProperty<Color>;
        'circle-blur': DataDrivenProperty<number>;
        'circle-opacity': DataDrivenProperty<number>;
        'circle-translate': DataConstantProperty<[number, number]>;
        'circle-translate-anchor': DataConstantProperty<'map' | 'viewport'>;
        'circle-pitch-scale': DataConstantProperty<'map' | 'viewport'>;
        'circle-pitch-alignment': DataConstantProperty<'map' | 'viewport'>;
        'circle-stroke-width': DataDrivenProperty<number>;
        'circle-stroke-color': DataDrivenProperty<Color>;
        'circle-stroke-opacity': DataDrivenProperty<number>;
    };
    export type CirclePaintPropsPossiblyEvaluated = {
        'circle-radius': PossiblyEvaluatedPropertyValue<number>;
        'circle-color': PossiblyEvaluatedPropertyValue<Color>;
        'circle-blur': PossiblyEvaluatedPropertyValue<number>;
        'circle-opacity': PossiblyEvaluatedPropertyValue<number>;
        'circle-translate': [number, number];
        'circle-translate-anchor': 'map' | 'viewport';
        'circle-pitch-scale': 'map' | 'viewport';
        'circle-pitch-alignment': 'map' | 'viewport';
        'circle-stroke-width': PossiblyEvaluatedPropertyValue<number>;
        'circle-stroke-color': PossiblyEvaluatedPropertyValue<Color>;
        'circle-stroke-opacity': PossiblyEvaluatedPropertyValue<number>;
    };
    const _default: {
        readonly paint: Properties<CirclePaintProps>;
        readonly layout: Properties<CircleLayoutProps>;
    };
    export default _default;
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/data/bucket/fill_bucket' {
    import { FillLayoutArray } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/array_types.g';
    import { SegmentVector } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/segment';
    import { ProgramConfigurationSet } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/program_configuration';
    import { LineIndexArray, TriangleIndexArray } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/index_array_type';
    import type { CanonicalTileID } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile_id';
    import type { Bucket, BucketParameters, BucketFeature, IndexedFeature, PopulateParameters } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/bucket';
    import type { FillStyleLayer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/fill_style_layer';
    import type { Context } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/context';
    import type { IndexBuffer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/index_buffer';
    import type { VertexBuffer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/vertex_buffer';
    import type Point from '@mapbox/point-geometry';
    import type { FeatureStates } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/source_state';
    import type { ImagePosition } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/image_atlas';
    import type { VectorTileLayer } from '@mapbox/vector-tile';
    export class FillBucket implements Bucket {
        index: number;
        zoom: number;
        overscaling: number;
        layers: Array<FillStyleLayer>;
        layerIds: Array<string>;
        stateDependentLayers: Array<FillStyleLayer>;
        stateDependentLayerIds: Array<string>;
        patternFeatures: Array<BucketFeature>;
        layoutVertexArray: FillLayoutArray;
        layoutVertexBuffer: VertexBuffer;
        indexArray: TriangleIndexArray;
        indexBuffer: IndexBuffer;
        indexArray2: LineIndexArray;
        indexBuffer2: IndexBuffer;
        hasPattern: boolean;
        programConfigurations: ProgramConfigurationSet<FillStyleLayer>;
        segments: SegmentVector;
        segments2: SegmentVector;
        uploaded: boolean;
        constructor(options: BucketParameters<FillStyleLayer>);
        populate(features: Array<IndexedFeature>, options: PopulateParameters, canonical: CanonicalTileID): void;
        update(states: FeatureStates, vtLayer: VectorTileLayer, imagePositions: {
            [_: string]: ImagePosition;
        }): void;
        addFeatures(options: PopulateParameters, canonical: CanonicalTileID, imagePositions: {
            [_: string]: ImagePosition;
        }): void;
        isEmpty(): boolean;
        uploadPending(): boolean;
        upload(context: Context): void;
        destroy(): void;
        addFeature(feature: BucketFeature, geometry: Array<Array<Point>>, index: number, canonical: CanonicalTileID, imagePositions: {
            [_: string]: ImagePosition;
        }): void;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/fill_style_layer_properties.g' {
    import { Properties, DataConstantProperty, DataDrivenProperty, CrossFadedDataDrivenProperty, PossiblyEvaluatedPropertyValue, CrossFaded } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/properties';
    import type { Color, ResolvedImage } from '@maplibre/maplibre-gl-style-spec';
    export type FillLayoutProps = {
        'fill-sort-key': DataDrivenProperty<number>;
    };
    export type FillLayoutPropsPossiblyEvaluated = {
        'fill-sort-key': PossiblyEvaluatedPropertyValue<number>;
    };
    export type FillPaintProps = {
        'fill-antialias': DataConstantProperty<boolean>;
        'fill-opacity': DataDrivenProperty<number>;
        'fill-color': DataDrivenProperty<Color>;
        'fill-outline-color': DataDrivenProperty<Color>;
        'fill-translate': DataConstantProperty<[number, number]>;
        'fill-translate-anchor': DataConstantProperty<'map' | 'viewport'>;
        'fill-pattern': CrossFadedDataDrivenProperty<ResolvedImage>;
    };
    export type FillPaintPropsPossiblyEvaluated = {
        'fill-antialias': boolean;
        'fill-opacity': PossiblyEvaluatedPropertyValue<number>;
        'fill-color': PossiblyEvaluatedPropertyValue<Color>;
        'fill-outline-color': PossiblyEvaluatedPropertyValue<Color>;
        'fill-translate': [number, number];
        'fill-translate-anchor': 'map' | 'viewport';
        'fill-pattern': PossiblyEvaluatedPropertyValue<CrossFaded<ResolvedImage>>;
    };
    const _default: {
        readonly paint: Properties<FillPaintProps>;
        readonly layout: Properties<FillLayoutProps>;
    };
    export default _default;
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/data/bucket/fill_extrusion_bucket' {
    import { FillExtrusionLayoutArray, PosArray } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/array_types.g';
    import { SegmentVector } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/segment';
    import { ProgramConfigurationSet } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/program_configuration';
    import { TriangleIndexArray } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/index_array_type';
    import type { CanonicalTileID } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile_id';
    import type { Bucket, BucketParameters, BucketFeature, IndexedFeature, PopulateParameters } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/bucket';
    import type { FillExtrusionStyleLayer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/fill_extrusion_style_layer';
    import type { Context } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/context';
    import type { IndexBuffer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/index_buffer';
    import type { VertexBuffer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/vertex_buffer';
    import type Point from '@mapbox/point-geometry';
    import type { FeatureStates } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/source_state';
    import type { ImagePosition } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/image_atlas';
    import type { VectorTileLayer } from '@mapbox/vector-tile';
    export class FillExtrusionBucket implements Bucket {
        index: number;
        zoom: number;
        overscaling: number;
        layers: Array<FillExtrusionStyleLayer>;
        layerIds: Array<string>;
        stateDependentLayers: Array<FillExtrusionStyleLayer>;
        stateDependentLayerIds: Array<string>;
        layoutVertexArray: FillExtrusionLayoutArray;
        layoutVertexBuffer: VertexBuffer;
        centroidVertexArray: PosArray;
        centroidVertexBuffer: VertexBuffer;
        indexArray: TriangleIndexArray;
        indexBuffer: IndexBuffer;
        hasPattern: boolean;
        programConfigurations: ProgramConfigurationSet<FillExtrusionStyleLayer>;
        segments: SegmentVector;
        uploaded: boolean;
        features: Array<BucketFeature>;
        constructor(options: BucketParameters<FillExtrusionStyleLayer>);
        populate(features: Array<IndexedFeature>, options: PopulateParameters, canonical: CanonicalTileID): void;
        addFeatures(options: PopulateParameters, canonical: CanonicalTileID, imagePositions: {
            [_: string]: ImagePosition;
        }): void;
        update(states: FeatureStates, vtLayer: VectorTileLayer, imagePositions: {
            [_: string]: ImagePosition;
        }): void;
        isEmpty(): boolean;
        uploadPending(): boolean;
        upload(context: Context): void;
        destroy(): void;
        addFeature(feature: BucketFeature, geometry: Array<Array<Point>>, index: number, canonical: CanonicalTileID, imagePositions: {
            [_: string]: ImagePosition;
        }): void;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/fill_extrusion_style_layer_properties.g' {
    import { Properties, DataConstantProperty, DataDrivenProperty, CrossFadedDataDrivenProperty, PossiblyEvaluatedPropertyValue, CrossFaded } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/properties';
    import type { Color, ResolvedImage } from '@maplibre/maplibre-gl-style-spec';
    export type FillExtrusionPaintProps = {
        'fill-extrusion-opacity': DataConstantProperty<number>;
        'fill-extrusion-color': DataDrivenProperty<Color>;
        'fill-extrusion-translate': DataConstantProperty<[number, number]>;
        'fill-extrusion-translate-anchor': DataConstantProperty<'map' | 'viewport'>;
        'fill-extrusion-pattern': CrossFadedDataDrivenProperty<ResolvedImage>;
        'fill-extrusion-height': DataDrivenProperty<number>;
        'fill-extrusion-base': DataDrivenProperty<number>;
        'fill-extrusion-vertical-gradient': DataConstantProperty<boolean>;
    };
    export type FillExtrusionPaintPropsPossiblyEvaluated = {
        'fill-extrusion-opacity': number;
        'fill-extrusion-color': PossiblyEvaluatedPropertyValue<Color>;
        'fill-extrusion-translate': [number, number];
        'fill-extrusion-translate-anchor': 'map' | 'viewport';
        'fill-extrusion-pattern': PossiblyEvaluatedPropertyValue<CrossFaded<ResolvedImage>>;
        'fill-extrusion-height': PossiblyEvaluatedPropertyValue<number>;
        'fill-extrusion-base': PossiblyEvaluatedPropertyValue<number>;
        'fill-extrusion-vertical-gradient': boolean;
    };
    const _default: {
        readonly paint: Properties<FillExtrusionPaintProps>;
    };
    export default _default;
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/data/bucket/heatmap_bucket' {
    import { CircleBucket } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/bucket/circle_bucket';
    import type { HeatmapStyleLayer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/heatmap_style_layer';
    export class HeatmapBucket extends CircleBucket<HeatmapStyleLayer> {
        layers: Array<HeatmapStyleLayer>;
    }
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/heatmap_style_layer_properties.g' {
    import { Properties, DataConstantProperty, DataDrivenProperty, ColorRampProperty, PossiblyEvaluatedPropertyValue } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/properties';
    export type HeatmapPaintProps = {
        'heatmap-radius': DataDrivenProperty<number>;
        'heatmap-weight': DataDrivenProperty<number>;
        'heatmap-intensity': DataConstantProperty<number>;
        'heatmap-color': ColorRampProperty;
        'heatmap-opacity': DataConstantProperty<number>;
    };
    export type HeatmapPaintPropsPossiblyEvaluated = {
        'heatmap-radius': PossiblyEvaluatedPropertyValue<number>;
        'heatmap-weight': PossiblyEvaluatedPropertyValue<number>;
        'heatmap-intensity': number;
        'heatmap-color': ColorRampProperty;
        'heatmap-opacity': number;
    };
    const _default: {
        readonly paint: Properties<HeatmapPaintProps>;
    };
    export default _default;
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/hillshade_style_layer_properties.g' {
    import { Properties, DataConstantProperty } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/properties';
    import type { Color } from '@maplibre/maplibre-gl-style-spec';
    export type HillshadePaintProps = {
        'hillshade-illumination-direction': DataConstantProperty<number>;
        'hillshade-illumination-anchor': DataConstantProperty<'map' | 'viewport'>;
        'hillshade-exaggeration': DataConstantProperty<number>;
        'hillshade-shadow-color': DataConstantProperty<Color>;
        'hillshade-highlight-color': DataConstantProperty<Color>;
        'hillshade-accent-color': DataConstantProperty<Color>;
    };
    export type HillshadePaintPropsPossiblyEvaluated = {
        'hillshade-illumination-direction': number;
        'hillshade-illumination-anchor': 'map' | 'viewport';
        'hillshade-exaggeration': number;
        'hillshade-shadow-color': Color;
        'hillshade-highlight-color': Color;
        'hillshade-accent-color': Color;
    };
    const _default: {
        readonly paint: Properties<HillshadePaintProps>;
    };
    export default _default;
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/data/bucket/line_bucket' {
    import { LineLayoutArray, LineExtLayoutArray } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/array_types.g';
    import { SegmentVector } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/segment';
    import { ProgramConfigurationSet } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/program_configuration';
    import { TriangleIndexArray } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/index_array_type';
    import type { CanonicalTileID } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/tile_id';
    import type { Bucket, BucketParameters, BucketFeature, IndexedFeature, PopulateParameters } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/bucket';
    import type { LineStyleLayer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/line_style_layer';
    import type Point from '@mapbox/point-geometry';
    import type { Segment } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/segment';
    import { RGBAImage } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/image';
    import type { Context } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/context';
    import type { Texture } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/texture';
    import type { IndexBuffer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/index_buffer';
    import type { VertexBuffer } from '@mappedin/mappedin-js/packages/outdoor-context-v4/gl/vertex_buffer';
    import type { FeatureStates } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/source_state';
    import type { ImagePosition } from '@mappedin/mappedin-js/packages/outdoor-context-v4/render/image_atlas';
    import type { VectorTileLayer } from '@mapbox/vector-tile';
    type LineClips = {
            start: number;
            end: number;
    };
    type GradientTexture = {
            texture?: Texture;
            gradient?: RGBAImage;
            version?: number;
    };
    /**
        * @internal
        * Line bucket class
        */
    export class LineBucket implements Bucket {
            distance: number;
            totalDistance: number;
            maxLineLength: number;
            scaledDistance: number;
            lineClips?: LineClips;
            e1: number;
            e2: number;
            index: number;
            zoom: number;
            overscaling: number;
            layers: Array<LineStyleLayer>;
            layerIds: Array<string>;
            gradients: {
                    [x: string]: GradientTexture;
            };
            stateDependentLayers: Array<any>;
            stateDependentLayerIds: Array<string>;
            patternFeatures: Array<BucketFeature>;
            lineClipsArray: Array<LineClips>;
            layoutVertexArray: LineLayoutArray;
            layoutVertexBuffer: VertexBuffer;
            layoutVertexArray2: LineExtLayoutArray;
            layoutVertexBuffer2: VertexBuffer;
            indexArray: TriangleIndexArray;
            indexBuffer: IndexBuffer;
            hasPattern: boolean;
            programConfigurations: ProgramConfigurationSet<LineStyleLayer>;
            segments: SegmentVector;
            uploaded: boolean;
            constructor(options: BucketParameters<LineStyleLayer>);
            populate(features: Array<IndexedFeature>, options: PopulateParameters, canonical: CanonicalTileID): void;
            update(states: FeatureStates, vtLayer: VectorTileLayer, imagePositions: {
                    [_: string]: ImagePosition;
            }): void;
            addFeatures(options: PopulateParameters, canonical: CanonicalTileID, imagePositions: {
                    [_: string]: ImagePosition;
            }): void;
            isEmpty(): boolean;
            uploadPending(): boolean;
            upload(context: Context): void;
            destroy(): void;
            lineFeatureClips(feature: BucketFeature): LineClips | undefined;
            addFeature(feature: BucketFeature, geometry: Array<Array<Point>>, index: number, canonical: CanonicalTileID, imagePositions: {
                    [_: string]: ImagePosition;
            }): void;
            addLine(vertices: Array<Point>, feature: BucketFeature, join: string, cap: string, miterLimit: number, roundLimit: number): void;
            /**
                * Add two vertices to the buffers.
                *
                * @param p - the line vertex to add buffer vertices for
                * @param normal - vertex normal
                * @param endLeft - extrude to shift the left vertex along the line
                * @param endRight - extrude to shift the left vertex along the line
                * @param segment - the segment object to add the vertex to
                * @param round - whether this is a round cap
                */
            addCurrentVertex(p: Point, normal: Point, endLeft: number, endRight: number, segment: Segment, round?: boolean): void;
            addHalfVertex({ x, y }: Point, extrudeX: number, extrudeY: number, round: boolean, up: boolean, dir: number, segment: Segment): void;
            updateScaledDistance(): void;
            updateDistance(prev: Point, next: Point): void;
    }
    export {};
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/style/style_layer/line_style_layer_properties.g' {
    import { Properties, DataConstantProperty, DataDrivenProperty, CrossFadedDataDrivenProperty, CrossFadedProperty, ColorRampProperty, PossiblyEvaluatedPropertyValue, CrossFaded } from '@mappedin/mappedin-js/packages/outdoor-context-v4/style/properties';
    import type { Color, ResolvedImage } from '@maplibre/maplibre-gl-style-spec';
    export type LineLayoutProps = {
        'line-cap': DataConstantProperty<'butt' | 'round' | 'square'>;
        'line-join': DataDrivenProperty<'bevel' | 'round' | 'miter'>;
        'line-miter-limit': DataConstantProperty<number>;
        'line-round-limit': DataConstantProperty<number>;
        'line-sort-key': DataDrivenProperty<number>;
    };
    export type LineLayoutPropsPossiblyEvaluated = {
        'line-cap': 'butt' | 'round' | 'square';
        'line-join': PossiblyEvaluatedPropertyValue<'bevel' | 'round' | 'miter'>;
        'line-miter-limit': number;
        'line-round-limit': number;
        'line-sort-key': PossiblyEvaluatedPropertyValue<number>;
    };
    export type LinePaintProps = {
        'line-opacity': DataDrivenProperty<number>;
        'line-color': DataDrivenProperty<Color>;
        'line-translate': DataConstantProperty<[number, number]>;
        'line-translate-anchor': DataConstantProperty<'map' | 'viewport'>;
        'line-width': DataDrivenProperty<number>;
        'line-gap-width': DataDrivenProperty<number>;
        'line-offset': DataDrivenProperty<number>;
        'line-blur': DataDrivenProperty<number>;
        'line-dasharray': CrossFadedProperty<Array<number>>;
        'line-pattern': CrossFadedDataDrivenProperty<ResolvedImage>;
        'line-gradient': ColorRampProperty;
    };
    export type LinePaintPropsPossiblyEvaluated = {
        'line-opacity': PossiblyEvaluatedPropertyValue<number>;
        'line-color': PossiblyEvaluatedPropertyValue<Color>;
        'line-translate': [number, number];
        'line-translate-anchor': 'map' | 'viewport';
        'line-width': PossiblyEvaluatedPropertyValue<number>;
        'line-gap-width': PossiblyEvaluatedPropertyValue<number>;
        'line-offset': PossiblyEvaluatedPropertyValue<number>;
        'line-blur': PossiblyEvaluatedPropertyValue<number>;
        'line-dasharray': CrossFaded<Array<number>>;
        'line-pattern': PossiblyEvaluatedPropertyValue<CrossFaded<ResolvedImage>>;
        'line-gradient': ColorRampProperty;
    };
    const _default: {
        readonly paint: Properties<LinePaintProps>;
        readonly layout: Properties<LineLayoutProps>;
    };
    export default _default;
}

declare module '@mappedin/mappedin-js/packages/outdoor-context-v4/source/raster_dem_tile_worker_source' {
    import { DEMData } from '@mappedin/mappedin-js/packages/outdoor-context-v4/data/dem_data';
    import type { Actor } from '@mappedin/mappedin-js/packages/outdoor-context-v4/util/actor';
    import type { WorkerDEMTileParameters, TileParameters } from '@mappedin/mappedin-js/packages/outdoor-context-v4/source/worker_source';
    export class RasterDEMTileWorkerSource {
        actor: Actor;
        loaded: {
            [_: string]: DEMData;
        };
        constructor();
        loadTile(params: WorkerDEMTileParameters): Promise<DEMData | null>;
        removeTile(params: TileParameters): void;
    }
}

