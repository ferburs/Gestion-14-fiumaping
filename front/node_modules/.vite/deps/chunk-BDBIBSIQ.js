import {
  $v,
  $y,
  Am,
  Bb,
  Bi,
  Ci,
  Cm,
  Cp,
  Dm,
  Dp,
  Em,
  Ep,
  Er,
  Gm,
  Go,
  It,
  Jl,
  Jp,
  Jt as Jt2,
  Jv,
  K,
  Kv,
  Lm,
  Lo,
  Lt,
  Mi,
  Mm,
  Np,
  Og,
  Om,
  Ov,
  Pt,
  Qv,
  Sp,
  Td,
  Tp,
  Vn,
  Vp,
  Wp,
  Wt,
  Xv,
  Yp,
  _n,
  ae,
  ay,
  bp,
  c0,
  ca,
  cy,
  d0,
  da,
  dg,
  du,
  dy,
  eb,
  el,
  ey,
  f0,
  fa,
  fy,
  gy,
  h0,
  hy,
  iy,
  ji,
  jn,
  jp,
  jy,
  km,
  kp,
  l0,
  lu,
  ly,
  m0,
  mt,
  my,
  np,
  ny,
  op,
  ou,
  oy,
  p0,
  pp,
  pt,
  py,
  qr,
  qs,
  qv,
  rp,
  rr,
  ry,
  s0,
  su,
  sy,
  tl as tl2,
  tr,
  tt,
  tu,
  ty,
  u0,
  ua,
  ur,
  uy,
  vl as vl2,
  vp,
  vy,
  wm,
  wp,
  wu,
  xd,
  xg,
  yl,
  yo,
  yp,
  zn,
  zp,
  zy
} from "./chunk-EU42VC65.js";
import {
  M
} from "./chunk-4OORONJH.js";
import {
  Ae,
  Cl,
  Cr,
  Ee,
  Gr,
  Ho,
  Ie,
  Jo,
  Jr,
  Jt,
  Nt,
  Nu,
  Pe,
  Ps,
  R,
  Te,
  Tl,
  Xl,
  Ye,
  Yo,
  Zr,
  Zu,
  al,
  an,
  at,
  bl,
  bn,
  cn,
  de,
  dl,
  fe,
  fs,
  gs,
  ke,
  ki,
  kr,
  kt,
  ll,
  ln,
  md,
  nn,
  pa,
  rl,
  si,
  sl,
  tl,
  ve,
  vl,
  vs,
  wl,
  ws,
  xe,
  xl
} from "./chunk-OXS4RIMJ.js";
import {
  Gu,
  ze
} from "./chunk-STL2KGEZ.js";
import {
  c,
  e
} from "./chunk-LZZZ25U2.js";
import {
  q,
  r,
  s,
  t,
  u,
  v,
  w,
  x
} from "./chunk-ASEP6WC2.js";

// node_modules/@mappedin/mappedin-js/lib/esm/chunk-G2WDUYHG.js
var yb = q((Wf, Xf) => {
  c();
  (function(r3, t3) {
    typeof Wf == "object" && typeof Xf < "u" ? Xf.exports = t3() : typeof define == "function" && define.amd ? define(t3) : (r3 = r3 || self).RBush = t3();
  })(Wf, function() {
    "use strict";
    function r3(y, S, T, w2, M2) {
      (function D(F, A, k, B, G) {
        for (; B > k; ) {
          if (B - k > 600) {
            var V = B - k + 1, W = A - k + 1, $ = Math.log(V), U = 0.5 * Math.exp(2 * $ / 3), ie = 0.5 * Math.sqrt($ * U * (V - U) / V) * (W - V / 2 < 0 ? -1 : 1), Z = Math.max(k, Math.floor(A - W * U / V + ie)), Ee2 = Math.min(B, Math.floor(A + (V - W) * U / V + ie));
            D(F, A, Z, Ee2, G);
          }
          var ue = F[A], ge = k, xe2 = B;
          for (t3(F, k, A), G(F[B], ue) > 0 && t3(F, k, B); ge < xe2; ) {
            for (t3(F, ge, xe2), ge++, xe2--; G(F[ge], ue) < 0; ) ge++;
            for (; G(F[xe2], ue) > 0; ) xe2--;
          }
          G(F[k], ue) === 0 ? t3(F, k, xe2) : t3(F, ++xe2, B), xe2 <= A && (k = xe2 + 1), A <= xe2 && (B = xe2 - 1);
        }
      })(y, S, T || 0, w2 || y.length - 1, M2 || e2);
    }
    function t3(y, S, T) {
      var w2 = y[S];
      y[S] = y[T], y[T] = w2;
    }
    function e2(y, S) {
      return y < S ? -1 : y > S ? 1 : 0;
    }
    var i = function(y) {
      y === void 0 && (y = 9), this._maxEntries = Math.max(4, y), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), this.clear();
    };
    function o(y, S, T) {
      if (!T) return S.indexOf(y);
      for (var w2 = 0; w2 < S.length; w2++) if (T(y, S[w2])) return w2;
      return -1;
    }
    function n(y, S) {
      s2(y, 0, y.children.length, S, y);
    }
    function s2(y, S, T, w2, M2) {
      M2 || (M2 = b(null)), M2.minX = 1 / 0, M2.minY = 1 / 0, M2.maxX = -1 / 0, M2.maxY = -1 / 0;
      for (var D = S; D < T; D++) {
        var F = y.children[D];
        c2(M2, y.leaf ? w2(F) : F);
      }
      return M2;
    }
    function c2(y, S) {
      return y.minX = Math.min(y.minX, S.minX), y.minY = Math.min(y.minY, S.minY), y.maxX = Math.max(y.maxX, S.maxX), y.maxY = Math.max(y.maxY, S.maxY), y;
    }
    function l(y, S) {
      return y.minX - S.minX;
    }
    function p(y, S) {
      return y.minY - S.minY;
    }
    function d(y) {
      return (y.maxX - y.minX) * (y.maxY - y.minY);
    }
    function f(y) {
      return y.maxX - y.minX + (y.maxY - y.minY);
    }
    function g(y, S) {
      return y.minX <= S.minX && y.minY <= S.minY && S.maxX <= y.maxX && S.maxY <= y.maxY;
    }
    function v2(y, S) {
      return S.minX <= y.maxX && S.minY <= y.maxY && S.maxX >= y.minX && S.maxY >= y.minY;
    }
    function b(y) {
      return { children: y, height: 1, leaf: true, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
    }
    function C(y, S, T, w2, M2) {
      for (var D = [S, T]; D.length; ) if (!((T = D.pop()) - (S = D.pop()) <= w2)) {
        var F = S + Math.ceil((T - S) / w2 / 2) * w2;
        r3(y, F, S, T, M2), D.push(S, F, F, T);
      }
    }
    return i.prototype.all = function() {
      return this._all(this.data, []);
    }, i.prototype.search = function(y) {
      var S = this.data, T = [];
      if (!v2(y, S)) return T;
      for (var w2 = this.toBBox, M2 = []; S; ) {
        for (var D = 0; D < S.children.length; D++) {
          var F = S.children[D], A = S.leaf ? w2(F) : F;
          v2(y, A) && (S.leaf ? T.push(F) : g(y, A) ? this._all(F, T) : M2.push(F));
        }
        S = M2.pop();
      }
      return T;
    }, i.prototype.collides = function(y) {
      var S = this.data;
      if (!v2(y, S)) return false;
      for (var T = []; S; ) {
        for (var w2 = 0; w2 < S.children.length; w2++) {
          var M2 = S.children[w2], D = S.leaf ? this.toBBox(M2) : M2;
          if (v2(y, D)) {
            if (S.leaf || g(y, D)) return true;
            T.push(M2);
          }
        }
        S = T.pop();
      }
      return false;
    }, i.prototype.load = function(y) {
      if (!y || !y.length) return this;
      if (y.length < this._minEntries) {
        for (var S = 0; S < y.length; S++) this.insert(y[S]);
        return this;
      }
      var T = this._build(y.slice(), 0, y.length - 1, 0);
      if (this.data.children.length) if (this.data.height === T.height) this._splitRoot(this.data, T);
      else {
        if (this.data.height < T.height) {
          var w2 = this.data;
          this.data = T, T = w2;
        }
        this._insert(T, this.data.height - T.height - 1, true);
      }
      else this.data = T;
      return this;
    }, i.prototype.insert = function(y) {
      return y && this._insert(y, this.data.height - 1), this;
    }, i.prototype.clear = function() {
      return this.data = b([]), this;
    }, i.prototype.remove = function(y, S) {
      if (!y) return this;
      for (var T, w2, M2, D = this.data, F = this.toBBox(y), A = [], k = []; D || A.length; ) {
        if (D || (D = A.pop(), w2 = A[A.length - 1], T = k.pop(), M2 = true), D.leaf) {
          var B = o(y, D.children, S);
          if (B !== -1) return D.children.splice(B, 1), A.push(D), this._condense(A), this;
        }
        M2 || D.leaf || !g(D, F) ? w2 ? (T++, D = w2.children[T], M2 = false) : D = null : (A.push(D), k.push(T), T = 0, w2 = D, D = D.children[0]);
      }
      return this;
    }, i.prototype.toBBox = function(y) {
      return y;
    }, i.prototype.compareMinX = function(y, S) {
      return y.minX - S.minX;
    }, i.prototype.compareMinY = function(y, S) {
      return y.minY - S.minY;
    }, i.prototype.toJSON = function() {
      return this.data;
    }, i.prototype.fromJSON = function(y) {
      return this.data = y, this;
    }, i.prototype._all = function(y, S) {
      for (var T = []; y; ) y.leaf ? S.push.apply(S, y.children) : T.push.apply(T, y.children), y = T.pop();
      return S;
    }, i.prototype._build = function(y, S, T, w2) {
      var M2, D = T - S + 1, F = this._maxEntries;
      if (D <= F) return n(M2 = b(y.slice(S, T + 1)), this.toBBox), M2;
      w2 || (w2 = Math.ceil(Math.log(D) / Math.log(F)), F = Math.ceil(D / Math.pow(F, w2 - 1))), (M2 = b([])).leaf = false, M2.height = w2;
      var A = Math.ceil(D / F), k = A * Math.ceil(Math.sqrt(F));
      C(y, S, T, k, this.compareMinX);
      for (var B = S; B <= T; B += k) {
        var G = Math.min(B + k - 1, T);
        C(y, B, G, A, this.compareMinY);
        for (var V = B; V <= G; V += A) {
          var W = Math.min(V + A - 1, G);
          M2.children.push(this._build(y, V, W, w2 - 1));
        }
      }
      return n(M2, this.toBBox), M2;
    }, i.prototype._chooseSubtree = function(y, S, T, w2) {
      for (; w2.push(S), !S.leaf && w2.length - 1 !== T; ) {
        for (var M2 = 1 / 0, D = 1 / 0, F = void 0, A = 0; A < S.children.length; A++) {
          var k = S.children[A], B = d(k), G = (V = y, W = k, (Math.max(W.maxX, V.maxX) - Math.min(W.minX, V.minX)) * (Math.max(W.maxY, V.maxY) - Math.min(W.minY, V.minY)) - B);
          G < D ? (D = G, M2 = B < M2 ? B : M2, F = k) : G === D && B < M2 && (M2 = B, F = k);
        }
        S = F || S.children[0];
      }
      var V, W;
      return S;
    }, i.prototype._insert = function(y, S, T) {
      var w2 = T ? y : this.toBBox(y), M2 = [], D = this._chooseSubtree(w2, this.data, S, M2);
      for (D.children.push(y), c2(D, w2); S >= 0 && M2[S].children.length > this._maxEntries; ) this._split(M2, S), S--;
      this._adjustParentBBoxes(w2, M2, S);
    }, i.prototype._split = function(y, S) {
      var T = y[S], w2 = T.children.length, M2 = this._minEntries;
      this._chooseSplitAxis(T, M2, w2);
      var D = this._chooseSplitIndex(T, M2, w2), F = b(T.children.splice(D, T.children.length - D));
      F.height = T.height, F.leaf = T.leaf, n(T, this.toBBox), n(F, this.toBBox), S ? y[S - 1].children.push(F) : this._splitRoot(T, F);
    }, i.prototype._splitRoot = function(y, S) {
      this.data = b([y, S]), this.data.height = y.height + 1, this.data.leaf = false, n(this.data, this.toBBox);
    }, i.prototype._chooseSplitIndex = function(y, S, T) {
      for (var w2, M2, D, F, A, k, B, G = 1 / 0, V = 1 / 0, W = S; W <= T - S; W++) {
        var $ = s2(y, 0, W, this.toBBox), U = s2(y, W, T, this.toBBox), ie = (M2 = $, D = U, F = void 0, A = void 0, k = void 0, B = void 0, F = Math.max(M2.minX, D.minX), A = Math.max(M2.minY, D.minY), k = Math.min(M2.maxX, D.maxX), B = Math.min(M2.maxY, D.maxY), Math.max(0, k - F) * Math.max(0, B - A)), Z = d($) + d(U);
        ie < G ? (G = ie, w2 = W, V = Z < V ? Z : V) : ie === G && Z < V && (V = Z, w2 = W);
      }
      return w2 || T - S;
    }, i.prototype._chooseSplitAxis = function(y, S, T) {
      var w2 = y.leaf ? this.compareMinX : l, M2 = y.leaf ? this.compareMinY : p;
      this._allDistMargin(y, S, T, w2) < this._allDistMargin(y, S, T, M2) && y.children.sort(w2);
    }, i.prototype._allDistMargin = function(y, S, T, w2) {
      y.children.sort(w2);
      for (var M2 = this.toBBox, D = s2(y, 0, S, M2), F = s2(y, T - S, T, M2), A = f(D) + f(F), k = S; k < T - S; k++) {
        var B = y.children[k];
        c2(D, y.leaf ? M2(B) : B), A += f(D);
      }
      for (var G = T - S - 1; G >= S; G--) {
        var V = y.children[G];
        c2(F, y.leaf ? M2(V) : V), A += f(F);
      }
      return A;
    }, i.prototype._adjustParentBBoxes = function(y, S, T) {
      for (var w2 = T; w2 >= 0; w2--) c2(S[w2], y);
    }, i.prototype._condense = function(y) {
      for (var S = y.length - 1, T = void 0; S >= 0; S--) y[S].children.length === 0 ? S > 0 ? (T = y[S - 1].children).splice(T.indexOf(y[S]), 1) : this.clear() : n(y[S], this.toBBox);
    }, i;
  });
});
var $f = q((J) => {
  "use strict";
  c();
  Object.defineProperty(J, "__esModule", { value: true });
  J.earthRadius = 63710088e-1;
  J.factors = { centimeters: J.earthRadius * 100, centimetres: J.earthRadius * 100, degrees: J.earthRadius / 111325, feet: J.earthRadius * 3.28084, inches: J.earthRadius * 39.37, kilometers: J.earthRadius / 1e3, kilometres: J.earthRadius / 1e3, meters: J.earthRadius, metres: J.earthRadius, miles: J.earthRadius / 1609.344, millimeters: J.earthRadius * 1e3, millimetres: J.earthRadius * 1e3, nauticalmiles: J.earthRadius / 1852, radians: 1, yards: J.earthRadius * 1.0936 };
  J.unitsFactors = { centimeters: 100, centimetres: 100, degrees: 1 / 111325, feet: 3.28084, inches: 39.37, kilometers: 1 / 1e3, kilometres: 1 / 1e3, meters: 1, metres: 1, miles: 1 / 1609.344, millimeters: 1e3, millimetres: 1e3, nauticalmiles: 1 / 1852, radians: 1 / J.earthRadius, yards: 1.0936133 };
  J.areaFactors = { acres: 247105e-9, centimeters: 1e4, centimetres: 1e4, feet: 10.763910417, hectares: 1e-4, inches: 1550.003100006, kilometers: 1e-6, kilometres: 1e-6, meters: 1, metres: 1, miles: 386e-9, millimeters: 1e6, millimetres: 1e6, yards: 1.195990046 };
  function mo(r3, t3, e2) {
    e2 === void 0 && (e2 = {});
    var i = { type: "Feature" };
    return (e2.id === 0 || e2.id) && (i.id = e2.id), e2.bbox && (i.bbox = e2.bbox), i.properties = t3 || {}, i.geometry = r3, i;
  }
  J.feature = mo;
  function b7(r3, t3, e2) {
    switch (e2 === void 0 && (e2 = {}), r3) {
      case "Point":
        return Yf(t3).geometry;
      case "LineString":
        return zf(t3).geometry;
      case "Polygon":
        return Zf(t3).geometry;
      case "MultiPoint":
        return vb(t3).geometry;
      case "MultiLineString":
        return bb(t3).geometry;
      case "MultiPolygon":
        return Cb(t3).geometry;
      default:
        throw new Error(r3 + " is invalid");
    }
  }
  J.geometry = b7;
  function Yf(r3, t3, e2) {
    if (e2 === void 0 && (e2 = {}), !r3) throw new Error("coordinates is required");
    if (!Array.isArray(r3)) throw new Error("coordinates must be an Array");
    if (r3.length < 2) throw new Error("coordinates must be at least 2 numbers long");
    if (!Nu2(r3[0]) || !Nu2(r3[1])) throw new Error("coordinates must contain numbers");
    var i = { type: "Point", coordinates: r3 };
    return mo(i, t3, e2);
  }
  J.point = Yf;
  function v7(r3, t3, e2) {
    return e2 === void 0 && (e2 = {}), Gu2(r3.map(function(i) {
      return Yf(i, t3);
    }), e2);
  }
  J.points = v7;
  function Zf(r3, t3, e2) {
    e2 === void 0 && (e2 = {});
    for (var i = 0, o = r3; i < o.length; i++) {
      var n = o[i];
      if (n.length < 4) throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
      for (var s2 = 0; s2 < n[n.length - 1].length; s2++) if (n[n.length - 1][s2] !== n[0][s2]) throw new Error("First and last Position are not equivalent.");
    }
    var c2 = { type: "Polygon", coordinates: r3 };
    return mo(c2, t3, e2);
  }
  J.polygon = Zf;
  function C7(r3, t3, e2) {
    return e2 === void 0 && (e2 = {}), Gu2(r3.map(function(i) {
      return Zf(i, t3);
    }), e2);
  }
  J.polygons = C7;
  function zf(r3, t3, e2) {
    if (e2 === void 0 && (e2 = {}), r3.length < 2) throw new Error("coordinates must be an array of two or more positions");
    var i = { type: "LineString", coordinates: r3 };
    return mo(i, t3, e2);
  }
  J.lineString = zf;
  function S7(r3, t3, e2) {
    return e2 === void 0 && (e2 = {}), Gu2(r3.map(function(i) {
      return zf(i, t3);
    }), e2);
  }
  J.lineStrings = S7;
  function Gu2(r3, t3) {
    t3 === void 0 && (t3 = {});
    var e2 = { type: "FeatureCollection" };
    return t3.id && (e2.id = t3.id), t3.bbox && (e2.bbox = t3.bbox), e2.features = r3, e2;
  }
  J.featureCollection = Gu2;
  function bb(r3, t3, e2) {
    e2 === void 0 && (e2 = {});
    var i = { type: "MultiLineString", coordinates: r3 };
    return mo(i, t3, e2);
  }
  J.multiLineString = bb;
  function vb(r3, t3, e2) {
    e2 === void 0 && (e2 = {});
    var i = { type: "MultiPoint", coordinates: r3 };
    return mo(i, t3, e2);
  }
  J.multiPoint = vb;
  function Cb(r3, t3, e2) {
    e2 === void 0 && (e2 = {});
    var i = { type: "MultiPolygon", coordinates: r3 };
    return mo(i, t3, e2);
  }
  J.multiPolygon = Cb;
  function x7(r3, t3, e2) {
    e2 === void 0 && (e2 = {});
    var i = { type: "GeometryCollection", geometries: r3 };
    return mo(i, t3, e2);
  }
  J.geometryCollection = x7;
  function I7(r3, t3) {
    if (t3 === void 0 && (t3 = 0), t3 && !(t3 >= 0)) throw new Error("precision must be a positive number");
    var e2 = Math.pow(10, t3 || 0);
    return Math.round(r3 * e2) / e2;
  }
  J.round = I7;
  function Sb(r3, t3) {
    t3 === void 0 && (t3 = "kilometers");
    var e2 = J.factors[t3];
    if (!e2) throw new Error(t3 + " units is invalid");
    return r3 * e2;
  }
  J.radiansToLength = Sb;
  function qf(r3, t3) {
    t3 === void 0 && (t3 = "kilometers");
    var e2 = J.factors[t3];
    if (!e2) throw new Error(t3 + " units is invalid");
    return r3 / e2;
  }
  J.lengthToRadians = qf;
  function P7(r3, t3) {
    return xb(qf(r3, t3));
  }
  J.lengthToDegrees = P7;
  function M7(r3) {
    var t3 = r3 % 360;
    return t3 < 0 && (t3 += 360), t3;
  }
  J.bearingToAzimuth = M7;
  function xb(r3) {
    var t3 = r3 % (2 * Math.PI);
    return t3 * 180 / Math.PI;
  }
  J.radiansToDegrees = xb;
  function T7(r3) {
    var t3 = r3 % 360;
    return t3 * Math.PI / 180;
  }
  J.degreesToRadians = T7;
  function w7(r3, t3, e2) {
    if (t3 === void 0 && (t3 = "kilometers"), e2 === void 0 && (e2 = "kilometers"), !(r3 >= 0)) throw new Error("length must be a positive number");
    return Sb(qf(r3, t3), e2);
  }
  J.convertLength = w7;
  function D7(r3, t3, e2) {
    if (t3 === void 0 && (t3 = "meters"), e2 === void 0 && (e2 = "kilometers"), !(r3 >= 0)) throw new Error("area must be a positive number");
    var i = J.areaFactors[t3];
    if (!i) throw new Error("invalid original units");
    var o = J.areaFactors[e2];
    if (!o) throw new Error("invalid final units");
    return r3 / i * o;
  }
  J.convertArea = D7;
  function Nu2(r3) {
    return !isNaN(r3) && r3 !== null && !Array.isArray(r3);
  }
  J.isNumber = Nu2;
  function E7(r3) {
    return !!r3 && r3.constructor === Object;
  }
  J.isObject = E7;
  function O7(r3) {
    if (!r3) throw new Error("bbox is required");
    if (!Array.isArray(r3)) throw new Error("bbox must be an Array");
    if (r3.length !== 4 && r3.length !== 6) throw new Error("bbox must be an Array of 4 or 6 numbers");
    r3.forEach(function(t3) {
      if (!Nu2(t3)) throw new Error("bbox must only contain numbers");
    });
  }
  J.validateBBox = O7;
  function L7(r3) {
    if (!r3) throw new Error("id is required");
    if (["string", "number"].indexOf(typeof r3) === -1) throw new Error("id must be a number or a string");
  }
  J.validateId = L7;
});
var wb = q((Ye2) => {
  "use strict";
  c();
  Object.defineProperty(Ye2, "__esModule", { value: true });
  var mt2 = $f();
  function xl2(r3, t3, e2) {
    if (r3 !== null) for (var i, o, n, s2, c2, l, p, d = 0, f = 0, g, v2 = r3.type, b = v2 === "FeatureCollection", C = v2 === "Feature", y = b ? r3.features.length : 1, S = 0; S < y; S++) {
      p = b ? r3.features[S].geometry : C ? r3.geometry : r3, g = p ? p.type === "GeometryCollection" : false, c2 = g ? p.geometries.length : 1;
      for (var T = 0; T < c2; T++) {
        var w2 = 0, M2 = 0;
        if (s2 = g ? p.geometries[T] : p, s2 !== null) {
          l = s2.coordinates;
          var D = s2.type;
          switch (d = e2 && (D === "Polygon" || D === "MultiPolygon") ? 1 : 0, D) {
            case null:
              break;
            case "Point":
              if (t3(l, f, S, w2, M2) === false) return false;
              f++, w2++;
              break;
            case "LineString":
            case "MultiPoint":
              for (i = 0; i < l.length; i++) {
                if (t3(l[i], f, S, w2, M2) === false) return false;
                f++, D === "MultiPoint" && w2++;
              }
              D === "LineString" && w2++;
              break;
            case "Polygon":
            case "MultiLineString":
              for (i = 0; i < l.length; i++) {
                for (o = 0; o < l[i].length - d; o++) {
                  if (t3(l[i][o], f, S, w2, M2) === false) return false;
                  f++;
                }
                D === "MultiLineString" && w2++, D === "Polygon" && M2++;
              }
              D === "Polygon" && w2++;
              break;
            case "MultiPolygon":
              for (i = 0; i < l.length; i++) {
                for (M2 = 0, o = 0; o < l[i].length; o++) {
                  for (n = 0; n < l[i][o].length - d; n++) {
                    if (t3(l[i][o][n], f, S, w2, M2) === false) return false;
                    f++;
                  }
                  M2++;
                }
                w2++;
              }
              break;
            case "GeometryCollection":
              for (i = 0; i < s2.geometries.length; i++) if (xl2(s2.geometries[i], t3, e2) === false) return false;
              break;
            default:
              throw new Error("Unknown Geometry Type");
          }
        }
      }
    }
  }
  function A7(r3, t3, e2, i) {
    var o = e2;
    return xl2(r3, function(n, s2, c2, l, p) {
      s2 === 0 && e2 === void 0 ? o = n : o = t3(o, n, s2, c2, l, p);
    }, i), o;
  }
  function Ib(r3, t3) {
    var e2;
    switch (r3.type) {
      case "FeatureCollection":
        for (e2 = 0; e2 < r3.features.length && t3(r3.features[e2].properties, e2) !== false; e2++) ;
        break;
      case "Feature":
        t3(r3.properties, 0);
        break;
    }
  }
  function F7(r3, t3, e2) {
    var i = e2;
    return Ib(r3, function(o, n) {
      n === 0 && e2 === void 0 ? i = o : i = t3(i, o, n);
    }), i;
  }
  function Pb(r3, t3) {
    if (r3.type === "Feature") t3(r3, 0);
    else if (r3.type === "FeatureCollection") for (var e2 = 0; e2 < r3.features.length && t3(r3.features[e2], e2) !== false; e2++) ;
  }
  function k7(r3, t3, e2) {
    var i = e2;
    return Pb(r3, function(o, n) {
      n === 0 && e2 === void 0 ? i = o : i = t3(i, o, n);
    }), i;
  }
  function B7(r3) {
    var t3 = [];
    return xl2(r3, function(e2) {
      t3.push(e2);
    }), t3;
  }
  function Jf(r3, t3) {
    var e2, i, o, n, s2, c2, l, p, d, f, g = 0, v2 = r3.type === "FeatureCollection", b = r3.type === "Feature", C = v2 ? r3.features.length : 1;
    for (e2 = 0; e2 < C; e2++) {
      for (c2 = v2 ? r3.features[e2].geometry : b ? r3.geometry : r3, p = v2 ? r3.features[e2].properties : b ? r3.properties : {}, d = v2 ? r3.features[e2].bbox : b ? r3.bbox : void 0, f = v2 ? r3.features[e2].id : b ? r3.id : void 0, l = c2 ? c2.type === "GeometryCollection" : false, s2 = l ? c2.geometries.length : 1, o = 0; o < s2; o++) {
        if (n = l ? c2.geometries[o] : c2, n === null) {
          if (t3(null, g, p, d, f) === false) return false;
          continue;
        }
        switch (n.type) {
          case "Point":
          case "LineString":
          case "MultiPoint":
          case "Polygon":
          case "MultiLineString":
          case "MultiPolygon": {
            if (t3(n, g, p, d, f) === false) return false;
            break;
          }
          case "GeometryCollection": {
            for (i = 0; i < n.geometries.length; i++) if (t3(n.geometries[i], g, p, d, f) === false) return false;
            break;
          }
          default:
            throw new Error("Unknown Geometry Type");
        }
      }
      g++;
    }
  }
  function _7(r3, t3, e2) {
    var i = e2;
    return Jf(r3, function(o, n, s2, c2, l) {
      n === 0 && e2 === void 0 ? i = o : i = t3(i, o, n, s2, c2, l);
    }), i;
  }
  function Vu(r3, t3) {
    Jf(r3, function(e2, i, o, n, s2) {
      var c2 = e2 === null ? null : e2.type;
      switch (c2) {
        case null:
        case "Point":
        case "LineString":
        case "Polygon":
          return t3(mt2.feature(e2, o, { bbox: n, id: s2 }), i, 0) === false ? false : void 0;
      }
      var l;
      switch (c2) {
        case "MultiPoint":
          l = "Point";
          break;
        case "MultiLineString":
          l = "LineString";
          break;
        case "MultiPolygon":
          l = "Polygon";
          break;
      }
      for (var p = 0; p < e2.coordinates.length; p++) {
        var d = e2.coordinates[p], f = { type: l, coordinates: d };
        if (t3(mt2.feature(f, o), i, p) === false) return false;
      }
    });
  }
  function R7(r3, t3, e2) {
    var i = e2;
    return Vu(r3, function(o, n, s2) {
      n === 0 && s2 === 0 && e2 === void 0 ? i = o : i = t3(i, o, n, s2);
    }), i;
  }
  function Mb(r3, t3) {
    Vu(r3, function(e2, i, o) {
      var n = 0;
      if (e2.geometry) {
        var s2 = e2.geometry.type;
        if (!(s2 === "Point" || s2 === "MultiPoint")) {
          var c2, l = 0, p = 0, d = 0;
          if (xl2(e2, function(f, g, v2, b, C) {
            if (c2 === void 0 || i > l || b > p || C > d) {
              c2 = f, l = i, p = b, d = C, n = 0;
              return;
            }
            var y = mt2.lineString([c2, f], e2.properties);
            if (t3(y, i, o, C, n) === false) return false;
            n++, c2 = f;
          }) === false) return false;
        }
      }
    });
  }
  function N7(r3, t3, e2) {
    var i = e2, o = false;
    return Mb(r3, function(n, s2, c2, l, p) {
      o === false && e2 === void 0 ? i = n : i = t3(i, n, s2, c2, l, p), o = true;
    }), i;
  }
  function Tb(r3, t3) {
    if (!r3) throw new Error("geojson is required");
    Vu(r3, function(e2, i, o) {
      if (e2.geometry !== null) {
        var n = e2.geometry.type, s2 = e2.geometry.coordinates;
        switch (n) {
          case "LineString":
            if (t3(e2, i, o, 0, 0) === false) return false;
            break;
          case "Polygon":
            for (var c2 = 0; c2 < s2.length; c2++) if (t3(mt2.lineString(s2[c2], e2.properties), i, o, c2) === false) return false;
            break;
        }
      }
    });
  }
  function G7(r3, t3, e2) {
    var i = e2;
    return Tb(r3, function(o, n, s2, c2) {
      n === 0 && e2 === void 0 ? i = o : i = t3(i, o, n, s2, c2);
    }), i;
  }
  function V7(r3, t3) {
    if (t3 = t3 || {}, !mt2.isObject(t3)) throw new Error("options is invalid");
    var e2 = t3.featureIndex || 0, i = t3.multiFeatureIndex || 0, o = t3.geometryIndex || 0, n = t3.segmentIndex || 0, s2 = t3.properties, c2;
    switch (r3.type) {
      case "FeatureCollection":
        e2 < 0 && (e2 = r3.features.length + e2), s2 = s2 || r3.features[e2].properties, c2 = r3.features[e2].geometry;
        break;
      case "Feature":
        s2 = s2 || r3.properties, c2 = r3.geometry;
        break;
      case "Point":
      case "MultiPoint":
        return null;
      case "LineString":
      case "Polygon":
      case "MultiLineString":
      case "MultiPolygon":
        c2 = r3;
        break;
      default:
        throw new Error("geojson is invalid");
    }
    if (c2 === null) return null;
    var l = c2.coordinates;
    switch (c2.type) {
      case "Point":
      case "MultiPoint":
        return null;
      case "LineString":
        return n < 0 && (n = l.length + n - 1), mt2.lineString([l[n], l[n + 1]], s2, t3);
      case "Polygon":
        return o < 0 && (o = l.length + o), n < 0 && (n = l[o].length + n - 1), mt2.lineString([l[o][n], l[o][n + 1]], s2, t3);
      case "MultiLineString":
        return i < 0 && (i = l.length + i), n < 0 && (n = l[i].length + n - 1), mt2.lineString([l[i][n], l[i][n + 1]], s2, t3);
      case "MultiPolygon":
        return i < 0 && (i = l.length + i), o < 0 && (o = l[i].length + o), n < 0 && (n = l[i][o].length - n - 1), mt2.lineString([l[i][o][n], l[i][o][n + 1]], s2, t3);
    }
    throw new Error("geojson is invalid");
  }
  function j7(r3, t3) {
    if (t3 = t3 || {}, !mt2.isObject(t3)) throw new Error("options is invalid");
    var e2 = t3.featureIndex || 0, i = t3.multiFeatureIndex || 0, o = t3.geometryIndex || 0, n = t3.coordIndex || 0, s2 = t3.properties, c2;
    switch (r3.type) {
      case "FeatureCollection":
        e2 < 0 && (e2 = r3.features.length + e2), s2 = s2 || r3.features[e2].properties, c2 = r3.features[e2].geometry;
        break;
      case "Feature":
        s2 = s2 || r3.properties, c2 = r3.geometry;
        break;
      case "Point":
      case "MultiPoint":
        return null;
      case "LineString":
      case "Polygon":
      case "MultiLineString":
      case "MultiPolygon":
        c2 = r3;
        break;
      default:
        throw new Error("geojson is invalid");
    }
    if (c2 === null) return null;
    var l = c2.coordinates;
    switch (c2.type) {
      case "Point":
        return mt2.point(l, s2, t3);
      case "MultiPoint":
        return i < 0 && (i = l.length + i), mt2.point(l[i], s2, t3);
      case "LineString":
        return n < 0 && (n = l.length + n), mt2.point(l[n], s2, t3);
      case "Polygon":
        return o < 0 && (o = l.length + o), n < 0 && (n = l[o].length + n), mt2.point(l[o][n], s2, t3);
      case "MultiLineString":
        return i < 0 && (i = l.length + i), n < 0 && (n = l[i].length + n), mt2.point(l[i][n], s2, t3);
      case "MultiPolygon":
        return i < 0 && (i = l.length + i), o < 0 && (o = l[i].length + o), n < 0 && (n = l[i][o].length - n), mt2.point(l[i][o][n], s2, t3);
    }
    throw new Error("geojson is invalid");
  }
  Ye2.coordAll = B7;
  Ye2.coordEach = xl2;
  Ye2.coordReduce = A7;
  Ye2.featureEach = Pb;
  Ye2.featureReduce = k7;
  Ye2.findPoint = j7;
  Ye2.findSegment = V7;
  Ye2.flattenEach = Vu;
  Ye2.flattenReduce = R7;
  Ye2.geomEach = Jf;
  Ye2.geomReduce = _7;
  Ye2.lineEach = Tb;
  Ye2.lineReduce = G7;
  Ye2.propEach = Ib;
  Ye2.propReduce = F7;
  Ye2.segmentEach = Mb;
  Ye2.segmentReduce = N7;
});
var Qf = q((yO, Eb) => {
  "use strict";
  c();
  var Db = Object.prototype.toString;
  Eb.exports = function(t3) {
    var e2 = Db.call(t3), i = e2 === "[object Arguments]";
    return i || (i = e2 !== "[object Array]" && t3 !== null && typeof t3 == "object" && typeof t3.length == "number" && t3.length >= 0 && Db.call(t3.callee) === "[object Function]"), i;
  };
});
var Nb = q((vO, Rb) => {
  "use strict";
  c();
  var _b;
  Object.keys || (Il = Object.prototype.hasOwnProperty, Kf = Object.prototype.toString, Ob = Qf(), em = Object.prototype.propertyIsEnumerable, Lb = !em.call({ toString: null }, "toString"), Ab = em.call(function() {
  }, "prototype"), Pl = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"], ju = function(r3) {
    var t3 = r3.constructor;
    return t3 && t3.prototype === r3;
  }, Fb = { $applicationCache: true, $console: true, $external: true, $frame: true, $frameElement: true, $frames: true, $innerHeight: true, $innerWidth: true, $onmozfullscreenchange: true, $onmozfullscreenerror: true, $outerHeight: true, $outerWidth: true, $pageXOffset: true, $pageYOffset: true, $parent: true, $scrollLeft: true, $scrollTop: true, $scrollX: true, $scrollY: true, $self: true, $webkitIndexedDB: true, $webkitStorageInfo: true, $window: true }, kb = function() {
    if (typeof window > "u") return false;
    for (var r3 in window) try {
      if (!Fb["$" + r3] && Il.call(window, r3) && window[r3] !== null && typeof window[r3] == "object") try {
        ju(window[r3]);
      } catch {
        return true;
      }
    } catch {
      return true;
    }
    return false;
  }(), Bb2 = function(r3) {
    if (typeof window > "u" || !kb) return ju(r3);
    try {
      return ju(r3);
    } catch {
      return false;
    }
  }, _b = function(t3) {
    var e2 = t3 !== null && typeof t3 == "object", i = Kf.call(t3) === "[object Function]", o = Ob(t3), n = e2 && Kf.call(t3) === "[object String]", s2 = [];
    if (!e2 && !i && !o) throw new TypeError("Object.keys called on a non-object");
    var c2 = Ab && i;
    if (n && t3.length > 0 && !Il.call(t3, 0)) for (var l = 0; l < t3.length; ++l) s2.push(String(l));
    if (o && t3.length > 0) for (var p = 0; p < t3.length; ++p) s2.push(String(p));
    else for (var d in t3) !(c2 && d === "prototype") && Il.call(t3, d) && s2.push(String(d));
    if (Lb) for (var f = Bb2(t3), g = 0; g < Pl.length; ++g) !(f && Pl[g] === "constructor") && Il.call(t3, Pl[g]) && s2.push(Pl[g]);
    return s2;
  });
  var Il, Kf, Ob, em, Lb, Ab, Pl, ju, Fb, kb, Bb2;
  Rb.exports = _b;
});
var Hu = q((SO, jb) => {
  "use strict";
  c();
  var U7 = Array.prototype.slice, H7 = Qf(), Gb = Object.keys, Uu = Gb ? function(t3) {
    return Gb(t3);
  } : Nb(), Vb = Object.keys;
  Uu.shim = function() {
    if (Object.keys) {
      var t3 = function() {
        var e2 = Object.keys(arguments);
        return e2 && e2.length === arguments.length;
      }(1, 2);
      t3 || (Object.keys = function(i) {
        return H7(i) ? Vb(U7.call(i)) : Vb(i);
      });
    } else Object.keys = Uu;
    return Object.keys || Uu;
  };
  jb.exports = Uu;
});
var Hb = q((IO, Ub) => {
  "use strict";
  c();
  Ub.exports = Error;
});
var Xb = q((MO, Wb) => {
  "use strict";
  c();
  Wb.exports = EvalError;
});
var Zb = q((wO, Yb) => {
  "use strict";
  c();
  Yb.exports = RangeError;
});
var qb = q((EO, zb) => {
  "use strict";
  c();
  zb.exports = ReferenceError;
});
var tm = q((LO, $b) => {
  "use strict";
  c();
  $b.exports = SyntaxError;
});
var Mi2 = q((FO, Jb) => {
  "use strict";
  c();
  Jb.exports = TypeError;
});
var Kb = q((BO, Qb) => {
  "use strict";
  c();
  Qb.exports = URIError;
});
var Ml = q((RO, ev) => {
  "use strict";
  c();
  ev.exports = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function") return false;
    if (typeof Symbol.iterator == "symbol") return true;
    var t3 = {}, e2 = Symbol("test"), i = Object(e2);
    if (typeof e2 == "string" || Object.prototype.toString.call(e2) !== "[object Symbol]" || Object.prototype.toString.call(i) !== "[object Symbol]") return false;
    var o = 42;
    t3[e2] = o;
    for (e2 in t3) return false;
    if (typeof Object.keys == "function" && Object.keys(t3).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(t3).length !== 0) return false;
    var n = Object.getOwnPropertySymbols(t3);
    if (n.length !== 1 || n[0] !== e2 || !Object.prototype.propertyIsEnumerable.call(t3, e2)) return false;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var s2 = Object.getOwnPropertyDescriptor(t3, e2);
      if (s2.value !== o || s2.enumerable !== true) return false;
    }
    return true;
  };
});
var Wu = q((GO, rv) => {
  "use strict";
  c();
  var tv = typeof Symbol < "u" && Symbol, W7 = Ml();
  rv.exports = function() {
    return typeof tv != "function" || typeof Symbol != "function" || typeof tv("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? false : W7();
  };
});
var ov = q((jO, iv) => {
  "use strict";
  c();
  var rm = { __proto__: null, foo: {} }, X7 = Object;
  iv.exports = function() {
    return { __proto__: rm }.foo === rm.foo && !(rm instanceof X7);
  };
});
var sv = q((HO, av) => {
  "use strict";
  c();
  var Y7 = "Function.prototype.bind called on incompatible ", Z7 = Object.prototype.toString, z7 = Math.max, q7 = "[object Function]", nv = function(t3, e2) {
    for (var i = [], o = 0; o < t3.length; o += 1) i[o] = t3[o];
    for (var n = 0; n < e2.length; n += 1) i[n + t3.length] = e2[n];
    return i;
  }, $7 = function(t3, e2) {
    for (var i = [], o = e2 || 0, n = 0; o < t3.length; o += 1, n += 1) i[n] = t3[o];
    return i;
  }, J7 = function(r3, t3) {
    for (var e2 = "", i = 0; i < r3.length; i += 1) e2 += r3[i], i + 1 < r3.length && (e2 += t3);
    return e2;
  };
  av.exports = function(t3) {
    var e2 = this;
    if (typeof e2 != "function" || Z7.apply(e2) !== q7) throw new TypeError(Y7 + e2);
    for (var i = $7(arguments, 1), o, n = function() {
      if (this instanceof o) {
        var d = e2.apply(this, nv(i, arguments));
        return Object(d) === d ? d : this;
      }
      return e2.apply(t3, nv(i, arguments));
    }, s2 = z7(0, e2.length - i.length), c2 = [], l = 0; l < s2; l++) c2[l] = "$" + l;
    if (o = Function("binder", "return function (" + J7(c2, ",") + "){ return binder.apply(this,arguments); }")(n), e2.prototype) {
      var p = function() {
      };
      p.prototype = e2.prototype, o.prototype = new p(), p.prototype = null;
    }
    return o;
  };
});
var Xu = q((XO, lv) => {
  "use strict";
  c();
  var Q7 = sv();
  lv.exports = Function.prototype.bind || Q7;
});
var im = q((ZO, cv) => {
  "use strict";
  c();
  var K7 = Function.prototype.call, e6 = Object.prototype.hasOwnProperty, t6 = Xu();
  cv.exports = t6.call(K7, e6);
});
var br = q((qO, fv) => {
  "use strict";
  c();
  var ce, r6 = Hb(), i6 = Xb(), o6 = Zb(), n6 = qb(), Za = tm(), Ya = Mi2(), a6 = Kb(), hv = Function, om = function(r3) {
    try {
      return hv('"use strict"; return (' + r3 + ").constructor;")();
    } catch {
    }
  }, Cn = Object.getOwnPropertyDescriptor;
  if (Cn) try {
    Cn({}, "");
  } catch {
    Cn = null;
  }
  var nm = function() {
    throw new Ya();
  }, s6 = Cn ? function() {
    try {
      return arguments.callee, nm;
    } catch {
      try {
        return Cn(arguments, "callee").get;
      } catch {
        return nm;
      }
    }
  }() : nm, Wa = Wu()(), l6 = ov()(), tt2 = Object.getPrototypeOf || (l6 ? function(r3) {
    return r3.__proto__;
  } : null), Xa = {}, c6 = typeof Uint8Array > "u" || !tt2 ? ce : tt2(Uint8Array), Sn = { __proto__: null, "%AggregateError%": typeof AggregateError > "u" ? ce : AggregateError, "%Array%": Array, "%ArrayBuffer%": typeof ArrayBuffer > "u" ? ce : ArrayBuffer, "%ArrayIteratorPrototype%": Wa && tt2 ? tt2([][Symbol.iterator]()) : ce, "%AsyncFromSyncIteratorPrototype%": ce, "%AsyncFunction%": Xa, "%AsyncGenerator%": Xa, "%AsyncGeneratorFunction%": Xa, "%AsyncIteratorPrototype%": Xa, "%Atomics%": typeof Atomics > "u" ? ce : Atomics, "%BigInt%": typeof BigInt > "u" ? ce : BigInt, "%BigInt64Array%": typeof BigInt64Array > "u" ? ce : BigInt64Array, "%BigUint64Array%": typeof BigUint64Array > "u" ? ce : BigUint64Array, "%Boolean%": Boolean, "%DataView%": typeof DataView > "u" ? ce : DataView, "%Date%": Date, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": r6, "%eval%": eval, "%EvalError%": i6, "%Float32Array%": typeof Float32Array > "u" ? ce : Float32Array, "%Float64Array%": typeof Float64Array > "u" ? ce : Float64Array, "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? ce : FinalizationRegistry, "%Function%": hv, "%GeneratorFunction%": Xa, "%Int8Array%": typeof Int8Array > "u" ? ce : Int8Array, "%Int16Array%": typeof Int16Array > "u" ? ce : Int16Array, "%Int32Array%": typeof Int32Array > "u" ? ce : Int32Array, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": Wa && tt2 ? tt2(tt2([][Symbol.iterator]())) : ce, "%JSON%": typeof JSON == "object" ? JSON : ce, "%Map%": typeof Map > "u" ? ce : Map, "%MapIteratorPrototype%": typeof Map > "u" || !Wa || !tt2 ? ce : tt2((/* @__PURE__ */ new Map())[Symbol.iterator]()), "%Math%": Math, "%Number%": Number, "%Object%": Object, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": typeof Promise > "u" ? ce : Promise, "%Proxy%": typeof Proxy > "u" ? ce : Proxy, "%RangeError%": o6, "%ReferenceError%": n6, "%Reflect%": typeof Reflect > "u" ? ce : Reflect, "%RegExp%": RegExp, "%Set%": typeof Set > "u" ? ce : Set, "%SetIteratorPrototype%": typeof Set > "u" || !Wa || !tt2 ? ce : tt2((/* @__PURE__ */ new Set())[Symbol.iterator]()), "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? ce : SharedArrayBuffer, "%String%": String, "%StringIteratorPrototype%": Wa && tt2 ? tt2(""[Symbol.iterator]()) : ce, "%Symbol%": Wa ? Symbol : ce, "%SyntaxError%": Za, "%ThrowTypeError%": s6, "%TypedArray%": c6, "%TypeError%": Ya, "%Uint8Array%": typeof Uint8Array > "u" ? ce : Uint8Array, "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? ce : Uint8ClampedArray, "%Uint16Array%": typeof Uint16Array > "u" ? ce : Uint16Array, "%Uint32Array%": typeof Uint32Array > "u" ? ce : Uint32Array, "%URIError%": a6, "%WeakMap%": typeof WeakMap > "u" ? ce : WeakMap, "%WeakRef%": typeof WeakRef > "u" ? ce : WeakRef, "%WeakSet%": typeof WeakSet > "u" ? ce : WeakSet };
  if (tt2) try {
    null.error;
  } catch (r3) {
    pv = tt2(tt2(r3)), Sn["%Error.prototype%"] = pv;
  }
  var pv, p6 = function r3(t3) {
    var e2;
    if (t3 === "%AsyncFunction%") e2 = om("async function () {}");
    else if (t3 === "%GeneratorFunction%") e2 = om("function* () {}");
    else if (t3 === "%AsyncGeneratorFunction%") e2 = om("async function* () {}");
    else if (t3 === "%AsyncGenerator%") {
      var i = r3("%AsyncGeneratorFunction%");
      i && (e2 = i.prototype);
    } else if (t3 === "%AsyncIteratorPrototype%") {
      var o = r3("%AsyncGenerator%");
      o && tt2 && (e2 = tt2(o.prototype));
    }
    return Sn[t3] = e2, e2;
  }, uv = { __proto__: null, "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"], "%ArrayPrototype%": ["Array", "prototype"], "%ArrayProto_entries%": ["Array", "prototype", "entries"], "%ArrayProto_forEach%": ["Array", "prototype", "forEach"], "%ArrayProto_keys%": ["Array", "prototype", "keys"], "%ArrayProto_values%": ["Array", "prototype", "values"], "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"], "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"], "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"], "%BooleanPrototype%": ["Boolean", "prototype"], "%DataViewPrototype%": ["DataView", "prototype"], "%DatePrototype%": ["Date", "prototype"], "%ErrorPrototype%": ["Error", "prototype"], "%EvalErrorPrototype%": ["EvalError", "prototype"], "%Float32ArrayPrototype%": ["Float32Array", "prototype"], "%Float64ArrayPrototype%": ["Float64Array", "prototype"], "%FunctionPrototype%": ["Function", "prototype"], "%Generator%": ["GeneratorFunction", "prototype"], "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"], "%Int8ArrayPrototype%": ["Int8Array", "prototype"], "%Int16ArrayPrototype%": ["Int16Array", "prototype"], "%Int32ArrayPrototype%": ["Int32Array", "prototype"], "%JSONParse%": ["JSON", "parse"], "%JSONStringify%": ["JSON", "stringify"], "%MapPrototype%": ["Map", "prototype"], "%NumberPrototype%": ["Number", "prototype"], "%ObjectPrototype%": ["Object", "prototype"], "%ObjProto_toString%": ["Object", "prototype", "toString"], "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"], "%PromisePrototype%": ["Promise", "prototype"], "%PromiseProto_then%": ["Promise", "prototype", "then"], "%Promise_all%": ["Promise", "all"], "%Promise_reject%": ["Promise", "reject"], "%Promise_resolve%": ["Promise", "resolve"], "%RangeErrorPrototype%": ["RangeError", "prototype"], "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"], "%RegExpPrototype%": ["RegExp", "prototype"], "%SetPrototype%": ["Set", "prototype"], "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"], "%StringPrototype%": ["String", "prototype"], "%SymbolPrototype%": ["Symbol", "prototype"], "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"], "%TypedArrayPrototype%": ["TypedArray", "prototype"], "%TypeErrorPrototype%": ["TypeError", "prototype"], "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"], "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"], "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"], "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"], "%URIErrorPrototype%": ["URIError", "prototype"], "%WeakMapPrototype%": ["WeakMap", "prototype"], "%WeakSetPrototype%": ["WeakSet", "prototype"] }, Tl2 = Xu(), Yu = im(), u6 = Tl2.call(Function.call, Array.prototype.concat), d6 = Tl2.call(Function.apply, Array.prototype.splice), dv = Tl2.call(Function.call, String.prototype.replace), Zu2 = Tl2.call(Function.call, String.prototype.slice), h6 = Tl2.call(Function.call, RegExp.prototype.exec), f6 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, m6 = /\\(\\)?/g, g6 = function(t3) {
    var e2 = Zu2(t3, 0, 1), i = Zu2(t3, -1);
    if (e2 === "%" && i !== "%") throw new Za("invalid intrinsic syntax, expected closing `%`");
    if (i === "%" && e2 !== "%") throw new Za("invalid intrinsic syntax, expected opening `%`");
    var o = [];
    return dv(t3, f6, function(n, s2, c2, l) {
      o[o.length] = c2 ? dv(l, m6, "$1") : s2 || n;
    }), o;
  }, y6 = function(t3, e2) {
    var i = t3, o;
    if (Yu(uv, i) && (o = uv[i], i = "%" + o[0] + "%"), Yu(Sn, i)) {
      var n = Sn[i];
      if (n === Xa && (n = p6(i)), typeof n > "u" && !e2) throw new Ya("intrinsic " + t3 + " exists, but is not available. Please file an issue!");
      return { alias: o, name: i, value: n };
    }
    throw new Za("intrinsic " + t3 + " does not exist!");
  };
  fv.exports = function(t3, e2) {
    if (typeof t3 != "string" || t3.length === 0) throw new Ya("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof e2 != "boolean") throw new Ya('"allowMissing" argument must be a boolean');
    if (h6(/^%?[^%]*%?$/, t3) === null) throw new Za("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var i = g6(t3), o = i.length > 0 ? i[0] : "", n = y6("%" + o + "%", e2), s2 = n.name, c2 = n.value, l = false, p = n.alias;
    p && (o = p[0], d6(i, u6([0, 1], p)));
    for (var d = 1, f = true; d < i.length; d += 1) {
      var g = i[d], v2 = Zu2(g, 0, 1), b = Zu2(g, -1);
      if ((v2 === '"' || v2 === "'" || v2 === "`" || b === '"' || b === "'" || b === "`") && v2 !== b) throw new Za("property names with quotes must have matching quotes");
      if ((g === "constructor" || !f) && (l = true), o += "." + g, s2 = "%" + o + "%", Yu(Sn, s2)) c2 = Sn[s2];
      else if (c2 != null) {
        if (!(g in c2)) {
          if (!e2) throw new Ya("base intrinsic for " + t3 + " exists, but the property is not available.");
          return;
        }
        if (Cn && d + 1 >= i.length) {
          var C = Cn(c2, g);
          f = !!C, f && "get" in C && !("originalValue" in C.get) ? c2 = C.get : c2 = c2[g];
        } else f = Yu(c2, g), c2 = c2[g];
        f && !l && (Sn[s2] = c2);
      }
    }
    return c2;
  };
});
var qu = q((JO, mv) => {
  "use strict";
  c();
  var b6 = br(), zu = b6("%Object.defineProperty%", true) || false;
  if (zu) try {
    zu({}, "a", { value: 1 });
  } catch {
    zu = false;
  }
  mv.exports = zu;
});
var Ju = q((KO, gv) => {
  "use strict";
  c();
  var v6 = br(), $u = v6("%Object.getOwnPropertyDescriptor%", true);
  if ($u) try {
    $u([], "length");
  } catch {
    $u = null;
  }
  gv.exports = $u;
});
var Qu = q((tL, vv) => {
  "use strict";
  c();
  var yv = qu(), C6 = tm(), za = Mi2(), bv = Ju();
  vv.exports = function(t3, e2, i) {
    if (!t3 || typeof t3 != "object" && typeof t3 != "function") throw new za("`obj` must be an object or a function`");
    if (typeof e2 != "string" && typeof e2 != "symbol") throw new za("`property` must be a string or a symbol`");
    if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null) throw new za("`nonEnumerable`, if provided, must be a boolean or null");
    if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null) throw new za("`nonWritable`, if provided, must be a boolean or null");
    if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null) throw new za("`nonConfigurable`, if provided, must be a boolean or null");
    if (arguments.length > 6 && typeof arguments[6] != "boolean") throw new za("`loose`, if provided, must be a boolean");
    var o = arguments.length > 3 ? arguments[3] : null, n = arguments.length > 4 ? arguments[4] : null, s2 = arguments.length > 5 ? arguments[5] : null, c2 = arguments.length > 6 ? arguments[6] : false, l = !!bv && bv(t3, e2);
    if (yv) yv(t3, e2, { configurable: s2 === null && l ? l.configurable : !s2, enumerable: o === null && l ? l.enumerable : !o, value: i, writable: n === null && l ? l.writable : !n });
    else if (c2 || !o && !n && !s2) t3[e2] = i;
    else throw new C6("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
  };
});
var Ku = q((iL, Sv) => {
  "use strict";
  c();
  var am = qu(), Cv = function() {
    return !!am;
  };
  Cv.hasArrayLengthDefineBug = function() {
    if (!am) return null;
    try {
      return am([], "length", { value: 1 }).length !== 1;
    } catch {
      return true;
    }
  };
  Sv.exports = Cv;
});
var go = q((nL, Mv) => {
  "use strict";
  c();
  var S6 = Hu(), x6 = typeof Symbol == "function" && typeof Symbol("foo") == "symbol", I6 = Object.prototype.toString, P6 = Array.prototype.concat, xv = Qu(), M6 = function(r3) {
    return typeof r3 == "function" && I6.call(r3) === "[object Function]";
  }, Iv = Ku()(), T6 = function(r3, t3, e2, i) {
    if (t3 in r3) {
      if (i === true) {
        if (r3[t3] === e2) return;
      } else if (!M6(i) || !i()) return;
    }
    Iv ? xv(r3, t3, e2, true) : xv(r3, t3, e2);
  }, Pv = function(r3, t3) {
    var e2 = arguments.length > 2 ? arguments[2] : {}, i = S6(t3);
    x6 && (i = P6.call(i, Object.getOwnPropertySymbols(t3)));
    for (var o = 0; o < i.length; o += 1) T6(r3, i[o], t3[i[o]], e2[i[o]]);
  };
  Pv.supportsDescriptors = !!Iv;
  Mv.exports = Pv;
});
var Ov2 = q((sL, Ev) => {
  "use strict";
  c();
  var w6 = br(), Tv = Qu(), D6 = Ku()(), wv = Ju(), Dv = Mi2(), E6 = w6("%Math.floor%");
  Ev.exports = function(t3, e2) {
    if (typeof t3 != "function") throw new Dv("`fn` is not a function");
    if (typeof e2 != "number" || e2 < 0 || e2 > 4294967295 || E6(e2) !== e2) throw new Dv("`length` must be a positive 32-bit integer");
    var i = arguments.length > 2 && !!arguments[2], o = true, n = true;
    if ("length" in t3 && wv) {
      var s2 = wv(t3, "length");
      s2 && !s2.configurable && (o = false), s2 && !s2.writable && (n = false);
    }
    return (o || n || !i) && (D6 ? Tv(t3, "length", e2, true, true) : Tv(t3, "length", e2)), t3;
  };
});
var xn = q((cL, ed) => {
  "use strict";
  c();
  var sm = Xu(), td = br(), O6 = Ov2(), L6 = Mi2(), Fv = td("%Function.prototype.apply%"), kv = td("%Function.prototype.call%"), Bv = td("%Reflect.apply%", true) || sm.call(kv, Fv), Lv = qu(), A6 = td("%Math.max%");
  ed.exports = function(t3) {
    if (typeof t3 != "function") throw new L6("a function is required");
    var e2 = Bv(sm, kv, arguments);
    return O6(e2, 1 + A6(0, t3.length - (arguments.length - 1)), true);
  };
  var Av = function() {
    return Bv(sm, Fv, arguments);
  };
  Lv ? Lv(ed.exports, "apply", { value: Av }) : ed.exports.apply = Av;
});
var Xt = q((uL, Nv) => {
  "use strict";
  c();
  var _v = br(), Rv = xn(), F6 = Rv(_v("String.prototype.indexOf"));
  Nv.exports = function(t3, e2) {
    var i = _v(t3, !!e2);
    return typeof i == "function" && F6(t3, ".prototype.") > -1 ? Rv(i) : i;
  };
});
var lm = q((hL, Hv) => {
  "use strict";
  c();
  var k6 = Hu(), jv = Ml()(), Uv = Xt(), Gv = Object, B6 = Uv("Array.prototype.push"), Vv = Uv("Object.prototype.propertyIsEnumerable"), _6 = jv ? Object.getOwnPropertySymbols : null;
  Hv.exports = function(t3, e2) {
    if (t3 == null) throw new TypeError("target must be an object");
    var i = Gv(t3);
    if (arguments.length === 1) return i;
    for (var o = 1; o < arguments.length; ++o) {
      var n = Gv(arguments[o]), s2 = k6(n), c2 = jv && (Object.getOwnPropertySymbols || _6);
      if (c2) for (var l = c2(n), p = 0; p < l.length; ++p) {
        var d = l[p];
        Vv(n, d) && B6(s2, d);
      }
      for (var f = 0; f < s2.length; ++f) {
        var g = s2[f];
        if (Vv(n, g)) {
          var v2 = n[g];
          i[g] = v2;
        }
      }
    }
    return i;
  };
});
var pm = q((mL, Wv) => {
  "use strict";
  c();
  var cm = lm(), R6 = function() {
    if (!Object.assign) return false;
    for (var r3 = "abcdefghijklmnopqrst", t3 = r3.split(""), e2 = {}, i = 0; i < t3.length; ++i) e2[t3[i]] = t3[i];
    var o = Object.assign({}, e2), n = "";
    for (var s2 in o) n += s2;
    return r3 !== n;
  }, N6 = function() {
    if (!Object.assign || !Object.preventExtensions) return false;
    var r3 = Object.preventExtensions({ 1: 2 });
    try {
      Object.assign(r3, "xy");
    } catch {
      return r3[1] === "y";
    }
    return false;
  };
  Wv.exports = function() {
    return !Object.assign || R6() || N6() ? cm : Object.assign;
  };
});
var Yv = q((yL, Xv2) => {
  "use strict";
  c();
  var G6 = go(), V6 = pm();
  Xv2.exports = function() {
    var t3 = V6();
    return G6(Object, { assign: t3 }, { assign: function() {
      return Object.assign !== t3;
    } }), t3;
  };
});
var $v2 = q((vL, qv2) => {
  "use strict";
  c();
  var j6 = go(), U6 = xn(), H6 = lm(), Zv = pm(), W6 = Yv(), X6 = U6.apply(Zv()), zv = function(t3, e2) {
    return X6(Object, arguments);
  };
  j6(zv, { getPolyfill: Zv, implementation: H6, shim: W6 });
  qv2.exports = zv;
});
var Qv2 = q((SL, Jv2) => {
  "use strict";
  c();
  var Dl = function() {
    return typeof (function() {
    }).name == "string";
  }, wl2 = Object.getOwnPropertyDescriptor;
  if (wl2) try {
    wl2([], "length");
  } catch {
    wl2 = null;
  }
  Dl.functionsHaveConfigurableNames = function() {
    if (!Dl() || !wl2) return false;
    var t3 = wl2(function() {
    }, "name");
    return !!t3 && !!t3.configurable;
  };
  var Y6 = Function.prototype.bind;
  Dl.boundFunctionsHaveNames = function() {
    return Dl() && typeof Y6 == "function" && (function() {
    }).bind().name !== "";
  };
  Jv2.exports = Dl;
});
var t2 = q((IL, e2) => {
  "use strict";
  c();
  var Kv2 = Qu(), Z6 = Ku()(), z6 = Qv2().functionsHaveConfigurableNames(), q6 = Mi2();
  e2.exports = function(t3, e3) {
    if (typeof t3 != "function") throw new q6("`fn` is not a function");
    var i = arguments.length > 2 && !!arguments[2];
    return (!i || z6) && (Z6 ? Kv2(t3, "name", e3, true, true) : Kv2(t3, "name", e3)), t3;
  };
});
var um = q((ML, r22) => {
  "use strict";
  c();
  var $6 = t2(), J6 = Mi2(), Q6 = Object;
  r22.exports = $6(function() {
    if (this == null || this !== Q6(this)) throw new J6("RegExp.prototype.flags getter called on non-object");
    var t3 = "";
    return this.hasIndices && (t3 += "d"), this.global && (t3 += "g"), this.ignoreCase && (t3 += "i"), this.multiline && (t3 += "m"), this.dotAll && (t3 += "s"), this.unicode && (t3 += "u"), this.unicodeSets && (t3 += "v"), this.sticky && (t3 += "y"), t3;
  }, "get flags", true);
});
var dm = q((wL, i2) => {
  "use strict";
  c();
  var K6 = um(), eI = go().supportsDescriptors, tI = Object.getOwnPropertyDescriptor;
  i2.exports = function() {
    if (eI && /a/mig.flags === "gim") {
      var t3 = tI(RegExp.prototype, "flags");
      if (t3 && typeof t3.get == "function" && typeof RegExp.prototype.dotAll == "boolean" && typeof RegExp.prototype.hasIndices == "boolean") {
        var e2 = "", i = {};
        if (Object.defineProperty(i, "hasIndices", { get: function() {
          e2 += "d";
        } }), Object.defineProperty(i, "sticky", { get: function() {
          e2 += "y";
        } }), e2 === "dy") return t3.get;
      }
    }
    return K6;
  };
});
var a2 = q((EL, n2) => {
  "use strict";
  c();
  var rI = go().supportsDescriptors, iI = dm(), oI = Object.getOwnPropertyDescriptor, nI = Object.defineProperty, aI = TypeError, o2 = Object.getPrototypeOf, sI = /a/;
  n2.exports = function() {
    if (!rI || !o2) throw new aI("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
    var t3 = iI(), e2 = o2(sI), i = oI(e2, "flags");
    return (!i || i.get !== t3) && nI(e2, "flags", { configurable: true, enumerable: false, get: t3 }), t3;
  };
});
var p2 = q((LL, c2) => {
  "use strict";
  c();
  var lI = go(), cI = xn(), pI = um(), s2 = dm(), uI = a2(), l2 = cI(s2());
  lI(l2, { getPolyfill: s2, implementation: pI, shim: uI });
  c2.exports = l2;
});
var yo2 = q((FL, u2) => {
  "use strict";
  c();
  var dI = Ml();
  u2.exports = function() {
    return dI() && !!Symbol.toStringTag;
  };
});
var fm = q((BL, h2) => {
  "use strict";
  c();
  var hI = yo2()(), fI = Xt(), hm = fI("Object.prototype.toString"), rd = function(t3) {
    return hI && t3 && typeof t3 == "object" && Symbol.toStringTag in t3 ? false : hm(t3) === "[object Arguments]";
  }, d2 = function(t3) {
    return rd(t3) ? true : t3 !== null && typeof t3 == "object" && typeof t3.length == "number" && t3.length >= 0 && hm(t3) !== "[object Array]" && hm(t3.callee) === "[object Function]";
  }, mI = function() {
    return rd(arguments);
  }();
  rd.isLegacyArguments = d2;
  h2.exports = mI ? rd : d2;
});
var f2 = q(() => {
  c();
});
var k2 = q((VL, F2) => {
  c();
  var Pm = typeof Map == "function" && Map.prototype, mm = Object.getOwnPropertyDescriptor && Pm ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null, od = Pm && mm && typeof mm.get == "function" ? mm.get : null, m2 = Pm && Map.prototype.forEach, Mm2 = typeof Set == "function" && Set.prototype, gm = Object.getOwnPropertyDescriptor && Mm2 ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null, nd = Mm2 && gm && typeof gm.get == "function" ? gm.get : null, g2 = Mm2 && Set.prototype.forEach, gI = typeof WeakMap == "function" && WeakMap.prototype, Ol = gI ? WeakMap.prototype.has : null, yI = typeof WeakSet == "function" && WeakSet.prototype, Ll = yI ? WeakSet.prototype.has : null, bI = typeof WeakRef == "function" && WeakRef.prototype, y2 = bI ? WeakRef.prototype.deref : null, vI = Boolean.prototype.valueOf, CI = Object.prototype.toString, SI = Function.prototype.toString, xI = String.prototype.match, Tm = String.prototype.slice, vo = String.prototype.replace, II = String.prototype.toUpperCase, b2 = String.prototype.toLowerCase, w2 = RegExp.prototype.test, v2 = Array.prototype.concat, Zr2 = Array.prototype.join, PI = Array.prototype.slice, C2 = Math.floor, vm = typeof BigInt == "function" ? BigInt.prototype.valueOf : null, ym = Object.getOwnPropertySymbols, Cm2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null, qa = typeof Symbol == "function" && typeof Symbol.iterator == "object", gt = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === qa || true) ? Symbol.toStringTag : null, D2 = Object.prototype.propertyIsEnumerable, S2 = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(r3) {
    return r3.__proto__;
  } : null);
  function x2(r3, t3) {
    if (r3 === 1 / 0 || r3 === -1 / 0 || r3 !== r3 || r3 && r3 > -1e3 && r3 < 1e3 || w2.call(/e/, t3)) return t3;
    var e2 = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof r3 == "number") {
      var i = r3 < 0 ? -C2(-r3) : C2(r3);
      if (i !== r3) {
        var o = String(i), n = Tm.call(t3, o.length + 1);
        return vo.call(o, e2, "$&_") + "." + vo.call(vo.call(n, /([0-9]{3})/g, "$&_"), /_$/, "");
      }
    }
    return vo.call(t3, e2, "$&_");
  }
  var Sm = f2(), I2 = Sm.custom, P2 = O2(I2) ? I2 : null;
  F2.exports = function r3(t3, e2, i, o) {
    var n = e2 || {};
    if (bo(n, "quoteStyle") && n.quoteStyle !== "single" && n.quoteStyle !== "double") throw new TypeError('option "quoteStyle" must be "single" or "double"');
    if (bo(n, "maxStringLength") && (typeof n.maxStringLength == "number" ? n.maxStringLength < 0 && n.maxStringLength !== 1 / 0 : n.maxStringLength !== null)) throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    var s2 = bo(n, "customInspect") ? n.customInspect : true;
    if (typeof s2 != "boolean" && s2 !== "symbol") throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
    if (bo(n, "indent") && n.indent !== null && n.indent !== "	" && !(parseInt(n.indent, 10) === n.indent && n.indent > 0)) throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    if (bo(n, "numericSeparator") && typeof n.numericSeparator != "boolean") throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    var c2 = n.numericSeparator;
    if (typeof t3 > "u") return "undefined";
    if (t3 === null) return "null";
    if (typeof t3 == "boolean") return t3 ? "true" : "false";
    if (typeof t3 == "string") return A2(t3, n);
    if (typeof t3 == "number") {
      if (t3 === 0) return 1 / 0 / t3 > 0 ? "0" : "-0";
      var l = String(t3);
      return c2 ? x2(t3, l) : l;
    }
    if (typeof t3 == "bigint") {
      var p = String(t3) + "n";
      return c2 ? x2(t3, p) : p;
    }
    var d = typeof n.depth > "u" ? 5 : n.depth;
    if (typeof i > "u" && (i = 0), i >= d && d > 0 && typeof t3 == "object") return xm(t3) ? "[Array]" : "[Object]";
    var f = UI(n, i);
    if (typeof o > "u") o = [];
    else if (L2(o, t3) >= 0) return "[Circular]";
    function g($, U, ie) {
      if (U && (o = PI.call(o), o.push(U)), ie) {
        var Z = { depth: n.depth };
        return bo(n, "quoteStyle") && (Z.quoteStyle = n.quoteStyle), r3($, Z, i + 1, o);
      }
      return r3($, n, i + 1, o);
    }
    if (typeof t3 == "function" && !M2(t3)) {
      var v3 = FI(t3), b = id(t3, g);
      return "[Function" + (v3 ? ": " + v3 : " (anonymous)") + "]" + (b.length > 0 ? " { " + Zr2.call(b, ", ") + " }" : "");
    }
    if (O2(t3)) {
      var C = qa ? vo.call(String(t3), /^(Symbol\(.*\))_[^)]*$/, "$1") : Cm2.call(t3);
      return typeof t3 == "object" && !qa ? El(C) : C;
    }
    if (GI(t3)) {
      for (var y = "<" + b2.call(String(t3.nodeName)), S = t3.attributes || [], T = 0; T < S.length; T++) y += " " + S[T].name + "=" + E2(MI(S[T].value), "double", n);
      return y += ">", t3.childNodes && t3.childNodes.length && (y += "..."), y += "</" + b2.call(String(t3.nodeName)) + ">", y;
    }
    if (xm(t3)) {
      if (t3.length === 0) return "[]";
      var w6 = id(t3, g);
      return f && !jI(w6) ? "[" + Im(w6, f) + "]" : "[ " + Zr2.call(w6, ", ") + " ]";
    }
    if (wI(t3)) {
      var M3 = id(t3, g);
      return !("cause" in Error.prototype) && "cause" in t3 && !D2.call(t3, "cause") ? "{ [" + String(t3) + "] " + Zr2.call(v2.call("[cause]: " + g(t3.cause), M3), ", ") + " }" : M3.length === 0 ? "[" + String(t3) + "]" : "{ [" + String(t3) + "] " + Zr2.call(M3, ", ") + " }";
    }
    if (typeof t3 == "object" && s2) {
      if (P2 && typeof t3[P2] == "function" && Sm) return Sm(t3, { depth: d - i });
      if (s2 !== "symbol" && typeof t3.inspect == "function") return t3.inspect();
    }
    if (kI(t3)) {
      var D = [];
      return m2 && m2.call(t3, function($, U) {
        D.push(g(U, t3, true) + " => " + g($, t3));
      }), T2("Map", od.call(t3), D, f);
    }
    if (RI(t3)) {
      var F = [];
      return g2 && g2.call(t3, function($) {
        F.push(g($, t3));
      }), T2("Set", nd.call(t3), F, f);
    }
    if (BI(t3)) return bm("WeakMap");
    if (NI(t3)) return bm("WeakSet");
    if (_I(t3)) return bm("WeakRef");
    if (EI(t3)) return El(g(Number(t3)));
    if (LI(t3)) return El(g(vm.call(t3)));
    if (OI(t3)) return El(vI.call(t3));
    if (DI(t3)) return El(g(String(t3)));
    if (typeof window < "u" && t3 === window) return "{ [object Window] }";
    if (t3 === global) return "{ [object globalThis] }";
    if (!TI(t3) && !M2(t3)) {
      var A = id(t3, g), k = S2 ? S2(t3) === Object.prototype : t3 instanceof Object || t3.constructor === Object, B = t3 instanceof Object ? "" : "null prototype", G = !k && gt && Object(t3) === t3 && gt in t3 ? Tm.call(Co(t3), 8, -1) : B ? "Object" : "", V = k || typeof t3.constructor != "function" ? "" : t3.constructor.name ? t3.constructor.name + " " : "", W = V + (G || B ? "[" + Zr2.call(v2.call([], G || [], B || []), ": ") + "] " : "");
      return A.length === 0 ? W + "{}" : f ? W + "{" + Im(A, f) + "}" : W + "{ " + Zr2.call(A, ", ") + " }";
    }
    return String(t3);
  };
  function E2(r3, t3, e2) {
    var i = (e2.quoteStyle || t3) === "double" ? '"' : "'";
    return i + r3 + i;
  }
  function MI(r3) {
    return vo.call(String(r3), /"/g, "&quot;");
  }
  function xm(r3) {
    return Co(r3) === "[object Array]" && (!gt || !(typeof r3 == "object" && gt in r3));
  }
  function TI(r3) {
    return Co(r3) === "[object Date]" && (!gt || !(typeof r3 == "object" && gt in r3));
  }
  function M2(r3) {
    return Co(r3) === "[object RegExp]" && (!gt || !(typeof r3 == "object" && gt in r3));
  }
  function wI(r3) {
    return Co(r3) === "[object Error]" && (!gt || !(typeof r3 == "object" && gt in r3));
  }
  function DI(r3) {
    return Co(r3) === "[object String]" && (!gt || !(typeof r3 == "object" && gt in r3));
  }
  function EI(r3) {
    return Co(r3) === "[object Number]" && (!gt || !(typeof r3 == "object" && gt in r3));
  }
  function OI(r3) {
    return Co(r3) === "[object Boolean]" && (!gt || !(typeof r3 == "object" && gt in r3));
  }
  function O2(r3) {
    if (qa) return r3 && typeof r3 == "object" && r3 instanceof Symbol;
    if (typeof r3 == "symbol") return true;
    if (!r3 || typeof r3 != "object" || !Cm2) return false;
    try {
      return Cm2.call(r3), true;
    } catch {
    }
    return false;
  }
  function LI(r3) {
    if (!r3 || typeof r3 != "object" || !vm) return false;
    try {
      return vm.call(r3), true;
    } catch {
    }
    return false;
  }
  var AI = Object.prototype.hasOwnProperty || function(r3) {
    return r3 in this;
  };
  function bo(r3, t3) {
    return AI.call(r3, t3);
  }
  function Co(r3) {
    return CI.call(r3);
  }
  function FI(r3) {
    if (r3.name) return r3.name;
    var t3 = xI.call(SI.call(r3), /^function\s*([\w$]+)/);
    return t3 ? t3[1] : null;
  }
  function L2(r3, t3) {
    if (r3.indexOf) return r3.indexOf(t3);
    for (var e2 = 0, i = r3.length; e2 < i; e2++) if (r3[e2] === t3) return e2;
    return -1;
  }
  function kI(r3) {
    if (!od || !r3 || typeof r3 != "object") return false;
    try {
      od.call(r3);
      try {
        nd.call(r3);
      } catch {
        return true;
      }
      return r3 instanceof Map;
    } catch {
    }
    return false;
  }
  function BI(r3) {
    if (!Ol || !r3 || typeof r3 != "object") return false;
    try {
      Ol.call(r3, Ol);
      try {
        Ll.call(r3, Ll);
      } catch {
        return true;
      }
      return r3 instanceof WeakMap;
    } catch {
    }
    return false;
  }
  function _I(r3) {
    if (!y2 || !r3 || typeof r3 != "object") return false;
    try {
      return y2.call(r3), true;
    } catch {
    }
    return false;
  }
  function RI(r3) {
    if (!nd || !r3 || typeof r3 != "object") return false;
    try {
      nd.call(r3);
      try {
        od.call(r3);
      } catch {
        return true;
      }
      return r3 instanceof Set;
    } catch {
    }
    return false;
  }
  function NI(r3) {
    if (!Ll || !r3 || typeof r3 != "object") return false;
    try {
      Ll.call(r3, Ll);
      try {
        Ol.call(r3, Ol);
      } catch {
        return true;
      }
      return r3 instanceof WeakSet;
    } catch {
    }
    return false;
  }
  function GI(r3) {
    return !r3 || typeof r3 != "object" ? false : typeof HTMLElement < "u" && r3 instanceof HTMLElement ? true : typeof r3.nodeName == "string" && typeof r3.getAttribute == "function";
  }
  function A2(r3, t3) {
    if (r3.length > t3.maxStringLength) {
      var e2 = r3.length - t3.maxStringLength, i = "... " + e2 + " more character" + (e2 > 1 ? "s" : "");
      return A2(Tm.call(r3, 0, t3.maxStringLength), t3) + i;
    }
    var o = vo.call(vo.call(r3, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, VI);
    return E2(o, "single", t3);
  }
  function VI(r3) {
    var t3 = r3.charCodeAt(0), e2 = { 8: "b", 9: "t", 10: "n", 12: "f", 13: "r" }[t3];
    return e2 ? "\\" + e2 : "\\x" + (t3 < 16 ? "0" : "") + II.call(t3.toString(16));
  }
  function El(r3) {
    return "Object(" + r3 + ")";
  }
  function bm(r3) {
    return r3 + " { ? }";
  }
  function T2(r3, t3, e2, i) {
    var o = i ? Im(e2, i) : Zr2.call(e2, ", ");
    return r3 + " (" + t3 + ") {" + o + "}";
  }
  function jI(r3) {
    for (var t3 = 0; t3 < r3.length; t3++) if (L2(r3[t3], "\n") >= 0) return false;
    return true;
  }
  function UI(r3, t3) {
    var e2;
    if (r3.indent === "	") e2 = "	";
    else if (typeof r3.indent == "number" && r3.indent > 0) e2 = Zr2.call(Array(r3.indent + 1), " ");
    else return null;
    return { base: e2, prev: Zr2.call(Array(t3 + 1), e2) };
  }
  function Im(r3, t3) {
    if (r3.length === 0) return "";
    var e2 = "\n" + t3.prev + t3.base;
    return e2 + Zr2.call(r3, "," + e2) + "\n" + t3.prev;
  }
  function id(r3, t3) {
    var e2 = xm(r3), i = [];
    if (e2) {
      i.length = r3.length;
      for (var o = 0; o < r3.length; o++) i[o] = bo(r3, o) ? t3(r3[o], r3) : "";
    }
    var n = typeof ym == "function" ? ym(r3) : [], s2;
    if (qa) {
      s2 = {};
      for (var c2 = 0; c2 < n.length; c2++) s2["$" + n[c2]] = n[c2];
    }
    for (var l in r3) bo(r3, l) && (e2 && String(Number(l)) === l && l < r3.length || qa && s2["$" + l] instanceof Symbol || (w2.call(/[^\w$]/, l) ? i.push(t3(l, r3) + ": " + t3(r3[l], r3)) : i.push(l + ": " + t3(r3[l], r3))));
    if (typeof ym == "function") for (var p = 0; p < n.length; p++) D2.call(r3, n[p]) && i.push("[" + t3(n[p]) + "]: " + t3(r3[n[p]], r3));
    return i;
  }
});
var Dm2 = q((UL, _2) => {
  "use strict";
  c();
  var B2 = br(), $a = Xt(), HI = k2(), WI = Mi2(), ad = B2("%WeakMap%", true), sd = B2("%Map%", true), XI = $a("WeakMap.prototype.get", true), YI = $a("WeakMap.prototype.set", true), ZI = $a("WeakMap.prototype.has", true), zI = $a("Map.prototype.get", true), qI = $a("Map.prototype.set", true), $I = $a("Map.prototype.has", true), wm2 = function(r3, t3) {
    for (var e2 = r3, i; (i = e2.next) !== null; e2 = i) if (i.key === t3) return e2.next = i.next, i.next = r3.next, r3.next = i, i;
  }, JI = function(r3, t3) {
    var e2 = wm2(r3, t3);
    return e2 && e2.value;
  }, QI = function(r3, t3, e2) {
    var i = wm2(r3, t3);
    i ? i.value = e2 : r3.next = { key: t3, next: r3.next, value: e2 };
  }, KI = function(r3, t3) {
    return !!wm2(r3, t3);
  };
  _2.exports = function() {
    var t3, e2, i, o = { assert: function(n) {
      if (!o.has(n)) throw new WI("Side channel does not contain " + HI(n));
    }, get: function(n) {
      if (ad && n && (typeof n == "object" || typeof n == "function")) {
        if (t3) return XI(t3, n);
      } else if (sd) {
        if (e2) return zI(e2, n);
      } else if (i) return JI(i, n);
    }, has: function(n) {
      if (ad && n && (typeof n == "object" || typeof n == "function")) {
        if (t3) return ZI(t3, n);
      } else if (sd) {
        if (e2) return $I(e2, n);
      } else if (i) return KI(i, n);
      return false;
    }, set: function(n, s2) {
      ad && n && (typeof n == "object" || typeof n == "function") ? (t3 || (t3 = new ad()), YI(t3, n, s2)) : sd ? (e2 || (e2 = new sd()), qI(e2, n, s2)) : (i || (i = { key: {}, next: null }), QI(i, n, s2));
    } };
    return o;
  };
});
var N2 = q((WL, R2) => {
  "use strict";
  c();
  var eP = im(), Al = Dm2()(), Ti = Mi2(), Em2 = { assert: function(r3, t3) {
    if (!r3 || typeof r3 != "object" && typeof r3 != "function") throw new Ti("`O` is not an object");
    if (typeof t3 != "string") throw new Ti("`slot` must be a string");
    if (Al.assert(r3), !Em2.has(r3, t3)) throw new Ti("`" + t3 + "` is not present on `O`");
  }, get: function(r3, t3) {
    if (!r3 || typeof r3 != "object" && typeof r3 != "function") throw new Ti("`O` is not an object");
    if (typeof t3 != "string") throw new Ti("`slot` must be a string");
    var e2 = Al.get(r3);
    return e2 && e2["$" + t3];
  }, has: function(r3, t3) {
    if (!r3 || typeof r3 != "object" && typeof r3 != "function") throw new Ti("`O` is not an object");
    if (typeof t3 != "string") throw new Ti("`slot` must be a string");
    var e2 = Al.get(r3);
    return !!e2 && eP(e2, "$" + t3);
  }, set: function(r3, t3, e2) {
    if (!r3 || typeof r3 != "object" && typeof r3 != "function") throw new Ti("`O` is not an object");
    if (typeof t3 != "string") throw new Ti("`slot` must be a string");
    var i = Al.get(r3);
    i || (i = {}, Al.set(r3, i)), i["$" + t3] = e2;
  } };
  Object.freeze && Object.freeze(Em2);
  R2.exports = Em2;
});
var j2 = q((YL, V2) => {
  "use strict";
  c();
  var Fl = N2(), tP = SyntaxError, G2 = typeof StopIteration == "object" ? StopIteration : null;
  V2.exports = function(t3) {
    if (!G2) throw new tP("this environment lacks StopIteration");
    Fl.set(t3, "[[Done]]", false);
    var e2 = { next: function() {
      var o = Fl.get(this, "[[Iterator]]"), n = Fl.get(o, "[[Done]]");
      try {
        return { done: n, value: n ? void 0 : o.next() };
      } catch (s2) {
        if (Fl.set(o, "[[Done]]", true), s2 !== G2) throw s2;
        return { done: true, value: void 0 };
      }
    } };
    return Fl.set(e2, "[[Iterator]]", t3), e2;
  };
});
var Om2 = q((zL, U2) => {
  c();
  var rP = {}.toString;
  U2.exports = Array.isArray || function(r3) {
    return rP.call(r3) == "[object Array]";
  };
});
var Lm2 = q(($L, H2) => {
  "use strict";
  c();
  var iP = String.prototype.valueOf, oP = function(t3) {
    try {
      return iP.call(t3), true;
    } catch {
      return false;
    }
  }, nP = Object.prototype.toString, aP = "[object String]", sP = yo2()();
  H2.exports = function(t3) {
    return typeof t3 == "string" ? true : typeof t3 != "object" ? false : sP ? oP(t3) : nP.call(t3) === aP;
  };
});
var Fm = q((QL, Y2) => {
  "use strict";
  c();
  var Am2 = typeof Map == "function" && Map.prototype ? Map : null, lP = typeof Set == "function" && Set.prototype ? Set : null, ld;
  Am2 || (ld = function(t3) {
    return false;
  });
  var X2 = Am2 ? Map.prototype.has : null, W2 = lP ? Set.prototype.has : null;
  !ld && !X2 && (ld = function(t3) {
    return false;
  });
  Y2.exports = ld || function(t3) {
    if (!t3 || typeof t3 != "object") return false;
    try {
      if (X2.call(t3), W2) try {
        W2.call(t3);
      } catch {
        return true;
      }
      return t3 instanceof Am2;
    } catch {
    }
    return false;
  };
});
var Bm = q((eA, q22) => {
  "use strict";
  c();
  var cP = typeof Map == "function" && Map.prototype ? Map : null, km2 = typeof Set == "function" && Set.prototype ? Set : null, cd;
  km2 || (cd = function(t3) {
    return false;
  });
  var Z2 = cP ? Map.prototype.has : null, z2 = km2 ? Set.prototype.has : null;
  !cd && !z2 && (cd = function(t3) {
    return false;
  });
  q22.exports = cd || function(t3) {
    if (!t3 || typeof t3 != "object") return false;
    try {
      if (z2.call(t3), Z2) try {
        Z2.call(t3);
      } catch {
        return true;
      }
      return t3 instanceof km2;
    } catch {
    }
    return false;
  };
});
var s3 = q((rA, dd) => {
  "use strict";
  c();
  var $2 = fm(), J2 = j2();
  Wu()() || Ml()() ? (pd = Symbol.iterator, dd.exports = function(t4) {
    if (t4 != null && typeof t4[pd] < "u") return t4[pd]();
    if ($2(t4)) return Array.prototype[pd].call(t4);
  }) : (Q2 = Om2(), K22 = Lm2(), _m = br(), e3 = _m("%Map%", true), t3 = _m("%Set%", true), tr2 = Xt(), Rm = tr2("Array.prototype.push"), Nm = tr2("String.prototype.charCodeAt"), r3 = tr2("String.prototype.slice"), i3 = function(t4, e2) {
    var i = t4.length;
    if (e2 + 1 >= i) return e2 + 1;
    var o = Nm(t4, e2);
    if (o < 55296 || o > 56319) return e2 + 1;
    var n = Nm(t4, e2 + 1);
    return n < 56320 || n > 57343 ? e2 + 1 : e2 + 2;
  }, ud = function(t4) {
    var e2 = 0;
    return { next: function() {
      var o = e2 >= t4.length, n;
      return o || (n = t4[e2], e2 += 1), { done: o, value: n };
    } };
  }, Gm2 = function(t4, e2) {
    if (Q2(t4) || $2(t4)) return ud(t4);
    if (K22(t4)) {
      var i = 0;
      return { next: function() {
        var n = i3(t4, i), s2 = r3(t4, i, n);
        return i = n, { done: n > t4.length, value: s2 };
      } };
    }
    if (e2 && typeof t4["_es6-shim iterator_"] < "u") return t4["_es6-shim iterator_"]();
  }, !e3 && !t3 ? dd.exports = function(t4) {
    if (t4 != null) return Gm2(t4, true);
  } : (o3 = Fm(), n3 = Bm(), Vm = tr2("Map.prototype.forEach", true), jm = tr2("Set.prototype.forEach", true), (typeof e > "u" || !e.versions || !e.versions.node) && (Um = tr2("Map.prototype.iterator", true), Hm = tr2("Set.prototype.iterator", true)), Wm = tr2("Map.prototype.@@iterator", true) || tr2("Map.prototype._es6-shim iterator_", true), Xm = tr2("Set.prototype.@@iterator", true) || tr2("Set.prototype._es6-shim iterator_", true), a3 = function(t4) {
    if (o3(t4)) {
      if (Um) return J2(Um(t4));
      if (Wm) return Wm(t4);
      if (Vm) {
        var e2 = [];
        return Vm(t4, function(o, n) {
          Rm(e2, [n, o]);
        }), ud(e2);
      }
    }
    if (n3(t4)) {
      if (Hm) return J2(Hm(t4));
      if (Xm) return Xm(t4);
      if (jm) {
        var i = [];
        return jm(t4, function(o) {
          Rm(i, o);
        }), ud(i);
      }
    }
  }, dd.exports = function(t4) {
    return a3(t4) || Gm2(t4);
  }));
  var pd, Q2, K22, _m, e3, t3, tr2, Rm, Nm, r3, i3, ud, Gm2, o3, n3, Vm, jm, Um, Hm, Wm, Xm, a3;
});
var Ym = q((oA, c3) => {
  "use strict";
  c();
  var l3 = function(r3) {
    return r3 !== r3;
  };
  c3.exports = function(t3, e2) {
    return t3 === 0 && e2 === 0 ? 1 / t3 === 1 / e2 : !!(t3 === e2 || l3(t3) && l3(e2));
  };
});
var Zm = q((aA, p3) => {
  "use strict";
  c();
  var pP = Ym();
  p3.exports = function() {
    return typeof Object.is == "function" ? Object.is : pP;
  };
});
var d3 = q((lA, u3) => {
  "use strict";
  c();
  var uP = Zm(), dP = go();
  u3.exports = function() {
    var t3 = uP();
    return dP(Object, { is: t3 }, { is: function() {
      return Object.is !== t3;
    } }), t3;
  };
});
var g3 = q((pA, m3) => {
  "use strict";
  c();
  var hP = go(), fP = xn(), mP = Ym(), h3 = Zm(), gP = d3(), f3 = fP(h3(), Object);
  hP(f3, { getPolyfill: h3, implementation: mP, shim: gP });
  m3.exports = f3;
});
var qm = q((dA, C3) => {
  "use strict";
  c();
  var yP = xn(), v3 = Xt(), bP = br(), zm = bP("%ArrayBuffer%", true), hd = v3("ArrayBuffer.prototype.byteLength", true), vP = v3("Object.prototype.toString"), y3 = !!zm && !hd && new zm(0).slice, b3 = !!y3 && yP(y3);
  C3.exports = hd || b3 ? function(t3) {
    if (!t3 || typeof t3 != "object") return false;
    try {
      return hd ? hd(t3) : b3(t3, 0), true;
    } catch {
      return false;
    }
  } : zm ? function(t3) {
    return vP(t3) === "[object ArrayBuffer]";
  } : function(t3) {
    return false;
  };
});
var x3 = q((fA, S3) => {
  "use strict";
  c();
  var CP = Date.prototype.getDay, SP = function(t3) {
    try {
      return CP.call(t3), true;
    } catch {
      return false;
    }
  }, xP = Object.prototype.toString, IP = "[object Date]", PP = yo2()();
  S3.exports = function(t3) {
    return typeof t3 != "object" || t3 === null ? false : PP ? SP(t3) : xP.call(t3) === IP;
  };
});
var w3 = q((gA, T3) => {
  "use strict";
  c();
  var $m = Xt(), I3 = yo2()(), P3, M3, Jm, Qm;
  I3 && (P3 = $m("Object.prototype.hasOwnProperty"), M3 = $m("RegExp.prototype.exec"), Jm = {}, fd = function() {
    throw Jm;
  }, Qm = { toString: fd, valueOf: fd }, typeof Symbol.toPrimitive == "symbol" && (Qm[Symbol.toPrimitive] = fd));
  var fd, MP = $m("Object.prototype.toString"), TP = Object.getOwnPropertyDescriptor, wP = "[object RegExp]";
  T3.exports = I3 ? function(t3) {
    if (!t3 || typeof t3 != "object") return false;
    var e2 = TP(t3, "lastIndex"), i = e2 && P3(e2, "value");
    if (!i) return false;
    try {
      M3(t3, Qm);
    } catch (o) {
      return o === Jm;
    }
  } : function(t3) {
    return !t3 || typeof t3 != "object" && typeof t3 != "function" ? false : MP(t3) === wP;
  };
});
var O3 = q((bA, E3) => {
  "use strict";
  c();
  var DP = Xt(), D3 = DP("SharedArrayBuffer.prototype.byteLength", true);
  E3.exports = D3 ? function(t3) {
    if (!t3 || typeof t3 != "object") return false;
    try {
      return D3(t3), true;
    } catch {
      return false;
    }
  } : function(t3) {
    return false;
  };
});
var A3 = q((CA, L3) => {
  "use strict";
  c();
  var EP = Number.prototype.toString, OP = function(t3) {
    try {
      return EP.call(t3), true;
    } catch {
      return false;
    }
  }, LP = Object.prototype.toString, AP = "[object Number]", FP = yo2()();
  L3.exports = function(t3) {
    return typeof t3 == "number" ? true : typeof t3 != "object" ? false : FP ? OP(t3) : LP.call(t3) === AP;
  };
});
var B3 = q((xA, k3) => {
  "use strict";
  c();
  var F3 = Xt(), kP = F3("Boolean.prototype.toString"), BP = F3("Object.prototype.toString"), _P = function(t3) {
    try {
      return kP(t3), true;
    } catch {
      return false;
    }
  }, RP = "[object Boolean]", NP = yo2()();
  k3.exports = function(t3) {
    return typeof t3 == "boolean" ? true : t3 === null || typeof t3 != "object" ? false : NP && Symbol.toStringTag in t3 ? _P(t3) : BP(t3) === RP;
  };
});
var G3 = q((PA, Km) => {
  "use strict";
  c();
  var GP = Object.prototype.toString, VP = Wu()();
  VP ? (_3 = Symbol.prototype.toString, R3 = /^Symbol\(.*\)$/, N3 = function(t3) {
    return typeof t3.valueOf() != "symbol" ? false : R3.test(_3.call(t3));
  }, Km.exports = function(t3) {
    if (typeof t3 == "symbol") return true;
    if (GP.call(t3) !== "[object Symbol]") return false;
    try {
      return N3(t3);
    } catch {
      return false;
    }
  }) : Km.exports = function(t3) {
    return false;
  };
  var _3, R3, N3;
});
var U3 = q((TA, j3) => {
  "use strict";
  c();
  var V3 = typeof BigInt < "u" && BigInt;
  j3.exports = function() {
    return typeof V3 == "function" && typeof BigInt == "function" && typeof V3(42) == "bigint" && typeof BigInt(42) == "bigint";
  };
});
var X3 = q((DA, eg) => {
  "use strict";
  c();
  var jP = U3()();
  jP ? (H3 = BigInt.prototype.valueOf, W3 = function(t3) {
    try {
      return H3.call(t3), true;
    } catch {
    }
    return false;
  }, eg.exports = function(t3) {
    return t3 === null || typeof t3 > "u" || typeof t3 == "boolean" || typeof t3 == "string" || typeof t3 == "number" || typeof t3 == "symbol" || typeof t3 == "function" ? false : typeof t3 == "bigint" ? true : W3(t3);
  }) : eg.exports = function(t3) {
    return false;
  };
  var H3, W3;
});
var Z3 = q((OA, Y3) => {
  "use strict";
  c();
  var UP = Lm2(), HP = A3(), WP = B3(), XP = G3(), YP = X3();
  Y3.exports = function(t3) {
    if (t3 == null || typeof t3 != "object" && typeof t3 != "function") return null;
    if (UP(t3)) return "String";
    if (HP(t3)) return "Number";
    if (WP(t3)) return "Boolean";
    if (XP(t3)) return "Symbol";
    if (YP(t3)) return "BigInt";
  };
});
var $3 = q((AA, q3) => {
  "use strict";
  c();
  var md2 = typeof WeakMap == "function" && WeakMap.prototype ? WeakMap : null, z3 = typeof WeakSet == "function" && WeakSet.prototype ? WeakSet : null, gd;
  md2 || (gd = function(t3) {
    return false;
  });
  var rg = md2 ? md2.prototype.has : null, tg = z3 ? z3.prototype.has : null;
  !gd && !rg && (gd = function(t3) {
    return false;
  });
  q3.exports = gd || function(t3) {
    if (!t3 || typeof t3 != "object") return false;
    try {
      if (rg.call(t3, rg), tg) try {
        tg.call(t3, tg);
      } catch {
        return true;
      }
      return t3 instanceof md2;
    } catch {
    }
    return false;
  };
});
var Q3 = q((kA, og) => {
  "use strict";
  c();
  var ZP = br(), J3 = Xt(), zP = ZP("%WeakSet%", true), ig = J3("WeakSet.prototype.has", true);
  ig ? (yd = J3("WeakMap.prototype.has", true), og.exports = function(t3) {
    if (!t3 || typeof t3 != "object") return false;
    try {
      if (ig(t3, ig), yd) try {
        yd(t3, yd);
      } catch {
        return true;
      }
      return t3 instanceof zP;
    } catch {
    }
    return false;
  }) : og.exports = function(t3) {
    return false;
  };
  var yd;
});
var eC = q((_A, K3) => {
  "use strict";
  c();
  var qP = Fm(), $P = Bm(), JP = $3(), QP = Q3();
  K3.exports = function(t3) {
    if (t3 && typeof t3 == "object") {
      if (qP(t3)) return "Map";
      if ($P(t3)) return "Set";
      if (JP(t3)) return "WeakMap";
      if (QP(t3)) return "WeakSet";
    }
    return false;
  };
});
var oC = q((NA, iC) => {
  "use strict";
  c();
  var rC = Function.prototype.toString, Ja = typeof Reflect == "object" && Reflect !== null && Reflect.apply, ag, bd;
  if (typeof Ja == "function" && typeof Object.defineProperty == "function") try {
    ag = Object.defineProperty({}, "length", { get: function() {
      throw bd;
    } }), bd = {}, Ja(function() {
      throw 42;
    }, null, ag);
  } catch (r3) {
    r3 !== bd && (Ja = null);
  }
  else Ja = null;
  var KP = /^\s*class\b/, sg = function(t3) {
    try {
      var e2 = rC.call(t3);
      return KP.test(e2);
    } catch {
      return false;
    }
  }, ng = function(t3) {
    try {
      return sg(t3) ? false : (rC.call(t3), true);
    } catch {
      return false;
    }
  }, vd = Object.prototype.toString, eM = "[object Object]", tM = "[object Function]", rM = "[object GeneratorFunction]", iM = "[object HTMLAllCollection]", oM = "[object HTML document.all class]", nM = "[object HTMLCollection]", aM = typeof Symbol == "function" && !!Symbol.toStringTag, sM = !(0 in [,]), lg = function() {
    return false;
  };
  typeof document == "object" && (tC = document.all, vd.call(tC) === vd.call(document.all) && (lg = function(t3) {
    if ((sM || !t3) && (typeof t3 > "u" || typeof t3 == "object")) try {
      var e2 = vd.call(t3);
      return (e2 === iM || e2 === oM || e2 === nM || e2 === eM) && t3("") == null;
    } catch {
    }
    return false;
  }));
  var tC;
  iC.exports = Ja ? function(t3) {
    if (lg(t3)) return true;
    if (!t3 || typeof t3 != "function" && typeof t3 != "object") return false;
    try {
      Ja(t3, null, ag);
    } catch (e2) {
      if (e2 !== bd) return false;
    }
    return !sg(t3) && ng(t3);
  } : function(t3) {
    if (lg(t3)) return true;
    if (!t3 || typeof t3 != "function" && typeof t3 != "object") return false;
    if (aM) return ng(t3);
    if (sg(t3)) return false;
    var e2 = vd.call(t3);
    return e2 !== tM && e2 !== rM && !/^\[object HTML/.test(e2) ? false : ng(t3);
  };
});
var sC = q((VA, aC) => {
  "use strict";
  c();
  var lM = oC(), cM = Object.prototype.toString, nC = Object.prototype.hasOwnProperty, pM = function(t3, e2, i) {
    for (var o = 0, n = t3.length; o < n; o++) nC.call(t3, o) && (i == null ? e2(t3[o], o, t3) : e2.call(i, t3[o], o, t3));
  }, uM = function(t3, e2, i) {
    for (var o = 0, n = t3.length; o < n; o++) i == null ? e2(t3.charAt(o), o, t3) : e2.call(i, t3.charAt(o), o, t3);
  }, dM = function(t3, e2, i) {
    for (var o in t3) nC.call(t3, o) && (i == null ? e2(t3[o], o, t3) : e2.call(i, t3[o], o, t3));
  }, hM = function(t3, e2, i) {
    if (!lM(e2)) throw new TypeError("iterator must be a function");
    var o;
    arguments.length >= 3 && (o = i), cM.call(t3) === "[object Array]" ? pM(t3, e2, o) : typeof t3 == "string" ? uM(t3, e2, o) : dM(t3, e2, o);
  };
  aC.exports = hM;
});
var cC = q((UA, lC) => {
  "use strict";
  c();
  lC.exports = ["Float32Array", "Float64Array", "Int8Array", "Int16Array", "Int32Array", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "BigInt64Array", "BigUint64Array"];
});
var uC = q((WA, pC) => {
  "use strict";
  c();
  var cg = cC(), fM = typeof globalThis > "u" ? global : globalThis;
  pC.exports = function() {
    for (var t3 = [], e2 = 0; e2 < cg.length; e2++) typeof fM[cg[e2]] == "function" && (t3[t3.length] = cg[e2]);
    return t3;
  };
});
var gC = q((YA, mC) => {
  "use strict";
  c();
  var Sd = sC(), mM = uC(), dC = xn(), dg2 = Xt(), Cd = Ju(), gM = dg2("Object.prototype.toString"), fC = yo2()(), hC = typeof globalThis > "u" ? global : globalThis, ug = mM(), hg = dg2("String.prototype.slice"), pg = Object.getPrototypeOf, yM = dg2("Array.prototype.indexOf", true) || function(t3, e2) {
    for (var i = 0; i < t3.length; i += 1) if (t3[i] === e2) return i;
    return -1;
  }, xd2 = { __proto__: null };
  fC && Cd && pg ? Sd(ug, function(r3) {
    var t3 = new hC[r3]();
    if (Symbol.toStringTag in t3) {
      var e2 = pg(t3), i = Cd(e2, Symbol.toStringTag);
      if (!i) {
        var o = pg(e2);
        i = Cd(o, Symbol.toStringTag);
      }
      xd2["$" + r3] = dC(i.get);
    }
  }) : Sd(ug, function(r3) {
    var t3 = new hC[r3](), e2 = t3.slice || t3.set;
    e2 && (xd2["$" + r3] = dC(e2));
  });
  var bM = function(t3) {
    var e2 = false;
    return Sd(xd2, function(i, o) {
      if (!e2) try {
        "$" + i(t3) === o && (e2 = hg(o, 1));
      } catch {
      }
    }), e2;
  }, vM = function(t3) {
    var e2 = false;
    return Sd(xd2, function(i, o) {
      if (!e2) try {
        i(t3), e2 = hg(o, 1);
      } catch {
      }
    }), e2;
  };
  mC.exports = function(t3) {
    if (!t3 || typeof t3 != "object") return false;
    if (!fC) {
      var e2 = hg(gM(t3), 8, -1);
      return yM(ug, e2) > -1 ? e2 : e2 !== "Object" ? false : vM(t3);
    }
    return Cd ? bM(t3) : null;
  };
});
var vC = q((zA, bC) => {
  "use strict";
  c();
  var CM = Xt(), yC = CM("ArrayBuffer.prototype.byteLength", true), SM = qm();
  bC.exports = function(t3) {
    return SM(t3) ? yC ? yC(t3) : t3.byteLength : NaN;
  };
});
var WC = q(($A, HC) => {
  "use strict";
  c();
  var VC = $v2(), zr = Xt(), CC = p2(), xM = br(), Qa = s3(), IM = Dm2(), SC = g3(), xC = fm(), IC = Om2(), PC = qm(), MC = x3(), TC = w3(), wC = O3(), DC = Hu(), EC = Z3(), OC = eC(), LC = gC(), AC = vC(), FC = zr("SharedArrayBuffer.prototype.byteLength", true), kC = zr("Date.prototype.getTime"), fg = Object.getPrototypeOf, BC = zr("Object.prototype.toString"), Pd = xM("%Set%", true), mg = zr("Map.prototype.has", true), Md = zr("Map.prototype.get", true), _C = zr("Map.prototype.size", true), Td2 = zr("Set.prototype.add", true), jC = zr("Set.prototype.delete", true), wd = zr("Set.prototype.has", true), Id = zr("Set.prototype.size", true);
  function RC(r3, t3, e2, i) {
    for (var o = Qa(r3), n; (n = o.next()) && !n.done; ) if (vr(t3, n.value, e2, i)) return jC(r3, n.value), true;
    return false;
  }
  function UC(r3) {
    if (typeof r3 > "u") return null;
    if (typeof r3 != "object") return typeof r3 == "symbol" ? false : typeof r3 == "string" || typeof r3 == "number" ? +r3 == +r3 : true;
  }
  function PM(r3, t3, e2, i, o, n) {
    var s2 = UC(e2);
    if (s2 != null) return s2;
    var c2 = Md(t3, s2), l = VC({}, o, { strict: false });
    return typeof c2 > "u" && !mg(t3, s2) || !vr(i, c2, l, n) ? false : !mg(r3, s2) && vr(i, c2, l, n);
  }
  function MM(r3, t3, e2) {
    var i = UC(e2);
    return i != null ? i : wd(t3, i) && !wd(r3, i);
  }
  function NC(r3, t3, e2, i, o, n) {
    for (var s2 = Qa(r3), c2, l; (c2 = s2.next()) && !c2.done; ) if (l = c2.value, vr(e2, l, o, n) && vr(i, Md(t3, l), o, n)) return jC(r3, l), true;
    return false;
  }
  function vr(r3, t3, e2, i) {
    var o = e2 || {};
    if (o.strict ? SC(r3, t3) : r3 === t3) return true;
    var n = EC(r3), s2 = EC(t3);
    if (n !== s2) return false;
    if (!r3 || !t3 || typeof r3 != "object" && typeof t3 != "object") return o.strict ? SC(r3, t3) : r3 == t3;
    var c2 = i.has(r3), l = i.has(t3), p;
    if (c2 && l) {
      if (i.get(r3) === i.get(t3)) return true;
    } else p = {};
    return c2 || i.set(r3, p), l || i.set(t3, p), DM(r3, t3, o, i);
  }
  function GC(r3) {
    return !r3 || typeof r3 != "object" || typeof r3.length != "number" || typeof r3.copy != "function" || typeof r3.slice != "function" || r3.length > 0 && typeof r3[0] != "number" ? false : !!(r3.constructor && r3.constructor.isBuffer && r3.constructor.isBuffer(r3));
  }
  function TM(r3, t3, e2, i) {
    if (Id(r3) !== Id(t3)) return false;
    for (var o = Qa(r3), n = Qa(t3), s2, c2, l; (s2 = o.next()) && !s2.done; ) if (s2.value && typeof s2.value == "object") l || (l = new Pd()), Td2(l, s2.value);
    else if (!wd(t3, s2.value)) {
      if (e2.strict || !MM(r3, t3, s2.value)) return false;
      l || (l = new Pd()), Td2(l, s2.value);
    }
    if (l) {
      for (; (c2 = n.next()) && !c2.done; ) if (c2.value && typeof c2.value == "object") {
        if (!RC(l, c2.value, e2.strict, i)) return false;
      } else if (!e2.strict && !wd(r3, c2.value) && !RC(l, c2.value, e2.strict, i)) return false;
      return Id(l) === 0;
    }
    return true;
  }
  function wM(r3, t3, e2, i) {
    if (_C(r3) !== _C(t3)) return false;
    for (var o = Qa(r3), n = Qa(t3), s2, c2, l, p, d, f; (s2 = o.next()) && !s2.done; ) if (p = s2.value[0], d = s2.value[1], p && typeof p == "object") l || (l = new Pd()), Td2(l, p);
    else if (f = Md(t3, p), typeof f > "u" && !mg(t3, p) || !vr(d, f, e2, i)) {
      if (e2.strict || !PM(r3, t3, p, d, e2, i)) return false;
      l || (l = new Pd()), Td2(l, p);
    }
    if (l) {
      for (; (c2 = n.next()) && !c2.done; ) if (p = c2.value[0], f = c2.value[1], p && typeof p == "object") {
        if (!NC(l, r3, p, f, e2, i)) return false;
      } else if (!e2.strict && (!r3.has(p) || !vr(Md(r3, p), f, e2, i)) && !NC(l, r3, p, f, VC({}, e2, { strict: false }), i)) return false;
      return Id(l) === 0;
    }
    return true;
  }
  function DM(r3, t3, e2, i) {
    var o, n;
    if (typeof r3 != typeof t3 || r3 == null || t3 == null || BC(r3) !== BC(t3) || xC(r3) !== xC(t3)) return false;
    var s2 = IC(r3), c2 = IC(t3);
    if (s2 !== c2) return false;
    var l = r3 instanceof Error, p = t3 instanceof Error;
    if (l !== p || (l || p) && (r3.name !== t3.name || r3.message !== t3.message)) return false;
    var d = TC(r3), f = TC(t3);
    if (d !== f || (d || f) && (r3.source !== t3.source || CC(r3) !== CC(t3))) return false;
    var g = MC(r3), v2 = MC(t3);
    if (g !== v2 || (g || v2) && kC(r3) !== kC(t3) || e2.strict && fg && fg(r3) !== fg(t3)) return false;
    var b = LC(r3), C = LC(t3);
    if (b !== C) return false;
    if (b || C) {
      if (r3.length !== t3.length) return false;
      for (o = 0; o < r3.length; o++) if (r3[o] !== t3[o]) return false;
      return true;
    }
    var y = GC(r3), S = GC(t3);
    if (y !== S) return false;
    if (y || S) {
      if (r3.length !== t3.length) return false;
      for (o = 0; o < r3.length; o++) if (r3[o] !== t3[o]) return false;
      return true;
    }
    var T = PC(r3), w2 = PC(t3);
    if (T !== w2) return false;
    if (T || w2) return AC(r3) !== AC(t3) ? false : typeof Uint8Array == "function" && vr(new Uint8Array(r3), new Uint8Array(t3), e2, i);
    var M2 = wC(r3), D = wC(t3);
    if (M2 !== D) return false;
    if (M2 || D) return FC(r3) !== FC(t3) ? false : typeof Uint8Array == "function" && vr(new Uint8Array(r3), new Uint8Array(t3), e2, i);
    if (typeof r3 != typeof t3) return false;
    var F = DC(r3), A = DC(t3);
    if (F.length !== A.length) return false;
    for (F.sort(), A.sort(), o = F.length - 1; o >= 0; o--) if (F[o] != A[o]) return false;
    for (o = F.length - 1; o >= 0; o--) if (n = F[o], !vr(r3[n], t3[n], e2, i)) return false;
    var k = OC(r3), B = OC(t3);
    return k !== B ? false : k === "Set" || B === "Set" ? TM(r3, t3, e2, i) : k === "Map" ? wM(r3, t3, e2, i) : true;
  }
  HC.exports = function(t3, e2, i) {
    return vr(t3, e2, i, IM());
  };
});
var a4 = q((fe2) => {
  "use strict";
  c();
  Object.defineProperty(fe2, "__esModule", { value: true });
  function EM(r3) {
    return r3 && r3.__esModule ? r3 : { default: r3 };
  }
  var OM = Object.defineProperty, ye = (r3, t3) => OM(r3, "name", { value: t3, configurable: true }), LM = WC(), AM = EM(LM), XC = class {
    constructor(t3) {
      this.direction = false, this.compareProperties = true;
      var e2, i, o;
      this.precision = 10 ** -((e2 = t3 == null ? void 0 : t3.precision) != null ? e2 : 17), this.direction = (i = t3 == null ? void 0 : t3.direction) != null ? i : false, this.compareProperties = (o = t3 == null ? void 0 : t3.compareProperties) != null ? o : true;
    }
    compare(t3, e2) {
      if (t3.type !== e2.type || !kl(t3, e2)) return false;
      switch (t3.type) {
        case "Point":
          return this.compareCoord(t3.coordinates, e2.coordinates);
        case "LineString":
          return this.compareLine(t3.coordinates, e2.coordinates);
        case "Polygon":
          return this.comparePolygon(t3, e2);
        case "GeometryCollection":
          return this.compareGeometryCollection(t3, e2);
        case "Feature":
          return this.compareFeature(t3, e2);
        case "FeatureCollection":
          return this.compareFeatureCollection(t3, e2);
        default:
          if (t3.type.startsWith("Multi")) {
            let i = gg(t3), o = gg(e2);
            return i.every((n) => o.some((s2) => this.compare(n, s2)));
          }
      }
      return false;
    }
    compareCoord(t3, e2) {
      return t3.length === e2.length && t3.every((i, o) => Math.abs(i - e2[o]) < this.precision);
    }
    compareLine(t3, e2, i = 0, o = false) {
      if (!kl(t3, e2)) return false;
      let n = t3, s2 = e2;
      if (o && !this.compareCoord(n[0], s2[0])) {
        let l = this.fixStartIndex(s2, n);
        if (l) s2 = l;
        else return false;
      }
      let c2 = this.compareCoord(n[i], s2[i]);
      return this.direction || c2 ? this.comparePath(n, s2) : this.compareCoord(n[i], s2[s2.length - (1 + i)]) ? this.comparePath(n.slice().reverse(), s2) : false;
    }
    fixStartIndex(t3, e2) {
      let i, o = -1;
      for (let n = 0; n < t3.length; n++) if (this.compareCoord(t3[n], e2[0])) {
        o = n;
        break;
      }
      return o >= 0 && (i = [].concat(t3.slice(o, t3.length), t3.slice(1, o + 1))), i;
    }
    comparePath(t3, e2) {
      return t3.every((i, o) => this.compareCoord(i, e2[o]));
    }
    comparePolygon(t3, e2) {
      if (this.compareLine(t3.coordinates[0], e2.coordinates[0], 1, true)) {
        let i = t3.coordinates.slice(1, t3.coordinates.length), o = e2.coordinates.slice(1, e2.coordinates.length);
        return i.every((n) => o.some((s2) => this.compareLine(n, s2, 1, true)));
      }
      return false;
    }
    compareGeometryCollection(t3, e2) {
      return kl(t3.geometries, e2.geometries) && this.compareBBox(t3, e2) && t3.geometries.every((i, o) => this.compare(i, e2.geometries[o]));
    }
    compareFeature(t3, e2) {
      return t3.id === e2.id && (this.compareProperties ? AM.default.call(void 0, t3.properties, e2.properties) : true) && this.compareBBox(t3, e2) && this.compare(t3.geometry, e2.geometry);
    }
    compareFeatureCollection(t3, e2) {
      return kl(t3.features, e2.features) && this.compareBBox(t3, e2) && t3.features.every((i, o) => this.compare(i, e2.features[o]));
    }
    compareBBox(t3, e2) {
      return !t3.bbox && !e2.bbox || (t3.bbox && e2.bbox ? this.compareCoord(t3.bbox, e2.bbox) : false);
    }
  };
  ye(XC, "GeojsonEquality");
  var FM = XC;
  function kl(r3, t3) {
    return r3.coordinates ? r3.coordinates.length === t3.coordinates.length : r3.length === t3.length;
  }
  ye(kl, "sameLength");
  function gg(r3) {
    return r3.coordinates.map((t3) => ({ type: r3.type.replace("Multi", ""), coordinates: t3 }));
  }
  ye(gg, "explode");
  var _t = 63710088e-1, bg = { centimeters: _t * 100, centimetres: _t * 100, degrees: 360 / (2 * Math.PI), feet: _t * 3.28084, inches: _t * 39.37, kilometers: _t / 1e3, kilometres: _t / 1e3, meters: _t, metres: _t, miles: _t / 1609.344, millimeters: _t * 1e3, millimetres: _t * 1e3, nauticalmiles: _t / 1852, radians: 1, yards: _t * 1.0936 }, yg = { acres: 247105e-9, centimeters: 1e4, centimetres: 1e4, feet: 10.763910417, hectares: 1e-4, inches: 1550.003100006, kilometers: 1e-6, kilometres: 1e-6, meters: 1, metres: 1, miles: 386e-9, nauticalmiles: 29155334959812285e-23, millimeters: 1e6, millimetres: 1e6, yards: 1.195990046 };
  function wi(r3, t3, e2 = {}) {
    let i = { type: "Feature" };
    return (e2.id === 0 || e2.id) && (i.id = e2.id), e2.bbox && (i.bbox = e2.bbox), i.properties = t3 || {}, i.geometry = r3, i;
  }
  ye(wi, "feature");
  function YC(r3, t3, e2 = {}) {
    switch (r3) {
      case "Point":
        return Dd(t3).geometry;
      case "LineString":
        return Od(t3).geometry;
      case "Polygon":
        return Ed(t3).geometry;
      case "MultiPoint":
        return Cg(t3).geometry;
      case "MultiLineString":
        return vg(t3).geometry;
      case "MultiPolygon":
        return Sg(t3).geometry;
      default:
        throw new Error(r3 + " is invalid");
    }
  }
  ye(YC, "geometry");
  function Dd(r3, t3, e2 = {}) {
    if (!r3) throw new Error("coordinates is required");
    if (!Array.isArray(r3)) throw new Error("coordinates must be an Array");
    if (r3.length < 2) throw new Error("coordinates must be at least 2 numbers long");
    if (!Bl(r3[0]) || !Bl(r3[1])) throw new Error("coordinates must contain numbers");
    return wi({ type: "Point", coordinates: r3 }, t3, e2);
  }
  ye(Dd, "point");
  function ZC(r3, t3, e2 = {}) {
    return _l(r3.map((i) => Dd(i, t3)), e2);
  }
  ye(ZC, "points");
  function Ed(r3, t3, e2 = {}) {
    for (let o of r3) {
      if (o.length < 4) throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
      if (o[o.length - 1].length !== o[0].length) throw new Error("First and last Position are not equivalent.");
      for (let n = 0; n < o[o.length - 1].length; n++) if (o[o.length - 1][n] !== o[0][n]) throw new Error("First and last Position are not equivalent.");
    }
    return wi({ type: "Polygon", coordinates: r3 }, t3, e2);
  }
  ye(Ed, "polygon");
  function zC(r3, t3, e2 = {}) {
    return _l(r3.map((i) => Ed(i, t3)), e2);
  }
  ye(zC, "polygons");
  function Od(r3, t3, e2 = {}) {
    if (r3.length < 2) throw new Error("coordinates must be an array of two or more positions");
    return wi({ type: "LineString", coordinates: r3 }, t3, e2);
  }
  ye(Od, "lineString");
  function qC(r3, t3, e2 = {}) {
    return _l(r3.map((i) => Od(i, t3)), e2);
  }
  ye(qC, "lineStrings");
  function _l(r3, t3 = {}) {
    let e2 = { type: "FeatureCollection" };
    return t3.id && (e2.id = t3.id), t3.bbox && (e2.bbox = t3.bbox), e2.features = r3, e2;
  }
  ye(_l, "featureCollection");
  function vg(r3, t3, e2 = {}) {
    return wi({ type: "MultiLineString", coordinates: r3 }, t3, e2);
  }
  ye(vg, "multiLineString");
  function Cg(r3, t3, e2 = {}) {
    return wi({ type: "MultiPoint", coordinates: r3 }, t3, e2);
  }
  ye(Cg, "multiPoint");
  function Sg(r3, t3, e2 = {}) {
    return wi({ type: "MultiPolygon", coordinates: r3 }, t3, e2);
  }
  ye(Sg, "multiPolygon");
  function $C(r3, t3, e2 = {}) {
    return wi({ type: "GeometryCollection", geometries: r3 }, t3, e2);
  }
  ye($C, "geometryCollection");
  function JC(r3, t3 = 0) {
    if (t3 && !(t3 >= 0)) throw new Error("precision must be a positive number");
    let e2 = Math.pow(10, t3 || 0);
    return Math.round(r3 * e2) / e2;
  }
  ye(JC, "round");
  function xg2(r3, t3 = "kilometers") {
    let e2 = bg[t3];
    if (!e2) throw new Error(t3 + " units is invalid");
    return r3 * e2;
  }
  ye(xg2, "radiansToLength");
  function Ld(r3, t3 = "kilometers") {
    let e2 = bg[t3];
    if (!e2) throw new Error(t3 + " units is invalid");
    return r3 / e2;
  }
  ye(Ld, "lengthToRadians");
  function QC(r3, t3) {
    return Ig(Ld(r3, t3));
  }
  ye(QC, "lengthToDegrees");
  function KC(r3) {
    let t3 = r3 % 360;
    return t3 < 0 && (t3 += 360), t3;
  }
  ye(KC, "bearingToAzimuth");
  function Ig(r3) {
    return r3 % (2 * Math.PI) * 180 / Math.PI;
  }
  ye(Ig, "radiansToDegrees");
  function e4(r3) {
    return r3 % 360 * Math.PI / 180;
  }
  ye(e4, "degreesToRadians");
  function t4(r3, t3 = "kilometers", e2 = "kilometers") {
    if (!(r3 >= 0)) throw new Error("length must be a positive number");
    return xg2(Ld(r3, t3), e2);
  }
  ye(t4, "convertLength");
  function r4(r3, t3 = "meters", e2 = "kilometers") {
    if (!(r3 >= 0)) throw new Error("area must be a positive number");
    let i = yg[t3];
    if (!i) throw new Error("invalid original units");
    let o = yg[e2];
    if (!o) throw new Error("invalid final units");
    return r3 / i * o;
  }
  ye(r4, "convertArea");
  function Bl(r3) {
    return !isNaN(r3) && r3 !== null && !Array.isArray(r3);
  }
  ye(Bl, "isNumber");
  function i4(r3) {
    return r3 !== null && typeof r3 == "object" && !Array.isArray(r3);
  }
  ye(i4, "isObject");
  function o4(r3) {
    if (!r3) throw new Error("bbox is required");
    if (!Array.isArray(r3)) throw new Error("bbox must be an Array");
    if (r3.length !== 4 && r3.length !== 6) throw new Error("bbox must be an Array of 4 or 6 numbers");
    r3.forEach((t3) => {
      if (!Bl(t3)) throw new Error("bbox must only contain numbers");
    });
  }
  ye(o4, "validateBBox");
  function n4(r3) {
    if (!r3) throw new Error("id is required");
    if (["string", "number"].indexOf(typeof r3) === -1) throw new Error("id must be a number or a string");
  }
  ye(n4, "validateId");
  fe2.GeojsonEquality = FM;
  fe2.areaFactors = yg;
  fe2.bearingToAzimuth = KC;
  fe2.convertArea = r4;
  fe2.convertLength = t4;
  fe2.degreesToRadians = e4;
  fe2.earthRadius = _t;
  fe2.factors = bg;
  fe2.feature = wi;
  fe2.featureCollection = _l;
  fe2.geometry = YC;
  fe2.geometryCollection = $C;
  fe2.isNumber = Bl;
  fe2.isObject = i4;
  fe2.lengthToDegrees = QC;
  fe2.lengthToRadians = Ld;
  fe2.lineString = Od;
  fe2.lineStrings = qC;
  fe2.multiLineString = vg;
  fe2.multiPoint = Cg;
  fe2.multiPolygon = Sg;
  fe2.point = Dd;
  fe2.points = ZC;
  fe2.polygon = Ed;
  fe2.polygons = zC;
  fe2.radiansToDegrees = Ig;
  fe2.radiansToLength = xg2;
  fe2.round = JC;
  fe2.validateBBox = o4;
  fe2.validateId = n4;
});
var y4 = q((Ze) => {
  "use strict";
  c();
  Object.defineProperty(Ze, "__esModule", { value: true });
  var kM = Object.defineProperty, at2 = (r3, t3) => kM(r3, "name", { value: t3, configurable: true }), yt = a4();
  function Ka(r3, t3, e2) {
    if (r3 !== null) for (var i, o, n, s2, c2, l, p, d = 0, f = 0, g, v2 = r3.type, b = v2 === "FeatureCollection", C = v2 === "Feature", y = b ? r3.features.length : 1, S = 0; S < y; S++) {
      p = b ? r3.features[S].geometry : C ? r3.geometry : r3, g = p ? p.type === "GeometryCollection" : false, c2 = g ? p.geometries.length : 1;
      for (var T = 0; T < c2; T++) {
        var w2 = 0, M2 = 0;
        if (s2 = g ? p.geometries[T] : p, s2 !== null) {
          l = s2.coordinates;
          var D = s2.type;
          switch (d = e2 && (D === "Polygon" || D === "MultiPolygon") ? 1 : 0, D) {
            case null:
              break;
            case "Point":
              if (t3(l, f, S, w2, M2) === false) return false;
              f++, w2++;
              break;
            case "LineString":
            case "MultiPoint":
              for (i = 0; i < l.length; i++) {
                if (t3(l[i], f, S, w2, M2) === false) return false;
                f++, D === "MultiPoint" && w2++;
              }
              D === "LineString" && w2++;
              break;
            case "Polygon":
            case "MultiLineString":
              for (i = 0; i < l.length; i++) {
                for (o = 0; o < l[i].length - d; o++) {
                  if (t3(l[i][o], f, S, w2, M2) === false) return false;
                  f++;
                }
                D === "MultiLineString" && w2++, D === "Polygon" && M2++;
              }
              D === "Polygon" && w2++;
              break;
            case "MultiPolygon":
              for (i = 0; i < l.length; i++) {
                for (M2 = 0, o = 0; o < l[i].length; o++) {
                  for (n = 0; n < l[i][o].length - d; n++) {
                    if (t3(l[i][o][n], f, S, w2, M2) === false) return false;
                    f++;
                  }
                  M2++;
                }
                w2++;
              }
              break;
            case "GeometryCollection":
              for (i = 0; i < s2.geometries.length; i++) if (Ka(s2.geometries[i], t3, e2) === false) return false;
              break;
            default:
              throw new Error("Unknown Geometry Type");
          }
        }
      }
    }
  }
  at2(Ka, "coordEach");
  function s4(r3, t3, e2, i) {
    var o = e2;
    return Ka(r3, function(n, s2, c2, l, p) {
      s2 === 0 && e2 === void 0 ? o = n : o = t3(o, n, s2, c2, l, p);
    }, i), o;
  }
  at2(s4, "coordReduce");
  function Pg(r3, t3) {
    var e2;
    switch (r3.type) {
      case "FeatureCollection":
        for (e2 = 0; e2 < r3.features.length && t3(r3.features[e2].properties, e2) !== false; e2++) ;
        break;
      case "Feature":
        t3(r3.properties, 0);
        break;
    }
  }
  at2(Pg, "propEach");
  function l4(r3, t3, e2) {
    var i = e2;
    return Pg(r3, function(o, n) {
      n === 0 && e2 === void 0 ? i = o : i = t3(i, o, n);
    }), i;
  }
  at2(l4, "propReduce");
  function Mg(r3, t3) {
    if (r3.type === "Feature") t3(r3, 0);
    else if (r3.type === "FeatureCollection") for (var e2 = 0; e2 < r3.features.length && t3(r3.features[e2], e2) !== false; e2++) ;
  }
  at2(Mg, "featureEach");
  function c4(r3, t3, e2) {
    var i = e2;
    return Mg(r3, function(o, n) {
      n === 0 && e2 === void 0 ? i = o : i = t3(i, o, n);
    }), i;
  }
  at2(c4, "featureReduce");
  function p4(r3) {
    var t3 = [];
    return Ka(r3, function(e2) {
      t3.push(e2);
    }), t3;
  }
  at2(p4, "coordAll");
  function Ad(r3, t3) {
    var e2, i, o, n, s2, c2, l, p, d, f, g = 0, v2 = r3.type === "FeatureCollection", b = r3.type === "Feature", C = v2 ? r3.features.length : 1;
    for (e2 = 0; e2 < C; e2++) {
      for (c2 = v2 ? r3.features[e2].geometry : b ? r3.geometry : r3, p = v2 ? r3.features[e2].properties : b ? r3.properties : {}, d = v2 ? r3.features[e2].bbox : b ? r3.bbox : void 0, f = v2 ? r3.features[e2].id : b ? r3.id : void 0, l = c2 ? c2.type === "GeometryCollection" : false, s2 = l ? c2.geometries.length : 1, o = 0; o < s2; o++) {
        if (n = l ? c2.geometries[o] : c2, n === null) {
          if (t3(null, g, p, d, f) === false) return false;
          continue;
        }
        switch (n.type) {
          case "Point":
          case "LineString":
          case "MultiPoint":
          case "Polygon":
          case "MultiLineString":
          case "MultiPolygon": {
            if (t3(n, g, p, d, f) === false) return false;
            break;
          }
          case "GeometryCollection": {
            for (i = 0; i < n.geometries.length; i++) if (t3(n.geometries[i], g, p, d, f) === false) return false;
            break;
          }
          default:
            throw new Error("Unknown Geometry Type");
        }
      }
      g++;
    }
  }
  at2(Ad, "geomEach");
  function u4(r3, t3, e2) {
    var i = e2;
    return Ad(r3, function(o, n, s2, c2, l) {
      n === 0 && e2 === void 0 ? i = o : i = t3(i, o, n, s2, c2, l);
    }), i;
  }
  at2(u4, "geomReduce");
  function Rl(r3, t3) {
    Ad(r3, function(e2, i, o, n, s2) {
      var c2 = e2 === null ? null : e2.type;
      switch (c2) {
        case null:
        case "Point":
        case "LineString":
        case "Polygon":
          return t3(yt.feature.call(void 0, e2, o, { bbox: n, id: s2 }), i, 0) === false ? false : void 0;
      }
      var l;
      switch (c2) {
        case "MultiPoint":
          l = "Point";
          break;
        case "MultiLineString":
          l = "LineString";
          break;
        case "MultiPolygon":
          l = "Polygon";
          break;
      }
      for (var p = 0; p < e2.coordinates.length; p++) {
        var d = e2.coordinates[p], f = { type: l, coordinates: d };
        if (t3(yt.feature.call(void 0, f, o), i, p) === false) return false;
      }
    });
  }
  at2(Rl, "flattenEach");
  function d4(r3, t3, e2) {
    var i = e2;
    return Rl(r3, function(o, n, s2) {
      n === 0 && s2 === 0 && e2 === void 0 ? i = o : i = t3(i, o, n, s2);
    }), i;
  }
  at2(d4, "flattenReduce");
  function Tg(r3, t3) {
    Rl(r3, function(e2, i, o) {
      var n = 0;
      if (e2.geometry) {
        var s2 = e2.geometry.type;
        if (!(s2 === "Point" || s2 === "MultiPoint")) {
          var c2, l = 0, p = 0, d = 0;
          if (Ka(e2, function(f, g, v2, b, C) {
            if (c2 === void 0 || i > l || b > p || C > d) {
              c2 = f, l = i, p = b, d = C, n = 0;
              return;
            }
            var y = yt.lineString.call(void 0, [c2, f], e2.properties);
            if (t3(y, i, o, C, n) === false) return false;
            n++, c2 = f;
          }) === false) return false;
        }
      }
    });
  }
  at2(Tg, "segmentEach");
  function h4(r3, t3, e2) {
    var i = e2, o = false;
    return Tg(r3, function(n, s2, c2, l, p) {
      o === false && e2 === void 0 ? i = n : i = t3(i, n, s2, c2, l, p), o = true;
    }), i;
  }
  at2(h4, "segmentReduce");
  function wg(r3, t3) {
    if (!r3) throw new Error("geojson is required");
    Rl(r3, function(e2, i, o) {
      if (e2.geometry !== null) {
        var n = e2.geometry.type, s2 = e2.geometry.coordinates;
        switch (n) {
          case "LineString":
            if (t3(e2, i, o, 0, 0) === false) return false;
            break;
          case "Polygon":
            for (var c2 = 0; c2 < s2.length; c2++) if (t3(yt.lineString.call(void 0, s2[c2], e2.properties), i, o, c2) === false) return false;
            break;
        }
      }
    });
  }
  at2(wg, "lineEach");
  function f4(r3, t3, e2) {
    var i = e2;
    return wg(r3, function(o, n, s2, c2) {
      n === 0 && e2 === void 0 ? i = o : i = t3(i, o, n, s2, c2);
    }), i;
  }
  at2(f4, "lineReduce");
  function m4(r3, t3) {
    if (t3 = t3 || {}, !yt.isObject.call(void 0, t3)) throw new Error("options is invalid");
    var e2 = t3.featureIndex || 0, i = t3.multiFeatureIndex || 0, o = t3.geometryIndex || 0, n = t3.segmentIndex || 0, s2 = t3.properties, c2;
    switch (r3.type) {
      case "FeatureCollection":
        e2 < 0 && (e2 = r3.features.length + e2), s2 = s2 || r3.features[e2].properties, c2 = r3.features[e2].geometry;
        break;
      case "Feature":
        s2 = s2 || r3.properties, c2 = r3.geometry;
        break;
      case "Point":
      case "MultiPoint":
        return null;
      case "LineString":
      case "Polygon":
      case "MultiLineString":
      case "MultiPolygon":
        c2 = r3;
        break;
      default:
        throw new Error("geojson is invalid");
    }
    if (c2 === null) return null;
    var l = c2.coordinates;
    switch (c2.type) {
      case "Point":
      case "MultiPoint":
        return null;
      case "LineString":
        return n < 0 && (n = l.length + n - 1), yt.lineString.call(void 0, [l[n], l[n + 1]], s2, t3);
      case "Polygon":
        return o < 0 && (o = l.length + o), n < 0 && (n = l[o].length + n - 1), yt.lineString.call(void 0, [l[o][n], l[o][n + 1]], s2, t3);
      case "MultiLineString":
        return i < 0 && (i = l.length + i), n < 0 && (n = l[i].length + n - 1), yt.lineString.call(void 0, [l[i][n], l[i][n + 1]], s2, t3);
      case "MultiPolygon":
        return i < 0 && (i = l.length + i), o < 0 && (o = l[i].length + o), n < 0 && (n = l[i][o].length - n - 1), yt.lineString.call(void 0, [l[i][o][n], l[i][o][n + 1]], s2, t3);
    }
    throw new Error("geojson is invalid");
  }
  at2(m4, "findSegment");
  function g4(r3, t3) {
    if (t3 = t3 || {}, !yt.isObject.call(void 0, t3)) throw new Error("options is invalid");
    var e2 = t3.featureIndex || 0, i = t3.multiFeatureIndex || 0, o = t3.geometryIndex || 0, n = t3.coordIndex || 0, s2 = t3.properties, c2;
    switch (r3.type) {
      case "FeatureCollection":
        e2 < 0 && (e2 = r3.features.length + e2), s2 = s2 || r3.features[e2].properties, c2 = r3.features[e2].geometry;
        break;
      case "Feature":
        s2 = s2 || r3.properties, c2 = r3.geometry;
        break;
      case "Point":
      case "MultiPoint":
        return null;
      case "LineString":
      case "Polygon":
      case "MultiLineString":
      case "MultiPolygon":
        c2 = r3;
        break;
      default:
        throw new Error("geojson is invalid");
    }
    if (c2 === null) return null;
    var l = c2.coordinates;
    switch (c2.type) {
      case "Point":
        return yt.point.call(void 0, l, s2, t3);
      case "MultiPoint":
        return i < 0 && (i = l.length + i), yt.point.call(void 0, l[i], s2, t3);
      case "LineString":
        return n < 0 && (n = l.length + n), yt.point.call(void 0, l[n], s2, t3);
      case "Polygon":
        return o < 0 && (o = l.length + o), n < 0 && (n = l[o].length + n), yt.point.call(void 0, l[o][n], s2, t3);
      case "MultiLineString":
        return i < 0 && (i = l.length + i), n < 0 && (n = l[i].length + n), yt.point.call(void 0, l[i][n], s2, t3);
      case "MultiPolygon":
        return i < 0 && (i = l.length + i), o < 0 && (o = l[i].length + o), n < 0 && (n = l[i][o].length - n), yt.point.call(void 0, l[i][o][n], s2, t3);
    }
    throw new Error("geojson is invalid");
  }
  at2(g4, "findPoint");
  Ze.coordAll = p4;
  Ze.coordEach = Ka;
  Ze.coordReduce = s4;
  Ze.featureEach = Mg;
  Ze.featureReduce = c4;
  Ze.findPoint = g4;
  Ze.findSegment = m4;
  Ze.flattenEach = Rl;
  Ze.flattenReduce = d4;
  Ze.geomEach = Ad;
  Ze.geomReduce = u4;
  Ze.lineEach = wg;
  Ze.lineReduce = f4;
  Ze.propEach = Pg;
  Ze.propReduce = l4;
  Ze.segmentEach = Tg;
  Ze.segmentReduce = h4;
});
var b4 = q((Fd) => {
  "use strict";
  c();
  Object.defineProperty(Fd, "__esModule", { value: true });
  var BM = Object.defineProperty, _M = (r3, t3) => BM(r3, "name", { value: t3, configurable: true }), RM = y4();
  function Dg(r3, t3 = {}) {
    if (r3.bbox != null && t3.recompute !== true) return r3.bbox;
    let e2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
    return RM.coordEach.call(void 0, r3, (i) => {
      e2[0] > i[0] && (e2[0] = i[0]), e2[1] > i[1] && (e2[1] = i[1]), e2[2] < i[0] && (e2[2] = i[0]), e2[3] < i[1] && (e2[3] = i[1]);
    }), e2;
  }
  _M(Dg, "bbox");
  var NM = Dg;
  Fd.bbox = Dg;
  Fd.default = NM;
});
var I4 = q((sF, Eg) => {
  c();
  var qr2 = yb(), C4 = $f(), S4 = wb(), es = b4().default, GM = S4.featureEach, nF = S4.coordEach, aF = C4.polygon, v4 = C4.featureCollection;
  function x4(r3) {
    var t3 = new qr2(r3);
    return t3.insert = function(e2) {
      if (e2.type !== "Feature") throw new Error("invalid feature");
      return e2.bbox = e2.bbox ? e2.bbox : es(e2), qr2.prototype.insert.call(this, e2);
    }, t3.load = function(e2) {
      var i = [];
      return Array.isArray(e2) ? e2.forEach(function(o) {
        if (o.type !== "Feature") throw new Error("invalid features");
        o.bbox = o.bbox ? o.bbox : es(o), i.push(o);
      }) : GM(e2, function(o) {
        if (o.type !== "Feature") throw new Error("invalid features");
        o.bbox = o.bbox ? o.bbox : es(o), i.push(o);
      }), qr2.prototype.load.call(this, i);
    }, t3.remove = function(e2, i) {
      if (e2.type !== "Feature") throw new Error("invalid feature");
      return e2.bbox = e2.bbox ? e2.bbox : es(e2), qr2.prototype.remove.call(this, e2, i);
    }, t3.clear = function() {
      return qr2.prototype.clear.call(this);
    }, t3.search = function(e2) {
      var i = qr2.prototype.search.call(this, this.toBBox(e2));
      return v4(i);
    }, t3.collides = function(e2) {
      return qr2.prototype.collides.call(this, this.toBBox(e2));
    }, t3.all = function() {
      var e2 = qr2.prototype.all.call(this);
      return v4(e2);
    }, t3.toJSON = function() {
      return qr2.prototype.toJSON.call(this);
    }, t3.fromJSON = function(e2) {
      return qr2.prototype.fromJSON.call(this, e2);
    }, t3.toBBox = function(e2) {
      var i;
      if (e2.bbox) i = e2.bbox;
      else if (Array.isArray(e2) && e2.length === 4) i = e2;
      else if (Array.isArray(e2) && e2.length === 6) i = [e2[0], e2[1], e2[3], e2[4]];
      else if (e2.type === "Feature") i = es(e2);
      else if (e2.type === "FeatureCollection") i = es(e2);
      else throw new Error("invalid geojson");
      return { minX: i[0], minY: i[1], maxX: i[2], maxY: i[3] };
    }, t3;
  }
  Eg.exports = x4;
  Eg.exports.default = x4;
});
var z5 = q((lj, Dc) => {
  "use strict";
  c();
  var PT = false, qn = false, j5 = true, U5 = false, h = {}, H5 = false;
  typeof Dc < "u" && Dc.exports ? (Dc.exports = h, H5 = true) : typeof document < "u" ? window.ClipperLib = h : self.ClipperLib = h;
  var lh;
  H5 ? ($e = "chrome", lh = "Netscape") : ($e = navigator.userAgent.toString().toLowerCase(), lh = navigator.appName);
  var $e, le = {};
  $e.indexOf("chrome") != -1 && $e.indexOf("chromium") == -1 ? le.chrome = 1 : le.chrome = 0;
  $e.indexOf("chromium") != -1 ? le.chromium = 1 : le.chromium = 0;
  $e.indexOf("safari") != -1 && $e.indexOf("chrome") == -1 && $e.indexOf("chromium") == -1 ? le.safari = 1 : le.safari = 0;
  $e.indexOf("firefox") != -1 ? le.firefox = 1 : le.firefox = 0;
  $e.indexOf("firefox/17") != -1 ? le.firefox17 = 1 : le.firefox17 = 0;
  $e.indexOf("firefox/15") != -1 ? le.firefox15 = 1 : le.firefox15 = 0;
  $e.indexOf("firefox/3") != -1 ? le.firefox3 = 1 : le.firefox3 = 0;
  $e.indexOf("opera") != -1 ? le.opera = 1 : le.opera = 0;
  $e.indexOf("msie 10") != -1 ? le.msie10 = 1 : le.msie10 = 0;
  $e.indexOf("msie 9") != -1 ? le.msie9 = 1 : le.msie9 = 0;
  $e.indexOf("msie 8") != -1 ? le.msie8 = 1 : le.msie8 = 0;
  $e.indexOf("msie 7") != -1 ? le.msie7 = 1 : le.msie7 = 0;
  $e.indexOf("msie ") != -1 ? le.msie = 1 : le.msie = 0;
  h.biginteger_used = null;
  var Go2, MT = 244837814094590, G5 = (MT & 16777215) == 15715070;
  function R2(r3, t3, e2) {
    h.biginteger_used = 1, r3 != null && (typeof r3 == "number" && typeof t3 > "u" ? this.fromInt(r3) : typeof r3 == "number" ? this.fromNumber(r3, t3, e2) : t3 == null && typeof r3 != "string" ? this.fromString(r3, 256) : this.fromString(r3, t3));
  }
  function pe() {
    return new R2(null);
  }
  function TT(r3, t3, e2, i, o, n) {
    for (; --n >= 0; ) {
      var s2 = t3 * this[r3++] + e2[i] + o;
      o = Math.floor(s2 / 67108864), e2[i++] = s2 & 67108863;
    }
    return o;
  }
  function wT(r3, t3, e2, i, o, n) {
    for (var s2 = t3 & 32767, c2 = t3 >> 15; --n >= 0; ) {
      var l = this[r3] & 32767, p = this[r3++] >> 15, d = c2 * l + p * s2;
      l = s2 * l + ((d & 32767) << 15) + e2[i] + (o & 1073741823), o = (l >>> 30) + (d >>> 15) + c2 * p + (o >>> 30), e2[i++] = l & 1073741823;
    }
    return o;
  }
  function DT(r3, t3, e2, i, o, n) {
    for (var s2 = t3 & 16383, c2 = t3 >> 14; --n >= 0; ) {
      var l = this[r3] & 16383, p = this[r3++] >> 14, d = c2 * l + p * s2;
      l = s2 * l + ((d & 16383) << 14) + e2[i] + o, o = (l >> 28) + (d >> 14) + c2 * p, e2[i++] = l & 268435455;
    }
    return o;
  }
  G5 && lh == "Microsoft Internet Explorer" ? (R2.prototype.am = wT, Go2 = 30) : G5 && lh != "Netscape" ? (R2.prototype.am = TT, Go2 = 26) : (R2.prototype.am = DT, Go2 = 28);
  R2.prototype.DB = Go2;
  R2.prototype.DM = (1 << Go2) - 1;
  R2.prototype.DV = 1 << Go2;
  var gy2 = 52;
  R2.prototype.FV = Math.pow(2, gy2);
  R2.prototype.F1 = gy2 - Go2;
  R2.prototype.F2 = 2 * Go2 - gy2;
  var ET = "0123456789abcdefghijklmnopqrstuvwxyz", ph = new Array(), xs, pr;
  xs = 48;
  for (pr = 0; pr <= 9; ++pr) ph[xs++] = pr;
  xs = 97;
  for (pr = 10; pr < 36; ++pr) ph[xs++] = pr;
  xs = 65;
  for (pr = 10; pr < 36; ++pr) ph[xs++] = pr;
  function V5(r3) {
    return ET.charAt(r3);
  }
  function W5(r3, t3) {
    var e2 = ph[r3.charCodeAt(t3)];
    return e2 == null ? -1 : e2;
  }
  function OT(r3) {
    for (var t3 = this.t - 1; t3 >= 0; --t3) r3[t3] = this[t3];
    r3.t = this.t, r3.s = this.s;
  }
  function LT(r3) {
    this.t = 1, this.s = r3 < 0 ? -1 : 0, r3 > 0 ? this[0] = r3 : r3 < -1 ? this[0] = r3 + this.DV : this.t = 0;
  }
  function No(r3) {
    var t3 = pe();
    return t3.fromInt(r3), t3;
  }
  function AT(r3, t3) {
    var e2;
    if (t3 == 16) e2 = 4;
    else if (t3 == 8) e2 = 3;
    else if (t3 == 256) e2 = 8;
    else if (t3 == 2) e2 = 1;
    else if (t3 == 32) e2 = 5;
    else if (t3 == 4) e2 = 2;
    else {
      this.fromRadix(r3, t3);
      return;
    }
    this.t = 0, this.s = 0;
    for (var i = r3.length, o = false, n = 0; --i >= 0; ) {
      var s2 = e2 == 8 ? r3[i] & 255 : W5(r3, i);
      if (s2 < 0) {
        r3.charAt(i) == "-" && (o = true);
        continue;
      }
      o = false, n == 0 ? this[this.t++] = s2 : n + e2 > this.DB ? (this[this.t - 1] |= (s2 & (1 << this.DB - n) - 1) << n, this[this.t++] = s2 >> this.DB - n) : this[this.t - 1] |= s2 << n, n += e2, n >= this.DB && (n -= this.DB);
    }
    e2 == 8 && (r3[0] & 128) != 0 && (this.s = -1, n > 0 && (this[this.t - 1] |= (1 << this.DB - n) - 1 << n)), this.clamp(), o && R2.ZERO.subTo(this, this);
  }
  function FT() {
    for (var r3 = this.s & this.DM; this.t > 0 && this[this.t - 1] == r3; ) --this.t;
  }
  function kT(r3) {
    if (this.s < 0) return "-" + this.negate().toString(r3);
    var t3;
    if (r3 == 16) t3 = 4;
    else if (r3 == 8) t3 = 3;
    else if (r3 == 2) t3 = 1;
    else if (r3 == 32) t3 = 5;
    else if (r3 == 4) t3 = 2;
    else return this.toRadix(r3);
    var e2 = (1 << t3) - 1, i, o = false, n = "", s2 = this.t, c2 = this.DB - s2 * this.DB % t3;
    if (s2-- > 0) for (c2 < this.DB && (i = this[s2] >> c2) > 0 && (o = true, n = V5(i)); s2 >= 0; ) c2 < t3 ? (i = (this[s2] & (1 << c2) - 1) << t3 - c2, i |= this[--s2] >> (c2 += this.DB - t3)) : (i = this[s2] >> (c2 -= t3) & e2, c2 <= 0 && (c2 += this.DB, --s2)), i > 0 && (o = true), o && (n += V5(i));
    return o ? n : "0";
  }
  function BT() {
    var r3 = pe();
    return R2.ZERO.subTo(this, r3), r3;
  }
  function _T() {
    return this.s < 0 ? this.negate() : this;
  }
  function RT(r3) {
    var t3 = this.s - r3.s;
    if (t3 != 0) return t3;
    var e2 = this.t;
    if (t3 = e2 - r3.t, t3 != 0) return this.s < 0 ? -t3 : t3;
    for (; --e2 >= 0; ) if ((t3 = this[e2] - r3[e2]) != 0) return t3;
    return 0;
  }
  function uh(r3) {
    var t3 = 1, e2;
    return (e2 = r3 >>> 16) != 0 && (r3 = e2, t3 += 16), (e2 = r3 >> 8) != 0 && (r3 = e2, t3 += 8), (e2 = r3 >> 4) != 0 && (r3 = e2, t3 += 4), (e2 = r3 >> 2) != 0 && (r3 = e2, t3 += 2), (e2 = r3 >> 1) != 0 && (r3 = e2, t3 += 1), t3;
  }
  function NT() {
    return this.t <= 0 ? 0 : this.DB * (this.t - 1) + uh(this[this.t - 1] ^ this.s & this.DM);
  }
  function GT(r3, t3) {
    var e2;
    for (e2 = this.t - 1; e2 >= 0; --e2) t3[e2 + r3] = this[e2];
    for (e2 = r3 - 1; e2 >= 0; --e2) t3[e2] = 0;
    t3.t = this.t + r3, t3.s = this.s;
  }
  function VT(r3, t3) {
    for (var e2 = r3; e2 < this.t; ++e2) t3[e2 - r3] = this[e2];
    t3.t = Math.max(this.t - r3, 0), t3.s = this.s;
  }
  function jT(r3, t3) {
    var e2 = r3 % this.DB, i = this.DB - e2, o = (1 << i) - 1, n = Math.floor(r3 / this.DB), s2 = this.s << e2 & this.DM, c2;
    for (c2 = this.t - 1; c2 >= 0; --c2) t3[c2 + n + 1] = this[c2] >> i | s2, s2 = (this[c2] & o) << e2;
    for (c2 = n - 1; c2 >= 0; --c2) t3[c2] = 0;
    t3[n] = s2, t3.t = this.t + n + 1, t3.s = this.s, t3.clamp();
  }
  function UT(r3, t3) {
    t3.s = this.s;
    var e2 = Math.floor(r3 / this.DB);
    if (e2 >= this.t) {
      t3.t = 0;
      return;
    }
    var i = r3 % this.DB, o = this.DB - i, n = (1 << i) - 1;
    t3[0] = this[e2] >> i;
    for (var s2 = e2 + 1; s2 < this.t; ++s2) t3[s2 - e2 - 1] |= (this[s2] & n) << o, t3[s2 - e2] = this[s2] >> i;
    i > 0 && (t3[this.t - e2 - 1] |= (this.s & n) << o), t3.t = this.t - e2, t3.clamp();
  }
  function HT(r3, t3) {
    for (var e2 = 0, i = 0, o = Math.min(r3.t, this.t); e2 < o; ) i += this[e2] - r3[e2], t3[e2++] = i & this.DM, i >>= this.DB;
    if (r3.t < this.t) {
      for (i -= r3.s; e2 < this.t; ) i += this[e2], t3[e2++] = i & this.DM, i >>= this.DB;
      i += this.s;
    } else {
      for (i += this.s; e2 < r3.t; ) i -= r3[e2], t3[e2++] = i & this.DM, i >>= this.DB;
      i -= r3.s;
    }
    t3.s = i < 0 ? -1 : 0, i < -1 ? t3[e2++] = this.DV + i : i > 0 && (t3[e2++] = i), t3.t = e2, t3.clamp();
  }
  function WT(r3, t3) {
    var e2 = this.abs(), i = r3.abs(), o = e2.t;
    for (t3.t = o + i.t; --o >= 0; ) t3[o] = 0;
    for (o = 0; o < i.t; ++o) t3[o + e2.t] = e2.am(0, i[o], t3, o, 0, e2.t);
    t3.s = 0, t3.clamp(), this.s != r3.s && R2.ZERO.subTo(t3, t3);
  }
  function XT(r3) {
    for (var t3 = this.abs(), e2 = r3.t = 2 * t3.t; --e2 >= 0; ) r3[e2] = 0;
    for (e2 = 0; e2 < t3.t - 1; ++e2) {
      var i = t3.am(e2, t3[e2], r3, 2 * e2, 0, 1);
      (r3[e2 + t3.t] += t3.am(e2 + 1, 2 * t3[e2], r3, 2 * e2 + 1, i, t3.t - e2 - 1)) >= t3.DV && (r3[e2 + t3.t] -= t3.DV, r3[e2 + t3.t + 1] = 1);
    }
    r3.t > 0 && (r3[r3.t - 1] += t3.am(e2, t3[e2], r3, 2 * e2, 0, 1)), r3.s = 0, r3.clamp();
  }
  function YT(r3, t3, e2) {
    var i = r3.abs();
    if (!(i.t <= 0)) {
      var o = this.abs();
      if (o.t < i.t) {
        t3 != null && t3.fromInt(0), e2 != null && this.copyTo(e2);
        return;
      }
      e2 == null && (e2 = pe());
      var n = pe(), s2 = this.s, c2 = r3.s, l = this.DB - uh(i[i.t - 1]);
      l > 0 ? (i.lShiftTo(l, n), o.lShiftTo(l, e2)) : (i.copyTo(n), o.copyTo(e2));
      var p = n.t, d = n[p - 1];
      if (d != 0) {
        var f = d * (1 << this.F1) + (p > 1 ? n[p - 2] >> this.F2 : 0), g = this.FV / f, v2 = (1 << this.F1) / f, b = 1 << this.F2, C = e2.t, y = C - p, S = t3 == null ? pe() : t3;
        for (n.dlShiftTo(y, S), e2.compareTo(S) >= 0 && (e2[e2.t++] = 1, e2.subTo(S, e2)), R2.ONE.dlShiftTo(p, S), S.subTo(n, n); n.t < p; ) n[n.t++] = 0;
        for (; --y >= 0; ) {
          var T = e2[--C] == d ? this.DM : Math.floor(e2[C] * g + (e2[C - 1] + b) * v2);
          if ((e2[C] += n.am(0, T, e2, y, 0, p)) < T) for (n.dlShiftTo(y, S), e2.subTo(S, e2); e2[C] < --T; ) e2.subTo(S, e2);
        }
        t3 != null && (e2.drShiftTo(p, t3), s2 != c2 && R2.ZERO.subTo(t3, t3)), e2.t = p, e2.clamp(), l > 0 && e2.rShiftTo(l, e2), s2 < 0 && R2.ZERO.subTo(e2, e2);
      }
    }
  }
  function ZT(r3) {
    var t3 = pe();
    return this.abs().divRemTo(r3, null, t3), this.s < 0 && t3.compareTo(R2.ZERO) > 0 && r3.subTo(t3, t3), t3;
  }
  function $n(r3) {
    this.m = r3;
  }
  function zT(r3) {
    return r3.s < 0 || r3.compareTo(this.m) >= 0 ? r3.mod(this.m) : r3;
  }
  function qT(r3) {
    return r3;
  }
  function $T(r3) {
    r3.divRemTo(this.m, null, r3);
  }
  function JT(r3, t3, e2) {
    r3.multiplyTo(t3, e2), this.reduce(e2);
  }
  function QT(r3, t3) {
    r3.squareTo(t3), this.reduce(t3);
  }
  $n.prototype.convert = zT;
  $n.prototype.revert = qT;
  $n.prototype.reduce = $T;
  $n.prototype.mulTo = JT;
  $n.prototype.sqrTo = QT;
  function KT() {
    if (this.t < 1) return 0;
    var r3 = this[0];
    if ((r3 & 1) == 0) return 0;
    var t3 = r3 & 3;
    return t3 = t3 * (2 - (r3 & 15) * t3) & 15, t3 = t3 * (2 - (r3 & 255) * t3) & 255, t3 = t3 * (2 - ((r3 & 65535) * t3 & 65535)) & 65535, t3 = t3 * (2 - r3 * t3 % this.DV) % this.DV, t3 > 0 ? this.DV - t3 : -t3;
  }
  function Jn(r3) {
    this.m = r3, this.mp = r3.invDigit(), this.mpl = this.mp & 32767, this.mph = this.mp >> 15, this.um = (1 << r3.DB - 15) - 1, this.mt2 = 2 * r3.t;
  }
  function e9(r3) {
    var t3 = pe();
    return r3.abs().dlShiftTo(this.m.t, t3), t3.divRemTo(this.m, null, t3), r3.s < 0 && t3.compareTo(R2.ZERO) > 0 && this.m.subTo(t3, t3), t3;
  }
  function t9(r3) {
    var t3 = pe();
    return r3.copyTo(t3), this.reduce(t3), t3;
  }
  function r9(r3) {
    for (; r3.t <= this.mt2; ) r3[r3.t++] = 0;
    for (var t3 = 0; t3 < this.m.t; ++t3) {
      var e2 = r3[t3] & 32767, i = e2 * this.mpl + ((e2 * this.mph + (r3[t3] >> 15) * this.mpl & this.um) << 15) & r3.DM;
      for (e2 = t3 + this.m.t, r3[e2] += this.m.am(0, i, r3, t3, 0, this.m.t); r3[e2] >= r3.DV; ) r3[e2] -= r3.DV, r3[++e2]++;
    }
    r3.clamp(), r3.drShiftTo(this.m.t, r3), r3.compareTo(this.m) >= 0 && r3.subTo(this.m, r3);
  }
  function i9(r3, t3) {
    r3.squareTo(t3), this.reduce(t3);
  }
  function o9(r3, t3, e2) {
    r3.multiplyTo(t3, e2), this.reduce(e2);
  }
  Jn.prototype.convert = e9;
  Jn.prototype.revert = t9;
  Jn.prototype.reduce = r9;
  Jn.prototype.mulTo = o9;
  Jn.prototype.sqrTo = i9;
  function n9() {
    return (this.t > 0 ? this[0] & 1 : this.s) == 0;
  }
  function a9(r3, t3) {
    if (r3 > 4294967295 || r3 < 1) return R2.ONE;
    var e2 = pe(), i = pe(), o = t3.convert(this), n = uh(r3) - 1;
    for (o.copyTo(e2); --n >= 0; ) if (t3.sqrTo(e2, i), (r3 & 1 << n) > 0) t3.mulTo(i, o, e2);
    else {
      var s2 = e2;
      e2 = i, i = s2;
    }
    return t3.revert(e2);
  }
  function s9(r3, t3) {
    var e2;
    return r3 < 256 || t3.isEven() ? e2 = new $n(t3) : e2 = new Jn(t3), this.exp(r3, e2);
  }
  R2.prototype.copyTo = OT;
  R2.prototype.fromInt = LT;
  R2.prototype.fromString = AT;
  R2.prototype.clamp = FT;
  R2.prototype.dlShiftTo = GT;
  R2.prototype.drShiftTo = VT;
  R2.prototype.lShiftTo = jT;
  R2.prototype.rShiftTo = UT;
  R2.prototype.subTo = HT;
  R2.prototype.multiplyTo = WT;
  R2.prototype.squareTo = XT;
  R2.prototype.divRemTo = YT;
  R2.prototype.invDigit = KT;
  R2.prototype.isEven = n9;
  R2.prototype.exp = a9;
  R2.prototype.toString = kT;
  R2.prototype.negate = BT;
  R2.prototype.abs = _T;
  R2.prototype.compareTo = RT;
  R2.prototype.bitLength = NT;
  R2.prototype.mod = ZT;
  R2.prototype.modPowInt = s9;
  R2.ZERO = No(0);
  R2.ONE = No(1);
  function l9() {
    var r3 = pe();
    return this.copyTo(r3), r3;
  }
  function c9() {
    if (this.s < 0) {
      if (this.t == 1) return this[0] - this.DV;
      if (this.t == 0) return -1;
    } else {
      if (this.t == 1) return this[0];
      if (this.t == 0) return 0;
    }
    return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
  }
  function p9() {
    return this.t == 0 ? this.s : this[0] << 24 >> 24;
  }
  function u9() {
    return this.t == 0 ? this.s : this[0] << 16 >> 16;
  }
  function d9(r3) {
    return Math.floor(Math.LN2 * this.DB / Math.log(r3));
  }
  function h9() {
    return this.s < 0 ? -1 : this.t <= 0 || this.t == 1 && this[0] <= 0 ? 0 : 1;
  }
  function f9(r3) {
    if (r3 == null && (r3 = 10), this.signum() == 0 || r3 < 2 || r3 > 36) return "0";
    var t3 = this.chunkSize(r3), e2 = Math.pow(r3, t3), i = No(e2), o = pe(), n = pe(), s2 = "";
    for (this.divRemTo(i, o, n); o.signum() > 0; ) s2 = (e2 + n.intValue()).toString(r3).substr(1) + s2, o.divRemTo(i, o, n);
    return n.intValue().toString(r3) + s2;
  }
  function m9(r3, t3) {
    this.fromInt(0), t3 == null && (t3 = 10);
    for (var e2 = this.chunkSize(t3), i = Math.pow(t3, e2), o = false, n = 0, s2 = 0, c2 = 0; c2 < r3.length; ++c2) {
      var l = W5(r3, c2);
      if (l < 0) {
        r3.charAt(c2) == "-" && this.signum() == 0 && (o = true);
        continue;
      }
      s2 = t3 * s2 + l, ++n >= e2 && (this.dMultiply(i), this.dAddOffset(s2, 0), n = 0, s2 = 0);
    }
    n > 0 && (this.dMultiply(Math.pow(t3, n)), this.dAddOffset(s2, 0)), o && R2.ZERO.subTo(this, this);
  }
  function g9(r3, t3, e2) {
    if (typeof t3 == "number") if (r3 < 2) this.fromInt(1);
    else for (this.fromNumber(r3, e2), this.testBit(r3 - 1) || this.bitwiseTo(R2.ONE.shiftLeft(r3 - 1), yy, this), this.isEven() && this.dAddOffset(1, 0); !this.isProbablePrime(t3); ) this.dAddOffset(2, 0), this.bitLength() > r3 && this.subTo(R2.ONE.shiftLeft(r3 - 1), this);
    else {
      var i = new Array(), o = r3 & 7;
      i.length = (r3 >> 3) + 1, t3.nextBytes(i), o > 0 ? i[0] &= (1 << o) - 1 : i[0] = 0, this.fromString(i, 256);
    }
  }
  function y9() {
    var r3 = this.t, t3 = new Array();
    t3[0] = this.s;
    var e2 = this.DB - r3 * this.DB % 8, i, o = 0;
    if (r3-- > 0) for (e2 < this.DB && (i = this[r3] >> e2) != (this.s & this.DM) >> e2 && (t3[o++] = i | this.s << this.DB - e2); r3 >= 0; ) e2 < 8 ? (i = (this[r3] & (1 << e2) - 1) << 8 - e2, i |= this[--r3] >> (e2 += this.DB - 8)) : (i = this[r3] >> (e2 -= 8) & 255, e2 <= 0 && (e2 += this.DB, --r3)), (i & 128) != 0 && (i |= -256), o == 0 && (this.s & 128) != (i & 128) && ++o, (o > 0 || i != this.s) && (t3[o++] = i);
    return t3;
  }
  function b9(r3) {
    return this.compareTo(r3) == 0;
  }
  function v9(r3) {
    return this.compareTo(r3) < 0 ? this : r3;
  }
  function C9(r3) {
    return this.compareTo(r3) > 0 ? this : r3;
  }
  function S9(r3, t3, e2) {
    var i, o, n = Math.min(r3.t, this.t);
    for (i = 0; i < n; ++i) e2[i] = t3(this[i], r3[i]);
    if (r3.t < this.t) {
      for (o = r3.s & this.DM, i = n; i < this.t; ++i) e2[i] = t3(this[i], o);
      e2.t = this.t;
    } else {
      for (o = this.s & this.DM, i = n; i < r3.t; ++i) e2[i] = t3(o, r3[i]);
      e2.t = r3.t;
    }
    e2.s = t3(this.s, r3.s), e2.clamp();
  }
  function x9(r3, t3) {
    return r3 & t3;
  }
  function I9(r3) {
    var t3 = pe();
    return this.bitwiseTo(r3, x9, t3), t3;
  }
  function yy(r3, t3) {
    return r3 | t3;
  }
  function P9(r3) {
    var t3 = pe();
    return this.bitwiseTo(r3, yy, t3), t3;
  }
  function X5(r3, t3) {
    return r3 ^ t3;
  }
  function M9(r3) {
    var t3 = pe();
    return this.bitwiseTo(r3, X5, t3), t3;
  }
  function Y5(r3, t3) {
    return r3 & ~t3;
  }
  function T9(r3) {
    var t3 = pe();
    return this.bitwiseTo(r3, Y5, t3), t3;
  }
  function w9() {
    for (var r3 = pe(), t3 = 0; t3 < this.t; ++t3) r3[t3] = this.DM & ~this[t3];
    return r3.t = this.t, r3.s = ~this.s, r3;
  }
  function D9(r3) {
    var t3 = pe();
    return r3 < 0 ? this.rShiftTo(-r3, t3) : this.lShiftTo(r3, t3), t3;
  }
  function E9(r3) {
    var t3 = pe();
    return r3 < 0 ? this.lShiftTo(-r3, t3) : this.rShiftTo(r3, t3), t3;
  }
  function O9(r3) {
    if (r3 == 0) return -1;
    var t3 = 0;
    return (r3 & 65535) == 0 && (r3 >>= 16, t3 += 16), (r3 & 255) == 0 && (r3 >>= 8, t3 += 8), (r3 & 15) == 0 && (r3 >>= 4, t3 += 4), (r3 & 3) == 0 && (r3 >>= 2, t3 += 2), (r3 & 1) == 0 && ++t3, t3;
  }
  function L9() {
    for (var r3 = 0; r3 < this.t; ++r3) if (this[r3] != 0) return r3 * this.DB + O9(this[r3]);
    return this.s < 0 ? this.t * this.DB : -1;
  }
  function A9(r3) {
    for (var t3 = 0; r3 != 0; ) r3 &= r3 - 1, ++t3;
    return t3;
  }
  function F9() {
    for (var r3 = 0, t3 = this.s & this.DM, e2 = 0; e2 < this.t; ++e2) r3 += A9(this[e2] ^ t3);
    return r3;
  }
  function k9(r3) {
    var t3 = Math.floor(r3 / this.DB);
    return t3 >= this.t ? this.s != 0 : (this[t3] & 1 << r3 % this.DB) != 0;
  }
  function B9(r3, t3) {
    var e2 = R2.ONE.shiftLeft(r3);
    return this.bitwiseTo(e2, t3, e2), e2;
  }
  function _9(r3) {
    return this.changeBit(r3, yy);
  }
  function R9(r3) {
    return this.changeBit(r3, Y5);
  }
  function N9(r3) {
    return this.changeBit(r3, X5);
  }
  function G9(r3, t3) {
    for (var e2 = 0, i = 0, o = Math.min(r3.t, this.t); e2 < o; ) i += this[e2] + r3[e2], t3[e2++] = i & this.DM, i >>= this.DB;
    if (r3.t < this.t) {
      for (i += r3.s; e2 < this.t; ) i += this[e2], t3[e2++] = i & this.DM, i >>= this.DB;
      i += this.s;
    } else {
      for (i += this.s; e2 < r3.t; ) i += r3[e2], t3[e2++] = i & this.DM, i >>= this.DB;
      i += r3.s;
    }
    t3.s = i < 0 ? -1 : 0, i > 0 ? t3[e2++] = i : i < -1 && (t3[e2++] = this.DV + i), t3.t = e2, t3.clamp();
  }
  function V9(r3) {
    var t3 = pe();
    return this.addTo(r3, t3), t3;
  }
  function j9(r3) {
    var t3 = pe();
    return this.subTo(r3, t3), t3;
  }
  function U9(r3) {
    var t3 = pe();
    return this.multiplyTo(r3, t3), t3;
  }
  function H9() {
    var r3 = pe();
    return this.squareTo(r3), r3;
  }
  function W9(r3) {
    var t3 = pe();
    return this.divRemTo(r3, t3, null), t3;
  }
  function X9(r3) {
    var t3 = pe();
    return this.divRemTo(r3, null, t3), t3;
  }
  function Y9(r3) {
    var t3 = pe(), e2 = pe();
    return this.divRemTo(r3, t3, e2), new Array(t3, e2);
  }
  function Z9(r3) {
    this[this.t] = this.am(0, r3 - 1, this, 0, 0, this.t), ++this.t, this.clamp();
  }
  function z9(r3, t3) {
    if (r3 != 0) {
      for (; this.t <= t3; ) this[this.t++] = 0;
      for (this[t3] += r3; this[t3] >= this.DV; ) this[t3] -= this.DV, ++t3 >= this.t && (this[this.t++] = 0), ++this[t3];
    }
  }
  function Ec() {
  }
  function Z5(r3) {
    return r3;
  }
  function q9(r3, t3, e2) {
    r3.multiplyTo(t3, e2);
  }
  function $9(r3, t3) {
    r3.squareTo(t3);
  }
  Ec.prototype.convert = Z5;
  Ec.prototype.revert = Z5;
  Ec.prototype.mulTo = q9;
  Ec.prototype.sqrTo = $9;
  function J9(r3) {
    return this.exp(r3, new Ec());
  }
  function Q9(r3, t3, e2) {
    var i = Math.min(this.t + r3.t, t3);
    for (e2.s = 0, e2.t = i; i > 0; ) e2[--i] = 0;
    var o;
    for (o = e2.t - this.t; i < o; ++i) e2[i + this.t] = this.am(0, r3[i], e2, i, 0, this.t);
    for (o = Math.min(r3.t, t3); i < o; ++i) this.am(0, r3[i], e2, i, 0, t3 - i);
    e2.clamp();
  }
  function K9(r3, t3, e2) {
    --t3;
    var i = e2.t = this.t + r3.t - t3;
    for (e2.s = 0; --i >= 0; ) e2[i] = 0;
    for (i = Math.max(t3 - this.t, 0); i < r3.t; ++i) e2[this.t + i - t3] = this.am(t3 - i, r3[i], e2, 0, 0, this.t + i - t3);
    e2.clamp(), e2.drShiftTo(1, e2);
  }
  function Is(r3) {
    this.r2 = pe(), this.q3 = pe(), R2.ONE.dlShiftTo(2 * r3.t, this.r2), this.mu = this.r2.divide(r3), this.m = r3;
  }
  function e8(r3) {
    if (r3.s < 0 || r3.t > 2 * this.m.t) return r3.mod(this.m);
    if (r3.compareTo(this.m) < 0) return r3;
    var t3 = pe();
    return r3.copyTo(t3), this.reduce(t3), t3;
  }
  function t8(r3) {
    return r3;
  }
  function r8(r3) {
    for (r3.drShiftTo(this.m.t - 1, this.r2), r3.t > this.m.t + 1 && (r3.t = this.m.t + 1, r3.clamp()), this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3), this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2); r3.compareTo(this.r2) < 0; ) r3.dAddOffset(1, this.m.t + 1);
    for (r3.subTo(this.r2, r3); r3.compareTo(this.m) >= 0; ) r3.subTo(this.m, r3);
  }
  function i8(r3, t3) {
    r3.squareTo(t3), this.reduce(t3);
  }
  function o8(r3, t3, e2) {
    r3.multiplyTo(t3, e2), this.reduce(e2);
  }
  Is.prototype.convert = e8;
  Is.prototype.revert = t8;
  Is.prototype.reduce = r8;
  Is.prototype.mulTo = o8;
  Is.prototype.sqrTo = i8;
  function n8(r3, t3) {
    var e2 = r3.bitLength(), i, o = No(1), n;
    if (e2 <= 0) return o;
    e2 < 18 ? i = 1 : e2 < 48 ? i = 3 : e2 < 144 ? i = 4 : e2 < 768 ? i = 5 : i = 6, e2 < 8 ? n = new $n(t3) : t3.isEven() ? n = new Is(t3) : n = new Jn(t3);
    var s2 = new Array(), c2 = 3, l = i - 1, p = (1 << i) - 1;
    if (s2[1] = n.convert(this), i > 1) {
      var d = pe();
      for (n.sqrTo(s2[1], d); c2 <= p; ) s2[c2] = pe(), n.mulTo(d, s2[c2 - 2], s2[c2]), c2 += 2;
    }
    var f = r3.t - 1, g, v2 = true, b = pe(), C;
    for (e2 = uh(r3[f]) - 1; f >= 0; ) {
      for (e2 >= l ? g = r3[f] >> e2 - l & p : (g = (r3[f] & (1 << e2 + 1) - 1) << l - e2, f > 0 && (g |= r3[f - 1] >> this.DB + e2 - l)), c2 = i; (g & 1) == 0; ) g >>= 1, --c2;
      if ((e2 -= c2) < 0 && (e2 += this.DB, --f), v2) s2[g].copyTo(o), v2 = false;
      else {
        for (; c2 > 1; ) n.sqrTo(o, b), n.sqrTo(b, o), c2 -= 2;
        c2 > 0 ? n.sqrTo(o, b) : (C = o, o = b, b = C), n.mulTo(b, s2[g], o);
      }
      for (; f >= 0 && (r3[f] & 1 << e2) == 0; ) n.sqrTo(o, b), C = o, o = b, b = C, --e2 < 0 && (e2 = this.DB - 1, --f);
    }
    return n.revert(o);
  }
  function a8(r3) {
    var t3 = this.s < 0 ? this.negate() : this.clone(), e2 = r3.s < 0 ? r3.negate() : r3.clone();
    if (t3.compareTo(e2) < 0) {
      var i = t3;
      t3 = e2, e2 = i;
    }
    var o = t3.getLowestSetBit(), n = e2.getLowestSetBit();
    if (n < 0) return t3;
    for (o < n && (n = o), n > 0 && (t3.rShiftTo(n, t3), e2.rShiftTo(n, e2)); t3.signum() > 0; ) (o = t3.getLowestSetBit()) > 0 && t3.rShiftTo(o, t3), (o = e2.getLowestSetBit()) > 0 && e2.rShiftTo(o, e2), t3.compareTo(e2) >= 0 ? (t3.subTo(e2, t3), t3.rShiftTo(1, t3)) : (e2.subTo(t3, e2), e2.rShiftTo(1, e2));
    return n > 0 && e2.lShiftTo(n, e2), e2;
  }
  function s8(r3) {
    if (r3 <= 0) return 0;
    var t3 = this.DV % r3, e2 = this.s < 0 ? r3 - 1 : 0;
    if (this.t > 0) if (t3 == 0) e2 = this[0] % r3;
    else for (var i = this.t - 1; i >= 0; --i) e2 = (t3 * e2 + this[i]) % r3;
    return e2;
  }
  function l8(r3) {
    var t3 = r3.isEven();
    if (this.isEven() && t3 || r3.signum() == 0) return R2.ZERO;
    for (var e2 = r3.clone(), i = this.clone(), o = No(1), n = No(0), s2 = No(0), c2 = No(1); e2.signum() != 0; ) {
      for (; e2.isEven(); ) e2.rShiftTo(1, e2), t3 ? ((!o.isEven() || !n.isEven()) && (o.addTo(this, o), n.subTo(r3, n)), o.rShiftTo(1, o)) : n.isEven() || n.subTo(r3, n), n.rShiftTo(1, n);
      for (; i.isEven(); ) i.rShiftTo(1, i), t3 ? ((!s2.isEven() || !c2.isEven()) && (s2.addTo(this, s2), c2.subTo(r3, c2)), s2.rShiftTo(1, s2)) : c2.isEven() || c2.subTo(r3, c2), c2.rShiftTo(1, c2);
      e2.compareTo(i) >= 0 ? (e2.subTo(i, e2), t3 && o.subTo(s2, o), n.subTo(c2, n)) : (i.subTo(e2, i), t3 && s2.subTo(o, s2), c2.subTo(n, c2));
    }
    if (i.compareTo(R2.ONE) != 0) return R2.ZERO;
    if (c2.compareTo(r3) >= 0) return c2.subtract(r3);
    if (c2.signum() < 0) c2.addTo(r3, c2);
    else return c2;
    return c2.signum() < 0 ? c2.add(r3) : c2;
  }
  var wt = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997], c8 = (1 << 26) / wt[wt.length - 1];
  function p8(r3) {
    var t3, e2 = this.abs();
    if (e2.t == 1 && e2[0] <= wt[wt.length - 1]) {
      for (t3 = 0; t3 < wt.length; ++t3) if (e2[0] == wt[t3]) return true;
      return false;
    }
    if (e2.isEven()) return false;
    for (t3 = 1; t3 < wt.length; ) {
      for (var i = wt[t3], o = t3 + 1; o < wt.length && i < c8; ) i *= wt[o++];
      for (i = e2.modInt(i); t3 < o; ) if (i % wt[t3++] == 0) return false;
    }
    return e2.millerRabin(r3);
  }
  function u8(r3) {
    var t3 = this.subtract(R2.ONE), e2 = t3.getLowestSetBit();
    if (e2 <= 0) return false;
    var i = t3.shiftRight(e2);
    r3 = r3 + 1 >> 1, r3 > wt.length && (r3 = wt.length);
    for (var o = pe(), n = 0; n < r3; ++n) {
      o.fromInt(wt[Math.floor(Math.random() * wt.length)]);
      var s2 = o.modPow(i, this);
      if (s2.compareTo(R2.ONE) != 0 && s2.compareTo(t3) != 0) {
        for (var c2 = 1; c2++ < e2 && s2.compareTo(t3) != 0; ) if (s2 = s2.modPowInt(2, this), s2.compareTo(R2.ONE) == 0) return false;
        if (s2.compareTo(t3) != 0) return false;
      }
    }
    return true;
  }
  R2.prototype.chunkSize = d9;
  R2.prototype.toRadix = f9;
  R2.prototype.fromRadix = m9;
  R2.prototype.fromNumber = g9;
  R2.prototype.bitwiseTo = S9;
  R2.prototype.changeBit = B9;
  R2.prototype.addTo = G9;
  R2.prototype.dMultiply = Z9;
  R2.prototype.dAddOffset = z9;
  R2.prototype.multiplyLowerTo = Q9;
  R2.prototype.multiplyUpperTo = K9;
  R2.prototype.modInt = s8;
  R2.prototype.millerRabin = u8;
  R2.prototype.clone = l9;
  R2.prototype.intValue = c9;
  R2.prototype.byteValue = p9;
  R2.prototype.shortValue = u9;
  R2.prototype.signum = h9;
  R2.prototype.toByteArray = y9;
  R2.prototype.equals = b9;
  R2.prototype.min = v9;
  R2.prototype.max = C9;
  R2.prototype.and = I9;
  R2.prototype.or = P9;
  R2.prototype.xor = M9;
  R2.prototype.andNot = T9;
  R2.prototype.not = w9;
  R2.prototype.shiftLeft = D9;
  R2.prototype.shiftRight = E9;
  R2.prototype.getLowestSetBit = L9;
  R2.prototype.bitCount = F9;
  R2.prototype.testBit = k9;
  R2.prototype.setBit = _9;
  R2.prototype.clearBit = R9;
  R2.prototype.flipBit = N9;
  R2.prototype.add = V9;
  R2.prototype.subtract = j9;
  R2.prototype.multiply = U9;
  R2.prototype.divide = W9;
  R2.prototype.remainder = X9;
  R2.prototype.divideAndRemainder = Y9;
  R2.prototype.modPow = n8;
  R2.prototype.modInverse = l8;
  R2.prototype.pow = J9;
  R2.prototype.gcd = a8;
  R2.prototype.isProbablePrime = p8;
  R2.prototype.square = H9;
  var se = R2;
  se.prototype.IsNegative = function() {
    return this.compareTo(se.ZERO) == -1;
  };
  se.op_Equality = function(r3, t3) {
    return r3.compareTo(t3) == 0;
  };
  se.op_Inequality = function(r3, t3) {
    return r3.compareTo(t3) != 0;
  };
  se.op_GreaterThan = function(r3, t3) {
    return r3.compareTo(t3) > 0;
  };
  se.op_LessThan = function(r3, t3) {
    return r3.compareTo(t3) < 0;
  };
  se.op_Addition = function(r3, t3) {
    return new se(r3).add(new se(t3));
  };
  se.op_Subtraction = function(r3, t3) {
    return new se(r3).subtract(new se(t3));
  };
  se.Int128Mul = function(r3, t3) {
    return new se(r3).multiply(new se(t3));
  };
  se.op_Division = function(r3, t3) {
    return r3.divide(t3);
  };
  se.prototype.ToDouble = function() {
    return parseFloat(this.toString());
  };
  typeof ch > "u" && (ch = function(r3, t3) {
    var e2;
    if (typeof Object.getOwnPropertyNames > "u") {
      for (e2 in t3.prototype) (typeof r3.prototype[e2] > "u" || r3.prototype[e2] == Object.prototype[e2]) && (r3.prototype[e2] = t3.prototype[e2]);
      for (e2 in t3) typeof r3[e2] > "u" && (r3[e2] = t3[e2]);
      r3.$baseCtor = t3;
    } else {
      for (var i = Object.getOwnPropertyNames(t3.prototype), o = 0; o < i.length; o++) typeof Object.getOwnPropertyDescriptor(r3.prototype, i[o]) > "u" && Object.defineProperty(r3.prototype, i[o], Object.getOwnPropertyDescriptor(t3.prototype, i[o]));
      for (e2 in t3) typeof r3[e2] > "u" && (r3[e2] = t3[e2]);
      r3.$baseCtor = t3;
    }
  });
  var ch;
  h.Path = function() {
    return [];
  };
  h.Paths = function() {
    return [];
  };
  h.DoublePoint = function() {
    var r3 = arguments;
    this.X = 0, this.Y = 0, r3.length == 1 ? (this.X = r3[0].X, this.Y = r3[0].Y) : r3.length == 2 && (this.X = r3[0], this.Y = r3[1]);
  };
  h.DoublePoint0 = function() {
    this.X = 0, this.Y = 0;
  };
  h.DoublePoint1 = function(r3) {
    this.X = r3.X, this.Y = r3.Y;
  };
  h.DoublePoint2 = function(r3, t3) {
    this.X = r3, this.Y = t3;
  };
  h.PolyNode = function() {
    this.m_Parent = null, this.m_polygon = new h.Path(), this.m_Index = 0, this.m_jointype = 0, this.m_endtype = 0, this.m_Childs = [], this.IsOpen = false;
  };
  h.PolyNode.prototype.IsHoleNode = function() {
    for (var r3 = true, t3 = this.m_Parent; t3 !== null; ) r3 = !r3, t3 = t3.m_Parent;
    return r3;
  };
  h.PolyNode.prototype.ChildCount = function() {
    return this.m_Childs.length;
  };
  h.PolyNode.prototype.Contour = function() {
    return this.m_polygon;
  };
  h.PolyNode.prototype.AddChild = function(r3) {
    var t3 = this.m_Childs.length;
    this.m_Childs.push(r3), r3.m_Parent = this, r3.m_Index = t3;
  };
  h.PolyNode.prototype.GetNext = function() {
    return this.m_Childs.length > 0 ? this.m_Childs[0] : this.GetNextSiblingUp();
  };
  h.PolyNode.prototype.GetNextSiblingUp = function() {
    return this.m_Parent === null ? null : this.m_Index == this.m_Parent.m_Childs.length - 1 ? this.m_Parent.GetNextSiblingUp() : this.m_Parent.m_Childs[this.m_Index + 1];
  };
  h.PolyNode.prototype.Childs = function() {
    return this.m_Childs;
  };
  h.PolyNode.prototype.Parent = function() {
    return this.m_Parent;
  };
  h.PolyNode.prototype.IsHole = function() {
    return this.IsHoleNode();
  };
  h.PolyTree = function() {
    this.m_AllPolys = [], h.PolyNode.call(this);
  };
  h.PolyTree.prototype.Clear = function() {
    for (var r3 = 0, t3 = this.m_AllPolys.length; r3 < t3; r3++) this.m_AllPolys[r3] = null;
    this.m_AllPolys.length = 0, this.m_Childs.length = 0;
  };
  h.PolyTree.prototype.GetFirst = function() {
    return this.m_Childs.length > 0 ? this.m_Childs[0] : null;
  };
  h.PolyTree.prototype.Total = function() {
    return this.m_AllPolys.length;
  };
  ch(h.PolyTree, h.PolyNode);
  h.Math_Abs_Int64 = h.Math_Abs_Int32 = h.Math_Abs_Double = function(r3) {
    return Math.abs(r3);
  };
  h.Math_Max_Int32_Int32 = function(r3, t3) {
    return Math.max(r3, t3);
  };
  le.msie || le.opera || le.safari ? h.Cast_Int32 = function(r3) {
    return r3 | 0;
  } : h.Cast_Int32 = function(r3) {
    return ~~r3;
  };
  le.chrome ? h.Cast_Int64 = function(r3) {
    return r3 < -2147483648 || r3 > 2147483647 ? r3 < 0 ? Math.ceil(r3) : Math.floor(r3) : ~~r3;
  } : le.firefox && typeof Number.toInteger == "function" ? h.Cast_Int64 = function(r3) {
    return Number.toInteger(r3);
  } : le.msie7 || le.msie8 ? h.Cast_Int64 = function(r3) {
    return parseInt(r3, 10);
  } : le.msie ? h.Cast_Int64 = function(r3) {
    return r3 < -2147483648 || r3 > 2147483647 ? r3 < 0 ? Math.ceil(r3) : Math.floor(r3) : r3 | 0;
  } : h.Cast_Int64 = function(r3) {
    return r3 < 0 ? Math.ceil(r3) : Math.floor(r3);
  };
  h.Clear = function(r3) {
    r3.length = 0;
  };
  h.PI = 3.141592653589793;
  h.PI2 = 2 * 3.141592653589793;
  h.IntPoint = function() {
    var r3 = arguments, t3 = r3.length;
    if (this.X = 0, this.Y = 0, qn) if (this.Z = 0, t3 == 3) this.X = r3[0], this.Y = r3[1], this.Z = r3[2];
    else if (t3 == 2) this.X = r3[0], this.Y = r3[1], this.Z = 0;
    else if (t3 == 1) if (r3[0] instanceof h.DoublePoint) {
      var e2 = r3[0];
      this.X = h.Clipper.Round(e2.X), this.Y = h.Clipper.Round(e2.Y), this.Z = 0;
    } else {
      var i = r3[0];
      typeof i.Z > "u" && (i.Z = 0), this.X = i.X, this.Y = i.Y, this.Z = i.Z;
    }
    else this.X = 0, this.Y = 0, this.Z = 0;
    else if (t3 == 2) this.X = r3[0], this.Y = r3[1];
    else if (t3 == 1) if (r3[0] instanceof h.DoublePoint) {
      var e2 = r3[0];
      this.X = h.Clipper.Round(e2.X), this.Y = h.Clipper.Round(e2.Y);
    } else {
      var i = r3[0];
      this.X = i.X, this.Y = i.Y;
    }
    else this.X = 0, this.Y = 0;
  };
  h.IntPoint.op_Equality = function(r3, t3) {
    return r3.X == t3.X && r3.Y == t3.Y;
  };
  h.IntPoint.op_Inequality = function(r3, t3) {
    return r3.X != t3.X || r3.Y != t3.Y;
  };
  qn ? (h.IntPoint0 = function() {
    this.X = 0, this.Y = 0, this.Z = 0;
  }, h.IntPoint1 = function(r3) {
    this.X = r3.X, this.Y = r3.Y, this.Z = r3.Z;
  }, h.IntPoint1dp = function(r3) {
    this.X = h.Clipper.Round(r3.X), this.Y = h.Clipper.Round(r3.Y), this.Z = 0;
  }, h.IntPoint2 = function(r3, t3) {
    this.X = r3, this.Y = t3, this.Z = 0;
  }, h.IntPoint3 = function(r3, t3, e2) {
    this.X = r3, this.Y = t3, this.Z = e2;
  }) : (h.IntPoint0 = function() {
    this.X = 0, this.Y = 0;
  }, h.IntPoint1 = function(r3) {
    this.X = r3.X, this.Y = r3.Y;
  }, h.IntPoint1dp = function(r3) {
    this.X = h.Clipper.Round(r3.X), this.Y = h.Clipper.Round(r3.Y);
  }, h.IntPoint2 = function(r3, t3) {
    this.X = r3, this.Y = t3;
  });
  h.IntRect = function() {
    var r3 = arguments, t3 = r3.length;
    t3 == 4 ? (this.left = r3[0], this.top = r3[1], this.right = r3[2], this.bottom = r3[3]) : t3 == 1 ? (this.left = ir.left, this.top = ir.top, this.right = ir.right, this.bottom = ir.bottom) : (this.left = 0, this.top = 0, this.right = 0, this.bottom = 0);
  };
  h.IntRect0 = function() {
    this.left = 0, this.top = 0, this.right = 0, this.bottom = 0;
  };
  h.IntRect1 = function(r3) {
    this.left = r3.left, this.top = r3.top, this.right = r3.right, this.bottom = r3.bottom;
  };
  h.IntRect4 = function(r3, t3, e2, i) {
    this.left = r3, this.top = t3, this.right = e2, this.bottom = i;
  };
  h.ClipType = { ctIntersection: 0, ctUnion: 1, ctDifference: 2, ctXor: 3 };
  h.PolyType = { ptSubject: 0, ptClip: 1 };
  h.PolyFillType = { pftEvenOdd: 0, pftNonZero: 1, pftPositive: 2, pftNegative: 3 };
  h.JoinType = { jtSquare: 0, jtRound: 1, jtMiter: 2 };
  h.EndType = { etOpenSquare: 0, etOpenRound: 1, etOpenButt: 2, etClosedLine: 3, etClosedPolygon: 4 };
  U5 && (h.EndType_ = { etSquare: 0, etRound: 1, etButt: 2, etClosed: 3 });
  h.EdgeSide = { esLeft: 0, esRight: 1 };
  h.Direction = { dRightToLeft: 0, dLeftToRight: 1 };
  h.TEdge = function() {
    this.Bot = new h.IntPoint(), this.Curr = new h.IntPoint(), this.Top = new h.IntPoint(), this.Delta = new h.IntPoint(), this.Dx = 0, this.PolyTyp = h.PolyType.ptSubject, this.Side = h.EdgeSide.esLeft, this.WindDelta = 0, this.WindCnt = 0, this.WindCnt2 = 0, this.OutIdx = 0, this.Next = null, this.Prev = null, this.NextInLML = null, this.NextInAEL = null, this.PrevInAEL = null, this.NextInSEL = null, this.PrevInSEL = null;
  };
  h.IntersectNode = function() {
    this.Edge1 = null, this.Edge2 = null, this.Pt = new h.IntPoint();
  };
  h.MyIntersectNodeSort = function() {
  };
  h.MyIntersectNodeSort.Compare = function(r3, t3) {
    return t3.Pt.Y - r3.Pt.Y;
  };
  h.LocalMinima = function() {
    this.Y = 0, this.LeftBound = null, this.RightBound = null, this.Next = null;
  };
  h.Scanbeam = function() {
    this.Y = 0, this.Next = null;
  };
  h.OutRec = function() {
    this.Idx = 0, this.IsHole = false, this.IsOpen = false, this.FirstLeft = null, this.Pts = null, this.BottomPt = null, this.PolyNode = null;
  };
  h.OutPt = function() {
    this.Idx = 0, this.Pt = new h.IntPoint(), this.Next = null, this.Prev = null;
  };
  h.Join = function() {
    this.OutPt1 = null, this.OutPt2 = null, this.OffPt = new h.IntPoint();
  };
  h.ClipperBase = function() {
    this.m_MinimaList = null, this.m_CurrentLM = null, this.m_edges = new Array(), this.m_UseFullRange = false, this.m_HasOpenPaths = false, this.PreserveCollinear = false, this.m_MinimaList = null, this.m_CurrentLM = null, this.m_UseFullRange = false, this.m_HasOpenPaths = false;
  };
  h.ClipperBase.horizontal = -9007199254740992;
  h.ClipperBase.Skip = -2;
  h.ClipperBase.Unassigned = -1;
  h.ClipperBase.tolerance = 1e-20;
  PT ? (h.ClipperBase.loRange = 46340, h.ClipperBase.hiRange = 46340) : (h.ClipperBase.loRange = 47453132, h.ClipperBase.hiRange = 4503599627370495);
  h.ClipperBase.near_zero = function(r3) {
    return r3 > -h.ClipperBase.tolerance && r3 < h.ClipperBase.tolerance;
  };
  h.ClipperBase.IsHorizontal = function(r3) {
    return r3.Delta.Y === 0;
  };
  h.ClipperBase.prototype.PointIsVertex = function(r3, t3) {
    var e2 = t3;
    do {
      if (h.IntPoint.op_Equality(e2.Pt, r3)) return true;
      e2 = e2.Next;
    } while (e2 != t3);
    return false;
  };
  h.ClipperBase.prototype.PointOnLineSegment = function(r3, t3, e2, i) {
    return i ? r3.X == t3.X && r3.Y == t3.Y || r3.X == e2.X && r3.Y == e2.Y || r3.X > t3.X == r3.X < e2.X && r3.Y > t3.Y == r3.Y < e2.Y && se.op_Equality(se.Int128Mul(r3.X - t3.X, e2.Y - t3.Y), se.Int128Mul(e2.X - t3.X, r3.Y - t3.Y)) : r3.X == t3.X && r3.Y == t3.Y || r3.X == e2.X && r3.Y == e2.Y || r3.X > t3.X == r3.X < e2.X && r3.Y > t3.Y == r3.Y < e2.Y && (r3.X - t3.X) * (e2.Y - t3.Y) == (e2.X - t3.X) * (r3.Y - t3.Y);
  };
  h.ClipperBase.prototype.PointOnPolygon = function(r3, t3, e2) {
    for (var i = t3; ; ) {
      if (this.PointOnLineSegment(r3, i.Pt, i.Next.Pt, e2)) return true;
      if (i = i.Next, i == t3) break;
    }
    return false;
  };
  h.ClipperBase.prototype.SlopesEqual = h.ClipperBase.SlopesEqual = function() {
    var r3 = arguments, t3 = r3.length, e2, i, o, n, s2, c2, l;
    return t3 == 3 ? (e2 = r3[0], i = r3[1], l = r3[2], l ? se.op_Equality(se.Int128Mul(e2.Delta.Y, i.Delta.X), se.Int128Mul(e2.Delta.X, i.Delta.Y)) : h.Cast_Int64(e2.Delta.Y * i.Delta.X) == h.Cast_Int64(e2.Delta.X * i.Delta.Y)) : t3 == 4 ? (o = r3[0], n = r3[1], s2 = r3[2], l = r3[3], l ? se.op_Equality(se.Int128Mul(o.Y - n.Y, n.X - s2.X), se.Int128Mul(o.X - n.X, n.Y - s2.Y)) : h.Cast_Int64((o.Y - n.Y) * (n.X - s2.X)) - h.Cast_Int64((o.X - n.X) * (n.Y - s2.Y)) === 0) : (o = r3[0], n = r3[1], s2 = r3[2], c2 = r3[3], l = r3[4], l ? se.op_Equality(se.Int128Mul(o.Y - n.Y, s2.X - c2.X), se.Int128Mul(o.X - n.X, s2.Y - c2.Y)) : h.Cast_Int64((o.Y - n.Y) * (s2.X - c2.X)) - h.Cast_Int64((o.X - n.X) * (s2.Y - c2.Y)) === 0);
  };
  h.ClipperBase.SlopesEqual3 = function(r3, t3, e2) {
    return e2 ? se.op_Equality(se.Int128Mul(r3.Delta.Y, t3.Delta.X), se.Int128Mul(r3.Delta.X, t3.Delta.Y)) : h.Cast_Int64(r3.Delta.Y * t3.Delta.X) == h.Cast_Int64(r3.Delta.X * t3.Delta.Y);
  };
  h.ClipperBase.SlopesEqual4 = function(r3, t3, e2, i) {
    return i ? se.op_Equality(se.Int128Mul(r3.Y - t3.Y, t3.X - e2.X), se.Int128Mul(r3.X - t3.X, t3.Y - e2.Y)) : h.Cast_Int64((r3.Y - t3.Y) * (t3.X - e2.X)) - h.Cast_Int64((r3.X - t3.X) * (t3.Y - e2.Y)) === 0;
  };
  h.ClipperBase.SlopesEqual5 = function(r3, t3, e2, i, o) {
    return o ? se.op_Equality(se.Int128Mul(r3.Y - t3.Y, e2.X - i.X), se.Int128Mul(r3.X - t3.X, e2.Y - i.Y)) : h.Cast_Int64((r3.Y - t3.Y) * (e2.X - i.X)) - h.Cast_Int64((r3.X - t3.X) * (e2.Y - i.Y)) === 0;
  };
  h.ClipperBase.prototype.Clear = function() {
    this.DisposeLocalMinimaList();
    for (var r3 = 0, t3 = this.m_edges.length; r3 < t3; ++r3) {
      for (var e2 = 0, i = this.m_edges[r3].length; e2 < i; ++e2) this.m_edges[r3][e2] = null;
      h.Clear(this.m_edges[r3]);
    }
    h.Clear(this.m_edges), this.m_UseFullRange = false, this.m_HasOpenPaths = false;
  };
  h.ClipperBase.prototype.DisposeLocalMinimaList = function() {
    for (; this.m_MinimaList !== null; ) {
      var r3 = this.m_MinimaList.Next;
      this.m_MinimaList = null, this.m_MinimaList = r3;
    }
    this.m_CurrentLM = null;
  };
  h.ClipperBase.prototype.RangeTest = function(r3, t3) {
    t3.Value ? (r3.X > h.ClipperBase.hiRange || r3.Y > h.ClipperBase.hiRange || -r3.X > h.ClipperBase.hiRange || -r3.Y > h.ClipperBase.hiRange) && h.Error("Coordinate outside allowed range in RangeTest().") : (r3.X > h.ClipperBase.loRange || r3.Y > h.ClipperBase.loRange || -r3.X > h.ClipperBase.loRange || -r3.Y > h.ClipperBase.loRange) && (t3.Value = true, this.RangeTest(r3, t3));
  };
  h.ClipperBase.prototype.InitEdge = function(r3, t3, e2, i) {
    r3.Next = t3, r3.Prev = e2, r3.Curr.X = i.X, r3.Curr.Y = i.Y, r3.OutIdx = -1;
  };
  h.ClipperBase.prototype.InitEdge2 = function(r3, t3) {
    r3.Curr.Y >= r3.Next.Curr.Y ? (r3.Bot.X = r3.Curr.X, r3.Bot.Y = r3.Curr.Y, r3.Top.X = r3.Next.Curr.X, r3.Top.Y = r3.Next.Curr.Y) : (r3.Top.X = r3.Curr.X, r3.Top.Y = r3.Curr.Y, r3.Bot.X = r3.Next.Curr.X, r3.Bot.Y = r3.Next.Curr.Y), this.SetDx(r3), r3.PolyTyp = t3;
  };
  h.ClipperBase.prototype.FindNextLocMin = function(r3) {
    for (var t3; ; ) {
      for (; h.IntPoint.op_Inequality(r3.Bot, r3.Prev.Bot) || h.IntPoint.op_Equality(r3.Curr, r3.Top); ) r3 = r3.Next;
      if (r3.Dx != h.ClipperBase.horizontal && r3.Prev.Dx != h.ClipperBase.horizontal) break;
      for (; r3.Prev.Dx == h.ClipperBase.horizontal; ) r3 = r3.Prev;
      for (t3 = r3; r3.Dx == h.ClipperBase.horizontal; ) r3 = r3.Next;
      if (r3.Top.Y != r3.Prev.Bot.Y) {
        t3.Prev.Bot.X < r3.Bot.X && (r3 = t3);
        break;
      }
    }
    return r3;
  };
  h.ClipperBase.prototype.ProcessBound = function(r3, t3) {
    var e2 = r3, i = r3, o, n;
    if (r3.Dx == h.ClipperBase.horizontal && (t3 ? n = r3.Prev.Bot.X : n = r3.Next.Bot.X, r3.Bot.X != n && this.ReverseHorizontal(r3)), i.OutIdx != h.ClipperBase.Skip) if (t3) {
      for (; i.Top.Y == i.Next.Bot.Y && i.Next.OutIdx != h.ClipperBase.Skip; ) i = i.Next;
      if (i.Dx == h.ClipperBase.horizontal && i.Next.OutIdx != h.ClipperBase.Skip) {
        for (o = i; o.Prev.Dx == h.ClipperBase.horizontal; ) o = o.Prev;
        o.Prev.Top.X == i.Next.Top.X ? t3 || (i = o.Prev) : o.Prev.Top.X > i.Next.Top.X && (i = o.Prev);
      }
      for (; r3 != i; ) r3.NextInLML = r3.Next, r3.Dx == h.ClipperBase.horizontal && r3 != e2 && r3.Bot.X != r3.Prev.Top.X && this.ReverseHorizontal(r3), r3 = r3.Next;
      r3.Dx == h.ClipperBase.horizontal && r3 != e2 && r3.Bot.X != r3.Prev.Top.X && this.ReverseHorizontal(r3), i = i.Next;
    } else {
      for (; i.Top.Y == i.Prev.Bot.Y && i.Prev.OutIdx != h.ClipperBase.Skip; ) i = i.Prev;
      if (i.Dx == h.ClipperBase.horizontal && i.Prev.OutIdx != h.ClipperBase.Skip) {
        for (o = i; o.Next.Dx == h.ClipperBase.horizontal; ) o = o.Next;
        o.Next.Top.X == i.Prev.Top.X ? t3 || (i = o.Next) : o.Next.Top.X > i.Prev.Top.X && (i = o.Next);
      }
      for (; r3 != i; ) r3.NextInLML = r3.Prev, r3.Dx == h.ClipperBase.horizontal && r3 != e2 && r3.Bot.X != r3.Next.Top.X && this.ReverseHorizontal(r3), r3 = r3.Prev;
      r3.Dx == h.ClipperBase.horizontal && r3 != e2 && r3.Bot.X != r3.Next.Top.X && this.ReverseHorizontal(r3), i = i.Prev;
    }
    if (i.OutIdx == h.ClipperBase.Skip) {
      if (r3 = i, t3) {
        for (; r3.Top.Y == r3.Next.Bot.Y; ) r3 = r3.Next;
        for (; r3 != i && r3.Dx == h.ClipperBase.horizontal; ) r3 = r3.Prev;
      } else {
        for (; r3.Top.Y == r3.Prev.Bot.Y; ) r3 = r3.Prev;
        for (; r3 != i && r3.Dx == h.ClipperBase.horizontal; ) r3 = r3.Next;
      }
      if (r3 == i) t3 ? i = r3.Next : i = r3.Prev;
      else {
        t3 ? r3 = i.Next : r3 = i.Prev;
        var s2 = new h.LocalMinima();
        s2.Next = null, s2.Y = r3.Bot.Y, s2.LeftBound = null, s2.RightBound = r3, s2.RightBound.WindDelta = 0, i = this.ProcessBound(s2.RightBound, t3), this.InsertLocalMinima(s2);
      }
    }
    return i;
  };
  h.ClipperBase.prototype.AddPath = function(r3, t3, e2) {
    j5 ? !e2 && t3 == h.PolyType.ptClip && h.Error("AddPath: Open paths must be subject.") : e2 || h.Error("AddPath: Open paths have been disabled.");
    var i = r3.length - 1;
    if (e2) for (; i > 0 && h.IntPoint.op_Equality(r3[i], r3[0]); ) --i;
    for (; i > 0 && h.IntPoint.op_Equality(r3[i], r3[i - 1]); ) --i;
    if (e2 && i < 2 || !e2 && i < 1) return false;
    for (var o = new Array(), n = 0; n <= i; n++) o.push(new h.TEdge());
    var s2 = true;
    o[1].Curr.X = r3[1].X, o[1].Curr.Y = r3[1].Y;
    var c2 = { Value: this.m_UseFullRange };
    this.RangeTest(r3[0], c2), this.m_UseFullRange = c2.Value, c2.Value = this.m_UseFullRange, this.RangeTest(r3[i], c2), this.m_UseFullRange = c2.Value, this.InitEdge(o[0], o[1], o[i], r3[0]), this.InitEdge(o[i], o[0], o[i - 1], r3[i]);
    for (var n = i - 1; n >= 1; --n) c2.Value = this.m_UseFullRange, this.RangeTest(r3[n], c2), this.m_UseFullRange = c2.Value, this.InitEdge(o[n], o[n + 1], o[n - 1], r3[n]);
    for (var l = o[0], p = l, d = l; ; ) {
      if (h.IntPoint.op_Equality(p.Curr, p.Next.Curr)) {
        if (p == p.Next) break;
        p == l && (l = p.Next), p = this.RemoveEdge(p), d = p;
        continue;
      }
      if (p.Prev == p.Next) break;
      if (e2 && h.ClipperBase.SlopesEqual(p.Prev.Curr, p.Curr, p.Next.Curr, this.m_UseFullRange) && (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(p.Prev.Curr, p.Curr, p.Next.Curr))) {
        p == l && (l = p.Next), p = this.RemoveEdge(p), p = p.Prev, d = p;
        continue;
      }
      if (p = p.Next, p == d) break;
    }
    if (!e2 && p == p.Next || e2 && p.Prev == p.Next) return false;
    e2 || (this.m_HasOpenPaths = true, l.Prev.OutIdx = h.ClipperBase.Skip);
    var f = l;
    p = l;
    do
      this.InitEdge2(p, t3), p = p.Next, s2 && p.Curr.Y != l.Curr.Y && (s2 = false);
    while (p != l);
    if (s2) {
      if (e2) return false;
      p.Prev.OutIdx = h.ClipperBase.Skip, p.Prev.Bot.X < p.Prev.Top.X && this.ReverseHorizontal(p.Prev);
      var g = new h.LocalMinima();
      for (g.Next = null, g.Y = p.Bot.Y, g.LeftBound = null, g.RightBound = p, g.RightBound.Side = h.EdgeSide.esRight, g.RightBound.WindDelta = 0; p.Next.OutIdx != h.ClipperBase.Skip; ) p.NextInLML = p.Next, p.Bot.X != p.Prev.Top.X && this.ReverseHorizontal(p), p = p.Next;
      return this.InsertLocalMinima(g), this.m_edges.push(o), true;
    }
    this.m_edges.push(o);
    for (var v2, b = null; p = this.FindNextLocMin(p), p != b; ) {
      b == null && (b = p);
      var g = new h.LocalMinima();
      g.Next = null, g.Y = p.Bot.Y, p.Dx < p.Prev.Dx ? (g.LeftBound = p.Prev, g.RightBound = p, v2 = false) : (g.LeftBound = p, g.RightBound = p.Prev, v2 = true), g.LeftBound.Side = h.EdgeSide.esLeft, g.RightBound.Side = h.EdgeSide.esRight, e2 ? g.LeftBound.Next == g.RightBound ? g.LeftBound.WindDelta = -1 : g.LeftBound.WindDelta = 1 : g.LeftBound.WindDelta = 0, g.RightBound.WindDelta = -g.LeftBound.WindDelta, p = this.ProcessBound(g.LeftBound, v2);
      var C = this.ProcessBound(g.RightBound, !v2);
      g.LeftBound.OutIdx == h.ClipperBase.Skip ? g.LeftBound = null : g.RightBound.OutIdx == h.ClipperBase.Skip && (g.RightBound = null), this.InsertLocalMinima(g), v2 || (p = C);
    }
    return true;
  };
  h.ClipperBase.prototype.AddPaths = function(r3, t3, e2) {
    for (var i = false, o = 0, n = r3.length; o < n; ++o) this.AddPath(r3[o], t3, e2) && (i = true);
    return i;
  };
  h.ClipperBase.prototype.Pt2IsBetweenPt1AndPt3 = function(r3, t3, e2) {
    return h.IntPoint.op_Equality(r3, e2) || h.IntPoint.op_Equality(r3, t3) || h.IntPoint.op_Equality(e2, t3) ? false : r3.X != e2.X ? t3.X > r3.X == t3.X < e2.X : t3.Y > r3.Y == t3.Y < e2.Y;
  };
  h.ClipperBase.prototype.RemoveEdge = function(r3) {
    r3.Prev.Next = r3.Next, r3.Next.Prev = r3.Prev;
    var t3 = r3.Next;
    return r3.Prev = null, t3;
  };
  h.ClipperBase.prototype.SetDx = function(r3) {
    r3.Delta.X = r3.Top.X - r3.Bot.X, r3.Delta.Y = r3.Top.Y - r3.Bot.Y, r3.Delta.Y === 0 ? r3.Dx = h.ClipperBase.horizontal : r3.Dx = r3.Delta.X / r3.Delta.Y;
  };
  h.ClipperBase.prototype.InsertLocalMinima = function(r3) {
    if (this.m_MinimaList === null) this.m_MinimaList = r3;
    else if (r3.Y >= this.m_MinimaList.Y) r3.Next = this.m_MinimaList, this.m_MinimaList = r3;
    else {
      for (var t3 = this.m_MinimaList; t3.Next !== null && r3.Y < t3.Next.Y; ) t3 = t3.Next;
      r3.Next = t3.Next, t3.Next = r3;
    }
  };
  h.ClipperBase.prototype.PopLocalMinima = function() {
    this.m_CurrentLM !== null && (this.m_CurrentLM = this.m_CurrentLM.Next);
  };
  h.ClipperBase.prototype.ReverseHorizontal = function(r3) {
    var t3 = r3.Top.X;
    r3.Top.X = r3.Bot.X, r3.Bot.X = t3, qn && (t3 = r3.Top.Z, r3.Top.Z = r3.Bot.Z, r3.Bot.Z = t3);
  };
  h.ClipperBase.prototype.Reset = function() {
    if (this.m_CurrentLM = this.m_MinimaList, this.m_CurrentLM != null) for (var r3 = this.m_MinimaList; r3 != null; ) {
      var t3 = r3.LeftBound;
      t3 != null && (t3.Curr.X = t3.Bot.X, t3.Curr.Y = t3.Bot.Y, t3.Side = h.EdgeSide.esLeft, t3.OutIdx = h.ClipperBase.Unassigned), t3 = r3.RightBound, t3 != null && (t3.Curr.X = t3.Bot.X, t3.Curr.Y = t3.Bot.Y, t3.Side = h.EdgeSide.esRight, t3.OutIdx = h.ClipperBase.Unassigned), r3 = r3.Next;
    }
  };
  h.Clipper = function(r3) {
    typeof r3 > "u" && (r3 = 0), this.m_PolyOuts = null, this.m_ClipType = h.ClipType.ctIntersection, this.m_Scanbeam = null, this.m_ActiveEdges = null, this.m_SortedEdges = null, this.m_IntersectList = null, this.m_IntersectNodeComparer = null, this.m_ExecuteLocked = false, this.m_ClipFillType = h.PolyFillType.pftEvenOdd, this.m_SubjFillType = h.PolyFillType.pftEvenOdd, this.m_Joins = null, this.m_GhostJoins = null, this.m_UsingPolyTree = false, this.ReverseSolution = false, this.StrictlySimple = false, h.ClipperBase.call(this), this.m_Scanbeam = null, this.m_ActiveEdges = null, this.m_SortedEdges = null, this.m_IntersectList = new Array(), this.m_IntersectNodeComparer = h.MyIntersectNodeSort.Compare, this.m_ExecuteLocked = false, this.m_UsingPolyTree = false, this.m_PolyOuts = new Array(), this.m_Joins = new Array(), this.m_GhostJoins = new Array(), this.ReverseSolution = (1 & r3) !== 0, this.StrictlySimple = (2 & r3) !== 0, this.PreserveCollinear = (4 & r3) !== 0, qn && (this.ZFillFunction = null);
  };
  h.Clipper.ioReverseSolution = 1;
  h.Clipper.ioStrictlySimple = 2;
  h.Clipper.ioPreserveCollinear = 4;
  h.Clipper.prototype.Clear = function() {
    this.m_edges.length !== 0 && (this.DisposeAllPolyPts(), h.ClipperBase.prototype.Clear.call(this));
  };
  h.Clipper.prototype.DisposeScanbeamList = function() {
    for (; this.m_Scanbeam !== null; ) {
      var r3 = this.m_Scanbeam.Next;
      this.m_Scanbeam = null, this.m_Scanbeam = r3;
    }
  };
  h.Clipper.prototype.Reset = function() {
    h.ClipperBase.prototype.Reset.call(this), this.m_Scanbeam = null, this.m_ActiveEdges = null, this.m_SortedEdges = null;
    for (var r3 = this.m_MinimaList; r3 !== null; ) this.InsertScanbeam(r3.Y), r3 = r3.Next;
  };
  h.Clipper.prototype.InsertScanbeam = function(r3) {
    if (this.m_Scanbeam === null) this.m_Scanbeam = new h.Scanbeam(), this.m_Scanbeam.Next = null, this.m_Scanbeam.Y = r3;
    else if (r3 > this.m_Scanbeam.Y) {
      var t3 = new h.Scanbeam();
      t3.Y = r3, t3.Next = this.m_Scanbeam, this.m_Scanbeam = t3;
    } else {
      for (var e2 = this.m_Scanbeam; e2.Next !== null && r3 <= e2.Next.Y; ) e2 = e2.Next;
      if (r3 == e2.Y) return;
      var t3 = new h.Scanbeam();
      t3.Y = r3, t3.Next = e2.Next, e2.Next = t3;
    }
  };
  h.Clipper.prototype.Execute = function() {
    var r3 = arguments, t3 = r3.length, e2 = r3[1] instanceof h.PolyTree;
    if (t3 == 4 && !e2) {
      var i = r3[0], o = r3[1], n = r3[2], s2 = r3[3];
      if (this.m_ExecuteLocked) return false;
      this.m_HasOpenPaths && h.Error("Error: PolyTree struct is need for open path clipping."), this.m_ExecuteLocked = true, h.Clear(o), this.m_SubjFillType = n, this.m_ClipFillType = s2, this.m_ClipType = i, this.m_UsingPolyTree = false;
      try {
        var c2 = this.ExecuteInternal();
        c2 && this.BuildResult(o);
      } finally {
        this.DisposeAllPolyPts(), this.m_ExecuteLocked = false;
      }
      return c2;
    } else if (t3 == 4 && e2) {
      var i = r3[0], l = r3[1], n = r3[2], s2 = r3[3];
      if (this.m_ExecuteLocked) return false;
      this.m_ExecuteLocked = true, this.m_SubjFillType = n, this.m_ClipFillType = s2, this.m_ClipType = i, this.m_UsingPolyTree = true;
      try {
        var c2 = this.ExecuteInternal();
        c2 && this.BuildResult2(l);
      } finally {
        this.DisposeAllPolyPts(), this.m_ExecuteLocked = false;
      }
      return c2;
    } else if (t3 == 2 && !e2) {
      var i = r3[0], o = r3[1];
      return this.Execute(i, o, h.PolyFillType.pftEvenOdd, h.PolyFillType.pftEvenOdd);
    } else if (t3 == 2 && e2) {
      var i = r3[0], l = r3[1];
      return this.Execute(i, l, h.PolyFillType.pftEvenOdd, h.PolyFillType.pftEvenOdd);
    }
  };
  h.Clipper.prototype.FixHoleLinkage = function(r3) {
    if (!(r3.FirstLeft === null || r3.IsHole != r3.FirstLeft.IsHole && r3.FirstLeft.Pts !== null)) {
      for (var t3 = r3.FirstLeft; t3 !== null && (t3.IsHole == r3.IsHole || t3.Pts === null); ) t3 = t3.FirstLeft;
      r3.FirstLeft = t3;
    }
  };
  h.Clipper.prototype.ExecuteInternal = function() {
    try {
      if (this.Reset(), this.m_CurrentLM === null) return false;
      var r3 = this.PopScanbeam();
      do {
        if (this.InsertLocalMinimaIntoAEL(r3), h.Clear(this.m_GhostJoins), this.ProcessHorizontals(false), this.m_Scanbeam === null) break;
        var t3 = this.PopScanbeam();
        if (!this.ProcessIntersections(r3, t3)) return false;
        this.ProcessEdgesAtTopOfScanbeam(t3), r3 = t3;
      } while (this.m_Scanbeam !== null || this.m_CurrentLM !== null);
      for (var e2 = 0, i = this.m_PolyOuts.length; e2 < i; e2++) {
        var o = this.m_PolyOuts[e2];
        o.Pts === null || o.IsOpen || (o.IsHole ^ this.ReverseSolution) == this.Area(o) > 0 && this.ReversePolyPtLinks(o.Pts);
      }
      this.JoinCommonEdges();
      for (var e2 = 0, i = this.m_PolyOuts.length; e2 < i; e2++) {
        var o = this.m_PolyOuts[e2];
        o.Pts !== null && !o.IsOpen && this.FixupOutPolygon(o);
      }
      return this.StrictlySimple && this.DoSimplePolygons(), true;
    } finally {
      h.Clear(this.m_Joins), h.Clear(this.m_GhostJoins);
    }
  };
  h.Clipper.prototype.PopScanbeam = function() {
    var r3 = this.m_Scanbeam.Y, t3 = this.m_Scanbeam;
    return this.m_Scanbeam = this.m_Scanbeam.Next, t3 = null, r3;
  };
  h.Clipper.prototype.DisposeAllPolyPts = function() {
    for (var r3 = 0, t3 = this.m_PolyOuts.length; r3 < t3; ++r3) this.DisposeOutRec(r3);
    h.Clear(this.m_PolyOuts);
  };
  h.Clipper.prototype.DisposeOutRec = function(r3) {
    var t3 = this.m_PolyOuts[r3];
    t3.Pts !== null && this.DisposeOutPts(t3.Pts), t3 = null, this.m_PolyOuts[r3] = null;
  };
  h.Clipper.prototype.DisposeOutPts = function(r3) {
    if (r3 !== null) {
      var t3 = null;
      for (r3.Prev.Next = null; r3 !== null; ) t3 = r3, r3 = r3.Next, t3 = null;
    }
  };
  h.Clipper.prototype.AddJoin = function(r3, t3, e2) {
    var i = new h.Join();
    i.OutPt1 = r3, i.OutPt2 = t3, i.OffPt.X = e2.X, i.OffPt.Y = e2.Y, this.m_Joins.push(i);
  };
  h.Clipper.prototype.AddGhostJoin = function(r3, t3) {
    var e2 = new h.Join();
    e2.OutPt1 = r3, e2.OffPt.X = t3.X, e2.OffPt.Y = t3.Y, this.m_GhostJoins.push(e2);
  };
  qn && (h.Clipper.prototype.SetZ = function(r3, t3) {
    r3.Z = 0, this.ZFillFunction !== null && (t3.OutIdx < 0 ? this.ZFillFunction(t3.Bot, t3.Top, r3) : this.ZFillFunction(t3.Top, t3.Bot, r3));
  });
  h.Clipper.prototype.InsertLocalMinimaIntoAEL = function(r3) {
    for (; this.m_CurrentLM !== null && this.m_CurrentLM.Y == r3; ) {
      var t3 = this.m_CurrentLM.LeftBound, e2 = this.m_CurrentLM.RightBound;
      this.PopLocalMinima();
      var i = null;
      if (t3 === null ? (this.InsertEdgeIntoAEL(e2, null), this.SetWindingCount(e2), this.IsContributing(e2) && (i = this.AddOutPt(e2, e2.Bot))) : e2 == null ? (this.InsertEdgeIntoAEL(t3, null), this.SetWindingCount(t3), this.IsContributing(t3) && (i = this.AddOutPt(t3, t3.Bot)), this.InsertScanbeam(t3.Top.Y)) : (this.InsertEdgeIntoAEL(t3, null), this.InsertEdgeIntoAEL(e2, t3), this.SetWindingCount(t3), e2.WindCnt = t3.WindCnt, e2.WindCnt2 = t3.WindCnt2, this.IsContributing(t3) && (i = this.AddLocalMinPoly(t3, e2, t3.Bot)), this.InsertScanbeam(t3.Top.Y)), e2 != null && (h.ClipperBase.IsHorizontal(e2) ? this.AddEdgeToSEL(e2) : this.InsertScanbeam(e2.Top.Y)), !(t3 == null || e2 == null)) {
        if (i !== null && h.ClipperBase.IsHorizontal(e2) && this.m_GhostJoins.length > 0 && e2.WindDelta !== 0) for (var o = 0, n = this.m_GhostJoins.length; o < n; o++) {
          var s2 = this.m_GhostJoins[o];
          this.HorzSegmentsOverlap(s2.OutPt1.Pt, s2.OffPt, e2.Bot, e2.Top) && this.AddJoin(s2.OutPt1, i, s2.OffPt);
        }
        if (t3.OutIdx >= 0 && t3.PrevInAEL !== null && t3.PrevInAEL.Curr.X == t3.Bot.X && t3.PrevInAEL.OutIdx >= 0 && h.ClipperBase.SlopesEqual(t3.PrevInAEL, t3, this.m_UseFullRange) && t3.WindDelta !== 0 && t3.PrevInAEL.WindDelta !== 0) {
          var c2 = this.AddOutPt(t3.PrevInAEL, t3.Bot);
          this.AddJoin(i, c2, t3.Top);
        }
        if (t3.NextInAEL != e2) {
          if (e2.OutIdx >= 0 && e2.PrevInAEL.OutIdx >= 0 && h.ClipperBase.SlopesEqual(e2.PrevInAEL, e2, this.m_UseFullRange) && e2.WindDelta !== 0 && e2.PrevInAEL.WindDelta !== 0) {
            var c2 = this.AddOutPt(e2.PrevInAEL, e2.Bot);
            this.AddJoin(i, c2, e2.Top);
          }
          var l = t3.NextInAEL;
          if (l !== null) for (; l != e2; ) this.IntersectEdges(e2, l, t3.Curr, false), l = l.NextInAEL;
        }
      }
    }
  };
  h.Clipper.prototype.InsertEdgeIntoAEL = function(r3, t3) {
    if (this.m_ActiveEdges === null) r3.PrevInAEL = null, r3.NextInAEL = null, this.m_ActiveEdges = r3;
    else if (t3 === null && this.E2InsertsBeforeE1(this.m_ActiveEdges, r3)) r3.PrevInAEL = null, r3.NextInAEL = this.m_ActiveEdges, this.m_ActiveEdges.PrevInAEL = r3, this.m_ActiveEdges = r3;
    else {
      for (t3 === null && (t3 = this.m_ActiveEdges); t3.NextInAEL !== null && !this.E2InsertsBeforeE1(t3.NextInAEL, r3); ) t3 = t3.NextInAEL;
      r3.NextInAEL = t3.NextInAEL, t3.NextInAEL !== null && (t3.NextInAEL.PrevInAEL = r3), r3.PrevInAEL = t3, t3.NextInAEL = r3;
    }
  };
  h.Clipper.prototype.E2InsertsBeforeE1 = function(r3, t3) {
    return t3.Curr.X == r3.Curr.X ? t3.Top.Y > r3.Top.Y ? t3.Top.X < h.Clipper.TopX(r3, t3.Top.Y) : r3.Top.X > h.Clipper.TopX(t3, r3.Top.Y) : t3.Curr.X < r3.Curr.X;
  };
  h.Clipper.prototype.IsEvenOddFillType = function(r3) {
    return r3.PolyTyp == h.PolyType.ptSubject ? this.m_SubjFillType == h.PolyFillType.pftEvenOdd : this.m_ClipFillType == h.PolyFillType.pftEvenOdd;
  };
  h.Clipper.prototype.IsEvenOddAltFillType = function(r3) {
    return r3.PolyTyp == h.PolyType.ptSubject ? this.m_ClipFillType == h.PolyFillType.pftEvenOdd : this.m_SubjFillType == h.PolyFillType.pftEvenOdd;
  };
  h.Clipper.prototype.IsContributing = function(r3) {
    var t3, e2;
    switch (r3.PolyTyp == h.PolyType.ptSubject ? (t3 = this.m_SubjFillType, e2 = this.m_ClipFillType) : (t3 = this.m_ClipFillType, e2 = this.m_SubjFillType), t3) {
      case h.PolyFillType.pftEvenOdd:
        if (r3.WindDelta === 0 && r3.WindCnt != 1) return false;
        break;
      case h.PolyFillType.pftNonZero:
        if (Math.abs(r3.WindCnt) != 1) return false;
        break;
      case h.PolyFillType.pftPositive:
        if (r3.WindCnt != 1) return false;
        break;
      default:
        if (r3.WindCnt != -1) return false;
        break;
    }
    switch (this.m_ClipType) {
      case h.ClipType.ctIntersection:
        switch (e2) {
          case h.PolyFillType.pftEvenOdd:
          case h.PolyFillType.pftNonZero:
            return r3.WindCnt2 !== 0;
          case h.PolyFillType.pftPositive:
            return r3.WindCnt2 > 0;
          default:
            return r3.WindCnt2 < 0;
        }
      case h.ClipType.ctUnion:
        switch (e2) {
          case h.PolyFillType.pftEvenOdd:
          case h.PolyFillType.pftNonZero:
            return r3.WindCnt2 === 0;
          case h.PolyFillType.pftPositive:
            return r3.WindCnt2 <= 0;
          default:
            return r3.WindCnt2 >= 0;
        }
      case h.ClipType.ctDifference:
        if (r3.PolyTyp == h.PolyType.ptSubject) switch (e2) {
          case h.PolyFillType.pftEvenOdd:
          case h.PolyFillType.pftNonZero:
            return r3.WindCnt2 === 0;
          case h.PolyFillType.pftPositive:
            return r3.WindCnt2 <= 0;
          default:
            return r3.WindCnt2 >= 0;
        }
        else switch (e2) {
          case h.PolyFillType.pftEvenOdd:
          case h.PolyFillType.pftNonZero:
            return r3.WindCnt2 !== 0;
          case h.PolyFillType.pftPositive:
            return r3.WindCnt2 > 0;
          default:
            return r3.WindCnt2 < 0;
        }
      case h.ClipType.ctXor:
        if (r3.WindDelta === 0) switch (e2) {
          case h.PolyFillType.pftEvenOdd:
          case h.PolyFillType.pftNonZero:
            return r3.WindCnt2 === 0;
          case h.PolyFillType.pftPositive:
            return r3.WindCnt2 <= 0;
          default:
            return r3.WindCnt2 >= 0;
        }
        else return true;
    }
    return true;
  };
  h.Clipper.prototype.SetWindingCount = function(r3) {
    for (var t3 = r3.PrevInAEL; t3 !== null && (t3.PolyTyp != r3.PolyTyp || t3.WindDelta === 0); ) t3 = t3.PrevInAEL;
    if (t3 === null) r3.WindCnt = r3.WindDelta === 0 ? 1 : r3.WindDelta, r3.WindCnt2 = 0, t3 = this.m_ActiveEdges;
    else if (r3.WindDelta === 0 && this.m_ClipType != h.ClipType.ctUnion) r3.WindCnt = 1, r3.WindCnt2 = t3.WindCnt2, t3 = t3.NextInAEL;
    else if (this.IsEvenOddFillType(r3)) {
      if (r3.WindDelta === 0) {
        for (var e2 = true, i = t3.PrevInAEL; i !== null; ) i.PolyTyp == t3.PolyTyp && i.WindDelta !== 0 && (e2 = !e2), i = i.PrevInAEL;
        r3.WindCnt = e2 ? 0 : 1;
      } else r3.WindCnt = r3.WindDelta;
      r3.WindCnt2 = t3.WindCnt2, t3 = t3.NextInAEL;
    } else t3.WindCnt * t3.WindDelta < 0 ? Math.abs(t3.WindCnt) > 1 ? t3.WindDelta * r3.WindDelta < 0 ? r3.WindCnt = t3.WindCnt : r3.WindCnt = t3.WindCnt + r3.WindDelta : r3.WindCnt = r3.WindDelta === 0 ? 1 : r3.WindDelta : r3.WindDelta === 0 ? r3.WindCnt = t3.WindCnt < 0 ? t3.WindCnt - 1 : t3.WindCnt + 1 : t3.WindDelta * r3.WindDelta < 0 ? r3.WindCnt = t3.WindCnt : r3.WindCnt = t3.WindCnt + r3.WindDelta, r3.WindCnt2 = t3.WindCnt2, t3 = t3.NextInAEL;
    if (this.IsEvenOddAltFillType(r3)) for (; t3 != r3; ) t3.WindDelta !== 0 && (r3.WindCnt2 = r3.WindCnt2 === 0 ? 1 : 0), t3 = t3.NextInAEL;
    else for (; t3 != r3; ) r3.WindCnt2 += t3.WindDelta, t3 = t3.NextInAEL;
  };
  h.Clipper.prototype.AddEdgeToSEL = function(r3) {
    this.m_SortedEdges === null ? (this.m_SortedEdges = r3, r3.PrevInSEL = null, r3.NextInSEL = null) : (r3.NextInSEL = this.m_SortedEdges, r3.PrevInSEL = null, this.m_SortedEdges.PrevInSEL = r3, this.m_SortedEdges = r3);
  };
  h.Clipper.prototype.CopyAELToSEL = function() {
    var r3 = this.m_ActiveEdges;
    for (this.m_SortedEdges = r3; r3 !== null; ) r3.PrevInSEL = r3.PrevInAEL, r3.NextInSEL = r3.NextInAEL, r3 = r3.NextInAEL;
  };
  h.Clipper.prototype.SwapPositionsInAEL = function(r3, t3) {
    if (!(r3.NextInAEL == r3.PrevInAEL || t3.NextInAEL == t3.PrevInAEL)) {
      if (r3.NextInAEL == t3) {
        var e2 = t3.NextInAEL;
        e2 !== null && (e2.PrevInAEL = r3);
        var i = r3.PrevInAEL;
        i !== null && (i.NextInAEL = t3), t3.PrevInAEL = i, t3.NextInAEL = r3, r3.PrevInAEL = t3, r3.NextInAEL = e2;
      } else if (t3.NextInAEL == r3) {
        var e2 = r3.NextInAEL;
        e2 !== null && (e2.PrevInAEL = t3);
        var i = t3.PrevInAEL;
        i !== null && (i.NextInAEL = r3), r3.PrevInAEL = i, r3.NextInAEL = t3, t3.PrevInAEL = r3, t3.NextInAEL = e2;
      } else {
        var e2 = r3.NextInAEL, i = r3.PrevInAEL;
        r3.NextInAEL = t3.NextInAEL, r3.NextInAEL !== null && (r3.NextInAEL.PrevInAEL = r3), r3.PrevInAEL = t3.PrevInAEL, r3.PrevInAEL !== null && (r3.PrevInAEL.NextInAEL = r3), t3.NextInAEL = e2, t3.NextInAEL !== null && (t3.NextInAEL.PrevInAEL = t3), t3.PrevInAEL = i, t3.PrevInAEL !== null && (t3.PrevInAEL.NextInAEL = t3);
      }
      r3.PrevInAEL === null ? this.m_ActiveEdges = r3 : t3.PrevInAEL === null && (this.m_ActiveEdges = t3);
    }
  };
  h.Clipper.prototype.SwapPositionsInSEL = function(r3, t3) {
    if (!(r3.NextInSEL === null && r3.PrevInSEL === null) && !(t3.NextInSEL === null && t3.PrevInSEL === null)) {
      if (r3.NextInSEL == t3) {
        var e2 = t3.NextInSEL;
        e2 !== null && (e2.PrevInSEL = r3);
        var i = r3.PrevInSEL;
        i !== null && (i.NextInSEL = t3), t3.PrevInSEL = i, t3.NextInSEL = r3, r3.PrevInSEL = t3, r3.NextInSEL = e2;
      } else if (t3.NextInSEL == r3) {
        var e2 = r3.NextInSEL;
        e2 !== null && (e2.PrevInSEL = t3);
        var i = t3.PrevInSEL;
        i !== null && (i.NextInSEL = r3), r3.PrevInSEL = i, r3.NextInSEL = t3, t3.PrevInSEL = r3, t3.NextInSEL = e2;
      } else {
        var e2 = r3.NextInSEL, i = r3.PrevInSEL;
        r3.NextInSEL = t3.NextInSEL, r3.NextInSEL !== null && (r3.NextInSEL.PrevInSEL = r3), r3.PrevInSEL = t3.PrevInSEL, r3.PrevInSEL !== null && (r3.PrevInSEL.NextInSEL = r3), t3.NextInSEL = e2, t3.NextInSEL !== null && (t3.NextInSEL.PrevInSEL = t3), t3.PrevInSEL = i, t3.PrevInSEL !== null && (t3.PrevInSEL.NextInSEL = t3);
      }
      r3.PrevInSEL === null ? this.m_SortedEdges = r3 : t3.PrevInSEL === null && (this.m_SortedEdges = t3);
    }
  };
  h.Clipper.prototype.AddLocalMaxPoly = function(r3, t3, e2) {
    this.AddOutPt(r3, e2), t3.WindDelta == 0 && this.AddOutPt(t3, e2), r3.OutIdx == t3.OutIdx ? (r3.OutIdx = -1, t3.OutIdx = -1) : r3.OutIdx < t3.OutIdx ? this.AppendPolygon(r3, t3) : this.AppendPolygon(t3, r3);
  };
  h.Clipper.prototype.AddLocalMinPoly = function(r3, t3, e2) {
    var i, o, n;
    if (h.ClipperBase.IsHorizontal(t3) || r3.Dx > t3.Dx ? (i = this.AddOutPt(r3, e2), t3.OutIdx = r3.OutIdx, r3.Side = h.EdgeSide.esLeft, t3.Side = h.EdgeSide.esRight, o = r3, o.PrevInAEL == t3 ? n = t3.PrevInAEL : n = o.PrevInAEL) : (i = this.AddOutPt(t3, e2), r3.OutIdx = t3.OutIdx, r3.Side = h.EdgeSide.esRight, t3.Side = h.EdgeSide.esLeft, o = t3, o.PrevInAEL == r3 ? n = r3.PrevInAEL : n = o.PrevInAEL), n !== null && n.OutIdx >= 0 && h.Clipper.TopX(n, e2.Y) == h.Clipper.TopX(o, e2.Y) && h.ClipperBase.SlopesEqual(o, n, this.m_UseFullRange) && o.WindDelta !== 0 && n.WindDelta !== 0) {
      var s2 = this.AddOutPt(n, e2);
      this.AddJoin(i, s2, o.Top);
    }
    return i;
  };
  h.Clipper.prototype.CreateOutRec = function() {
    var r3 = new h.OutRec();
    return r3.Idx = -1, r3.IsHole = false, r3.IsOpen = false, r3.FirstLeft = null, r3.Pts = null, r3.BottomPt = null, r3.PolyNode = null, this.m_PolyOuts.push(r3), r3.Idx = this.m_PolyOuts.length - 1, r3;
  };
  h.Clipper.prototype.AddOutPt = function(r3, t3) {
    var e2 = r3.Side == h.EdgeSide.esLeft;
    if (r3.OutIdx < 0) {
      var i = this.CreateOutRec();
      i.IsOpen = r3.WindDelta === 0;
      var o = new h.OutPt();
      return i.Pts = o, o.Idx = i.Idx, o.Pt.X = t3.X, o.Pt.Y = t3.Y, o.Next = o, o.Prev = o, i.IsOpen || this.SetHoleState(r3, i), qn && (h.IntPoint.op_Equality(t3, r3.Bot) ? (o.Pt.X = r3.Bot.X, o.Pt.Y = r3.Bot.Y, o.Pt.Z = r3.Bot.Z) : h.IntPoint.op_Equality(t3, r3.Top) ? (o.Pt.X = r3.Top.X, o.Pt.Y = r3.Top.Y, o.Pt.Z = r3.Top.Z) : this.SetZ(o.Pt, r3)), r3.OutIdx = i.Idx, o;
    } else {
      var i = this.m_PolyOuts[r3.OutIdx], n = i.Pts;
      if (e2 && h.IntPoint.op_Equality(t3, n.Pt)) return n;
      if (!e2 && h.IntPoint.op_Equality(t3, n.Prev.Pt)) return n.Prev;
      var o = new h.OutPt();
      return o.Idx = i.Idx, o.Pt.X = t3.X, o.Pt.Y = t3.Y, o.Next = n, o.Prev = n.Prev, o.Prev.Next = o, n.Prev = o, e2 && (i.Pts = o), qn && (h.IntPoint.op_Equality(t3, r3.Bot) ? (o.Pt.X = r3.Bot.X, o.Pt.Y = r3.Bot.Y, o.Pt.Z = r3.Bot.Z) : h.IntPoint.op_Equality(t3, r3.Top) ? (o.Pt.X = r3.Top.X, o.Pt.Y = r3.Top.Y, o.Pt.Z = r3.Top.Z) : this.SetZ(o.Pt, r3)), o;
    }
  };
  h.Clipper.prototype.SwapPoints = function(r3, t3) {
    var e2 = new h.IntPoint(r3.Value);
    r3.Value.X = t3.Value.X, r3.Value.Y = t3.Value.Y, t3.Value.X = e2.X, t3.Value.Y = e2.Y;
  };
  h.Clipper.prototype.HorzSegmentsOverlap = function(r3, t3, e2, i) {
    return r3.X > e2.X == r3.X < i.X || t3.X > e2.X == t3.X < i.X || e2.X > r3.X == e2.X < t3.X || i.X > r3.X == i.X < t3.X || r3.X == e2.X && t3.X == i.X ? true : r3.X == i.X && t3.X == e2.X;
  };
  h.Clipper.prototype.InsertPolyPtBetween = function(r3, t3, e2) {
    var i = new h.OutPt();
    return i.Pt.X = e2.X, i.Pt.Y = e2.Y, t3 == r3.Next ? (r3.Next = i, t3.Prev = i, i.Next = t3, i.Prev = r3) : (t3.Next = i, r3.Prev = i, i.Next = r3, i.Prev = t3), i;
  };
  h.Clipper.prototype.SetHoleState = function(r3, t3) {
    for (var e2 = false, i = r3.PrevInAEL; i !== null; ) i.OutIdx >= 0 && i.WindDelta != 0 && (e2 = !e2, t3.FirstLeft === null && (t3.FirstLeft = this.m_PolyOuts[i.OutIdx])), i = i.PrevInAEL;
    e2 && (t3.IsHole = true);
  };
  h.Clipper.prototype.GetDx = function(r3, t3) {
    return r3.Y == t3.Y ? h.ClipperBase.horizontal : (t3.X - r3.X) / (t3.Y - r3.Y);
  };
  h.Clipper.prototype.FirstIsBottomPt = function(r3, t3) {
    for (var e2 = r3.Prev; h.IntPoint.op_Equality(e2.Pt, r3.Pt) && e2 != r3; ) e2 = e2.Prev;
    var i = Math.abs(this.GetDx(r3.Pt, e2.Pt));
    for (e2 = r3.Next; h.IntPoint.op_Equality(e2.Pt, r3.Pt) && e2 != r3; ) e2 = e2.Next;
    var o = Math.abs(this.GetDx(r3.Pt, e2.Pt));
    for (e2 = t3.Prev; h.IntPoint.op_Equality(e2.Pt, t3.Pt) && e2 != t3; ) e2 = e2.Prev;
    var n = Math.abs(this.GetDx(t3.Pt, e2.Pt));
    for (e2 = t3.Next; h.IntPoint.op_Equality(e2.Pt, t3.Pt) && e2 != t3; ) e2 = e2.Next;
    var s2 = Math.abs(this.GetDx(t3.Pt, e2.Pt));
    return i >= n && i >= s2 || o >= n && o >= s2;
  };
  h.Clipper.prototype.GetBottomPt = function(r3) {
    for (var t3 = null, e2 = r3.Next; e2 != r3; ) e2.Pt.Y > r3.Pt.Y ? (r3 = e2, t3 = null) : e2.Pt.Y == r3.Pt.Y && e2.Pt.X <= r3.Pt.X && (e2.Pt.X < r3.Pt.X ? (t3 = null, r3 = e2) : e2.Next != r3 && e2.Prev != r3 && (t3 = e2)), e2 = e2.Next;
    if (t3 !== null) for (; t3 != e2; ) for (this.FirstIsBottomPt(e2, t3) || (r3 = t3), t3 = t3.Next; h.IntPoint.op_Inequality(t3.Pt, r3.Pt); ) t3 = t3.Next;
    return r3;
  };
  h.Clipper.prototype.GetLowermostRec = function(r3, t3) {
    r3.BottomPt === null && (r3.BottomPt = this.GetBottomPt(r3.Pts)), t3.BottomPt === null && (t3.BottomPt = this.GetBottomPt(t3.Pts));
    var e2 = r3.BottomPt, i = t3.BottomPt;
    return e2.Pt.Y > i.Pt.Y ? r3 : e2.Pt.Y < i.Pt.Y ? t3 : e2.Pt.X < i.Pt.X ? r3 : e2.Pt.X > i.Pt.X || e2.Next == e2 ? t3 : i.Next == i || this.FirstIsBottomPt(e2, i) ? r3 : t3;
  };
  h.Clipper.prototype.Param1RightOfParam2 = function(r3, t3) {
    do
      if (r3 = r3.FirstLeft, r3 == t3) return true;
    while (r3 !== null);
    return false;
  };
  h.Clipper.prototype.GetOutRec = function(r3) {
    for (var t3 = this.m_PolyOuts[r3]; t3 != this.m_PolyOuts[t3.Idx]; ) t3 = this.m_PolyOuts[t3.Idx];
    return t3;
  };
  h.Clipper.prototype.AppendPolygon = function(r3, t3) {
    var e2 = this.m_PolyOuts[r3.OutIdx], i = this.m_PolyOuts[t3.OutIdx], o;
    this.Param1RightOfParam2(e2, i) ? o = i : this.Param1RightOfParam2(i, e2) ? o = e2 : o = this.GetLowermostRec(e2, i);
    var n = e2.Pts, s2 = n.Prev, c2 = i.Pts, l = c2.Prev, p;
    r3.Side == h.EdgeSide.esLeft ? (t3.Side == h.EdgeSide.esLeft ? (this.ReversePolyPtLinks(c2), c2.Next = n, n.Prev = c2, s2.Next = l, l.Prev = s2, e2.Pts = l) : (l.Next = n, n.Prev = l, c2.Prev = s2, s2.Next = c2, e2.Pts = c2), p = h.EdgeSide.esLeft) : (t3.Side == h.EdgeSide.esRight ? (this.ReversePolyPtLinks(c2), s2.Next = l, l.Prev = s2, c2.Next = n, n.Prev = c2) : (s2.Next = c2, c2.Prev = s2, n.Prev = l, l.Next = n), p = h.EdgeSide.esRight), e2.BottomPt = null, o == i && (i.FirstLeft != e2 && (e2.FirstLeft = i.FirstLeft), e2.IsHole = i.IsHole), i.Pts = null, i.BottomPt = null, i.FirstLeft = e2;
    var d = r3.OutIdx, f = t3.OutIdx;
    r3.OutIdx = -1, t3.OutIdx = -1;
    for (var g = this.m_ActiveEdges; g !== null; ) {
      if (g.OutIdx == f) {
        g.OutIdx = d, g.Side = p;
        break;
      }
      g = g.NextInAEL;
    }
    i.Idx = e2.Idx;
  };
  h.Clipper.prototype.ReversePolyPtLinks = function(r3) {
    if (r3 !== null) {
      var t3, e2;
      t3 = r3;
      do
        e2 = t3.Next, t3.Next = t3.Prev, t3.Prev = e2, t3 = e2;
      while (t3 != r3);
    }
  };
  h.Clipper.SwapSides = function(r3, t3) {
    var e2 = r3.Side;
    r3.Side = t3.Side, t3.Side = e2;
  };
  h.Clipper.SwapPolyIndexes = function(r3, t3) {
    var e2 = r3.OutIdx;
    r3.OutIdx = t3.OutIdx, t3.OutIdx = e2;
  };
  h.Clipper.prototype.IntersectEdges = function(r3, t3, e2, i) {
    var o = !i && r3.NextInLML === null && r3.Top.X == e2.X && r3.Top.Y == e2.Y, n = !i && t3.NextInLML === null && t3.Top.X == e2.X && t3.Top.Y == e2.Y, s2 = r3.OutIdx >= 0, c2 = t3.OutIdx >= 0;
    if (j5 && (r3.WindDelta === 0 || t3.WindDelta === 0)) {
      r3.WindDelta === 0 && t3.WindDelta === 0 ? (o || n) && s2 && c2 && this.AddLocalMaxPoly(r3, t3, e2) : r3.PolyTyp == t3.PolyTyp && r3.WindDelta != t3.WindDelta && this.m_ClipType == h.ClipType.ctUnion ? r3.WindDelta === 0 ? c2 && (this.AddOutPt(r3, e2), s2 && (r3.OutIdx = -1)) : s2 && (this.AddOutPt(t3, e2), c2 && (t3.OutIdx = -1)) : r3.PolyTyp != t3.PolyTyp && (r3.WindDelta === 0 && Math.abs(t3.WindCnt) == 1 && (this.m_ClipType != h.ClipType.ctUnion || t3.WindCnt2 === 0) ? (this.AddOutPt(r3, e2), s2 && (r3.OutIdx = -1)) : t3.WindDelta === 0 && Math.abs(r3.WindCnt) == 1 && (this.m_ClipType != h.ClipType.ctUnion || r3.WindCnt2 === 0) && (this.AddOutPt(t3, e2), c2 && (t3.OutIdx = -1))), o && (r3.OutIdx < 0 ? this.DeleteFromAEL(r3) : h.Error("Error intersecting polylines")), n && (t3.OutIdx < 0 ? this.DeleteFromAEL(t3) : h.Error("Error intersecting polylines"));
      return;
    }
    if (r3.PolyTyp == t3.PolyTyp) if (this.IsEvenOddFillType(r3)) {
      var l = r3.WindCnt;
      r3.WindCnt = t3.WindCnt, t3.WindCnt = l;
    } else r3.WindCnt + t3.WindDelta === 0 ? r3.WindCnt = -r3.WindCnt : r3.WindCnt += t3.WindDelta, t3.WindCnt - r3.WindDelta === 0 ? t3.WindCnt = -t3.WindCnt : t3.WindCnt -= r3.WindDelta;
    else this.IsEvenOddFillType(t3) ? r3.WindCnt2 = r3.WindCnt2 === 0 ? 1 : 0 : r3.WindCnt2 += t3.WindDelta, this.IsEvenOddFillType(r3) ? t3.WindCnt2 = t3.WindCnt2 === 0 ? 1 : 0 : t3.WindCnt2 -= r3.WindDelta;
    var p, d, f, g;
    r3.PolyTyp == h.PolyType.ptSubject ? (p = this.m_SubjFillType, f = this.m_ClipFillType) : (p = this.m_ClipFillType, f = this.m_SubjFillType), t3.PolyTyp == h.PolyType.ptSubject ? (d = this.m_SubjFillType, g = this.m_ClipFillType) : (d = this.m_ClipFillType, g = this.m_SubjFillType);
    var v2, b;
    switch (p) {
      case h.PolyFillType.pftPositive:
        v2 = r3.WindCnt;
        break;
      case h.PolyFillType.pftNegative:
        v2 = -r3.WindCnt;
        break;
      default:
        v2 = Math.abs(r3.WindCnt);
        break;
    }
    switch (d) {
      case h.PolyFillType.pftPositive:
        b = t3.WindCnt;
        break;
      case h.PolyFillType.pftNegative:
        b = -t3.WindCnt;
        break;
      default:
        b = Math.abs(t3.WindCnt);
        break;
    }
    if (s2 && c2) o || n || v2 !== 0 && v2 != 1 || b !== 0 && b != 1 || r3.PolyTyp != t3.PolyTyp && this.m_ClipType != h.ClipType.ctXor ? this.AddLocalMaxPoly(r3, t3, e2) : (this.AddOutPt(r3, e2), this.AddOutPt(t3, e2), h.Clipper.SwapSides(r3, t3), h.Clipper.SwapPolyIndexes(r3, t3));
    else if (s2) (b === 0 || b == 1) && (this.AddOutPt(r3, e2), h.Clipper.SwapSides(r3, t3), h.Clipper.SwapPolyIndexes(r3, t3));
    else if (c2) (v2 === 0 || v2 == 1) && (this.AddOutPt(t3, e2), h.Clipper.SwapSides(r3, t3), h.Clipper.SwapPolyIndexes(r3, t3));
    else if ((v2 === 0 || v2 == 1) && (b === 0 || b == 1) && !o && !n) {
      var C, y;
      switch (f) {
        case h.PolyFillType.pftPositive:
          C = r3.WindCnt2;
          break;
        case h.PolyFillType.pftNegative:
          C = -r3.WindCnt2;
          break;
        default:
          C = Math.abs(r3.WindCnt2);
          break;
      }
      switch (g) {
        case h.PolyFillType.pftPositive:
          y = t3.WindCnt2;
          break;
        case h.PolyFillType.pftNegative:
          y = -t3.WindCnt2;
          break;
        default:
          y = Math.abs(t3.WindCnt2);
          break;
      }
      if (r3.PolyTyp != t3.PolyTyp) this.AddLocalMinPoly(r3, t3, e2);
      else if (v2 == 1 && b == 1) switch (this.m_ClipType) {
        case h.ClipType.ctIntersection:
          C > 0 && y > 0 && this.AddLocalMinPoly(r3, t3, e2);
          break;
        case h.ClipType.ctUnion:
          C <= 0 && y <= 0 && this.AddLocalMinPoly(r3, t3, e2);
          break;
        case h.ClipType.ctDifference:
          (r3.PolyTyp == h.PolyType.ptClip && C > 0 && y > 0 || r3.PolyTyp == h.PolyType.ptSubject && C <= 0 && y <= 0) && this.AddLocalMinPoly(r3, t3, e2);
          break;
        case h.ClipType.ctXor:
          this.AddLocalMinPoly(r3, t3, e2);
          break;
      }
      else h.Clipper.SwapSides(r3, t3);
    }
    o != n && (o && r3.OutIdx >= 0 || n && t3.OutIdx >= 0) && (h.Clipper.SwapSides(r3, t3), h.Clipper.SwapPolyIndexes(r3, t3)), o && this.DeleteFromAEL(r3), n && this.DeleteFromAEL(t3);
  };
  h.Clipper.prototype.DeleteFromAEL = function(r3) {
    var t3 = r3.PrevInAEL, e2 = r3.NextInAEL;
    t3 === null && e2 === null && r3 != this.m_ActiveEdges || (t3 !== null ? t3.NextInAEL = e2 : this.m_ActiveEdges = e2, e2 !== null && (e2.PrevInAEL = t3), r3.NextInAEL = null, r3.PrevInAEL = null);
  };
  h.Clipper.prototype.DeleteFromSEL = function(r3) {
    var t3 = r3.PrevInSEL, e2 = r3.NextInSEL;
    t3 === null && e2 === null && r3 != this.m_SortedEdges || (t3 !== null ? t3.NextInSEL = e2 : this.m_SortedEdges = e2, e2 !== null && (e2.PrevInSEL = t3), r3.NextInSEL = null, r3.PrevInSEL = null);
  };
  h.Clipper.prototype.UpdateEdgeIntoAEL = function(r3) {
    r3.NextInLML === null && h.Error("UpdateEdgeIntoAEL: invalid call");
    var t3 = r3.PrevInAEL, e2 = r3.NextInAEL;
    return r3.NextInLML.OutIdx = r3.OutIdx, t3 !== null ? t3.NextInAEL = r3.NextInLML : this.m_ActiveEdges = r3.NextInLML, e2 !== null && (e2.PrevInAEL = r3.NextInLML), r3.NextInLML.Side = r3.Side, r3.NextInLML.WindDelta = r3.WindDelta, r3.NextInLML.WindCnt = r3.WindCnt, r3.NextInLML.WindCnt2 = r3.WindCnt2, r3 = r3.NextInLML, r3.Curr.X = r3.Bot.X, r3.Curr.Y = r3.Bot.Y, r3.PrevInAEL = t3, r3.NextInAEL = e2, h.ClipperBase.IsHorizontal(r3) || this.InsertScanbeam(r3.Top.Y), r3;
  };
  h.Clipper.prototype.ProcessHorizontals = function(r3) {
    for (var t3 = this.m_SortedEdges; t3 !== null; ) this.DeleteFromSEL(t3), this.ProcessHorizontal(t3, r3), t3 = this.m_SortedEdges;
  };
  h.Clipper.prototype.GetHorzDirection = function(r3, t3) {
    r3.Bot.X < r3.Top.X ? (t3.Left = r3.Bot.X, t3.Right = r3.Top.X, t3.Dir = h.Direction.dLeftToRight) : (t3.Left = r3.Top.X, t3.Right = r3.Bot.X, t3.Dir = h.Direction.dRightToLeft);
  };
  h.Clipper.prototype.PrepareHorzJoins = function(r3, t3) {
    var e2 = this.m_PolyOuts[r3.OutIdx].Pts;
    r3.Side != h.EdgeSide.esLeft && (e2 = e2.Prev), t3 && (h.IntPoint.op_Equality(e2.Pt, r3.Top) ? this.AddGhostJoin(e2, r3.Bot) : this.AddGhostJoin(e2, r3.Top));
  };
  h.Clipper.prototype.ProcessHorizontal = function(r3, t3) {
    var e2 = { Dir: null, Left: null, Right: null };
    this.GetHorzDirection(r3, e2);
    for (var i = e2.Dir, o = e2.Left, n = e2.Right, s2 = r3, c2 = null; s2.NextInLML !== null && h.ClipperBase.IsHorizontal(s2.NextInLML); ) s2 = s2.NextInLML;
    for (s2.NextInLML === null && (c2 = this.GetMaximaPair(s2)); ; ) {
      for (var l = r3 == s2, p = this.GetNextInAEL(r3, i); p !== null && !(p.Curr.X == r3.Top.X && r3.NextInLML !== null && p.Dx < r3.NextInLML.Dx); ) {
        var d = this.GetNextInAEL(p, i);
        if (i == h.Direction.dLeftToRight && p.Curr.X <= n || i == h.Direction.dRightToLeft && p.Curr.X >= o) {
          if (r3.OutIdx >= 0 && r3.WindDelta != 0 && this.PrepareHorzJoins(r3, t3), p == c2 && l) {
            i == h.Direction.dLeftToRight ? this.IntersectEdges(r3, p, p.Top, false) : this.IntersectEdges(p, r3, p.Top, false), c2.OutIdx >= 0 && h.Error("ProcessHorizontal error");
            return;
          } else if (i == h.Direction.dLeftToRight) {
            var f = new h.IntPoint(p.Curr.X, r3.Curr.Y);
            this.IntersectEdges(r3, p, f, true);
          } else {
            var f = new h.IntPoint(p.Curr.X, r3.Curr.Y);
            this.IntersectEdges(p, r3, f, true);
          }
          this.SwapPositionsInAEL(r3, p);
        } else if (i == h.Direction.dLeftToRight && p.Curr.X >= n || i == h.Direction.dRightToLeft && p.Curr.X <= o) break;
        p = d;
      }
      if (r3.OutIdx >= 0 && r3.WindDelta !== 0 && this.PrepareHorzJoins(r3, t3), r3.NextInLML !== null && h.ClipperBase.IsHorizontal(r3.NextInLML)) {
        r3 = this.UpdateEdgeIntoAEL(r3), r3.OutIdx >= 0 && this.AddOutPt(r3, r3.Bot);
        var e2 = { Dir: i, Left: o, Right: n };
        this.GetHorzDirection(r3, e2), i = e2.Dir, o = e2.Left, n = e2.Right;
      } else break;
    }
    if (r3.NextInLML !== null) if (r3.OutIdx >= 0) {
      var g = this.AddOutPt(r3, r3.Top);
      if (r3 = this.UpdateEdgeIntoAEL(r3), r3.WindDelta === 0) return;
      var v2 = r3.PrevInAEL, d = r3.NextInAEL;
      if (v2 !== null && v2.Curr.X == r3.Bot.X && v2.Curr.Y == r3.Bot.Y && v2.WindDelta !== 0 && v2.OutIdx >= 0 && v2.Curr.Y > v2.Top.Y && h.ClipperBase.SlopesEqual(r3, v2, this.m_UseFullRange)) {
        var b = this.AddOutPt(v2, r3.Bot);
        this.AddJoin(g, b, r3.Top);
      } else if (d !== null && d.Curr.X == r3.Bot.X && d.Curr.Y == r3.Bot.Y && d.WindDelta !== 0 && d.OutIdx >= 0 && d.Curr.Y > d.Top.Y && h.ClipperBase.SlopesEqual(r3, d, this.m_UseFullRange)) {
        var b = this.AddOutPt(d, r3.Bot);
        this.AddJoin(g, b, r3.Top);
      }
    } else r3 = this.UpdateEdgeIntoAEL(r3);
    else c2 !== null ? c2.OutIdx >= 0 ? (i == h.Direction.dLeftToRight ? this.IntersectEdges(r3, c2, r3.Top, false) : this.IntersectEdges(c2, r3, r3.Top, false), c2.OutIdx >= 0 && h.Error("ProcessHorizontal error")) : (this.DeleteFromAEL(r3), this.DeleteFromAEL(c2)) : (r3.OutIdx >= 0 && this.AddOutPt(r3, r3.Top), this.DeleteFromAEL(r3));
  };
  h.Clipper.prototype.GetNextInAEL = function(r3, t3) {
    return t3 == h.Direction.dLeftToRight ? r3.NextInAEL : r3.PrevInAEL;
  };
  h.Clipper.prototype.IsMinima = function(r3) {
    return r3 !== null && r3.Prev.NextInLML != r3 && r3.Next.NextInLML != r3;
  };
  h.Clipper.prototype.IsMaxima = function(r3, t3) {
    return r3 !== null && r3.Top.Y == t3 && r3.NextInLML === null;
  };
  h.Clipper.prototype.IsIntermediate = function(r3, t3) {
    return r3.Top.Y == t3 && r3.NextInLML !== null;
  };
  h.Clipper.prototype.GetMaximaPair = function(r3) {
    var t3 = null;
    return h.IntPoint.op_Equality(r3.Next.Top, r3.Top) && r3.Next.NextInLML === null ? t3 = r3.Next : h.IntPoint.op_Equality(r3.Prev.Top, r3.Top) && r3.Prev.NextInLML === null && (t3 = r3.Prev), t3 !== null && (t3.OutIdx == -2 || t3.NextInAEL == t3.PrevInAEL && !h.ClipperBase.IsHorizontal(t3)) ? null : t3;
  };
  h.Clipper.prototype.ProcessIntersections = function(r3, t3) {
    if (this.m_ActiveEdges == null) return true;
    try {
      if (this.BuildIntersectList(r3, t3), this.m_IntersectList.length == 0) return true;
      if (this.m_IntersectList.length == 1 || this.FixupIntersectionOrder()) this.ProcessIntersectList();
      else return false;
    } catch {
      this.m_SortedEdges = null, this.m_IntersectList.length = 0, h.Error("ProcessIntersections error");
    }
    return this.m_SortedEdges = null, true;
  };
  h.Clipper.prototype.BuildIntersectList = function(r3, t3) {
    if (this.m_ActiveEdges !== null) {
      var e2 = this.m_ActiveEdges;
      for (this.m_SortedEdges = e2; e2 !== null; ) e2.PrevInSEL = e2.PrevInAEL, e2.NextInSEL = e2.NextInAEL, e2.Curr.X = h.Clipper.TopX(e2, t3), e2 = e2.NextInAEL;
      for (var i = true; i && this.m_SortedEdges !== null; ) {
        for (i = false, e2 = this.m_SortedEdges; e2.NextInSEL !== null; ) {
          var o = e2.NextInSEL, n = new h.IntPoint();
          if (e2.Curr.X > o.Curr.X) {
            !this.IntersectPoint(e2, o, n) && e2.Curr.X > o.Curr.X + 1 && h.Error("Intersection error"), n.Y > r3 && (n.Y = r3, Math.abs(e2.Dx) > Math.abs(o.Dx) ? n.X = h.Clipper.TopX(o, r3) : n.X = h.Clipper.TopX(e2, r3));
            var s2 = new h.IntersectNode();
            s2.Edge1 = e2, s2.Edge2 = o, s2.Pt.X = n.X, s2.Pt.Y = n.Y, this.m_IntersectList.push(s2), this.SwapPositionsInSEL(e2, o), i = true;
          } else e2 = o;
        }
        if (e2.PrevInSEL !== null) e2.PrevInSEL.NextInSEL = null;
        else break;
      }
      this.m_SortedEdges = null;
    }
  };
  h.Clipper.prototype.EdgesAdjacent = function(r3) {
    return r3.Edge1.NextInSEL == r3.Edge2 || r3.Edge1.PrevInSEL == r3.Edge2;
  };
  h.Clipper.IntersectNodeSort = function(r3, t3) {
    return t3.Pt.Y - r3.Pt.Y;
  };
  h.Clipper.prototype.FixupIntersectionOrder = function() {
    this.m_IntersectList.sort(this.m_IntersectNodeComparer), this.CopyAELToSEL();
    for (var r3 = this.m_IntersectList.length, t3 = 0; t3 < r3; t3++) {
      if (!this.EdgesAdjacent(this.m_IntersectList[t3])) {
        for (var e2 = t3 + 1; e2 < r3 && !this.EdgesAdjacent(this.m_IntersectList[e2]); ) e2++;
        if (e2 == r3) return false;
        var i = this.m_IntersectList[t3];
        this.m_IntersectList[t3] = this.m_IntersectList[e2], this.m_IntersectList[e2] = i;
      }
      this.SwapPositionsInSEL(this.m_IntersectList[t3].Edge1, this.m_IntersectList[t3].Edge2);
    }
    return true;
  };
  h.Clipper.prototype.ProcessIntersectList = function() {
    for (var r3 = 0, t3 = this.m_IntersectList.length; r3 < t3; r3++) {
      var e2 = this.m_IntersectList[r3];
      this.IntersectEdges(e2.Edge1, e2.Edge2, e2.Pt, true), this.SwapPositionsInAEL(e2.Edge1, e2.Edge2);
    }
    this.m_IntersectList.length = 0;
  };
  var d8 = function(r3) {
    return r3 < 0 ? Math.ceil(r3 - 0.5) : Math.round(r3);
  }, h8 = function(r3) {
    return r3 < 0 ? Math.ceil(r3 - 0.5) : Math.floor(r3 + 0.5);
  }, f8 = function(r3) {
    return r3 < 0 ? -Math.round(Math.abs(r3)) : Math.round(r3);
  }, m8 = function(r3) {
    return r3 < 0 ? (r3 -= 0.5, r3 < -2147483648 ? Math.ceil(r3) : r3 | 0) : (r3 += 0.5, r3 > 2147483647 ? Math.floor(r3) : r3 | 0);
  };
  le.msie ? h.Clipper.Round = d8 : le.chromium ? h.Clipper.Round = f8 : le.safari ? h.Clipper.Round = m8 : h.Clipper.Round = h8;
  h.Clipper.TopX = function(r3, t3) {
    return t3 == r3.Top.Y ? r3.Top.X : r3.Bot.X + h.Clipper.Round(r3.Dx * (t3 - r3.Bot.Y));
  };
  h.Clipper.prototype.IntersectPoint = function(r3, t3, e2) {
    e2.X = 0, e2.Y = 0;
    var i, o;
    if (h.ClipperBase.SlopesEqual(r3, t3, this.m_UseFullRange) || r3.Dx == t3.Dx) return t3.Bot.Y > r3.Bot.Y ? (e2.X = t3.Bot.X, e2.Y = t3.Bot.Y) : (e2.X = r3.Bot.X, e2.Y = r3.Bot.Y), false;
    if (r3.Delta.X === 0) e2.X = r3.Bot.X, h.ClipperBase.IsHorizontal(t3) ? e2.Y = t3.Bot.Y : (o = t3.Bot.Y - t3.Bot.X / t3.Dx, e2.Y = h.Clipper.Round(e2.X / t3.Dx + o));
    else if (t3.Delta.X === 0) e2.X = t3.Bot.X, h.ClipperBase.IsHorizontal(r3) ? e2.Y = r3.Bot.Y : (i = r3.Bot.Y - r3.Bot.X / r3.Dx, e2.Y = h.Clipper.Round(e2.X / r3.Dx + i));
    else {
      i = r3.Bot.X - r3.Bot.Y * r3.Dx, o = t3.Bot.X - t3.Bot.Y * t3.Dx;
      var n = (o - i) / (r3.Dx - t3.Dx);
      e2.Y = h.Clipper.Round(n), Math.abs(r3.Dx) < Math.abs(t3.Dx) ? e2.X = h.Clipper.Round(r3.Dx * n + i) : e2.X = h.Clipper.Round(t3.Dx * n + o);
    }
    if (e2.Y < r3.Top.Y || e2.Y < t3.Top.Y) {
      if (r3.Top.Y > t3.Top.Y) return e2.Y = r3.Top.Y, e2.X = h.Clipper.TopX(t3, r3.Top.Y), e2.X < r3.Top.X;
      e2.Y = t3.Top.Y, Math.abs(r3.Dx) < Math.abs(t3.Dx) ? e2.X = h.Clipper.TopX(r3, e2.Y) : e2.X = h.Clipper.TopX(t3, e2.Y);
    }
    return true;
  };
  h.Clipper.prototype.ProcessEdgesAtTopOfScanbeam = function(r3) {
    for (var t3 = this.m_ActiveEdges; t3 !== null; ) {
      var e2 = this.IsMaxima(t3, r3);
      if (e2) {
        var i = this.GetMaximaPair(t3);
        e2 = i === null || !h.ClipperBase.IsHorizontal(i);
      }
      if (e2) {
        var o = t3.PrevInAEL;
        this.DoMaxima(t3), o === null ? t3 = this.m_ActiveEdges : t3 = o.NextInAEL;
      } else {
        if (this.IsIntermediate(t3, r3) && h.ClipperBase.IsHorizontal(t3.NextInLML) ? (t3 = this.UpdateEdgeIntoAEL(t3), t3.OutIdx >= 0 && this.AddOutPt(t3, t3.Bot), this.AddEdgeToSEL(t3)) : (t3.Curr.X = h.Clipper.TopX(t3, r3), t3.Curr.Y = r3), this.StrictlySimple) {
          var o = t3.PrevInAEL;
          if (t3.OutIdx >= 0 && t3.WindDelta !== 0 && o !== null && o.OutIdx >= 0 && o.Curr.X == t3.Curr.X && o.WindDelta !== 0) {
            var n = this.AddOutPt(o, t3.Curr), s2 = this.AddOutPt(t3, t3.Curr);
            this.AddJoin(n, s2, t3.Curr);
          }
        }
        t3 = t3.NextInAEL;
      }
    }
    for (this.ProcessHorizontals(true), t3 = this.m_ActiveEdges; t3 !== null; ) {
      if (this.IsIntermediate(t3, r3)) {
        var n = null;
        t3.OutIdx >= 0 && (n = this.AddOutPt(t3, t3.Top)), t3 = this.UpdateEdgeIntoAEL(t3);
        var o = t3.PrevInAEL, c2 = t3.NextInAEL;
        if (o !== null && o.Curr.X == t3.Bot.X && o.Curr.Y == t3.Bot.Y && n !== null && o.OutIdx >= 0 && o.Curr.Y > o.Top.Y && h.ClipperBase.SlopesEqual(t3, o, this.m_UseFullRange) && t3.WindDelta !== 0 && o.WindDelta !== 0) {
          var s2 = this.AddOutPt(o, t3.Bot);
          this.AddJoin(n, s2, t3.Top);
        } else if (c2 !== null && c2.Curr.X == t3.Bot.X && c2.Curr.Y == t3.Bot.Y && n !== null && c2.OutIdx >= 0 && c2.Curr.Y > c2.Top.Y && h.ClipperBase.SlopesEqual(t3, c2, this.m_UseFullRange) && t3.WindDelta !== 0 && c2.WindDelta !== 0) {
          var s2 = this.AddOutPt(c2, t3.Bot);
          this.AddJoin(n, s2, t3.Top);
        }
      }
      t3 = t3.NextInAEL;
    }
  };
  h.Clipper.prototype.DoMaxima = function(r3) {
    var t3 = this.GetMaximaPair(r3);
    if (t3 === null) {
      r3.OutIdx >= 0 && this.AddOutPt(r3, r3.Top), this.DeleteFromAEL(r3);
      return;
    }
    for (var e2 = r3.NextInAEL, i = true; e2 !== null && e2 != t3; ) this.IntersectEdges(r3, e2, r3.Top, true), this.SwapPositionsInAEL(r3, e2), e2 = r3.NextInAEL;
    r3.OutIdx == -1 && t3.OutIdx == -1 ? (this.DeleteFromAEL(r3), this.DeleteFromAEL(t3)) : r3.OutIdx >= 0 && t3.OutIdx >= 0 ? this.IntersectEdges(r3, t3, r3.Top, false) : i && r3.WindDelta === 0 ? (r3.OutIdx >= 0 && (this.AddOutPt(r3, r3.Top), r3.OutIdx = -1), this.DeleteFromAEL(r3), t3.OutIdx >= 0 && (this.AddOutPt(t3, r3.Top), t3.OutIdx = -1), this.DeleteFromAEL(t3)) : h.Error("DoMaxima error");
  };
  h.Clipper.ReversePaths = function(r3) {
    for (var t3 = 0, e2 = r3.length; t3 < e2; t3++) r3[t3].reverse();
  };
  h.Clipper.Orientation = function(r3) {
    return h.Clipper.Area(r3) >= 0;
  };
  h.Clipper.prototype.PointCount = function(r3) {
    if (r3 === null) return 0;
    var t3 = 0, e2 = r3;
    do
      t3++, e2 = e2.Next;
    while (e2 != r3);
    return t3;
  };
  h.Clipper.prototype.BuildResult = function(r3) {
    h.Clear(r3);
    for (var t3 = 0, e2 = this.m_PolyOuts.length; t3 < e2; t3++) {
      var i = this.m_PolyOuts[t3];
      if (i.Pts !== null) {
        var o = i.Pts.Prev, n = this.PointCount(o);
        if (!(n < 2)) {
          for (var s2 = new Array(n), c2 = 0; c2 < n; c2++) s2[c2] = o.Pt, o = o.Prev;
          r3.push(s2);
        }
      }
    }
  };
  h.Clipper.prototype.BuildResult2 = function(r3) {
    r3.Clear();
    for (var t3 = 0, e2 = this.m_PolyOuts.length; t3 < e2; t3++) {
      var i = this.m_PolyOuts[t3], o = this.PointCount(i.Pts);
      if (!(i.IsOpen && o < 2 || !i.IsOpen && o < 3)) {
        this.FixHoleLinkage(i);
        var n = new h.PolyNode();
        r3.m_AllPolys.push(n), i.PolyNode = n, n.m_polygon.length = o;
        for (var s2 = i.Pts.Prev, c2 = 0; c2 < o; c2++) n.m_polygon[c2] = s2.Pt, s2 = s2.Prev;
      }
    }
    for (var t3 = 0, e2 = this.m_PolyOuts.length; t3 < e2; t3++) {
      var i = this.m_PolyOuts[t3];
      i.PolyNode !== null && (i.IsOpen ? (i.PolyNode.IsOpen = true, r3.AddChild(i.PolyNode)) : i.FirstLeft !== null && i.FirstLeft.PolyNode != null ? i.FirstLeft.PolyNode.AddChild(i.PolyNode) : r3.AddChild(i.PolyNode));
    }
  };
  h.Clipper.prototype.FixupOutPolygon = function(r3) {
    var t3 = null;
    r3.BottomPt = null;
    for (var e2 = r3.Pts; ; ) {
      if (e2.Prev == e2 || e2.Prev == e2.Next) {
        this.DisposeOutPts(e2), r3.Pts = null;
        return;
      }
      if (h.IntPoint.op_Equality(e2.Pt, e2.Next.Pt) || h.IntPoint.op_Equality(e2.Pt, e2.Prev.Pt) || h.ClipperBase.SlopesEqual(e2.Prev.Pt, e2.Pt, e2.Next.Pt, this.m_UseFullRange) && (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(e2.Prev.Pt, e2.Pt, e2.Next.Pt))) {
        t3 = null;
        var i = e2;
        e2.Prev.Next = e2.Next, e2.Next.Prev = e2.Prev, e2 = e2.Prev, i = null;
      } else {
        if (e2 == t3) break;
        t3 === null && (t3 = e2), e2 = e2.Next;
      }
    }
    r3.Pts = e2;
  };
  h.Clipper.prototype.DupOutPt = function(r3, t3) {
    var e2 = new h.OutPt();
    return e2.Pt.X = r3.Pt.X, e2.Pt.Y = r3.Pt.Y, e2.Idx = r3.Idx, t3 ? (e2.Next = r3.Next, e2.Prev = r3, r3.Next.Prev = e2, r3.Next = e2) : (e2.Prev = r3.Prev, e2.Next = r3, r3.Prev.Next = e2, r3.Prev = e2), e2;
  };
  h.Clipper.prototype.GetOverlap = function(r3, t3, e2, i, o) {
    return r3 < t3 ? e2 < i ? (o.Left = Math.max(r3, e2), o.Right = Math.min(t3, i)) : (o.Left = Math.max(r3, i), o.Right = Math.min(t3, e2)) : e2 < i ? (o.Left = Math.max(t3, e2), o.Right = Math.min(r3, i)) : (o.Left = Math.max(t3, i), o.Right = Math.min(r3, e2)), o.Left < o.Right;
  };
  h.Clipper.prototype.JoinHorz = function(r3, t3, e2, i, o, n) {
    var s2 = r3.Pt.X > t3.Pt.X ? h.Direction.dRightToLeft : h.Direction.dLeftToRight, c2 = e2.Pt.X > i.Pt.X ? h.Direction.dRightToLeft : h.Direction.dLeftToRight;
    if (s2 == c2) return false;
    if (s2 == h.Direction.dLeftToRight) {
      for (; r3.Next.Pt.X <= o.X && r3.Next.Pt.X >= r3.Pt.X && r3.Next.Pt.Y == o.Y; ) r3 = r3.Next;
      n && r3.Pt.X != o.X && (r3 = r3.Next), t3 = this.DupOutPt(r3, !n), h.IntPoint.op_Inequality(t3.Pt, o) && (r3 = t3, r3.Pt.X = o.X, r3.Pt.Y = o.Y, t3 = this.DupOutPt(r3, !n));
    } else {
      for (; r3.Next.Pt.X >= o.X && r3.Next.Pt.X <= r3.Pt.X && r3.Next.Pt.Y == o.Y; ) r3 = r3.Next;
      !n && r3.Pt.X != o.X && (r3 = r3.Next), t3 = this.DupOutPt(r3, n), h.IntPoint.op_Inequality(t3.Pt, o) && (r3 = t3, r3.Pt.X = o.X, r3.Pt.Y = o.Y, t3 = this.DupOutPt(r3, n));
    }
    if (c2 == h.Direction.dLeftToRight) {
      for (; e2.Next.Pt.X <= o.X && e2.Next.Pt.X >= e2.Pt.X && e2.Next.Pt.Y == o.Y; ) e2 = e2.Next;
      n && e2.Pt.X != o.X && (e2 = e2.Next), i = this.DupOutPt(e2, !n), h.IntPoint.op_Inequality(i.Pt, o) && (e2 = i, e2.Pt.X = o.X, e2.Pt.Y = o.Y, i = this.DupOutPt(e2, !n));
    } else {
      for (; e2.Next.Pt.X >= o.X && e2.Next.Pt.X <= e2.Pt.X && e2.Next.Pt.Y == o.Y; ) e2 = e2.Next;
      !n && e2.Pt.X != o.X && (e2 = e2.Next), i = this.DupOutPt(e2, n), h.IntPoint.op_Inequality(i.Pt, o) && (e2 = i, e2.Pt.X = o.X, e2.Pt.Y = o.Y, i = this.DupOutPt(e2, n));
    }
    return s2 == h.Direction.dLeftToRight == n ? (r3.Prev = e2, e2.Next = r3, t3.Next = i, i.Prev = t3) : (r3.Next = e2, e2.Prev = r3, t3.Prev = i, i.Next = t3), true;
  };
  h.Clipper.prototype.JoinPoints = function(r3, t3, e2) {
    var i = r3.OutPt1, o = new h.OutPt(), n = r3.OutPt2, s2 = new h.OutPt(), c2 = r3.OutPt1.Pt.Y == r3.OffPt.Y;
    if (c2 && h.IntPoint.op_Equality(r3.OffPt, r3.OutPt1.Pt) && h.IntPoint.op_Equality(r3.OffPt, r3.OutPt2.Pt)) {
      for (o = r3.OutPt1.Next; o != i && h.IntPoint.op_Equality(o.Pt, r3.OffPt); ) o = o.Next;
      var l = o.Pt.Y > r3.OffPt.Y;
      for (s2 = r3.OutPt2.Next; s2 != n && h.IntPoint.op_Equality(s2.Pt, r3.OffPt); ) s2 = s2.Next;
      var p = s2.Pt.Y > r3.OffPt.Y;
      return l == p ? false : l ? (o = this.DupOutPt(i, false), s2 = this.DupOutPt(n, true), i.Prev = n, n.Next = i, o.Next = s2, s2.Prev = o, r3.OutPt1 = i, r3.OutPt2 = o, true) : (o = this.DupOutPt(i, true), s2 = this.DupOutPt(n, false), i.Next = n, n.Prev = i, o.Prev = s2, s2.Next = o, r3.OutPt1 = i, r3.OutPt2 = o, true);
    } else if (c2) {
      for (o = i; i.Prev.Pt.Y == i.Pt.Y && i.Prev != o && i.Prev != n; ) i = i.Prev;
      for (; o.Next.Pt.Y == o.Pt.Y && o.Next != i && o.Next != n; ) o = o.Next;
      if (o.Next == i || o.Next == n) return false;
      for (s2 = n; n.Prev.Pt.Y == n.Pt.Y && n.Prev != s2 && n.Prev != o; ) n = n.Prev;
      for (; s2.Next.Pt.Y == s2.Pt.Y && s2.Next != n && s2.Next != i; ) s2 = s2.Next;
      if (s2.Next == n || s2.Next == i) return false;
      var d = { Left: null, Right: null };
      if (!this.GetOverlap(i.Pt.X, o.Pt.X, n.Pt.X, s2.Pt.X, d)) return false;
      var f = d.Left, g = d.Right, v2 = new h.IntPoint(), b;
      return i.Pt.X >= f && i.Pt.X <= g ? (v2.X = i.Pt.X, v2.Y = i.Pt.Y, b = i.Pt.X > o.Pt.X) : n.Pt.X >= f && n.Pt.X <= g ? (v2.X = n.Pt.X, v2.Y = n.Pt.Y, b = n.Pt.X > s2.Pt.X) : o.Pt.X >= f && o.Pt.X <= g ? (v2.X = o.Pt.X, v2.Y = o.Pt.Y, b = o.Pt.X > i.Pt.X) : (v2.X = s2.Pt.X, v2.Y = s2.Pt.Y, b = s2.Pt.X > n.Pt.X), r3.OutPt1 = i, r3.OutPt2 = n, this.JoinHorz(i, o, n, s2, v2, b);
    } else {
      for (o = i.Next; h.IntPoint.op_Equality(o.Pt, i.Pt) && o != i; ) o = o.Next;
      var C = o.Pt.Y > i.Pt.Y || !h.ClipperBase.SlopesEqual(i.Pt, o.Pt, r3.OffPt, this.m_UseFullRange);
      if (C) {
        for (o = i.Prev; h.IntPoint.op_Equality(o.Pt, i.Pt) && o != i; ) o = o.Prev;
        if (o.Pt.Y > i.Pt.Y || !h.ClipperBase.SlopesEqual(i.Pt, o.Pt, r3.OffPt, this.m_UseFullRange)) return false;
      }
      for (s2 = n.Next; h.IntPoint.op_Equality(s2.Pt, n.Pt) && s2 != n; ) s2 = s2.Next;
      var y = s2.Pt.Y > n.Pt.Y || !h.ClipperBase.SlopesEqual(n.Pt, s2.Pt, r3.OffPt, this.m_UseFullRange);
      if (y) {
        for (s2 = n.Prev; h.IntPoint.op_Equality(s2.Pt, n.Pt) && s2 != n; ) s2 = s2.Prev;
        if (s2.Pt.Y > n.Pt.Y || !h.ClipperBase.SlopesEqual(n.Pt, s2.Pt, r3.OffPt, this.m_UseFullRange)) return false;
      }
      return o == i || s2 == n || o == s2 || t3 == e2 && C == y ? false : C ? (o = this.DupOutPt(i, false), s2 = this.DupOutPt(n, true), i.Prev = n, n.Next = i, o.Next = s2, s2.Prev = o, r3.OutPt1 = i, r3.OutPt2 = o, true) : (o = this.DupOutPt(i, true), s2 = this.DupOutPt(n, false), i.Next = n, n.Prev = i, o.Prev = s2, s2.Next = o, r3.OutPt1 = i, r3.OutPt2 = o, true);
    }
  };
  h.Clipper.GetBounds = function(r3) {
    for (var t3 = 0, e2 = r3.length; t3 < e2 && r3[t3].length == 0; ) t3++;
    if (t3 == e2) return new h.IntRect(0, 0, 0, 0);
    var i = new h.IntRect();
    for (i.left = r3[t3][0].X, i.right = i.left, i.top = r3[t3][0].Y, i.bottom = i.top; t3 < e2; t3++) for (var o = 0, n = r3[t3].length; o < n; o++) r3[t3][o].X < i.left ? i.left = r3[t3][o].X : r3[t3][o].X > i.right && (i.right = r3[t3][o].X), r3[t3][o].Y < i.top ? i.top = r3[t3][o].Y : r3[t3][o].Y > i.bottom && (i.bottom = r3[t3][o].Y);
    return i;
  };
  h.Clipper.prototype.GetBounds2 = function(r3) {
    var t3 = r3, e2 = new h.IntRect();
    for (e2.left = r3.Pt.X, e2.right = r3.Pt.X, e2.top = r3.Pt.Y, e2.bottom = r3.Pt.Y, r3 = r3.Next; r3 != t3; ) r3.Pt.X < e2.left && (e2.left = r3.Pt.X), r3.Pt.X > e2.right && (e2.right = r3.Pt.X), r3.Pt.Y < e2.top && (e2.top = r3.Pt.Y), r3.Pt.Y > e2.bottom && (e2.bottom = r3.Pt.Y), r3 = r3.Next;
    return e2;
  };
  h.Clipper.PointInPolygon = function(r3, t3) {
    var e2 = 0, i = t3.length;
    if (i < 3) return 0;
    for (var o = t3[0], n = 1; n <= i; ++n) {
      var s2 = n == i ? t3[0] : t3[n];
      if (s2.Y == r3.Y && (s2.X == r3.X || o.Y == r3.Y && s2.X > r3.X == o.X < r3.X)) return -1;
      if (o.Y < r3.Y != s2.Y < r3.Y) {
        if (o.X >= r3.X) if (s2.X > r3.X) e2 = 1 - e2;
        else {
          var c2 = (o.X - r3.X) * (s2.Y - r3.Y) - (s2.X - r3.X) * (o.Y - r3.Y);
          if (c2 == 0) return -1;
          c2 > 0 == s2.Y > o.Y && (e2 = 1 - e2);
        }
        else if (s2.X > r3.X) {
          var c2 = (o.X - r3.X) * (s2.Y - r3.Y) - (s2.X - r3.X) * (o.Y - r3.Y);
          if (c2 == 0) return -1;
          c2 > 0 == s2.Y > o.Y && (e2 = 1 - e2);
        }
      }
      o = s2;
    }
    return e2;
  };
  h.Clipper.prototype.PointInPolygon = function(r3, t3) {
    for (var e2 = 0, i = t3; ; ) {
      var o = t3.Pt.X, n = t3.Pt.Y, s2 = t3.Next.Pt.X, c2 = t3.Next.Pt.Y;
      if (c2 == r3.Y && (s2 == r3.X || n == r3.Y && s2 > r3.X == o < r3.X)) return -1;
      if (n < r3.Y != c2 < r3.Y) {
        if (o >= r3.X) if (s2 > r3.X) e2 = 1 - e2;
        else {
          var l = (o - r3.X) * (c2 - r3.Y) - (s2 - r3.X) * (n - r3.Y);
          if (l == 0) return -1;
          l > 0 == c2 > n && (e2 = 1 - e2);
        }
        else if (s2 > r3.X) {
          var l = (o - r3.X) * (c2 - r3.Y) - (s2 - r3.X) * (n - r3.Y);
          if (l == 0) return -1;
          l > 0 == c2 > n && (e2 = 1 - e2);
        }
      }
      if (t3 = t3.Next, i == t3) break;
    }
    return e2;
  };
  h.Clipper.prototype.Poly2ContainsPoly1 = function(r3, t3) {
    var e2 = r3;
    do {
      var i = this.PointInPolygon(e2.Pt, t3);
      if (i >= 0) return i != 0;
      e2 = e2.Next;
    } while (e2 != r3);
    return true;
  };
  h.Clipper.prototype.FixupFirstLefts1 = function(r3, t3) {
    for (var e2 = 0, i = this.m_PolyOuts.length; e2 < i; e2++) {
      var o = this.m_PolyOuts[e2];
      o.Pts !== null && o.FirstLeft == r3 && this.Poly2ContainsPoly1(o.Pts, t3.Pts) && (o.FirstLeft = t3);
    }
  };
  h.Clipper.prototype.FixupFirstLefts2 = function(r3, t3) {
    for (var e2 = 0, i = this.m_PolyOuts, o = i.length, n = i[e2]; e2 < o; e2++, n = i[e2]) n.FirstLeft == r3 && (n.FirstLeft = t3);
  };
  h.Clipper.ParseFirstLeft = function(r3) {
    for (; r3 != null && r3.Pts == null; ) r3 = r3.FirstLeft;
    return r3;
  };
  h.Clipper.prototype.JoinCommonEdges = function() {
    for (var r3 = 0, t3 = this.m_Joins.length; r3 < t3; r3++) {
      var e2 = this.m_Joins[r3], i = this.GetOutRec(e2.OutPt1.Idx), o = this.GetOutRec(e2.OutPt2.Idx);
      if (!(i.Pts == null || o.Pts == null)) {
        var n;
        if (i == o ? n = i : this.Param1RightOfParam2(i, o) ? n = o : this.Param1RightOfParam2(o, i) ? n = i : n = this.GetLowermostRec(i, o), !!this.JoinPoints(e2, i, o)) if (i == o) {
          if (i.Pts = e2.OutPt1, i.BottomPt = null, o = this.CreateOutRec(), o.Pts = e2.OutPt2, this.UpdateOutPtIdxs(o), this.m_UsingPolyTree) for (var s2 = 0, c2 = this.m_PolyOuts.length; s2 < c2 - 1; s2++) {
            var l = this.m_PolyOuts[s2];
            l.Pts == null || h.Clipper.ParseFirstLeft(l.FirstLeft) != i || l.IsHole == i.IsHole || this.Poly2ContainsPoly1(l.Pts, e2.OutPt2) && (l.FirstLeft = o);
          }
          this.Poly2ContainsPoly1(o.Pts, i.Pts) ? (o.IsHole = !i.IsHole, o.FirstLeft = i, this.m_UsingPolyTree && this.FixupFirstLefts2(o, i), (o.IsHole ^ this.ReverseSolution) == this.Area(o) > 0 && this.ReversePolyPtLinks(o.Pts)) : this.Poly2ContainsPoly1(i.Pts, o.Pts) ? (o.IsHole = i.IsHole, i.IsHole = !o.IsHole, o.FirstLeft = i.FirstLeft, i.FirstLeft = o, this.m_UsingPolyTree && this.FixupFirstLefts2(i, o), (i.IsHole ^ this.ReverseSolution) == this.Area(i) > 0 && this.ReversePolyPtLinks(i.Pts)) : (o.IsHole = i.IsHole, o.FirstLeft = i.FirstLeft, this.m_UsingPolyTree && this.FixupFirstLefts1(i, o));
        } else o.Pts = null, o.BottomPt = null, o.Idx = i.Idx, i.IsHole = n.IsHole, n == o && (i.FirstLeft = o.FirstLeft), o.FirstLeft = i, this.m_UsingPolyTree && this.FixupFirstLefts2(o, i);
      }
    }
  };
  h.Clipper.prototype.UpdateOutPtIdxs = function(r3) {
    var t3 = r3.Pts;
    do
      t3.Idx = r3.Idx, t3 = t3.Prev;
    while (t3 != r3.Pts);
  };
  h.Clipper.prototype.DoSimplePolygons = function() {
    for (var r3 = 0; r3 < this.m_PolyOuts.length; ) {
      var t3 = this.m_PolyOuts[r3++], e2 = t3.Pts;
      if (e2 !== null) do {
        for (var i = e2.Next; i != t3.Pts; ) {
          if (h.IntPoint.op_Equality(e2.Pt, i.Pt) && i.Next != e2 && i.Prev != e2) {
            var o = e2.Prev, n = i.Prev;
            e2.Prev = n, n.Next = e2, i.Prev = o, o.Next = i, t3.Pts = e2;
            var s2 = this.CreateOutRec();
            s2.Pts = i, this.UpdateOutPtIdxs(s2), this.Poly2ContainsPoly1(s2.Pts, t3.Pts) ? (s2.IsHole = !t3.IsHole, s2.FirstLeft = t3) : this.Poly2ContainsPoly1(t3.Pts, s2.Pts) ? (s2.IsHole = t3.IsHole, t3.IsHole = !s2.IsHole, s2.FirstLeft = t3.FirstLeft, t3.FirstLeft = s2) : (s2.IsHole = t3.IsHole, s2.FirstLeft = t3.FirstLeft), i = e2;
          }
          i = i.Next;
        }
        e2 = e2.Next;
      } while (e2 != t3.Pts);
    }
  };
  h.Clipper.Area = function(r3) {
    var t3 = r3.length;
    if (t3 < 3) return 0;
    for (var e2 = 0, i = 0, o = t3 - 1; i < t3; ++i) e2 += (r3[o].X + r3[i].X) * (r3[o].Y - r3[i].Y), o = i;
    return -e2 * 0.5;
  };
  h.Clipper.prototype.Area = function(r3) {
    var t3 = r3.Pts;
    if (t3 == null) return 0;
    var e2 = 0;
    do
      e2 = e2 + (t3.Prev.Pt.X + t3.Pt.X) * (t3.Prev.Pt.Y - t3.Pt.Y), t3 = t3.Next;
    while (t3 != r3.Pts);
    return e2 * 0.5;
  };
  U5 && (h.Clipper.OffsetPaths = function(r3, t3, e2, i, o) {
    var n = new h.Paths(), s2 = new h.ClipperOffset(o, o);
    return s2.AddPaths(r3, e2, i), s2.Execute(n, t3), n;
  });
  h.Clipper.SimplifyPolygon = function(r3, t3) {
    var e2 = new Array(), i = new h.Clipper(0);
    return i.StrictlySimple = true, i.AddPath(r3, h.PolyType.ptSubject, true), i.Execute(h.ClipType.ctUnion, e2, t3, t3), e2;
  };
  h.Clipper.SimplifyPolygons = function(r3, t3) {
    typeof t3 > "u" && (t3 = h.PolyFillType.pftEvenOdd);
    var e2 = new Array(), i = new h.Clipper(0);
    return i.StrictlySimple = true, i.AddPaths(r3, h.PolyType.ptSubject, true), i.Execute(h.ClipType.ctUnion, e2, t3, t3), e2;
  };
  h.Clipper.DistanceSqrd = function(r3, t3) {
    var e2 = r3.X - t3.X, i = r3.Y - t3.Y;
    return e2 * e2 + i * i;
  };
  h.Clipper.DistanceFromLineSqrd = function(r3, t3, e2) {
    var i = t3.Y - e2.Y, o = e2.X - t3.X, n = i * t3.X + o * t3.Y;
    return n = i * r3.X + o * r3.Y - n, n * n / (i * i + o * o);
  };
  h.Clipper.SlopesNearCollinear = function(r3, t3, e2, i) {
    return h.Clipper.DistanceFromLineSqrd(t3, r3, e2) < i;
  };
  h.Clipper.PointsAreClose = function(r3, t3, e2) {
    var i = r3.X - t3.X, o = r3.Y - t3.Y;
    return i * i + o * o <= e2;
  };
  h.Clipper.ExcludeOp = function(r3) {
    var t3 = r3.Prev;
    return t3.Next = r3.Next, r3.Next.Prev = t3, t3.Idx = 0, t3;
  };
  h.Clipper.CleanPolygon = function(r3, t3) {
    typeof t3 > "u" && (t3 = 1.415);
    var e2 = r3.length;
    if (e2 == 0) return new Array();
    for (var i = new Array(e2), o = 0; o < e2; ++o) i[o] = new h.OutPt();
    for (var o = 0; o < e2; ++o) i[o].Pt = r3[o], i[o].Next = i[(o + 1) % e2], i[o].Next.Prev = i[o], i[o].Idx = 0;
    for (var n = t3 * t3, s2 = i[0]; s2.Idx == 0 && s2.Next != s2.Prev; ) h.Clipper.PointsAreClose(s2.Pt, s2.Prev.Pt, n) ? (s2 = h.Clipper.ExcludeOp(s2), e2--) : h.Clipper.PointsAreClose(s2.Prev.Pt, s2.Next.Pt, n) ? (h.Clipper.ExcludeOp(s2.Next), s2 = h.Clipper.ExcludeOp(s2), e2 -= 2) : h.Clipper.SlopesNearCollinear(s2.Prev.Pt, s2.Pt, s2.Next.Pt, n) ? (s2 = h.Clipper.ExcludeOp(s2), e2--) : (s2.Idx = 1, s2 = s2.Next);
    e2 < 3 && (e2 = 0);
    for (var c2 = new Array(e2), o = 0; o < e2; ++o) c2[o] = new h.IntPoint(s2.Pt), s2 = s2.Next;
    return i = null, c2;
  };
  h.Clipper.CleanPolygons = function(r3, t3) {
    for (var e2 = new Array(r3.length), i = 0, o = r3.length; i < o; i++) e2[i] = h.Clipper.CleanPolygon(r3[i], t3);
    return e2;
  };
  h.Clipper.Minkowski = function(r3, t3, e2, i) {
    var o = i ? 1 : 0, n = r3.length, s2 = t3.length, c2 = new Array();
    if (e2) for (var l = 0; l < s2; l++) {
      for (var p = new Array(n), d = 0, f = r3.length, g = r3[d]; d < f; d++, g = r3[d]) p[d] = new h.IntPoint(t3[l].X + g.X, t3[l].Y + g.Y);
      c2.push(p);
    }
    else for (var l = 0; l < s2; l++) {
      for (var p = new Array(n), d = 0, f = r3.length, g = r3[d]; d < f; d++, g = r3[d]) p[d] = new h.IntPoint(t3[l].X - g.X, t3[l].Y - g.Y);
      c2.push(p);
    }
    for (var v2 = new Array(), l = 0; l < s2 - 1 + o; l++) for (var d = 0; d < n; d++) {
      var b = new Array();
      b.push(c2[l % s2][d % n]), b.push(c2[(l + 1) % s2][d % n]), b.push(c2[(l + 1) % s2][(d + 1) % n]), b.push(c2[l % s2][(d + 1) % n]), h.Clipper.Orientation(b) || b.reverse(), v2.push(b);
    }
    var C = new h.Clipper(0);
    return C.AddPaths(v2, h.PolyType.ptSubject, true), C.Execute(h.ClipType.ctUnion, c2, h.PolyFillType.pftNonZero, h.PolyFillType.pftNonZero), c2;
  };
  h.Clipper.MinkowskiSum = function() {
    var r3 = arguments, t3 = r3.length;
    if (t3 == 3) {
      var e2 = r3[0], i = r3[1], o = r3[2];
      return h.Clipper.Minkowski(e2, i, true, o);
    } else if (t3 == 4) {
      for (var e2 = r3[0], n = r3[1], s2 = r3[2], o = r3[3], c2 = new h.Clipper(), l, p = 0, d = n.length; p < d; ++p) {
        var l = h.Clipper.Minkowski(e2, n[p], true, o);
        c2.AddPaths(l, h.PolyType.ptSubject, true);
      }
      o && c2.AddPaths(n, h.PolyType.ptClip, true);
      var f = new h.Paths();
      return c2.Execute(h.ClipType.ctUnion, f, s2, s2), f;
    }
  };
  h.Clipper.MinkowskiDiff = function(r3, t3, e2) {
    return h.Clipper.Minkowski(r3, t3, false, e2);
  };
  h.Clipper.PolyTreeToPaths = function(r3) {
    var t3 = new Array();
    return h.Clipper.AddPolyNodeToPaths(r3, h.Clipper.NodeType.ntAny, t3), t3;
  };
  h.Clipper.AddPolyNodeToPaths = function(r3, t3, e2) {
    var i = true;
    switch (t3) {
      case h.Clipper.NodeType.ntOpen:
        return;
      case h.Clipper.NodeType.ntClosed:
        i = !r3.IsOpen;
        break;
      default:
        break;
    }
    r3.m_polygon.length > 0 && i && e2.push(r3.m_polygon);
    for (var o = 0, n = r3.Childs(), s2 = n.length, c2 = n[o]; o < s2; o++, c2 = n[o]) h.Clipper.AddPolyNodeToPaths(c2, t3, e2);
  };
  h.Clipper.OpenPathsFromPolyTree = function(r3) {
    for (var t3 = new h.Paths(), e2 = 0, i = r3.ChildCount(); e2 < i; e2++) r3.Childs()[e2].IsOpen && t3.push(r3.Childs()[e2].m_polygon);
    return t3;
  };
  h.Clipper.ClosedPathsFromPolyTree = function(r3) {
    var t3 = new h.Paths();
    return h.Clipper.AddPolyNodeToPaths(r3, h.Clipper.NodeType.ntClosed, t3), t3;
  };
  ch(h.Clipper, h.ClipperBase);
  h.Clipper.NodeType = { ntAny: 0, ntOpen: 1, ntClosed: 2 };
  h.ClipperOffset = function(r3, t3) {
    typeof r3 > "u" && (r3 = 2), typeof t3 > "u" && (t3 = h.ClipperOffset.def_arc_tolerance), this.m_destPolys = new h.Paths(), this.m_srcPoly = new h.Path(), this.m_destPoly = new h.Path(), this.m_normals = new Array(), this.m_delta = 0, this.m_sinA = 0, this.m_sin = 0, this.m_cos = 0, this.m_miterLim = 0, this.m_StepsPerRad = 0, this.m_lowest = new h.IntPoint(), this.m_polyNodes = new h.PolyNode(), this.MiterLimit = r3, this.ArcTolerance = t3, this.m_lowest.X = -1;
  };
  h.ClipperOffset.two_pi = 6.28318530717959;
  h.ClipperOffset.def_arc_tolerance = 0.25;
  h.ClipperOffset.prototype.Clear = function() {
    h.Clear(this.m_polyNodes.Childs()), this.m_lowest.X = -1;
  };
  h.ClipperOffset.Round = h.Clipper.Round;
  h.ClipperOffset.prototype.AddPath = function(r3, t3, e2) {
    var i = r3.length - 1;
    if (!(i < 0)) {
      var o = new h.PolyNode();
      if (o.m_jointype = t3, o.m_endtype = e2, e2 == h.EndType.etClosedLine || e2 == h.EndType.etClosedPolygon) for (; i > 0 && h.IntPoint.op_Equality(r3[0], r3[i]); ) i--;
      o.m_polygon.push(r3[0]);
      for (var n = 0, s2 = 0, c2 = 1; c2 <= i; c2++) h.IntPoint.op_Inequality(o.m_polygon[n], r3[c2]) && (n++, o.m_polygon.push(r3[c2]), (r3[c2].Y > o.m_polygon[s2].Y || r3[c2].Y == o.m_polygon[s2].Y && r3[c2].X < o.m_polygon[s2].X) && (s2 = n));
      if (!(e2 == h.EndType.etClosedPolygon && n < 2 || e2 != h.EndType.etClosedPolygon && n < 0) && (this.m_polyNodes.AddChild(o), e2 == h.EndType.etClosedPolygon)) if (this.m_lowest.X < 0) this.m_lowest = new h.IntPoint(0, s2);
      else {
        var l = this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon[this.m_lowest.Y];
        (o.m_polygon[s2].Y > l.Y || o.m_polygon[s2].Y == l.Y && o.m_polygon[s2].X < l.X) && (this.m_lowest = new h.IntPoint(this.m_polyNodes.ChildCount() - 1, s2));
      }
    }
  };
  h.ClipperOffset.prototype.AddPaths = function(r3, t3, e2) {
    for (var i = 0, o = r3.length; i < o; i++) this.AddPath(r3[i], t3, e2);
  };
  h.ClipperOffset.prototype.FixOrientations = function() {
    if (this.m_lowest.X >= 0 && !h.Clipper.Orientation(this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon)) for (var r3 = 0; r3 < this.m_polyNodes.ChildCount(); r3++) {
      var t3 = this.m_polyNodes.Childs()[r3];
      (t3.m_endtype == h.EndType.etClosedPolygon || t3.m_endtype == h.EndType.etClosedLine && h.Clipper.Orientation(t3.m_polygon)) && t3.m_polygon.reverse();
    }
    else for (var r3 = 0; r3 < this.m_polyNodes.ChildCount(); r3++) {
      var t3 = this.m_polyNodes.Childs()[r3];
      t3.m_endtype == h.EndType.etClosedLine && !h.Clipper.Orientation(t3.m_polygon) && t3.m_polygon.reverse();
    }
  };
  h.ClipperOffset.GetUnitNormal = function(r3, t3) {
    var e2 = t3.X - r3.X, i = t3.Y - r3.Y;
    if (e2 == 0 && i == 0) return new h.DoublePoint(0, 0);
    var o = 1 / Math.sqrt(e2 * e2 + i * i);
    return e2 *= o, i *= o, new h.DoublePoint(i, -e2);
  };
  h.ClipperOffset.prototype.DoOffset = function(r3) {
    if (this.m_destPolys = new Array(), this.m_delta = r3, h.ClipperBase.near_zero(r3)) {
      for (var t3 = 0; t3 < this.m_polyNodes.ChildCount(); t3++) {
        var e2 = this.m_polyNodes.Childs()[t3];
        e2.m_endtype == h.EndType.etClosedPolygon && this.m_destPolys.push(e2.m_polygon);
      }
      return;
    }
    this.MiterLimit > 2 ? this.m_miterLim = 2 / (this.MiterLimit * this.MiterLimit) : this.m_miterLim = 0.5;
    var i;
    this.ArcTolerance <= 0 ? i = h.ClipperOffset.def_arc_tolerance : this.ArcTolerance > Math.abs(r3) * h.ClipperOffset.def_arc_tolerance ? i = Math.abs(r3) * h.ClipperOffset.def_arc_tolerance : i = this.ArcTolerance;
    var o = 3.14159265358979 / Math.acos(1 - i / Math.abs(r3));
    this.m_sin = Math.sin(h.ClipperOffset.two_pi / o), this.m_cos = Math.cos(h.ClipperOffset.two_pi / o), this.m_StepsPerRad = o / h.ClipperOffset.two_pi, r3 < 0 && (this.m_sin = -this.m_sin);
    for (var t3 = 0; t3 < this.m_polyNodes.ChildCount(); t3++) {
      var e2 = this.m_polyNodes.Childs()[t3];
      this.m_srcPoly = e2.m_polygon;
      var n = this.m_srcPoly.length;
      if (!(n == 0 || r3 <= 0 && (n < 3 || e2.m_endtype != h.EndType.etClosedPolygon))) {
        if (this.m_destPoly = new Array(), n == 1) {
          if (e2.m_jointype == h.JoinType.jtRound) for (var s2 = 1, c2 = 0, l = 1; l <= o; l++) {
            this.m_destPoly.push(new h.IntPoint(h.ClipperOffset.Round(this.m_srcPoly[0].X + s2 * r3), h.ClipperOffset.Round(this.m_srcPoly[0].Y + c2 * r3)));
            var p = s2;
            s2 = s2 * this.m_cos - this.m_sin * c2, c2 = p * this.m_sin + c2 * this.m_cos;
          }
          else for (var s2 = -1, c2 = -1, l = 0; l < 4; ++l) this.m_destPoly.push(new h.IntPoint(h.ClipperOffset.Round(this.m_srcPoly[0].X + s2 * r3), h.ClipperOffset.Round(this.m_srcPoly[0].Y + c2 * r3))), s2 < 0 ? s2 = 1 : c2 < 0 ? c2 = 1 : s2 = -1;
          this.m_destPolys.push(this.m_destPoly);
          continue;
        }
        this.m_normals.length = 0;
        for (var l = 0; l < n - 1; l++) this.m_normals.push(h.ClipperOffset.GetUnitNormal(this.m_srcPoly[l], this.m_srcPoly[l + 1]));
        if (e2.m_endtype == h.EndType.etClosedLine || e2.m_endtype == h.EndType.etClosedPolygon ? this.m_normals.push(h.ClipperOffset.GetUnitNormal(this.m_srcPoly[n - 1], this.m_srcPoly[0])) : this.m_normals.push(new h.DoublePoint(this.m_normals[n - 2])), e2.m_endtype == h.EndType.etClosedPolygon) {
          for (var d = n - 1, l = 0; l < n; l++) d = this.OffsetPoint(l, d, e2.m_jointype);
          this.m_destPolys.push(this.m_destPoly);
        } else if (e2.m_endtype == h.EndType.etClosedLine) {
          for (var d = n - 1, l = 0; l < n; l++) d = this.OffsetPoint(l, d, e2.m_jointype);
          this.m_destPolys.push(this.m_destPoly), this.m_destPoly = new Array();
          for (var f = this.m_normals[n - 1], l = n - 1; l > 0; l--) this.m_normals[l] = new h.DoublePoint(-this.m_normals[l - 1].X, -this.m_normals[l - 1].Y);
          this.m_normals[0] = new h.DoublePoint(-f.X, -f.Y), d = 0;
          for (var l = n - 1; l >= 0; l--) d = this.OffsetPoint(l, d, e2.m_jointype);
          this.m_destPolys.push(this.m_destPoly);
        } else {
          for (var d = 0, l = 1; l < n - 1; ++l) d = this.OffsetPoint(l, d, e2.m_jointype);
          var g;
          if (e2.m_endtype == h.EndType.etOpenButt) {
            var l = n - 1;
            g = new h.IntPoint(h.ClipperOffset.Round(this.m_srcPoly[l].X + this.m_normals[l].X * r3), h.ClipperOffset.Round(this.m_srcPoly[l].Y + this.m_normals[l].Y * r3)), this.m_destPoly.push(g), g = new h.IntPoint(h.ClipperOffset.Round(this.m_srcPoly[l].X - this.m_normals[l].X * r3), h.ClipperOffset.Round(this.m_srcPoly[l].Y - this.m_normals[l].Y * r3)), this.m_destPoly.push(g);
          } else {
            var l = n - 1;
            d = n - 2, this.m_sinA = 0, this.m_normals[l] = new h.DoublePoint(-this.m_normals[l].X, -this.m_normals[l].Y), e2.m_endtype == h.EndType.etOpenSquare ? this.DoSquare(l, d) : this.DoRound(l, d);
          }
          for (var l = n - 1; l > 0; l--) this.m_normals[l] = new h.DoublePoint(-this.m_normals[l - 1].X, -this.m_normals[l - 1].Y);
          this.m_normals[0] = new h.DoublePoint(-this.m_normals[1].X, -this.m_normals[1].Y), d = n - 1;
          for (var l = d - 1; l > 0; --l) d = this.OffsetPoint(l, d, e2.m_jointype);
          e2.m_endtype == h.EndType.etOpenButt ? (g = new h.IntPoint(h.ClipperOffset.Round(this.m_srcPoly[0].X - this.m_normals[0].X * r3), h.ClipperOffset.Round(this.m_srcPoly[0].Y - this.m_normals[0].Y * r3)), this.m_destPoly.push(g), g = new h.IntPoint(h.ClipperOffset.Round(this.m_srcPoly[0].X + this.m_normals[0].X * r3), h.ClipperOffset.Round(this.m_srcPoly[0].Y + this.m_normals[0].Y * r3)), this.m_destPoly.push(g)) : (d = 1, this.m_sinA = 0, e2.m_endtype == h.EndType.etOpenSquare ? this.DoSquare(0, 1) : this.DoRound(0, 1)), this.m_destPolys.push(this.m_destPoly);
        }
      }
    }
  };
  h.ClipperOffset.prototype.Execute = function() {
    var r3 = arguments, t3 = r3[0] instanceof h.PolyTree;
    if (t3) {
      var e2 = r3[0], i = r3[1];
      e2.Clear(), this.FixOrientations(), this.DoOffset(i);
      var o = new h.Clipper(0);
      if (o.AddPaths(this.m_destPolys, h.PolyType.ptSubject, true), i > 0) o.Execute(h.ClipType.ctUnion, e2, h.PolyFillType.pftPositive, h.PolyFillType.pftPositive);
      else {
        var n = h.Clipper.GetBounds(this.m_destPolys), s2 = new h.Path();
        if (s2.push(new h.IntPoint(n.left - 10, n.bottom + 10)), s2.push(new h.IntPoint(n.right + 10, n.bottom + 10)), s2.push(new h.IntPoint(n.right + 10, n.top - 10)), s2.push(new h.IntPoint(n.left - 10, n.top - 10)), o.AddPath(s2, h.PolyType.ptSubject, true), o.ReverseSolution = true, o.Execute(h.ClipType.ctUnion, e2, h.PolyFillType.pftNegative, h.PolyFillType.pftNegative), e2.ChildCount() == 1 && e2.Childs()[0].ChildCount() > 0) {
          var c2 = e2.Childs()[0];
          e2.Childs()[0] = c2.Childs()[0];
          for (var l = 1; l < c2.ChildCount(); l++) e2.AddChild(c2.Childs()[l]);
        } else e2.Clear();
      }
    } else {
      var e2 = r3[0], i = r3[1];
      h.Clear(e2), this.FixOrientations(), this.DoOffset(i);
      var o = new h.Clipper(0);
      if (o.AddPaths(this.m_destPolys, h.PolyType.ptSubject, true), i > 0) o.Execute(h.ClipType.ctUnion, e2, h.PolyFillType.pftPositive, h.PolyFillType.pftPositive);
      else {
        var n = h.Clipper.GetBounds(this.m_destPolys), s2 = new h.Path();
        s2.push(new h.IntPoint(n.left - 10, n.bottom + 10)), s2.push(new h.IntPoint(n.right + 10, n.bottom + 10)), s2.push(new h.IntPoint(n.right + 10, n.top - 10)), s2.push(new h.IntPoint(n.left - 10, n.top - 10)), o.AddPath(s2, h.PolyType.ptSubject, true), o.ReverseSolution = true, o.Execute(h.ClipType.ctUnion, e2, h.PolyFillType.pftNegative, h.PolyFillType.pftNegative), e2.length > 0 && e2.splice(0, 1);
      }
    }
  };
  h.ClipperOffset.prototype.OffsetPoint = function(r3, t3, e2) {
    if (this.m_sinA = this.m_normals[t3].X * this.m_normals[r3].Y - this.m_normals[r3].X * this.m_normals[t3].Y, this.m_sinA < 5e-5 && this.m_sinA > -5e-5) return t3;
    if (this.m_sinA > 1 ? this.m_sinA = 1 : this.m_sinA < -1 && (this.m_sinA = -1), this.m_sinA * this.m_delta < 0) this.m_destPoly.push(new h.IntPoint(h.ClipperOffset.Round(this.m_srcPoly[r3].X + this.m_normals[t3].X * this.m_delta), h.ClipperOffset.Round(this.m_srcPoly[r3].Y + this.m_normals[t3].Y * this.m_delta))), this.m_destPoly.push(new h.IntPoint(this.m_srcPoly[r3])), this.m_destPoly.push(new h.IntPoint(h.ClipperOffset.Round(this.m_srcPoly[r3].X + this.m_normals[r3].X * this.m_delta), h.ClipperOffset.Round(this.m_srcPoly[r3].Y + this.m_normals[r3].Y * this.m_delta)));
    else switch (e2) {
      case h.JoinType.jtMiter: {
        var i = 1 + (this.m_normals[r3].X * this.m_normals[t3].X + this.m_normals[r3].Y * this.m_normals[t3].Y);
        i >= this.m_miterLim ? this.DoMiter(r3, t3, i) : this.DoSquare(r3, t3);
        break;
      }
      case h.JoinType.jtSquare:
        this.DoSquare(r3, t3);
        break;
      case h.JoinType.jtRound:
        this.DoRound(r3, t3);
        break;
    }
    return t3 = r3, t3;
  };
  h.ClipperOffset.prototype.DoSquare = function(r3, t3) {
    var e2 = Math.tan(Math.atan2(this.m_sinA, this.m_normals[t3].X * this.m_normals[r3].X + this.m_normals[t3].Y * this.m_normals[r3].Y) / 4);
    this.m_destPoly.push(new h.IntPoint(h.ClipperOffset.Round(this.m_srcPoly[r3].X + this.m_delta * (this.m_normals[t3].X - this.m_normals[t3].Y * e2)), h.ClipperOffset.Round(this.m_srcPoly[r3].Y + this.m_delta * (this.m_normals[t3].Y + this.m_normals[t3].X * e2)))), this.m_destPoly.push(new h.IntPoint(h.ClipperOffset.Round(this.m_srcPoly[r3].X + this.m_delta * (this.m_normals[r3].X + this.m_normals[r3].Y * e2)), h.ClipperOffset.Round(this.m_srcPoly[r3].Y + this.m_delta * (this.m_normals[r3].Y - this.m_normals[r3].X * e2))));
  };
  h.ClipperOffset.prototype.DoMiter = function(r3, t3, e2) {
    var i = this.m_delta / e2;
    this.m_destPoly.push(new h.IntPoint(h.ClipperOffset.Round(this.m_srcPoly[r3].X + (this.m_normals[t3].X + this.m_normals[r3].X) * i), h.ClipperOffset.Round(this.m_srcPoly[r3].Y + (this.m_normals[t3].Y + this.m_normals[r3].Y) * i)));
  };
  h.ClipperOffset.prototype.DoRound = function(r3, t3) {
    for (var e2 = Math.atan2(this.m_sinA, this.m_normals[t3].X * this.m_normals[r3].X + this.m_normals[t3].Y * this.m_normals[r3].Y), i = h.Cast_Int32(h.ClipperOffset.Round(this.m_StepsPerRad * Math.abs(e2))), o = this.m_normals[t3].X, n = this.m_normals[t3].Y, s2, c2 = 0; c2 < i; ++c2) this.m_destPoly.push(new h.IntPoint(h.ClipperOffset.Round(this.m_srcPoly[r3].X + o * this.m_delta), h.ClipperOffset.Round(this.m_srcPoly[r3].Y + n * this.m_delta))), s2 = o, o = o * this.m_cos - this.m_sin * n, n = s2 * this.m_sin + n * this.m_cos;
    this.m_destPoly.push(new h.IntPoint(h.ClipperOffset.Round(this.m_srcPoly[r3].X + this.m_normals[r3].X * this.m_delta), h.ClipperOffset.Round(this.m_srcPoly[r3].Y + this.m_normals[r3].Y * this.m_delta)));
  };
  h.Error = function(r3) {
    try {
      throw new Error(r3);
    } catch (t3) {
      alert(t3.message);
    }
  };
  h.JS = {};
  h.JS.AreaOfPolygon = function(r3, t3) {
    return t3 || (t3 = 1), h.Clipper.Area(r3) / (t3 * t3);
  };
  h.JS.AreaOfPolygons = function(r3, t3) {
    t3 || (t3 = 1);
    for (var e2 = 0, i = 0; i < r3.length; i++) e2 += h.Clipper.Area(r3[i]);
    return e2 / (t3 * t3);
  };
  h.JS.BoundsOfPath = function(r3, t3) {
    return h.JS.BoundsOfPaths([r3], t3);
  };
  h.JS.BoundsOfPaths = function(r3, t3) {
    t3 || (t3 = 1);
    var e2 = h.Clipper.GetBounds(r3);
    return e2.left /= t3, e2.bottom /= t3, e2.right /= t3, e2.top /= t3, e2;
  };
  h.JS.Clean = function(i, t3) {
    if (!(i instanceof Array)) return [];
    var e2 = i[0] instanceof Array, i = h.JS.Clone(i);
    if (typeof t3 != "number" || t3 === null) return h.Error("Delta is not a number in Clean()."), i;
    if (i.length === 0 || i.length == 1 && i[0].length === 0 || t3 < 0) return i;
    e2 || (i = [i]);
    for (var o = i.length, n, s2, c2, l, p, d, f, g = [], v2 = 0; v2 < o; v2++) if (s2 = i[v2], n = s2.length, n !== 0) {
      if (n < 3) {
        c2 = s2, g.push(c2);
        continue;
      }
      for (c2 = s2, l = t3 * t3, p = s2[0], d = 1, f = 1; f < n; f++) (s2[f].X - p.X) * (s2[f].X - p.X) + (s2[f].Y - p.Y) * (s2[f].Y - p.Y) <= l || (c2[d] = s2[f], p = s2[f], d++);
      p = s2[d - 1], (s2[0].X - p.X) * (s2[0].X - p.X) + (s2[0].Y - p.Y) * (s2[0].Y - p.Y) <= l && d--, d < n && c2.splice(d, n - d), c2.length && g.push(c2);
    }
    return !e2 && g.length ? g = g[0] : !e2 && g.length === 0 ? g = [] : e2 && g.length === 0 && (g = [[]]), g;
  };
  h.JS.Clone = function(r3) {
    if (!(r3 instanceof Array)) return [];
    if (r3.length === 0) return [];
    if (r3.length == 1 && r3[0].length === 0) return [[]];
    var t3 = r3[0] instanceof Array;
    t3 || (r3 = [r3]);
    var e2 = r3.length, i, o, n, s2, c2 = new Array(e2);
    for (o = 0; o < e2; o++) {
      for (i = r3[o].length, s2 = new Array(i), n = 0; n < i; n++) s2[n] = { X: r3[o][n].X, Y: r3[o][n].Y };
      c2[o] = s2;
    }
    return t3 || (c2 = c2[0]), c2;
  };
  h.JS.Lighten = function(r3, t3) {
    if (!(r3 instanceof Array)) return [];
    if (typeof t3 != "number" || t3 === null) return h.Error("Tolerance is not a number in Lighten()."), h.JS.Clone(r3);
    if (r3.length === 0 || r3.length == 1 && r3[0].length === 0 || t3 < 0) return h.JS.Clone(r3);
    r3[0] instanceof Array || (r3 = [r3]);
    var e2, i, o, n, s2, c2, l, p, d, f, g, v2, b, C, y, S, T, w2 = r3.length, M2 = t3 * t3, D = [];
    for (e2 = 0; e2 < w2; e2++) if (o = r3[e2], c2 = o.length, c2 != 0) {
      for (n = 0; n < 1e6; n++) {
        for (s2 = [], c2 = o.length, o[c2 - 1].X != o[0].X || o[c2 - 1].Y != o[0].Y ? (v2 = 1, o.push({ X: o[0].X, Y: o[0].Y }), c2 = o.length) : v2 = 0, g = [], i = 0; i < c2 - 2; i++) l = o[i], d = o[i + 1], p = o[i + 2], S = l.X, T = l.Y, b = p.X - S, C = p.Y - T, (b !== 0 || C !== 0) && (y = ((d.X - S) * b + (d.Y - T) * C) / (b * b + C * C), y > 1 ? (S = p.X, T = p.Y) : y > 0 && (S += b * y, T += C * y)), b = d.X - S, C = d.Y - T, f = b * b + C * C, f <= M2 && (g[i + 1] = 1, i++);
        for (s2.push({ X: o[0].X, Y: o[0].Y }), i = 1; i < c2 - 1; i++) g[i] || s2.push({ X: o[i].X, Y: o[i].Y });
        if (s2.push({ X: o[c2 - 1].X, Y: o[c2 - 1].Y }), v2 && o.pop(), g.length) o = s2;
        else break;
      }
      c2 = s2.length, s2[c2 - 1].X == s2[0].X && s2[c2 - 1].Y == s2[0].Y && s2.pop(), s2.length > 2 && D.push(s2);
    }
    return !r3[0] instanceof Array && (D = D[0]), typeof D > "u" && (D = [[]]), D;
  };
  h.JS.PerimeterOfPath = function(r3, t3, e2) {
    if (typeof r3 > "u") return 0;
    var i = Math.sqrt, o = 0, n, s2, c2 = 0, l = 0, p = 0, d = 0, f = r3.length;
    if (f < 2) return 0;
    for (t3 && (r3[f] = r3[0], f++); --f; ) n = r3[f], c2 = n.X, l = n.Y, s2 = r3[f - 1], p = s2.X, d = s2.Y, o += i((c2 - p) * (c2 - p) + (l - d) * (l - d));
    return t3 && r3.pop(), o / e2;
  };
  h.JS.PerimeterOfPaths = function(r3, t3, e2) {
    e2 || (e2 = 1);
    for (var i = 0, o = 0; o < r3.length; o++) i += h.JS.PerimeterOfPath(r3[o], t3, e2);
    return i;
  };
  h.JS.ScaleDownPath = function(r3, t3) {
    var e2, i;
    for (t3 || (t3 = 1), e2 = r3.length; e2--; ) i = r3[e2], i.X = i.X / t3, i.Y = i.Y / t3;
  };
  h.JS.ScaleDownPaths = function(r3, t3) {
    var e2, i, o, n = Math.round;
    for (t3 || (t3 = 1), e2 = r3.length; e2--; ) for (i = r3[e2].length; i--; ) o = r3[e2][i], o.X = o.X / t3, o.Y = o.Y / t3;
  };
  h.JS.ScaleUpPath = function(r3, t3) {
    var e2, i, o = Math.round;
    for (t3 || (t3 = 1), e2 = r3.length; e2--; ) i = r3[e2], i.X = o(i.X * t3), i.Y = o(i.Y * t3);
  };
  h.JS.ScaleUpPaths = function(r3, t3) {
    var e2, i, o, n = Math.round;
    for (t3 || (t3 = 1), e2 = r3.length; e2--; ) for (i = r3[e2].length; i--; ) o = r3[e2][i], o.X = n(o.X * t3), o.Y = n(o.Y * t3);
  };
  h.ExPolygons = function() {
    return [];
  };
  h.ExPolygon = function() {
    this.outer = null, this.holes = null;
  };
  h.JS.AddOuterPolyNodeToExPolygons = function(r3, t3) {
    var e2 = new h.ExPolygon();
    e2.outer = r3.Contour();
    var i = r3.Childs(), o = i.length;
    e2.holes = new Array(o);
    var n, s2, c2, l, p, d;
    for (c2 = 0; c2 < o; c2++) for (n = i[c2], e2.holes[c2] = n.Contour(), l = 0, p = n.Childs(), d = p.length; l < d; l++) s2 = p[l], h.JS.AddOuterPolyNodeToExPolygons(s2, t3);
    t3.push(e2);
  };
  h.JS.ExPolygonsToPaths = function(r3) {
    var t3, e2, i, o, n = new h.Paths();
    for (t3 = 0, i = r3.length; t3 < i; t3++) for (n.push(r3[t3].outer), e2 = 0, o = r3[t3].holes.length; e2 < o; e2++) n.push(r3[t3].holes[e2]);
    return n;
  };
  h.JS.PolyTreeToExPolygons = function(r3) {
    var t3 = new h.ExPolygons(), e2, i, o, n;
    for (i = 0, o = r3.Childs(), n = o.length; i < n; i++) e2 = o[i], h.JS.AddOuterPolyNodeToExPolygons(e2, t3);
    return t3;
  };
  Dc.exports = h;
});
var fx = q((AJ, of) => {
  c();
  (function() {
    "use strict";
    function r3(s2, c2) {
      var l = s2.x - c2.x, p = s2.y - c2.y;
      return l * l + p * p;
    }
    function t3(s2, c2, l) {
      var p = c2.x, d = c2.y, f = l.x - p, g = l.y - d;
      if (f !== 0 || g !== 0) {
        var v2 = ((s2.x - p) * f + (s2.y - d) * g) / (f * f + g * g);
        v2 > 1 ? (p = l.x, d = l.y) : v2 > 0 && (p += f * v2, d += g * v2);
      }
      return f = s2.x - p, g = s2.y - d, f * f + g * g;
    }
    function e2(s2, c2) {
      for (var l = s2[0], p = [l], d, f = 1, g = s2.length; f < g; f++) d = s2[f], r3(d, l) > c2 && (p.push(d), l = d);
      return l !== d && p.push(d), p;
    }
    function i(s2, c2, l, p, d) {
      for (var f = p, g, v2 = c2 + 1; v2 < l; v2++) {
        var b = t3(s2[v2], s2[c2], s2[l]);
        b > f && (g = v2, f = b);
      }
      f > p && (g - c2 > 1 && i(s2, c2, g, p, d), d.push(s2[g]), l - g > 1 && i(s2, g, l, p, d));
    }
    function o(s2, c2) {
      var l = s2.length - 1, p = [s2[0]];
      return i(s2, 0, l, c2, p), p.push(s2[l]), p;
    }
    function n(s2, c2, l) {
      if (s2.length <= 2) return s2;
      var p = c2 !== void 0 ? c2 * c2 : 1;
      return s2 = l ? s2 : e2(s2, p), s2 = o(s2, p), s2;
    }
    typeof define == "function" && define.amd ? define(function() {
      return n;
    }) : typeof of < "u" ? (of.exports = n, of.exports.default = n) : typeof self < "u" ? self.simplify = n : window.simplify = n;
  })();
});
c();
c();
c();
c();
c();
c();
var hl = (r3) => r3 != null;
var jx = function() {
  let t3 = globalThis.fetch;
  return { fetch(...e2) {
    if (!hl(t3)) throw new Error("fetch is not available in your environment. Pass your own function into `setFetchFn` (node-fetch, etc)");
    return t3 == null ? void 0 : t3(...e2);
  }, setFetch(e2) {
    t3 = e2;
  } };
}();
var W0 = jx.fetch;
var z0 = ["websdk", "web", "webv2", "kiosk-v2", "mobile", "iossdk", "androidsdk", "reactnativesdk", "gen7", "bespoke"];
var X0 = z0[0];
var q0 = "https://api-gateway.mappedin.com/track-analytics/a/";
var $0 = "deny-watchposition";
var J0 = "load-mapview";
var Q0 = "load-mapdata";
var K0 = "change-language";
var eb2 = "query-directions";
var Ii;
var gr;
var Na;
var Ou;
var Ga = class {
  constructor() {
    v(this, Na);
    v(this, Ii, Object.freeze({}));
    v(this, gr);
    t(this, "oneTimeEventsSent", /* @__PURE__ */ new Set());
    t(this, "sendGetDirectionsEvent", Yp((t3, e2) => this.sendAnalyticEvent(eb2, { start: t3, end: e2, type: "location_to_location" }), 2500));
    w(this, gr, x(this, Na, Ou).call(this, u(this, Ii)));
  }
  init(t3) {
    this.reset(), this.updateStateWithOptions(t3);
  }
  reset() {
    w(this, Ii, {}), w(this, gr, x(this, Na, Ou).call(this, {})), this.oneTimeEventsSent.clear();
  }
  updateStateWithOptions(t3) {
    return w(this, Ii, Object.freeze(Object.assign({}, u(this, Ii), t3))), w(this, gr, x(this, Na, Ou).call(this, t3)), u(this, gr);
  }
  updateState(t3) {
    let e2 = { ...t3 };
    e2.mapId && (e2.analyticsBaseUrl = Bf({ ...u(this, gr), mapId: e2.mapId })), e2.context && (e2.context = Z0(e2.context)), e2.baseUri && (e2.analyticsBaseUrl = Bf({ baseUri: e2.baseUri, mapId: u(this, gr).mapId })), Object.assign(u(this, gr), e2), this.handleStateUpdate(t3);
  }
  handleStateUpdate(t3) {
    var e2;
    (e2 = t3.userPosition) != null && e2.floorLevel ? this.sendBlueDotEvents("found-floor") : t3.userPosition && this.sendBlueDotEvents("found-position");
  }
  get authReady() {
    let { key: t3, secret: e2, accessToken: i } = this.getState();
    return !!(t3 && e2) || !!i;
  }
  getState() {
    return u(this, gr);
  }
  getContext() {
    return this.getState().context || u(this, Ii).context || X0;
  }
  getSessionId() {
    return this.getState().sessionId || u(this, Ii).sessionId || Y0();
  }
  sendAnalyticEvent(t3, e2 = {}) {
    let i = this.getState(), o = Hx(i.analyticsBaseUrl, t3), n = { "mi-context": this.getContext(), "mi-session": this.getSessionId(), "mi-device": i.deviceId };
    if (i.logEvents && Lt.log("Analytics.track", o, n), !i.sendEvents) return Promise.resolve();
    if (!this.authReady) return Lt.warn("Auth needs to be ready to send analytics.");
    let s2 = { ...e2, g: i.geolocationMode, sdk_version: i.version };
    return i.userPosition && Object.assign(s2, i.userPosition), n["Content-Type"] = "application/json", i.accessToken ? n.Authorization = "Bearer ".concat(i.accessToken) : i.noAuth || i.secret && i.key && (n["x-mappedin-key"] = btoa(i.key), n["x-mappedin-secret"] = btoa(i.secret)), W0(o, { method: "POST", mode: "cors", headers: n, body: JSON.stringify(s2) });
  }
  capture(t3, e2) {
    if (Xx.includes(t3)) return Lt.warn("".concat(t3, " event is sent internally.")), Promise.resolve();
    let i = Wx.includes(t3) ? t3.slice(1) : t3;
    return this.sendAnalyticEvent(i, e2);
  }
  sendGetMapDataEvent(t3) {
    return this.sendAnalyticEvent(Q0, t3);
  }
  sendChangeLanguageEvent(t3) {
    return this.sendAnalyticEvent(K0, t3);
  }
  sendWatchPositionDenied() {
    return this.sendAnalyticEvent($0);
  }
  sendMapViewLoadedEvent({ firstRenderDuration: t3, dimension: e2 }) {
    return this.sendAnalyticEvent(J0, { type: "3d", firstRenderDuration: t3, width: e2.width, height: e2.height, devicePixelRatio: window.devicePixelRatio });
  }
  sendBlueDotEvents(t3) {
    if (!((t3 === "found-floor" || t3 === "found-position") && this.oneTimeEventsSent.has(t3))) return this.oneTimeEventsSent.add(t3), this.sendAnalyticEvent(t3);
  }
};
Ii = /* @__PURE__ */ new WeakMap(), gr = /* @__PURE__ */ new WeakMap(), Na = /* @__PURE__ */ new WeakSet(), Ou = function(t3) {
  var i, o, n, s2;
  let e2 = (i = t3.baseUri) != null ? i : q0;
  return { baseUri: e2, analyticsBaseUrl: Bf({ ...t3, baseUri: e2 }), version: ((o = e == null ? void 0 : e.env) == null ? void 0 : o.npm_package_version) || "v6", deviceId: t3.deviceId || Ux(), accessToken: t3.accessToken, mapId: t3.mapId, sessionId: t3.sessionId || Y0(), platformString: t3.platformString || "", context: Z0(t3.context) || X0, geolocationMode: false, sendEvents: (n = t3.sendEvents) != null ? n : true, logEvents: (s2 = t3.logEvents) != null ? s2 : false, noAuth: t3.noAuth || false, key: t3.key, secret: t3.secret };
};
function Bf({ mapId: r3, baseUri: t3 = q0 }) {
  return "".concat(t3).concat(r3, "/");
}
function Ux() {
  return yo.getInstance().loadLocalData("deviceId");
}
function Y0() {
  return yo.getInstance().loadSessionData("id");
}
function Hx(r3, t3) {
  return r3 + t3;
}
function Z0(r3) {
  return z0.find((t3) => t3 === r3);
}
var Wx = ["$select-location", "$select-category", "$query-suggest", "$query-search"];
var Xx = [J0, Q0, eb2, $0, K0];
var GD = new Ga();
var Pi;
var fl = class {
  constructor(t3) {
    v(this, Pi);
    t(this, "capture");
    t(this, "updateState");
    w(this, Pi, t3), this.capture = u(this, Pi).capture.bind(u(this, Pi)), this.updateState = u(this, Pi).updateState.bind(u(this, Pi));
  }
  getState() {
    return Object.assign({}, u(this, Pi).getState());
  }
};
Pi = /* @__PURE__ */ new WeakMap();
c();
c();
var gl;
var yl2;
var bl2;
var ml = class {
  constructor(t3, e2, { enabled: i = false } = {}) {
    v(this, gl);
    t(this, "searchInstance");
    v(this, yl2);
    v(this, bl2);
    t(this, "enabled", false);
    w(this, gl, t3), w(this, yl2, e2), w(this, bl2, () => {
      var o;
      (o = this.searchInstance) == null || o.then((n) => n.populate());
    }), i && this.enable();
  }
  async query(t3, e2 = {}) {
    if (this.enabled || await this.enable(), !this.searchInstance) return Lt.error("Search should be enabled by now"), { places: [], enterpriseLocations: [], enterpriseCategories: [] };
    try {
      return await (await this.searchInstance).search(t3, e2);
    } catch (i) {
      return Lt.error("Search.query failed due to", i), { places: [], enterpriseLocations: [], enterpriseCategories: [] };
    }
  }
  async suggest(t3, e2 = {}) {
    if (this.enabled || await this.enable(), !this.searchInstance) return Lt.error("Search should be enabled by now"), [];
    try {
      return await (await this.searchInstance).suggest(t3, e2);
    } catch (i) {
      return Lt.error("Search.suggest failed due to", i), [];
    }
  }
  async enable() {
    this.enabled || (this.enabled = true, this.searchInstance || (this.searchInstance = import("./internal-CKIQLSVC-GVNS6AWO.js").then(({ InternalSearch: t3 }) => new t3(u(this, gl)))), u(this, yl2).on("language-change", u(this, bl2)), await this.searchInstance);
  }
};
gl = /* @__PURE__ */ new WeakMap(), yl2 = /* @__PURE__ */ new WeakMap(), bl2 = /* @__PURE__ */ new WeakMap();
var tb = /* @__PURE__ */ new WeakMap();
var _e;
var _f = class extends _n {
  constructor(e2, { search: i } = {}) {
    super();
    v(this, _e);
    t(this, "Analytics");
    t(this, "Search");
    t(this, "Query");
    t(this, "getDirections", (e3, i2, o) => u(this, _e).getDirections(e3, i2, o));
    t(this, "getDirectionsMultiDestination", (e3, i2, o) => u(this, _e).getDirectionsMultiDestination(e3, i2, o));
    w(this, _e, e2), tb.set(this, e2), this.Analytics = new fl(e2.Analytics), this.Query = e2.Query, this.Search = new ml(this, e2, { enabled: i == null ? void 0 : i.enabled }), u(this, _e).on("language-change", (o) => {
      this.publish("language-change", o);
    });
  }
  getEnv() {
    return u(this, _e).getEnv();
  }
  getAccessToken() {
    var e2;
    return (e2 = u(this, _e).tokenManager) == null ? void 0 : e2.getAccessToken().token;
  }
  get mapName() {
    return u(this, _e).mapName;
  }
  get mapCenter() {
    return u(this, _e).mapCenter;
  }
  get organizationId() {
    return u(this, _e).organizationId;
  }
  get outdoorViewToken() {
    return u(this, _e).outdoorViewToken;
  }
  getByType(e2) {
    return u(this, _e).getByType(e2);
  }
  getById(e2, i) {
    return u(this, _e).getById(e2, i);
  }
  getByExternalId(e2, i) {
    return u(this, _e).getByExternalId(e2, i);
  }
  getGeoJSON(e2) {
    return e2.geoJSON;
  }
  async changeLanguage(e2) {
    return u(this, _e).changeLanguage(e2);
  }
  get currentLanguage() {
    return u(this, _e).currentLanguage;
  }
  get naturalBearing() {
    var e2;
    return (e2 = u(this, _e).naturalBearing) != null ? e2 : 0;
  }
  getDistance(e2, i) {
    return u(this, _e).getDistance(e2, i);
  }
  toBinaryBundle({ downloadLanguagePacks: e2 = true } = {}) {
    return u(this, _e).toBinaryBundle({ downloadLanguagePacks: e2 });
  }
  toJSONBundle({ downloadLanguagePacks: e2 = true } = {}) {
    return u(this, _e).toJSONBundle({ downloadLanguagePacks: e2 });
  }
};
_e = /* @__PURE__ */ new WeakMap();
var Lu = _f;
function vl3(r3) {
  let t3 = tb.get(r3);
  if (!t3) throw new Error("MapDataInternal not found");
  return t3;
}
c();
c();
c();
c();
c();
function Va(r3) {
  return r3.endsWith("/") ? r3 : "".concat(r3, "/");
}
c();
var ja = "https://app.mappedin.com/";
var rb = "https://auth.mappedin.com/";
c();
c();
var Yx = (r3) => {
  let t3 = Date.now();
  return r3 - t3;
};
var Au = (r3, t3) => Yx(r3) <= t3 * 60 * 1e3;
var ob = 60;
var nb = ob * 60 * 1e3;
var ib = "accessTokens";
async function Cl2(r3, t3 = false) {
  let e2 = "".concat(r3.key), i = yo.getInstance(), o = (i == null ? void 0 : i.loadSessionData(ib)) || {}, n = Math.floor(Date.now() / 1e3);
  if (o[e2] && !Au(o[e2].expiresTimestamp * 1e3, ob)) return o[e2];
  let s2 = t3 ? await Zx(r3, n) : await zx(r3, n), c2 = { ...o, [e2]: s2 };
  return i == null || i.saveSessionData(ib, c2), s2;
}
async function Zx(r3, t3) {
  var n;
  let e2 = "".concat((n = r3.baseAuthUri) != null ? n : rb, "oauth2/token"), i = await yr()(e2, { method: "POST", headers: { "content-type": "application/json" }, body: JSON.stringify({ grant_type: "client_credentials", client_id: r3.key, client_secret: r3.secret }) });
  if (!i.ok) throw new Error("".concat(i.status, " ").concat(i.statusText, ": ").concat(await i.text()));
  let o = await i.json();
  return { accessToken: o.access_token, expiresTimestamp: t3 + o.expires_in };
}
async function zx(r3, t3) {
  let e2 = "".concat(r3.baseAuthUri ? Va(r3.baseAuthUri) : ja, "api/api-key/token"), i = await yr()(e2, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ key: r3.key, secret: r3.secret }) });
  if (!i.ok) throw new Error("".concat(i.status, " ").concat(i.statusText, ": ").concat(await i.text()));
  let o = await i.json();
  return { accessToken: o.access_token, expiresTimestamp: t3 + o.expires_in };
}
c();
var sb = 60;
var lb = sb * 60 * 1e3;
var ab = "miSasTokens";
async function Rf(r3, t3) {
  let e2 = "".concat(t3, "__").concat(r3.mapId), i = yo.getInstance(), o = (i == null ? void 0 : i.loadSessionData(ab)) || {};
  if (o[e2] && !Au(o[e2].expires, sb)) return o[e2];
  let n = await qx(r3, t3), s2 = { ...o, [e2]: { token: n.token, expires: new Date(n.expires).getTime() } };
  return i == null || i.saveSessionData(ab, s2), n;
}
async function qx(r3, t3) {
  let e2 = "".concat(r3.baseUri ? Va(r3.baseUri) : ja, "api/v1/venue/").concat(r3.mapId, "/sas-token"), i = await yr()(e2, { method: "GET", headers: { Authorization: "Bearer ".concat(t3) } });
  if (!i.ok) throw new Error("".concat(i.status, " ").concat(i.statusText, ": ").concat(await i.text()));
  let o = await i.json();
  return { token: o.token, expires: new Date(o.expires).getTime() };
}
var cb = globalThis.fetch;
var ub;
var $x = (ub = e == null ? void 0 : e.env) == null ? void 0 : ub.npm_package_version;
function yr() {
  if (cb == null) throw new Error("fetch is not available in your environment. Pass your own function into `setFetchFn` (node-fetch, etc)");
  return cb;
}
var Nf = { supplementaryUrl: "https://api-gateway.mappedin.com/analytics/", headers: {}, accessToken: "", clientId: "", noAuth: false, includeHidden: true, clientSecret: "", apiGateway: "", authorization: "", perspective: "Website", language: "", venue: "" };
function db(r3) {
  var e2;
  let t3 = { ...Nf, ...r3 };
  return t3.headers = { ...t3.headers, "mappedin-sdk-version": $x }, t3.things = [], "platformString" in r3 && (t3.headers = { ...t3.headers, "mappedin-platform-version": r3.platformString }), t3.noAuth || (t3.accessToken ? t3.authorization = "Bearer ".concat(t3.accessToken) : t3.clientId && t3.clientSecret && (t3.authorization = "Basic ".concat(globalThis.btoa("".concat(t3.clientId, ":").concat(t3.clientSecret))))), t3.language = (e2 = t3.language) == null ? void 0 : e2.toLowerCase(), t3;
}
function Jx(r3, t3, e2 = false) {
  let i = { language: r3.language, clientId: r3.clientId, clientSecret: r3.clientSecret };
  e2 && delete i.language;
  let { headers: o } = r3;
  o["Content-Type"] = o["Content-Type"] || "text/json", r3.accessToken ? o.Authorization = "Bearer ".concat(r3.accessToken) : r3.noAuth || r3.clientId && r3.clientSecret && (o["x-mappedin-key"] = btoa(r3.clientId), o["x-mappedin-secret"] = btoa(r3.clientSecret));
  let n = { method: "GET", headers: o };
  return r3.secure && (t3 += "&withcdntoken"), { req: n, url: t3 };
}
async function Qx(r3, t3, e2 = false) {
  let i = Jx(r3, t3, e2), o = await yr()(i.url, i.req);
  if (!o.ok) throw new Error("".concat(o.status, " ").concat(o.statusText));
  return o.json();
}
var Kx = (r3) => {
  let t3 = r3 != null && typeof r3 == "object" && "perspectives" in r3 && r3.perspectives != null && typeof r3.perspectives == "object" ? r3.perspectives : null;
  if (t3 == null || Object.keys(t3).length === 0) return Lt.warn("No perspectives available in response!"), null;
  let e2 = {};
  for (let [i, o] of Object.entries(t3)) {
    let n = "url" in o && typeof o.url == "string" ? o.url : null, s2 = "locale_packs" in o && typeof o.locale_packs == "object" ? o.locale_packs : null;
    if (n == null || s2 == null) {
      Lt.warn("Perspective ".concat(i, " is missing url or locale_packs!"));
      continue;
    }
    e2[i] = { url: n, locale_packs: s2 };
  }
  return e2;
};
async function e7(r3, t3 = "exports/mvf/1/bundle") {
  var p, d;
  let e2 = db({ baseUri: "https://api-gateway.mappedin.com/", ...Nf, ...r3 }), i = "".concat(e2.baseUri + t3, "?venue=").concat(e2.venue, "&version=").concat((p = e2.version) != null ? p : "2.0.0");
  e2.headers["Content-Type"] = "application/zip";
  let o = await Qx(e2, i), n = o.url, s2 = o.locale_packs, c2 = (d = e2.perspective) != null ? d : Nf.perspective, l = Kx(o);
  if (c2 != null && c2 !== "" && l != null) {
    let f = l[c2];
    f == null ? Lt.warn("Perspective ".concat(c2, " not found in response! Loading default perspective instead.")) : (Lt.log('Loading perspective "'.concat(c2, '"')), n = f.url, s2 = f.locale_packs);
  }
  return { url: n, localePacks: s2, updated_at: o.updated_at };
}
var Sl = /* @__PURE__ */ function() {
  let r3;
  return () => (r3 || (r3 = new TextDecoder()), r3);
}();
async function Gf(r3, { signal: t3 }) {
  let e2 = await (await yr()(r3, { signal: t3 })).arrayBuffer();
  return new Uint8Array(e2);
}
async function Ua(r3) {
  let e2 = (await import("./browser-JUQDIV75-PXQVLWW5.js")).unzipSync(r3), i = {};
  if (e2["enterprise/"] != null) {
    i.enterprise = {};
    let o = e2["enterprise/locations.json"];
    o && (i.enterprise.locations = JSON.parse(Sl().decode(o)));
    let n = e2["enterprise/categories.json"];
    n && (i.enterprise.categories = JSON.parse(Sl().decode(n)));
  }
  return e2["floorstack.json"] && (i["floorstack.json"] = JSON.parse(Sl().decode(e2["floorstack.json"]))), e2["floor.geojson"] && (i["floor.geojson"] = JSON.parse(Sl().decode(e2["floor.geojson"]))), e2["manifest.json"] && (i["manifest.geojson"] = JSON.parse(Sl().decode(e2["manifest.json"]))), i;
}
async function hb(r3, { signal: t3 }) {
  try {
    let e2 = await (await yr()(r3, { signal: t3 })).arrayBuffer();
    if (t3.aborted) return;
    let i = new Uint8Array(e2);
    return await Ua(i);
  } catch (e2) {
    let i = new Error("downloadLanguagePack failed");
    throw i.cause = e2, i;
  }
}
async function Vf(r3) {
  return new Promise(async (t3, e2) => {
    try {
      let i = r3.useDraftData ? "exports/mvf2-draft/1/bundle" : "exports/mvf2/1/bundle", { url: o, localePacks: n } = await e7(r3, i), s2 = await yr()(o).then((l) => l.arrayBuffer()), c2 = new Uint8Array(s2);
      t3({ compressed: c2, localePacks: n });
    } catch (i) {
      e2(i);
    }
  });
}
async function jf(r3, t3) {
  return new Promise(async (e2, i) => {
    try {
      let { url: o } = await t7(r3, t3), n = await yr()(o).then((c2) => c2.arrayBuffer()), s2 = new Uint8Array(n);
      e2(s2);
    } catch (o) {
      i(o);
    }
  });
}
async function t7(r3, t3) {
  let e2 = "".concat(r3.baseUri ? Va(r3.baseUri) : ja, "api/venue/").concat(r3.mapId, "/mvf").concat(r3.viewId ? "?configId=".concat(r3.viewId) : ""), i = await yr()(e2, { headers: { Authorization: "Bearer ".concat(t3) } });
  if (!i.ok) throw new Error("".concat(i.status, " ").concat(i.statusText));
  return i.json();
}
function Fu(r3) {
  var i, o, n, s2, c2, l, p, d, f, g, v2, b, C, y, S, T, w2, M2;
  let t3 = new TextDecoder(), e2 = t3.decode.bind(t3);
  try {
    let D = { "connection.json": JSON.parse(e2(r3["connection.json"])), "manifest.geojson": JSON.parse(e2(r3["manifest.geojson"])), "map.geojson": r3["map.geojson"] ? JSON.parse(e2(r3["map.geojson"])) : void 0, "mapstack.geojson": r3["mapstack.geojson"] ? JSON.parse(e2(r3["mapstack.geojson"])) : void 0, "node.geojson": JSON.parse(e2(r3["node.geojson"])), obstruction: {}, space: {}, entrance: {}, facade: {}, "tileset.json": r3["tileset.json"] ? JSON.parse(e2(r3["tileset.json"])) : void 0 };
    if (r3.enterprise != null && (D.enterprise = {}, (i = r3.enterprise) != null && i["locations.json"] && (D.enterprise.locations = JSON.parse(e2((o = r3.enterprise) == null ? void 0 : o["locations.json"]))), (n = r3.enterprise) != null && n["categories.json"] && (D.enterprise.categories = JSON.parse(e2((s2 = r3.enterprise) == null ? void 0 : s2["categories.json"]))), (c2 = r3.enterprise) != null && c2["venue.json"] && (D.enterprise.venue = JSON.parse(e2((l = r3.enterprise) == null ? void 0 : l["venue.json"]))), (p = r3.enterprise) != null && p["layers.json"] && (D.enterprise.layers = JSON.parse(e2((d = r3.enterprise) == null ? void 0 : d["layers.json"]))), (f = r3.enterprise) != null && f["locationInstances.json"] && (D.enterprise.locationInstances = JSON.parse(e2((g = r3.enterprise) == null ? void 0 : g["locationInstances.json"]))), (v2 = r3.enterprise) != null && v2["enterpriseStyles.json"] && (D.enterprise.enterpriseStyles = JSON.parse(e2((b = r3.enterprise) == null ? void 0 : b["enterpriseStyles.json"]))), (C = r3.enterprise) != null && C["textures.json"] && (D.enterprise.textures = JSON.parse(e2((y = r3.enterprise) == null ? void 0 : y["textures.json"]))), (S = r3.enterprise) != null && S["floorText.json"] && (D.enterprise.floorText = JSON.parse(e2((T = r3.enterprise) == null ? void 0 : T["floorText.json"]))), (w2 = r3.enterprise) != null && w2["categoryPriorities.json"] && (D.enterprise.categoryPriorities = JSON.parse(e2((M2 = r3.enterprise) == null ? void 0 : M2["categoryPriorities.json"])))), r3["floorstack.json"] != null ? D["floorstack.json"] = JSON.parse(e2(r3["floorstack.json"])) : r3["mapstack.json"] != null && (D["mapstack.json"] = JSON.parse(e2(r3["mapstack.json"]))), D["floorstack.json"] == null && D["mapstack.json"] == null && D["mapstack.geojson"] == null) throw new Error("MVF is missing floorstack.json or mapstack.json/mapstack.geojson");
    if (r3["floor.geojson"] && (D["floor.geojson"] = JSON.parse(e2(r3["floor.geojson"]))), D["floor.geojson"] == null && D["map.geojson"] == null) throw new Error("MVF is missing floor.geojson or map.geojson");
    if ("styles.json" in r3 && (D["styles.json"] = JSON.parse(e2(r3["styles.json"]))), "shapes.json" in r3 && (D["shapes.json"] = JSON.parse(e2(r3["shapes.json"]))), "location.json" in r3 && (D["location.json"] = JSON.parse(e2(r3["location.json"]))), "category.json" in r3 && (D["category.json"] = JSON.parse(e2(r3["category.json"]))), r3.annotation != null) {
      D.annotation = {};
      let A = Object.keys(r3.annotation);
      for (let k of A) {
        let B = k.replace(/\.json|\.geojson/g, "");
        D.annotation[B] = JSON.parse(e2(r3.annotation[k]));
      }
    }
    let F = Object.keys(r3.space);
    for (let A of F) {
      let k = A.replace(/\.json|\.geojson/g, "");
      D.space[k] = JSON.parse(e2(r3.space[A]));
    }
    if (r3.obstruction != null) {
      let A = Object.keys(r3.obstruction);
      for (let k of A) {
        let B = k.replace(/\.json|\.geojson/g, "");
        D.obstruction[B] = JSON.parse(e2(r3.obstruction[k]));
      }
    } else D.obstruction = {};
    if (r3.entrance != null) {
      let A = Object.keys(r3.entrance);
      for (let k of A) {
        let B = k.replace(/\.json|\.geojson/g, "");
        D.entrance[B] = JSON.parse(e2(r3.entrance[k]));
      }
    } else D.entrance = {};
    if ("floorImages" in r3 && r3.floorImages != null) {
      D.floorImages = {};
      for (let A of Object.keys(r3.floorImages)) {
        let k = A.replace(/\.json|\.geojson/g, "");
        D.floorImages[k] = JSON.parse(e2(r3.floorImages[A]));
      }
    }
    if ("textAreas" in r3 && r3.textAreas != null) {
      D.textAreas = {};
      for (let A of Object.keys(r3.textAreas)) {
        let k = A.replace(/\.json|\.geojson/g, "");
        D.textAreas[k] = JSON.parse(e2(r3.textAreas[A]));
      }
    }
    if ("facade" in r3 && r3.facade != null) {
      D.facade = {};
      for (let A of Object.keys(r3.facade)) {
        let k = A.replace(/\.json|\.geojson/g, "");
        D.facade[k] = JSON.parse(e2(r3.facade[A]));
      }
    }
    if ("area" in r3 && r3.area != null) {
      D.area = {};
      for (let A of Object.keys(r3.area)) {
        let k = A.replace(/\.json|\.geojson/g, "");
        D.area[k] = JSON.parse(e2(r3.area[A]));
      }
    }
    return D;
  } catch (D) {
    throw Lt.error(D), new Error("MVF parsing failed! Probably encountered a bad file.");
  }
}
function r7(r3) {
  if (r3 == null || typeof r3 != "object") return false;
  let t3 = ["connection.json", "manifest.geojson", "floor.geojson" in r3 ? "floor.geojson" : "map.geojson", "node.geojson", "floorstack.json" in r3 ? "floorstack.json" : "mapstack.json" in r3 ? "mapstack.json" : "mapstack.geojson"];
  "styles.json" in r3 && t3.push("styles.json"), "shapes.json" in r3 && t3.push("shapes.json");
  for (let e2 of t3) if (r3[e2] == null || r3[e2][Symbol.toStringTag] !== "Uint8Array") return false;
  return true;
}
async function ku(r3) {
  return new Promise(async (t3, e2) => {
    try {
      if (r3 == null || typeof r3 != "object") throw new Error("Error parsing data! Unzipping failed.");
      if (r3[Symbol.toStringTag] !== "Uint8Array") throw new Error("Unexpected file type! Unzipping failed.");
      let o = (await import("./browser-JUQDIV75-PXQVLWW5.js")).unzipSync(r3);
      if (!r7(o)) throw new Error("MVF is missing some expect static files. Unzipping failed.");
      let n = {}, s2 = Object.keys(o);
      for (let c2 of s2) {
        if (o[c2].length === 0) continue;
        let l = c2.split("/");
        if (l.length < 0) throw new Error("Encounted a file with no name! Unzipping failed.");
        if (l.length > 2) throw new Error("Encountered unexpected nesting in MVF! Unzipping failed.");
        if (l.length === 1) {
          n[l[0]] = o[c2];
          continue;
        }
        if (l[0] === "image") {
          Lt.warn("MVF unzipping encountered an image. Ignoring as this case has not been implemented.");
          continue;
        } else n[l[0]] == null && (n[l[0]] = {}), n[l[0]][l[1]] = o[c2];
      }
      t3(n);
    } catch (i) {
      e2(i);
    }
  });
}
function bn2() {
  let r3 = "us", t3 = {};
  function e2() {
    return a7(l7(r3), t3);
  }
  return { updateByUserOption(i) {
    var o, n;
    i.environment && (r3 = i.environment), i.baseUri && (t3.baseUri = i.baseUri), i.baseAuthUri && (t3.baseAuthUri = i.baseAuthUri), (o = i.analytics) != null && o.baseUri && (t3.analyticsBaseUri = (n = i.analytics) == null ? void 0 : n.baseUri);
  }, updateTileServerBaseUrl(i) {
    t3.tileServerUri = i;
  }, updateEnvironment(i) {
    r3 = i;
  }, getBaseUri(i) {
    return r3 === "us" && i ? pb.baseUri : e2().baseUri;
  }, getBaseAuthUri(i = false) {
    return r3 === "us" && i ? pb.baseAuthUri : e2().baseAuthUri;
  }, getAnalyticsBaseUri() {
    return e2().analyticsBaseUri;
  }, getTileServerUri() {
    return e2().tileServerUri;
  }, reset() {
    r3 = "us", t3 = {};
  }, __getState: e2 };
}
var fb = Object.freeze({ baseUri: "https://app.mappedin.com/", baseAuthUri: "https://app.mappedin.com/", analyticsBaseUri: "https://api-gateway.mappedin.com/track-analytics/a/", tileServerUri: "https://tiles-cdn.mappedin.com/styles/mappedin/style.json" });
var pb = Object.freeze({ ...fb, baseUri: "https://api-gateway.mappedin.com/", baseAuthUri: "https://auth.mappedin.com/" });
var i7 = Object.freeze({ baseUri: "https://api-gateway.eu.mappedin.com/", baseAuthUri: "https://auth.eu.mappedin.com/", analyticsBaseUri: "https://api-gateway.eu.mappedin.com/track-analytics/a/", tileServerUri: "https://tiles-cdn.eu.mappedin.com/styles/mappedin/style.json" });
var o7 = Object.freeze({ baseUri: "https://api-gateway-staging.mappedin.net/", baseAuthUri: "https://auth-staging.mappedin.net/", analyticsBaseUri: "https://api-gateway-staging.mappedin.net/track-analytics/a/", tileServerUri: "https://tiles-cdn.mappedin.com/styles/mappedin/style.json" });
var n7 = Object.freeze({ baseUri: "https://app-staging.mappedin.net/", baseAuthUri: "https://app-staging.mappedin.net/", analyticsBaseUri: "https://api-gateway-staging.mappedin.net/track-analytics/a/", tileServerUri: "https://tiles-cdn.mappedin.com/styles/mappedin/style.json" });
function a7(r3, t3) {
  return { ...r3, ...t3 };
}
var s7 = { eu: i7, us: fb, "us-staging-enterprise": o7, "us-staging-self-serve": n7 };
function l7(r3) {
  return s7[r3];
}
var Uf = (r3) => {
  var e2, i;
  let t3 = Object.values((i = (e2 = r3["floorstack.json"]) != null ? e2 : r3["mapstack.json"]) != null ? i : {});
  return t3.length === 1 ? [] : t3.filter((o) => o.type !== "Outdoor").map((o) => o.id.replace("fs_", "").replace("ms_", ""));
};
c();
c();
c();
function er(r3) {
  if (!r3) throw new Error("coord is required");
  if (!Array.isArray(r3)) {
    if (r3.type === "Feature" && r3.geometry !== null && r3.geometry.type === "Point") return r3.geometry.coordinates;
    if (r3.type === "Point") return r3.coordinates;
  }
  if (Array.isArray(r3) && r3.length >= 2 && !Array.isArray(r3[0]) && !Array.isArray(r3[1])) return r3;
  throw new Error("coord must be GeoJSON Point or an Array of numbers");
}
function Wt2(r3) {
  if (Array.isArray(r3)) return r3;
  if (r3.type === "Feature") {
    if (r3.geometry !== null) return r3.geometry.coordinates;
  } else if (r3.coordinates) return r3.coordinates;
  throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array");
}
function Ha(r3) {
  return r3.type === "Feature" ? r3.geometry : r3;
}
function mb(r3, t3) {
  return r3.type === "FeatureCollection" ? "FeatureCollection" : r3.type === "GeometryCollection" ? "GeometryCollection" : r3.type === "Feature" && r3.geometry !== null ? r3.geometry.type : r3.type;
}
function c7(r3, t3, e2) {
  e2 === void 0 && (e2 = {});
  for (var i = er(r3), o = Wt2(t3), n = 0; n < o.length - 1; n++) {
    var s2 = false;
    if (e2.ignoreEndVertices && (n === 0 && (s2 = "start"), n === o.length - 2 && (s2 = "end"), n === 0 && n + 1 === o.length - 1 && (s2 = "both")), p7(o[n], o[n + 1], i, s2, typeof e2.epsilon > "u" ? null : e2.epsilon)) return true;
  }
  return false;
}
function p7(r3, t3, e2, i, o) {
  var n = e2[0], s2 = e2[1], c2 = r3[0], l = r3[1], p = t3[0], d = t3[1], f = e2[0] - c2, g = e2[1] - l, v2 = p - c2, b = d - l, C = f * b - g * v2;
  if (o !== null) {
    if (Math.abs(C) > o) return false;
  } else if (C !== 0) return false;
  if (i) {
    if (i === "start") return Math.abs(v2) >= Math.abs(b) ? v2 > 0 ? c2 < n && n <= p : p <= n && n < c2 : b > 0 ? l < s2 && s2 <= d : d <= s2 && s2 < l;
    if (i === "end") return Math.abs(v2) >= Math.abs(b) ? v2 > 0 ? c2 <= n && n < p : p < n && n <= c2 : b > 0 ? l <= s2 && s2 < d : d < s2 && s2 <= l;
    if (i === "both") return Math.abs(v2) >= Math.abs(b) ? v2 > 0 ? c2 < n && n < p : p < n && n < c2 : b > 0 ? l < s2 && s2 < d : d < s2 && s2 < l;
  } else return Math.abs(v2) >= Math.abs(b) ? v2 > 0 ? c2 <= n && n <= p : p <= n && n <= c2 : b > 0 ? l <= s2 && s2 <= d : d <= s2 && s2 <= l;
  return false;
}
var gb = c7;
c();
function u7(r3, t3) {
  t3 === void 0 && (t3 = {});
  var e2 = tl2(r3), i = (e2[0] + e2[2]) / 2, o = (e2[1] + e2[3]) / 2;
  return xd([i, o], t3.properties, t3);
}
var Bu = u7;
c();
c();
function d7(r3, t3, e2) {
  e2 === void 0 && (e2 = {});
  var i = er(r3), o = er(t3), n = Om(o[1] - i[1]), s2 = Om(o[0] - i[0]), c2 = Om(i[1]), l = Om(o[1]), p = Math.pow(Math.sin(n / 2), 2) + Math.pow(Math.sin(s2 / 2), 2) * Math.cos(c2) * Math.cos(l);
  return Dm(2 * Math.atan2(Math.sqrt(p), Math.sqrt(1 - p)), e2.units);
}
var fo = d7;
function _u(r3, t3) {
  return t3 === void 0 && (t3 = {}), Gm(r3, function(e2, i) {
    var o = i.geometry.coordinates;
    return e2 + fo(o[0], o[1], t3);
  }, 0);
}
c();
c();
c();
function Ru(r3, t3, e2) {
  if (e2 === void 0 && (e2 = {}), e2.final === true) return h7(r3, t3);
  var i = er(r3), o = er(t3), n = Om(i[0]), s2 = Om(o[0]), c2 = Om(i[1]), l = Om(o[1]), p = Math.sin(s2 - n) * Math.cos(l), d = Math.cos(c2) * Math.sin(l) - Math.sin(c2) * Math.cos(l) * Math.cos(s2 - n);
  return Am(Math.atan2(p, d));
}
function h7(r3, t3) {
  var e2 = Ru(t3, r3);
  return e2 = (e2 + 180) % 360, e2;
}
c();
function vn(r3, t3, e2, i) {
  i === void 0 && (i = {});
  var o = er(r3), n = Om(o[0]), s2 = Om(o[1]), c2 = Om(e2), l = Em(t3, i.units), p = Math.asin(Math.sin(s2) * Math.cos(l) + Math.cos(s2) * Math.sin(l) * Math.cos(c2)), d = n + Math.atan2(Math.sin(c2) * Math.sin(l) * Math.cos(s2), Math.cos(l) - Math.sin(s2) * Math.sin(p)), f = Am(d), g = Am(p);
  return xd([f, g], i.properties);
}
c();
c();
function f7(r3) {
  if (!r3) throw new Error("geojson is required");
  var t3 = [];
  return Td(r3, function(e2) {
    m7(e2, t3);
  }), wm(t3);
}
function m7(r3, t3) {
  var e2 = [], i = r3.geometry;
  if (i !== null) {
    switch (i.type) {
      case "Polygon":
        e2 = Wt2(i);
        break;
      case "LineString":
        e2 = [Wt2(i)];
    }
    e2.forEach(function(o) {
      var n = g7(o, r3.properties);
      n.forEach(function(s2) {
        s2.id = t3.length, t3.push(s2);
      });
    });
  }
}
function g7(r3, t3) {
  var e2 = [];
  return r3.reduce(function(i, o) {
    var n = el([i, o], t3);
    return n.bbox = y7(i, o), e2.push(n), o;
  }), e2;
}
function y7(r3, t3) {
  var e2 = r3[0], i = r3[1], o = t3[0], n = t3[1], s2 = e2 < o ? e2 : o, c2 = i < n ? i : n, l = e2 > o ? e2 : o, p = i > n ? i : n;
  return [s2, c2, l, p];
}
var Hf = f7;
var M4 = s(I4(), 1);
function VM(r3, t3) {
  var e2 = {}, i = [];
  if (r3.type === "LineString" && (r3 = tr(r3)), t3.type === "LineString" && (t3 = tr(t3)), r3.type === "Feature" && t3.type === "Feature" && r3.geometry !== null && t3.geometry !== null && r3.geometry.type === "LineString" && t3.geometry.type === "LineString" && r3.geometry.coordinates.length === 2 && t3.geometry.coordinates.length === 2) {
    var o = P4(r3, t3);
    return o && i.push(o), wm(i);
  }
  var n = (0, M4.default)();
  return n.load(Hf(t3)), Lm(Hf(r3), function(s2) {
    Lm(n.search(s2), function(c2) {
      var l = P4(s2, c2);
      if (l) {
        var p = Wt2(l).join(",");
        e2[p] || (e2[p] = true, i.push(l));
      }
    });
  }), wm(i);
}
function P4(r3, t3) {
  var e2 = Wt2(r3), i = Wt2(t3);
  if (e2.length !== 2) throw new Error("<intersects> line1 must only contain 2 coordinates");
  if (i.length !== 2) throw new Error("<intersects> line2 must only contain 2 coordinates");
  var o = e2[0][0], n = e2[0][1], s2 = e2[1][0], c2 = e2[1][1], l = i[0][0], p = i[0][1], d = i[1][0], f = i[1][1], g = (f - p) * (s2 - o) - (d - l) * (c2 - n), v2 = (d - l) * (n - p) - (f - p) * (o - l), b = (s2 - o) * (n - p) - (c2 - n) * (o - l);
  if (g === 0) return null;
  var C = v2 / g, y = b / g;
  if (C >= 0 && C <= 1 && y >= 0 && y <= 1) {
    var S = o + C * (s2 - o), T = n + C * (c2 - n);
    return xd([S, T]);
  }
  return null;
}
var ts = VM;
function jM(r3, t3, e2) {
  e2 === void 0 && (e2 = {});
  var i = xd([1 / 0, 1 / 0], { dist: 1 / 0 }), o = 0;
  return Td(r3, function(n) {
    for (var s2 = Wt2(n), c2 = 0; c2 < s2.length - 1; c2++) {
      var l = xd(s2[c2]);
      l.properties.dist = fo(t3, l, e2);
      var p = xd(s2[c2 + 1]);
      p.properties.dist = fo(t3, p, e2);
      var d = fo(l, p, e2), f = Math.max(l.properties.dist, p.properties.dist), g = Ru(l, p), v2 = vn(t3, f, g + 90, e2), b = vn(t3, f, g - 90, e2), C = ts(el([v2.geometry.coordinates, b.geometry.coordinates]), el([l.geometry.coordinates, p.geometry.coordinates])), y = null;
      C.features.length > 0 && (y = C.features[0], y.properties.dist = fo(t3, y, e2), y.properties.location = o + fo(l, y, e2)), l.properties.dist < i.properties.dist && (i = l, i.properties.index = c2, i.properties.location = o), p.properties.dist < i.properties.dist && (i = p, i.properties.index = c2 + 1, i.properties.location = o + d), y && y.properties.dist < i.properties.dist && (i = y, i.properties.index = c2), o += d;
    }
  }), i;
}
var Nl = jM;
function UM(r3, t3, e2) {
  var i = Wt2(e2);
  if (mb(e2) !== "LineString") throw new Error("line must be a LineString");
  var o = Nl(e2, r3), n = Nl(e2, t3), s2;
  o.properties.index <= n.properties.index ? s2 = [o, n] : s2 = [n, o];
  for (var c2 = [s2[0].geometry.coordinates], l = s2[0].properties.index + 1; l < s2[1].properties.index + 1; l++) c2.push(i[l]);
  return c2.push(s2[1].geometry.coordinates), el(c2, e2.properties);
}
var Og2 = UM;
var HM = 1e-7;
function Lg(r3) {
  return { type: "Point", coordinates: r3 };
}
function WM(r3, t3) {
  let { coordinates: e2 } = t3.geometry, { coordinates: i } = r3.geometry, o = e2.map((n) => Nl(r3, Lg(n)));
  return i.reduce((n, s2) => {
    let c2 = Og2(Lg(s2), o[0], r3), l = Og2(Lg(s2), o[1], r3), p = _u(c2) < _u(l) ? c2 : l;
    return p.properties = { ...r3.properties, entrances: [] }, n.concat([p]);
  }, []);
}
function Ag(r3, t3) {
  return t3.reduce((e2, i) => {
    let o = { epsilon: HM }, n = e2.obstructions.findIndex((c2) => gb(Bu(i), c2, o)), s2 = e2.obstructions[n];
    if (s2) {
      let [c2, l] = WM(s2, i);
      e2.entrances.push(i), e2.obstructions.splice(n, 1, c2, l);
    }
    return e2;
  }, { obstructions: [r3], entrances: [] });
}
c();
c();
c();
var Gl = class Gl2 {
  constructor(t3, e2, i) {
    t(this, "__type", Gl2.__type);
    t(this, "id", tt());
    t(this, "latitude");
    t(this, "longitude");
    t(this, "floorId");
    t(this, "verticalOffset");
    var o;
    if (typeof t3 == "object") this.latitude = t3.latitude, this.longitude = t3.longitude, this.floorId = t3.floorId, this.verticalOffset = (o = t3.verticalOffset) != null ? o : 0;
    else {
      if (e2 == null) throw new Error("Coordinate longitude is required.");
      this.latitude = t3, this.longitude = e2, this.floorId = i, this.verticalOffset = 0;
    }
  }
  static is(t3) {
    return t3.__type === Gl2.__type;
  }
  get anchorTarget() {
    return this;
  }
  get focusTarget() {
    return this;
  }
  isEqual(t3) {
    return this.latitude === t3.latitude && this.longitude === t3.longitude && this.floorId === t3.floorId;
  }
  toJSON() {
    return { latitude: this.latitude, longitude: this.longitude, floor: this.floorId, verticalOffset: this.verticalOffset };
  }
  destroy() {
  }
};
t(Gl, "__type", "coordinate");
var Fg = Gl;
var K2 = Fg;
c();
var ze2 = class {
  constructor(t3) {
    t(this, "id");
    this.id = t3;
  }
};
var $r;
var It2;
var In;
var So;
var Vl = class Vl2 extends ze2 {
  constructor(e2, i) {
    super(i.mvfData.properties.id);
    t(this, "__type", Vl2.__type);
    v(this, $r);
    v(this, It2, {});
    v(this, In);
    v(this, So);
    w(this, $r, e2), w(this, In, i.floorId), w(this, So, i.mvfData);
  }
  static is(e2) {
    return e2.__type === Vl2.__type;
  }
  get locations() {
    return u(this, It2).locations ? u(this, It2).locations : (u(this, It2).locations = (u(this, $r).locationIdsByNodeId[this.id] || []).map((e2) => u(this, $r).getById("enterprise-location", e2)).filter(Boolean), u(this, It2).locations);
  }
  get space() {
    var e2;
    return u(this, $r).getById("space", (e2 = u(this, $r).spaceIdsByNodeId[this.id]) == null ? void 0 : e2[0]);
  }
  get floor() {
    let e2 = u(this, $r).getById("floor", u(this, In));
    if (e2 == null) throw new Error("Floor ".concat(u(this, In), " not found!"));
    return e2;
  }
  get coordinate() {
    if (u(this, It2).coordinate == null) {
      let [e2, i] = u(this, So).geometry.coordinates;
      u(this, It2).coordinate = new K2(i, e2, u(this, In));
    }
    return u(this, It2).coordinate;
  }
  get externalId() {
    var e2;
    return (e2 = u(this, So).properties.externalId) != null ? e2 : "";
  }
  get neighbors() {
    if (u(this, It2).neighbours == null) {
      let e2 = u(this, So).properties.neighbors.map((i) => {
        let o = u(this, $r).getById("node", i.id);
        if (o == null) throw new Error("Node ".concat(i.id, " not found!"));
        return o;
      });
      u(this, It2).neighbours = e2;
    }
    return u(this, It2).neighbours;
  }
  get geoJSON() {
    return { ...u(this, So), properties: null };
  }
  get focusTarget() {
    return this.coordinate;
  }
  get anchorTarget() {
    return this.coordinate;
  }
  toJSON() {
    return { id: this.id, floor: this.floor.id, coordinate: this.coordinate.toJSON(), neighbors: this.neighbors.map((e2) => e2.id) };
  }
  destroy() {
    for (let e2 of Object.keys(u(this, It2))) delete u(this, It2)[e2];
  }
};
$r = /* @__PURE__ */ new WeakMap(), It2 = /* @__PURE__ */ new WeakMap(), In = /* @__PURE__ */ new WeakMap(), So = /* @__PURE__ */ new WeakMap(), t(Vl, "__type", "node");
var kg = Vl;
var xo = kg;
c();
c();
c();
c();
var jl;
var Di;
var kd = class kd2 extends ze2 {
  constructor(e2) {
    super(String(tt()));
    v(this, jl, {});
    v(this, Di);
    w(this, Di, e2.mvfData);
  }
  static is(e2) {
    return e2.__type === kd2.__type;
  }
  get url() {
    return u(this, Di).url;
  }
  get name() {
    if ("displayName" in u(this, Di)) return u(this, Di).displayName;
    if ("label" in u(this, Di)) return u(this, Di).label;
  }
  toJSON() {
    return { id: this.id, url: this.url, name: this.name };
  }
  destroy() {
    for (let e2 of globalThis.Object.keys(u(this, jl))) delete u(this, jl)[e2];
  }
};
jl = /* @__PURE__ */ new WeakMap(), Di = /* @__PURE__ */ new WeakMap(), t(kd, "__type", "hyperlink");
var Bg = kd;
var Pn = Bg;
c();
c();
function Ul(r3) {
  return typeof r3 == "string" ? r3 : r3.id;
}
function Rg(r3) {
  return Array.isArray(r3) && Number.isFinite(r3[0]) && Number.isFinite(r3[1]);
}
var _g = 8;
var Jr2 = (r3) => typeof r3 == "number" ? r3.toFixed(_g) : Rg(r3) ? r3[1].toFixed(_g) + "-" + r3[0].toFixed(_g) : r3.map((t3) => Jr2(t3)).join("-");
var XM = (r3) => {
  let t3 = /^https:\/\/cdn\.mappedin\.com\/[^/]+\/[^/]+\.[a-zA-Z0-9]+$/, e2 = /^https:\/\/cdn-staging\.mappedin\.net\/[^/]+\/[^/]+\.[a-zA-Z0-9]+$/;
  return t3.test(r3) || e2.test(r3);
};
var Bd = (r3) => {
  if (!XM(r3)) return null;
  let t3 = "";
  r3.startsWith("https://") ? (t3 = "https://", r3 = r3.slice(8)) : r3.startsWith("http://") && (t3 = "http://", r3 = r3.slice(7));
  let [e2, i, o] = r3.split("/");
  return { origin: t3 + e2, mapId: i, fileName: o };
};
var Hl;
var Io;
var rs;
var _d = class _d2 extends ze2 {
  constructor(e2) {
    super(String(tt()));
    v(this, Hl, {});
    v(this, Io);
    v(this, rs);
    w(this, Io, e2.mvfData), w(this, rs, e2.mapData);
  }
  static is(e2) {
    return e2.__type === _d2.__type;
  }
  get url() {
    let e2 = u(this, Io).url;
    if (u(this, rs).tokenManager == null) return e2;
    let i = Bd(u(this, Io).url);
    if (i == null) return e2;
    let o = i.mapId;
    try {
      let n = u(this, rs).tokenManager.getSasToken(o).token;
      if (n == null || n === "") throw new Error("SAS token empty!");
      return "".concat(e2, "?").concat(n);
    } catch (n) {
      return Lt.error("Error getting SAS token for image", { error: n, url: e2 }), e2;
    }
  }
  get name() {
    return u(this, Io).altText;
  }
  get altText() {
    return u(this, Io).altText;
  }
  toJSON() {
    return { id: this.id, url: this.url, name: this.name };
  }
  destroy() {
    for (let e2 of globalThis.Object.keys(u(this, Hl))) delete u(this, Hl)[e2];
  }
};
Hl = /* @__PURE__ */ new WeakMap(), Io = /* @__PURE__ */ new WeakMap(), rs = /* @__PURE__ */ new WeakMap(), t(_d, "__type", "image");
var Ng = _d;
var Mn = Ng;
c();
var Tn;
var Cr2 = class {
  constructor(t3, e2) {
    t(this, "id");
    v(this, Tn);
    this.id = t3;
  }
  get geoJSONBoundingBox() {
    return u(this, Tn) ? u(this, Tn) : "bbox" in this.geoJSON.geometry && this.geoJSON.geometry.bbox ? this.geoJSON.geometry.bbox : (w(this, Tn, tl2(this.geoJSON)), u(this, Tn));
  }
  get geoJSON() {
    return { properties: null, type: "Feature", geometry: { type: "Polygon", coordinates: [[]] } };
  }
};
Tn = /* @__PURE__ */ new WeakMap();
var is;
var Sr;
var Ei;
var st = class extends Cr2 {
  constructor(e2, i) {
    super(i.properties.id, e2);
    v(this, is);
    v(this, Sr);
    v(this, Ei, {});
    w(this, is, e2), w(this, Sr, i);
  }
  get externalId() {
    var e2;
    return (e2 = u(this, Sr).properties.externalId) != null ? e2 : "";
  }
  get name() {
    var i, o, n, s2, c2;
    let e2 = "";
    return "details" in u(this, Sr).properties || (e2 = (i = u(this, Sr).properties.externalId) != null ? i : ""), e2 === "" && (e2 = (n = (o = u(this, Sr).properties.details) == null ? void 0 : o.name) != null ? n : ""), e2 === "" && (e2 = (c2 = (s2 = this.locationProfiles.find((l) => l.name && l.name.length > 0)) == null ? void 0 : s2.name) != null ? c2 : ""), e2;
  }
  get description() {
    var i, o, n, s2;
    let e2 = (o = (i = u(this, Sr).properties.details) == null ? void 0 : i.description) != null ? o : "";
    return e2 === "" && (e2 = (s2 = (n = this.locationProfiles.find((c2) => c2.description && c2.description.length > 0)) == null ? void 0 : n.description) != null ? s2 : ""), e2;
  }
  get images() {
    var i, o, n, s2, c2;
    if (u(this, Ei).images != null) return u(this, Ei).images;
    let e2 = (n = (o = (i = u(this, Sr).properties.details) == null ? void 0 : i.images) == null ? void 0 : o.map((l) => new Mn({ mvfData: l, mapData: u(this, is) }))) != null ? n : [];
    return (e2 == null || e2.length === 0) && (e2 = (c2 = (s2 = this.locationProfiles.find((l) => l.images.length > 0)) == null ? void 0 : s2.images) != null ? c2 : []), u(this, Ei).images = e2, e2;
  }
  get links() {
    var i, o, n, s2, c2;
    if (u(this, Ei).links != null) return u(this, Ei).links;
    let e2 = (n = (o = (i = u(this, Sr).properties.details) == null ? void 0 : i.links) == null ? void 0 : o.map((l) => new Pn({ mvfData: l }))) != null ? n : [];
    return (e2 == null || e2.length === 0) && (e2 = (c2 = (s2 = this.locationProfiles.find((l) => l.links.length > 0)) == null ? void 0 : s2.links) != null ? c2 : []), u(this, Ei).links = e2, e2;
  }
  get locationProfiles() {
    var e2;
    return (e2 = u(this, is).locationProfilesByAttachedFeatureId[this.id]) != null ? e2 : [];
  }
};
is = /* @__PURE__ */ new WeakMap(), Sr = /* @__PURE__ */ new WeakMap(), Ei = /* @__PURE__ */ new WeakMap();
var Xl2;
var wn;
var os;
var ns;
var Wl = class Wl2 extends st {
  constructor(e2, i) {
    super(e2, i.mvfData);
    t(this, "__type", Wl2.__type);
    v(this, Xl2);
    v(this, wn);
    v(this, os, {});
    v(this, ns);
    w(this, Xl2, e2), w(this, wn, i.floorId), w(this, ns, i.mvfData);
  }
  static is(e2) {
    return e2.__type === Wl2.__type;
  }
  get center() {
    var e2;
    if (u(this, os).center == null) {
      let [i, o] = (e2 = u(this, ns).properties.center) != null ? e2 : [0, 0];
      u(this, os).center = new K2(o, i, u(this, wn));
    }
    return u(this, os).center;
  }
  get floor() {
    let e2 = u(this, Xl2).getById("floor", u(this, wn));
    if (e2 == null) throw new Error("Floor ".concat(u(this, wn), " not found!"));
    return e2;
  }
  get geoJSON() {
    return { ...u(this, ns), properties: null };
  }
  get focusTarget() {
    return this;
  }
  get anchorTarget() {
    return this.center;
  }
  toJSON() {
    return { id: this.id, name: this.name, floor: this.floor.id };
  }
  destroy() {
  }
};
Xl2 = /* @__PURE__ */ new WeakMap(), wn = /* @__PURE__ */ new WeakMap(), os = /* @__PURE__ */ new WeakMap(), ns = /* @__PURE__ */ new WeakMap(), t(Wl, "__type", "area");
var Gg = Wl;
var Po = Gg;
c();
var Dn;
var Oi;
var En;
var as;
var Yl = class Yl2 extends st {
  constructor(e2, i) {
    super(e2, i.mvfData);
    t(this, "__type", Yl2.__type);
    v(this, Dn);
    v(this, Oi);
    v(this, En);
    v(this, as);
    w(this, Oi, {}), w(this, as, i.mvfData), w(this, Dn, e2), w(this, En, i.floorId);
  }
  static is(e2) {
    return e2.__type === Yl2.__type;
  }
  get floor() {
    let e2 = u(this, Dn).getById("floor", u(this, En));
    if (e2 == null) throw new Error("Floor ".concat(u(this, En), " not found!"));
    return e2;
  }
  get center() {
    if (u(this, Oi).center == null) {
      let [[e2, i], [o, n]] = u(this, as).geometry.coordinates, s2 = (e2 + o) / 2, c2 = (i + n) / 2;
      u(this, Oi).center = new K2(c2, s2, u(this, En));
    }
    return u(this, Oi).center;
  }
  get isExterior() {
    var o;
    let e2 = u(this, Dn).obstructionIdByEntranceId[this.id], i = u(this, Dn).getMVFFeatureById("obstruction", e2);
    return (o = i == null ? void 0 : i.properties.footprintComponent) != null ? o : false;
  }
  get geoJSON() {
    return { ...u(this, as), properties: null };
  }
  get focusTarget() {
    return this.center;
  }
  get anchorTarget() {
    return this.center;
  }
  toJSON() {
    return { id: this.id, name: this.name, floor: this.floor.id, center: this.center.toJSON() };
  }
  destroy() {
    for (let e2 of Object.keys(u(this, Oi))) delete u(this, Oi)[e2];
  }
};
Dn = /* @__PURE__ */ new WeakMap(), Oi = /* @__PURE__ */ new WeakMap(), En = /* @__PURE__ */ new WeakMap(), as = /* @__PURE__ */ new WeakMap(), t(Yl, "__type", "door");
var Vg = Yl;
var Qr = Vg;
c();
var Mo;
var On;
var Yt;
var Kr;
var Zl = class Zl2 extends st {
  constructor(e2, i) {
    super(e2, i.mvfData);
    t(this, "__type", Zl2.__type);
    v(this, Mo);
    v(this, On);
    v(this, Yt, {});
    v(this, Kr);
    w(this, Mo, e2), w(this, On, i.floorId), w(this, Kr, i.mvfData);
  }
  getMvfData() {
    return u(this, Kr);
  }
  static is(e2) {
    return e2.__type === Zl2.__type;
  }
  get type() {
    return ZM(u(this, Kr).properties.kind);
  }
  get locations() {
    if (u(this, Yt).locations) return u(this, Yt).locations;
    u(this, Yt).locations = [];
    let e2 = u(this, Mo).mvfLocationsBySpaceId[u(this, Kr).properties.id];
    if ((e2 == null ? void 0 : e2.length) > 0) for (let i of e2) {
      let o = u(this, Mo).getById("enterprise-location", i.id);
      o && u(this, Yt).locations.push(o);
    }
    return u(this, Yt).locations;
  }
  get floor() {
    let e2 = u(this, Mo).getById("floor", u(this, On));
    if (e2 == null) throw new Error("Floor ".concat(u(this, On), " not found!"));
    return e2;
  }
  get doors() {
    return u(this, Kr).properties.destinationNodes.reduce((e2, i) => {
      let o = u(this, Mo).doorsByNodeId[i];
      return o && e2.push(o), e2;
    }, []);
  }
  get center() {
    var e2;
    if (u(this, Yt).center == null) {
      let [i, o] = (e2 = u(this, Kr).properties.center) != null ? e2 : [0, 0];
      u(this, Yt).center = new K2(o, i, u(this, On));
    }
    return u(this, Yt).center;
  }
  get geoJSON() {
    return { ...u(this, Kr), properties: null };
  }
  get focusTarget() {
    return this.geoJSON.geometry.type === "Polygon" ? this : this.center;
  }
  get anchorTarget() {
    return this.center;
  }
  toJSON() {
    return { id: this.id, name: this.name, type: this.type, floor: this.floor.id, center: this.center.toJSON() };
  }
  destroy() {
    for (let e2 of Object.keys(u(this, Yt))) delete u(this, Yt)[e2];
  }
};
Mo = /* @__PURE__ */ new WeakMap(), On = /* @__PURE__ */ new WeakMap(), Yt = /* @__PURE__ */ new WeakMap(), Kr = /* @__PURE__ */ new WeakMap(), t(Zl, "__type", "space");
var jg = Zl;
var YM = ["room", "hallway", "exterior", "void", "connection.stairs", "connection.elevator", "poi"];
function ZM(r3) {
  if (r3 == null || r3 === "default") return "room";
  let t3 = r3.toLowerCase();
  return YM.includes(t3) ? t3 : "room";
}
var He = jg;
c();
var rr2;
var Te2;
var or;
var ql;
var Hg;
var zl = class zl2 extends Cr2 {
  constructor(e2, i) {
    super(i.mvfData.properties.id, e2);
    v(this, ql);
    t(this, "__type", zl2.__type);
    v(this, rr2);
    v(this, Te2, {});
    v(this, or);
    w(this, rr2, e2), w(this, or, i.mvfData);
  }
  static is(e2) {
    return e2.__type === zl2.__type;
  }
  get focusTarget() {
    return this;
  }
  get name() {
    var e2, i;
    return "name" in u(this, or).properties ? (i = x(this, ql, Hg).call(this, "name")) != null ? i : "" : (e2 = u(this, or).properties.externalId) != null ? e2 : "";
  }
  get shortName() {
    var e2, i;
    return "shortName" in u(this, or).properties ? (i = x(this, ql, Hg).call(this, "shortName")) != null ? i : "" : (e2 = u(this, or).properties.externalId) != null ? e2 : "";
  }
  get externalId() {
    var e2;
    return (e2 = u(this, or).properties.externalId) != null ? e2 : "";
  }
  get elevation() {
    return u(this, or).properties.elevation;
  }
  get spaces() {
    if (u(this, Te2).spaces == null) {
      let e2 = u(this, rr2).spaces.filter((i) => i.floor.id === this.id);
      u(this, Te2).spaces = e2;
    }
    return u(this, Te2).spaces;
  }
  get geoJSON() {
    var e2;
    return { type: "Feature", properties: null, geometry: (e2 = u(this, or).geometry) != null ? e2 : { type: "Polygon", coordinates: [] } };
  }
  get objects() {
    if (u(this, Te2).objects == null) {
      let e2 = u(this, rr2).objects.filter((i) => i.floor.id === this.id);
      u(this, Te2).objects = e2;
    }
    return u(this, Te2).objects;
  }
  get connections() {
    if (u(this, Te2).connections == null) {
      let e2 = u(this, rr2).connections.filter((i) => i.floors.includes(this));
      u(this, Te2).connections = e2;
    }
    return u(this, Te2).connections;
  }
  get doors() {
    if (u(this, Te2).doors == null) {
      let e2 = u(this, rr2).doors.filter((i) => i.floor.id === this.id);
      u(this, Te2).doors = e2;
    }
    return u(this, Te2).doors;
  }
  get annotations() {
    if (u(this, Te2).annotations == null) {
      let e2 = u(this, rr2).annotations.filter((i) => i.floor.id === this.id);
      u(this, Te2).annotations = e2;
    }
    return u(this, Te2).annotations;
  }
  get pois() {
    if (u(this, Te2).pois == null) {
      let e2 = u(this, rr2).pointsOfInterest.filter((i) => i.floor.id === this.id);
      u(this, Te2).pois = e2;
    }
    return u(this, Te2).pois;
  }
  get floorStack() {
    if (u(this, Te2).floorStack == null) {
      let e2 = u(this, rr2).floorStacks.find((i) => i.floors.includes(this));
      u(this, Te2).floorStack = e2;
    }
    return u(this, Te2).floorStack;
  }
  toJSON() {
    return { id: this.id, name: this.name, shortName: this.shortName, elevation: this.elevation, spaces: this.spaces.map((e2) => e2.id), objects: this.objects.map((e2) => e2.id), connections: this.connections.map((e2) => e2.id), doors: this.doors.map((e2) => e2.id), annotations: this.annotations.map((e2) => e2.id), pois: this.pois.map((e2) => e2.id) };
  }
  destroy() {
    for (let e2 of globalThis.Object.keys(u(this, Te2))) delete u(this, Te2)[e2];
  }
};
rr2 = /* @__PURE__ */ new WeakMap(), Te2 = /* @__PURE__ */ new WeakMap(), or = /* @__PURE__ */ new WeakMap(), ql = /* @__PURE__ */ new WeakSet(), Hg = function(e2) {
  let i = u(this, or).properties[e2];
  return u(this, rr2).getPropTranslation(this.__type, e2, this.id, i);
}, t(zl, "__type", "floor");
var Ug = zl;
var Zt = Ug;
c();
c();
c();
function $l(r3) {
  let t3;
  if (He.is(r3) || Qr.is(r3) || zt.is(r3) || Po.is(r3) || xr.is(r3)) t3 = r3.center;
  else if (To.is(r3) || wo.is(r3)) t3 = r3.coordinate;
  else if (K2.is(r3)) t3 = r3;
  else if (xo.is(r3)) t3 = r3.coordinate;
  else if (Li.is(r3)) t3 = r3.coordinates[0];
  else return;
  return t3;
}
c();
c();
var Ln = { auto: true, debug: false, pitch: 45, bearing: 0, antialiasing: { enabled: true }, shadingAndOutlines: true, outdoorView: { layersHiddenByGeometry: ["building", "building-top"] }, imagePlacementOptions: { mode: "default" }, flipImagesToFaceCamera: true, multiFloorView: { enabled: false, floorHeight: 10 } };
var ei = "ExteriorWalls";
var Do = "Walls";
var T4 = 0;
var ss = "InteriorDoors";
var ls = "ExteriorDoors";
var we = "GeometryLayer";
var Ai = "LabelsLayer";
var ti = "MarkersLayer";
var cs = "FootprintLayer";
var ps = "OcclusionLayer";
var w4 = "ImagesLayer";
var An = "FacadesLayer";
var D4 = ["https://mappedin.auth0.com", "https://mappedin-staging.auth0.com"];
var zM = { orange: "#F26336", teal: "#057685", lightTeal: "#5DC7D0" };
function Wg(r3) {
  var t3, e2;
  (t3 = r3.outdoorView) != null && t3.enabled && !((e2 = r3.outdoorView) != null && e2.token) && Lt.error("Enable outdoor view requires a token. Provide token in `options.outdoorView.token`");
}
function Xg(r3, t3) {
  var o, n, s2, c2, l, p;
  let e2 = ((o = r3 == null ? void 0 : r3.outdoorView) == null ? void 0 : o.token) || t3.outdoorViewToken, i = { ...Ln, ...r3, outdoorView: { enabled: ((n = r3 == null ? void 0 : r3.outdoorView) == null ? void 0 : n.enabled) === void 0 ? !!e2 : (s2 = r3 == null ? void 0 : r3.outdoorView) == null ? void 0 : s2.enabled, layersHiddenByGeometry: (c2 = Ln.outdoorView) == null ? void 0 : c2.layersHiddenByGeometry, ...r3 == null ? void 0 : r3.outdoorView }, bearing: (p = (l = r3 == null ? void 0 : r3.bearing) != null ? l : t3.naturalBearing) != null ? p : 0, imagePlacementOptions: { ...Ln.imagePlacementOptions, ...r3 == null ? void 0 : r3.imagePlacementOptions }, multiFloorView: { ...Ln.multiFloorView, ...r3 == null ? void 0 : r3.multiFloorView } };
  return e2 && i.outdoorView && (i.outdoorView.token = e2), i;
}
function E4(r3) {
  let t3 = { remove_watermark: false };
  if (r3) try {
    let e2 = Np(r3);
    Object.assign(t3, e2.capabilities);
  } catch (e2) {
    Lt.error("Error decoding capabilities from token", e2);
  }
  return t3;
}
var Eo;
var nr;
var Fi;
var Jl2 = class Jl3 extends st {
  constructor(e2, i) {
    let o = Object.values(i.mvfDataByFloorId)[0];
    super(e2, o);
    t(this, "__type", Jl3.__type);
    v(this, Eo);
    v(this, nr);
    v(this, Fi);
    w(this, nr, {}), w(this, Eo, e2), w(this, Fi, i.mvfDataByFloorId);
  }
  static is(e2) {
    return e2.__type === Jl3.__type;
  }
  get accessible() {
    var e2;
    return (e2 = Object.values(u(this, Fi))[0].properties.accessible) != null ? e2 : false;
  }
  get type() {
    var e2, i;
    return (i = (e2 = Object.values(u(this, Fi))[0].properties.kind) == null ? void 0 : e2.split(".")[1]) != null ? i : "unknown";
  }
  get extra() {
    return Object.values(u(this, Fi))[0].properties.extra;
  }
  get coordinates() {
    return u(this, nr).coordinates == null && (u(this, nr).coordinates = Object.entries(u(this, Fi)).map(([e2, i]) => new K2(i.geometry.coordinates[1], i.geometry.coordinates[0], e2))), u(this, nr).coordinates;
  }
  get nodes() {
    return Object.values(u(this, Fi))[0].properties.nodes.map((e2) => u(this, Eo).getById("node", e2));
  }
  get floors() {
    return this.coordinates.map((e2) => e2.floorId ? u(this, Eo).getById("floor", e2.floorId) : void 0).filter(hl);
  }
  get locationProfiles() {
    var i, o, n, s2, c2;
    if (u(this, nr).locationProfiles != null) return u(this, nr).locationProfiles;
    let e2 = super.locationProfiles;
    if (e2 == null || e2.length === 0) {
      let l = [(o = (i = this.coordinates[0]) == null ? void 0 : i.longitude) != null ? o : 0, (s2 = (n = this.coordinates[0]) == null ? void 0 : n.latitude) != null ? s2 : 0], p = Jr2(l), d = (c2 = u(this, Eo).mvfConnectionIdsByLatLon[p]) != null ? c2 : [];
      for (let f of d) {
        let g = u(this, Eo).locationProfilesByAttachedFeatureId[f];
        if (g != null) {
          e2 = g;
          break;
        }
      }
    }
    return u(this, nr).locationProfiles = e2 != null ? e2 : [], e2;
  }
  get focusTarget() {
    return this.coordinates;
  }
  toJSON() {
    return { id: this.id, name: this.name, type: this.type, externalId: this.externalId, coordinates: this.coordinates.map((e2) => e2.toJSON()), floors: this.floors.map((e2) => e2.id), extra: this.extra };
  }
  destroy() {
    for (let e2 of Object.keys(u(this, nr))) delete u(this, nr)[e2];
  }
};
Eo = /* @__PURE__ */ new WeakMap(), nr = /* @__PURE__ */ new WeakMap(), Fi = /* @__PURE__ */ new WeakMap(), t(Jl2, "__type", "connection");
var Yg = Jl2;
var Fn = Yg;
c();
var Kl;
var kn;
var Oo;
var Bn;
var Ql = class Ql2 extends st {
  constructor(e2, i) {
    super(e2, i.mvfData);
    t(this, "__type", Ql2.__type);
    v(this, Kl);
    v(this, kn);
    v(this, Oo, {});
    v(this, Bn);
    w(this, Kl, e2), w(this, kn, i.floorId), w(this, Bn, i.mvfData);
  }
  static is(e2) {
    return e2.__type === Ql2.__type;
  }
  get type() {
    let e2 = u(this, Bn).properties.kind;
    return e2 == null && (e2 = "object"), e2 === "Desks" && (e2 = "desk"), e2.toLowerCase();
  }
  get floor() {
    let e2 = u(this, Kl).getById("floor", u(this, kn));
    if (e2 == null) throw new Error("Floor ".concat(u(this, kn), " not found!"));
    return e2;
  }
  get center() {
    var e2;
    if (u(this, Oo).center == null) {
      let [i, o] = (e2 = u(this, Bn).properties.center) != null ? e2 : [0, 0];
      u(this, Oo).center = new K2(o, i, u(this, kn));
    }
    return u(this, Oo).center;
  }
  get geoJSON() {
    return { ...u(this, Bn), properties: null };
  }
  get anchorTarget() {
    return this.center;
  }
  get focusTarget() {
    return this.geoJSON.geometry.type === "Polygon" ? this : this.center;
  }
  toJSON() {
    return { id: this.id, name: this.name, type: this.type, floor: this.floor.id, center: this.center.toJSON() };
  }
  destroy() {
    for (let e2 of globalThis.Object.keys(u(this, Oo))) u(this, Oo)[e2] = null;
  }
};
Kl = /* @__PURE__ */ new WeakMap(), kn = /* @__PURE__ */ new WeakMap(), Oo = /* @__PURE__ */ new WeakMap(), Bn = /* @__PURE__ */ new WeakMap(), t(Ql, "__type", "object");
var Zg = Ql;
var zt = Zg;
c();
var tc;
var _n2;
var Lo2;
var us;
var ec = class ec2 extends st {
  constructor(e2, i) {
    super(e2, i.mvfData);
    t(this, "__type", ec2.__type);
    v(this, tc);
    v(this, _n2);
    v(this, Lo2, {});
    v(this, us);
    w(this, tc, e2), w(this, us, i.mvfData), w(this, _n2, i.floorId);
  }
  static is(e2) {
    return e2.__type === ec2.__type;
  }
  get floor() {
    let e2 = u(this, tc).getById("floor", u(this, _n2));
    if (e2 == null) throw new Error("Floor ".concat(u(this, _n2), " not found!"));
    return e2;
  }
  get coordinate() {
    var e2;
    if (u(this, Lo2).coordinate == null) {
      let [i, o] = (e2 = u(this, us).geometry.coordinates) != null ? e2 : [0, 0];
      u(this, Lo2).coordinate = new K2(o, i, u(this, _n2));
    }
    return u(this, Lo2).coordinate;
  }
  get geoJSON() {
    return { ...u(this, us), properties: null };
  }
  get focusTarget() {
    return this.coordinate;
  }
  get anchorTarget() {
    return this.coordinate;
  }
  toJSON() {
    return { id: this.id, name: this.name, floor: this.floor.id, coordinate: this.coordinate.toJSON() };
  }
  destroy() {
    for (let e2 in u(this, Lo2)) u(this, Lo2)[e2] = null;
  }
};
tc = /* @__PURE__ */ new WeakMap(), _n2 = /* @__PURE__ */ new WeakMap(), Lo2 = /* @__PURE__ */ new WeakMap(), us = /* @__PURE__ */ new WeakMap(), t(ec, "__type", "point-of-interest");
var zg = ec;
var To = zg;
c();
var ic;
var Rn;
var Ao;
var Nn;
var oc;
var $g;
var rc = class rc2 extends st {
  constructor(e2, i) {
    super(e2, i.mvfData);
    v(this, oc);
    t(this, "__type", rc2.__type);
    v(this, ic);
    v(this, Rn);
    v(this, Ao, {});
    v(this, Nn);
    w(this, ic, e2), w(this, Rn, i.floorId), w(this, Nn, i.mvfData);
  }
  static is(e2) {
    return e2.__type === rc2.__type;
  }
  get group() {
    return x(this, oc, $g).call(this).group;
  }
  get type() {
    return x(this, oc, $g).call(this).type;
  }
  get coordinate() {
    if (u(this, Ao).coordinate == null) {
      let [e2, i] = u(this, Nn).geometry.coordinates;
      u(this, Ao).coordinate = new K2(i, e2, u(this, Rn));
    }
    return u(this, Ao).coordinate;
  }
  get floor() {
    let e2 = u(this, ic).getById("floor", u(this, Rn));
    if (e2 == null) throw new Error("Floor ".concat(u(this, Rn), " not found!"));
    return e2;
  }
  get geoJSON() {
    return { ...u(this, Nn), properties: null };
  }
  get focusTarget() {
    return this.coordinate;
  }
  get anchorTarget() {
    return this.coordinate;
  }
  toJSON() {
    return { id: this.id, group: this.group, type: this.type, coordinate: this.coordinate.toJSON() };
  }
  destroy() {
    for (let e2 of Object.keys(u(this, Ao))) delete u(this, Ao)[e2];
  }
};
ic = /* @__PURE__ */ new WeakMap(), Rn = /* @__PURE__ */ new WeakMap(), Ao = /* @__PURE__ */ new WeakMap(), Nn = /* @__PURE__ */ new WeakMap(), oc = /* @__PURE__ */ new WeakSet(), $g = function() {
  let [e2, i] = u(this, Nn).properties.symbolId.split("--");
  return { group: e2, type: i };
}, t(rc, "__type", "annotation");
var qg = rc;
var wo = qg;
c();
var Fo;
var ar;
var Ir;
var ds;
var ac;
var Qg;
var nc = class nc2 extends Cr2 {
  constructor(e2, i) {
    super(i.mvfData.id, e2);
    v(this, ac);
    t(this, "__type", nc2.__type);
    v(this, Fo);
    v(this, ar, {});
    v(this, Ir);
    v(this, ds);
    w(this, Fo, e2), w(this, Ir, i.mvfData), w(this, ds, i.facadeId);
  }
  static is(e2) {
    return e2.__type === nc2.__type;
  }
  get type() {
    return u(this, Ir).type;
  }
  get name() {
    var e2;
    return (e2 = x(this, ac, Qg).call(this, "name")) != null ? e2 : "";
  }
  get shortName() {
    var e2;
    return (e2 = x(this, ac, Qg).call(this, "shortName")) != null ? e2 : "";
  }
  get externalId() {
    var e2;
    return (e2 = u(this, Ir).externalId) != null ? e2 : "";
  }
  get floors() {
    var e2, i;
    if (u(this, ar).floors == null) {
      let o = ((i = (e2 = u(this, Ir).floors) != null ? e2 : u(this, Ir).maps) != null ? i : []).reduce((n, s2) => {
        let c2 = u(this, Fo).floorsById[s2];
        return c2 && n.push(c2), n;
      }, []);
      o.length === 0 && Lt.error("Floor stack ".concat(this.id, " has no floors")), u(this, ar).floors = o;
    }
    return u(this, ar).floors;
  }
  get defaultFloor() {
    if (u(this, ar).defaultFloor != null) return u(this, ar).defaultFloor;
    let e2 = u(this, Ir).defaultFloor ? u(this, Fo).getById("floor", u(this, Ir).defaultFloor) : void 0;
    return u(this, ar).defaultFloor = e2 || this.floors.reduce((i, o) => Math.abs(o.elevation) < Math.abs(i.elevation) ? o : i), u(this, ar).defaultFloor;
  }
  get facade() {
    return u(this, ds) ? u(this, Fo).facadesById[u(this, ds)] : void 0;
  }
  toJSON() {
    return { id: this.id, name: this.name, shortName: this.shortName, type: this.type, floors: this.floors.map((e2) => e2.id) };
  }
  destroy() {
    for (let e2 of globalThis.Object.keys(u(this, ar))) delete u(this, ar)[e2];
  }
};
Fo = /* @__PURE__ */ new WeakMap(), ar = /* @__PURE__ */ new WeakMap(), Ir = /* @__PURE__ */ new WeakMap(), ds = /* @__PURE__ */ new WeakMap(), ac = /* @__PURE__ */ new WeakSet(), Qg = function(e2) {
  return u(this, Fo).getPropTranslation(this.__type, e2, this.id, u(this, Ir)[e2]);
}, t(nc, "__type", "floor-stack");
var Jg = nc;
var Rd = Jg;
c();
var hs;
var Gn;
var lc;
var ri;
var sc = class sc2 extends Cr2 {
  constructor(e2, i) {
    super(i.mvfData.id, e2);
    t(this, "__type", sc2.__type);
    v(this, hs);
    v(this, Gn);
    v(this, lc);
    v(this, ri, {});
    w(this, hs, i.mvfData), w(this, Gn, e2), w(this, lc, i.floorStackId);
  }
  static is(e2) {
    return e2.__type === sc2.__type;
  }
  get floorStack() {
    return u(this, Gn).getById("floor-stack", u(this, lc));
  }
  get spaces() {
    if (!u(this, ri).spaces) {
      u(this, ri).spaces = [];
      for (let e2 of u(this, hs).spaces) {
        let i = u(this, Gn).getById("space", e2.spaceId);
        i && u(this, ri).spaces.push(i);
      }
    }
    return u(this, ri).spaces;
  }
  get center() {
    if (!u(this, ri).center) {
      let e2 = { type: "FeatureCollection", features: [] };
      for (let o of this.spaces) {
        let n = u(this, Gn).mvfSpacesById[o.id];
        n && e2.features.push(n);
      }
      if (e2.features.length === 0) throw new Error("No geometry found for facade!");
      let i = Bu(e2);
      u(this, ri).center = new K2(i.geometry.coordinates[1], i.geometry.coordinates[0], u(this, hs).spaces[0].floorId);
    }
    return u(this, ri).center;
  }
  get focusTarget() {
    return this.spaces;
  }
  get anchorTarget() {
    return this.center;
  }
};
hs = /* @__PURE__ */ new WeakMap(), Gn = /* @__PURE__ */ new WeakMap(), lc = /* @__PURE__ */ new WeakMap(), ri = /* @__PURE__ */ new WeakMap(), t(sc, "__type", "facade");
var Kg = sc;
var xr = Kg;
c();
var qM = (r3, t3) => {
  var l, p, d, f, g, v2, b, C, y, S, T;
  let e2 = {}, i = {}, o = {}, n = {}, s2 = {}, c2 = {};
  for (let w2 of r3["location.json"] || []) {
    let M2 = new fs2(t3, { mvfData: w2 });
    if (e2[w2.id] = M2, w2.externalId && (n[w2.externalId] == null && (n[w2.externalId] = []), n[w2.externalId].push(M2)), w2.categories) for (let F of w2.categories) s2[F] == null && (s2[F] = []), s2[F].push(M2);
    let D = [...(p = (l = w2.obstructions) == null ? void 0 : l.map((F) => F.id)) != null ? p : [], ...(f = (d = w2.spaces) == null ? void 0 : d.map((F) => F.id)) != null ? f : [], ...(v2 = (g = w2.annotations) == null ? void 0 : g.map((F) => F.id)) != null ? v2 : [], ...(b = w2.connections) != null ? b : [], ...(y = (C = w2.entrances) == null ? void 0 : C.map((F) => F.id)) != null ? y : [], ...(T = (S = w2.areas) == null ? void 0 : S.map((F) => F.id)) != null ? T : []];
    for (let F of D) F && (c2[F] == null && (c2[F] = []), c2[F].push(M2));
  }
  for (let w2 of r3["category.json"] || []) {
    let M2 = new Gd(t3, { mvfData: w2 });
    i[w2.id] = M2, w2.parent && (o[w2.parent] == null && (o[w2.parent] = []), o[w2.parent].push(M2));
  }
  return { locationCategoriesByParentId: o, locationProfilesById: e2, locationCategoriesById: i, locationProfilesByExternalId: n, locationProfilesByCategoryId: s2, locationProfilesByAttachedFeatureId: c2 };
};
var $M = (r3, t3, e2) => {
  var y, S;
  let i = {}, o = {}, n = {}, s2 = {}, c2 = {}, l = {}, p = {}, d = {}, f = {}, g = {}, v2 = {}, b = {}, C = globalThis.Object.keys(r3.space);
  for (let T of C) {
    let w2 = r3.space[T];
    if (w2 != null) for (let M2 of w2.features) {
      b[M2.properties.id] = T, p[M2.properties.id] = M2;
      for (let D of M2.properties.destinationNodes) c2[D] == null && (c2[D] = []), c2[D].push(M2.properties.id);
      if (M2.properties.kind === "desk-entrance" && (l[M2.properties.externalId] == null && (l[M2.properties.externalId] = []), l[M2.properties.externalId].push(...M2.properties.destinationNodes)), !["void", "desk-entrance"].includes((y = M2.properties.kind) != null ? y : "")) {
        if ((S = M2.properties.kind) != null && S.includes("connection")) {
          let D = Jr2(M2.geometry.coordinates);
          g[D] == null && (g[D] = []), g[D].push(M2.properties.id);
          continue;
        }
        if (M2.properties.kind === "poi") {
          let D = new To(e2, { floorId: T, mvfData: M2 });
          n[M2.properties.id] = D, f[T] || (f[T] = []), f[T].push(M2), M2.properties.externalId && (s2[M2.properties.externalId] == null && (s2[M2.properties.externalId] = []), s2[M2.properties.externalId].push(D));
        } else {
          let D = new He(e2, { floorId: T, mvfData: M2 });
          i[M2.properties.id] = D, M2.properties.externalId && (o[M2.properties.externalId] == null && (o[M2.properties.externalId] = []), o[M2.properties.externalId].push(D)), d[T] || (d[T] = []), d[T].push(M2);
        }
      }
    }
  }
  for (let T in g) {
    let w2 = g[T], M2 = {};
    for (let F of w2) {
      let A = b[F], k = p[F], B = t3 == null ? void 0 : t3["n_" + k.properties.id.split("s_")[1]];
      M2[A] = { ...k, properties: { ...k.properties, accessible: (B == null ? void 0 : B.accessible) === true } };
    }
    let D = new Fn(e2, { mvfDataByFloorId: M2 });
    v2[D.id] = D;
  }
  return { spacesById: i, spacesByExternalId: o, poisById: n, poisByExternalId: s2, connectionsById: v2, spaceIdsByDestinationNodeId: c2, objectEntranceNodeIdsByObstructionId: l, mvfSpacesById: p, connectionIdsByLatLon: g, mvfSpacesByFloorId: d, mvfPoisByFloorId: f };
};
var JM = (r3, t3) => {
  var s2, c2;
  let e2 = {}, i = {}, o = {}, n = {};
  for (let l of r3["node.geojson"].features) {
    o[l.properties.id] = l;
    let p = new xo(t3, { mvfData: l, floorId: (s2 = l.properties.floor) != null ? s2 : l.properties.map });
    e2[l.properties.id] = p, l.properties.externalId && (i[l.properties.externalId] == null && (i[l.properties.externalId] = []), i[l.properties.externalId].push(p));
    let d = (c2 = l.properties.floor) != null ? c2 : l.properties.map;
    n[d] || (n[d] = []), n[d].push(l);
  }
  return { nodesById: e2, nodesByExternalId: i, mvfNodesById: o, mvfNodesByFloorId: n };
};
var QM = (r3, t3) => {
  let e2 = {}, i = {}, o = {}, n = {}, s2 = globalThis.Object.keys(r3.obstruction);
  for (let c2 of s2) {
    let l = r3.obstruction[c2];
    if (l != null) for (let p of l.features) {
      o[p.properties.id] = p;
      for (let f of p.properties.entrances) n[f] = p.properties.id;
      if (p.properties.kind === "Wall") continue;
      let d = new zt(t3, { floorId: c2, mvfData: p });
      e2[p.properties.id] = d, p.properties.externalId && (i[p.properties.externalId] == null && (i[p.properties.externalId] = []), i[p.properties.externalId].push(d));
    }
  }
  return { objectsById: e2, objectsByExternalId: i, mvfObstructionById: o, obstructionIdByEntranceId: n };
};
var KM = (r3, t3) => {
  let e2 = {}, i = {}, o = {};
  if ("floor.geojson" in r3 && r3["floor.geojson"] != null) for (let n of r3["floor.geojson"].features) {
    o[n.properties.id] = n.properties;
    let s2 = new Zt(t3, { mvfData: n });
    e2[n.properties.id] = s2, n.properties.externalId && (i[n.properties.externalId] == null && (i[n.properties.externalId] = []), i[n.properties.externalId].push(s2));
  }
  else for (let n of r3["map.geojson"]) {
    o[n.id] = n;
    let s2 = new Zt(t3, { mvfData: { properties: n } });
    e2[n.id] = s2;
  }
  return { floorsById: e2, floorsByExternalId: i, mvfFloorsById: o };
};
var eT = (r3, t3) => {
  var l;
  let e2 = {}, i = {}, o = {}, n = {}, s2 = {}, c2 = r3["floorstack.json"] || r3["mapstack.json"] || r3["mapstack.geojson"];
  if (c2 != null) for (let p of c2) {
    let d = (l = r3.facade) == null ? void 0 : l[p.id], f = new Rd(t3, { mvfData: p, facadeId: d == null ? void 0 : d.id });
    if (e2[p.id] = f, p.externalId && (i[p.externalId] == null && (i[p.externalId] = []), i[p.externalId].push(f)), o[p.id] = p, d) {
      let g = new xr(t3, { mvfData: d, floorStackId: p.id });
      n[d.id] = g;
      for (let v2 of d.spaces) s2[v2.spaceId] = g;
    }
  }
  return { floorStacksById: e2, floorStacksByExternalId: i, mvfFloorStacksById: o, facadesById: n, facadesBySpaceId: s2 };
};
var tT = (r3, t3) => {
  let e2 = {}, i = {}, o = r3["connection.json"].reduce((n, s2) => {
    s2.nodes.forEach((l) => n[l] = s2), e2[s2.id] = s2;
    let c2 = t3 == null ? void 0 : t3[s2.nodes[0]];
    if (c2 != null) {
      let l = Jr2(c2.geometry.coordinates);
      i[l] == null && (i[l] = []), i[l].push(s2.id);
    }
    return n;
  }, {});
  return { mvfConnectionsById: e2, mvfConnectionsByNodeId: o, mvfConnectionIdsByLatLon: i };
};
var rT = (r3, t3) => {
  let e2 = {}, i = {}, o = {}, n = {}, s2 = {}, c2 = globalThis.Object.keys(r3.entrance);
  for (let l of c2) {
    let p = r3.entrance[l];
    if (p != null) for (let d of p.features) {
      n[d.properties.id] = d;
      let f = new Qr(t3, { floorId: l, mvfData: d });
      d.properties.node && (o[d.properties.node] = f), e2[d.properties.id] = f, d.properties.externalId && (i[d.properties.externalId] == null && (i[d.properties.externalId] = []), i[d.properties.externalId].push(f)), s2[l] || (s2[l] = []), s2[l].push(d);
    }
  }
  return { doorsById: e2, doorsByExternalId: i, doorsByNodeId: o, mvfEntrancesById: n, mvfEntrancesByFloorId: s2 };
};
var iT = (r3, t3, e2) => {
  var i;
  if (r3.textAreas != null) for (let o in r3.textAreas) {
    let n = (i = r3.textAreas[o]) == null ? void 0 : i.features;
    if (n != null) {
      for (let s2 of n) if ("anchorId" in s2.properties) {
        let c2 = s2 == null ? void 0 : s2.properties, l = t3[c2.anchorId] || e2[c2.anchorId];
        if (l != null && c2 != null) {
          let p = l.properties;
          p.textArea = c2, p.textArea && (p.textArea.position = s2.geometry.coordinates);
        }
      }
    }
  }
};
var oT = (r3, t3, e2) => {
  var i;
  if (r3.floorImages != null) for (let o in r3.floorImages) {
    let n = (i = r3.floorImages[o]) == null ? void 0 : i.features;
    if (n != null) {
      for (let s2 of n) if ("anchorId" in s2.properties) {
        let c2 = s2 == null ? void 0 : s2.properties, l = t3[c2.anchorId] || e2[c2.anchorId];
        if (l != null && c2 != null) {
          let p = l.properties;
          p.image = c2, p.image && (p.image.position = s2.geometry.coordinates);
        }
      }
    }
  }
};
var nT = (r3, t3) => {
  var i, o;
  if (((i = r3.enterprise) == null ? void 0 : i.enterpriseStyles) == null) return;
  let e2 = (o = r3.enterprise) == null ? void 0 : o.enterpriseStyles;
  for (let n in e2) {
    let s2 = e2[n];
    s2.geometryAnchors.forEach((c2) => {
      let l = t3[c2.geometryId];
      if (l != null) {
        let p = l.properties;
        p.style = { styleId: n, edgeOffset: s2.edgeOffset };
      }
    });
  }
};
var aT = (r3, t3, e2) => {
  if (!(r3.enterprise == null || r3.enterprise.textures == null)) for (let i of r3.enterprise.textures) for (let o of i.geometryAnchors) {
    let n = t3[o.geometryId] || e2[o.geometryId];
    if (n != null) {
      let s2 = n.properties;
      s2.textures == null && (s2.textures = []), s2.textures.push(i);
    }
  }
};
var sT = (r3, t3) => {
  let e2 = {}, i = {}, o = {};
  if (r3.annotation == null) return { annotationsById: e2, mvfAnnotationsById: i, mvfAnnotationsByFloorId: o };
  let n = globalThis.Object.keys(r3.annotation);
  for (let s2 of n) {
    let c2 = r3.annotation[s2];
    if (c2 != null) for (let l of c2.features) {
      i[l.properties.id] = l;
      let p = new wo(t3, { floorId: s2, mvfData: l });
      e2[l.properties.id] = p, o[s2] || (o[s2] = []), o[s2].push(l);
    }
  }
  return { annotationsById: e2, mvfAnnotationsById: i, mvfAnnotationsByFloorId: o };
};
var lT = (r3, t3) => {
  let e2 = {}, i = {}, o = {};
  if (r3.area == null) return { areasById: e2, areasByExternalId: i, mvfAreasById: o };
  let n = globalThis.Object.keys(r3.area);
  for (let s2 of n) {
    let c2 = r3.area[s2];
    if (c2 != null) for (let l of c2.features) {
      o[l.properties.id] = l;
      let p = new Po(t3, { floorId: s2, mvfData: l });
      e2[l.properties.id] = p, l.properties.externalId && (i[l.properties.externalId] == null && (i[l.properties.externalId] = []), i[l.properties.externalId].push(p));
    }
  }
  return { areasById: e2, areasByExternalId: i, mvfAreasById: o };
};
var O4 = (r3, t3) => {
  var S, T, w2, M2, D, F, A, k, B, G, V, W, $;
  let e2 = {}, i = {}, o = {}, n = {}, s2 = ((T = (S = r3.enterprise) == null ? void 0 : S.locations) != null ? T : []).reduce((U, ie) => (U[ie.id] = ie, U), {}), c2 = {}, l = {}, p = {}, d = {}, f = {}, g = {}, v2 = ((w2 = r3.enterprise) == null ? void 0 : w2.venue) || {}, b = {}, C = {};
  for (let U of (D = (M2 = r3.enterprise) == null ? void 0 : M2.categories) != null ? D : []) {
    let ie = new Nd(t3, { mvfData: U });
    c2[U.id] = ie, U.externalId && (l[U.externalId] == null && (l[U.externalId] = []), l[U.externalId].push(ie)), p[U.id] = U, U.locations.forEach((Z) => {
      f[Z] == null && (f[Z] = []), f[Z].push(U.id);
    });
  }
  let y = {};
  for (let U of (A = (F = r3.enterprise) == null ? void 0 : F.locationInstances) != null ? A : []) {
    let ie = s2[U.parent], Z = Object.keys(ie), Ee2 = {};
    for (let ge of Z) Ee2[ge] = void 0;
    let ue = { ...Ee2, polygons: [], nodes: [], ...U };
    y[ue.parent] == null && (y[ue.parent] = []), y[ue.parent].push(new Li(t3, { mvfData: ue, categoryIds: ((B = (k = r3.enterprise) == null ? void 0 : k.categoryPriorities) == null ? void 0 : B[ue.id]) || f[ue.id], parentId: U.parent })), b[ue.id] = U;
  }
  for (let U in r3.space) {
    let ie = r3.space[U];
    if (ie != null) for (let Z of ie.features) for (let Ee2 of Z.properties.destinationNodes) C[Ee2] == null && (C[Ee2] = []), C[Ee2].push(Z.properties.id);
  }
  for (let U of (V = (G = r3.enterprise) == null ? void 0 : G.locations) != null ? V : []) {
    let ie = new Li(t3, { mvfData: U, categoryIds: (($ = (W = r3.enterprise) == null ? void 0 : W.categoryPriorities) == null ? void 0 : $[U.id]) || f[U.id], locationInstances: y[U.id] });
    o[U.id] = ie, U.externalId && (n[U.externalId] == null && (n[U.externalId] = []), n[U.externalId].push(ie)), U.nodes.forEach((Z) => {
      g[Z.id] == null && (g[Z.id] = []), g[Z.id].push(U.id);
    });
    for (let Z of U.polygons) d[Z.id] == null && (d[Z.id] = []), d[Z.id].push(U);
  }
  if (t3.enterpriseMode === true) {
    for (let U in t3.mvfConnectionsById) {
      let ie = {}, Z = t3.mvfConnectionsById[U];
      for (let Ee2 of t3.mvfConnectionsById[U].nodes) {
        let ue = t3.nodesById[Ee2];
        ue != null && (ie[ue.floor.id] = { type: "Feature", geometry: { type: "Point", coordinates: [ue.coordinate.longitude, ue.coordinate.latitude] }, properties: { id: U, externalId: Z.externalId, kind: "enterprise." + Z.type, destinationNodes: [], flags: "", type: Z.type, nodes: Z.nodes, accessible: Z.accessible, extra: Z.extra, details: Z.details } });
      }
      Object.keys(ie).length > 0 && (e2[U] = new Fn(t3, { mvfDataByFloorId: ie }), Z.externalId && (i[Z.externalId] == null && (i[Z.externalId] = []), i[Z.externalId].push(e2[U])));
    }
    t3.connectionsById = e2;
  }
  return { spaceIdsByNodeId: C, connectionsByExternalId: i, locationIdsByNodeId: g, mvfLocationsBySpaceId: d, mvfLocationsById: s2, mvfCategoriesById: p, locationsById: o, locationsByExternalId: n, locationInstancesById: b, categoriesById: c2, categoriesByExternalId: l, venue: v2 };
};
var L4 = (r3, t3) => {
  let { nodesById: e2, nodesByExternalId: i, mvfNodesById: o, mvfNodesByFloorId: n } = JM(r3, t3), { mvfConnectionsById: s2, mvfConnectionsByNodeId: c2, mvfConnectionIdsByLatLon: l } = tT(r3, o), { spacesById: p, spacesByExternalId: d, spaceIdsByDestinationNodeId: f, poisById: g, poisByExternalId: v2, mvfSpacesById: b, objectEntranceNodeIdsByObstructionId: C, connectionsById: y, connectionIdsByLatLon: S, mvfSpacesByFloorId: T, mvfPoisByFloorId: w2 } = $M(r3, c2, t3), { objectsById: M2, objectsByExternalId: D, mvfObstructionById: F, obstructionIdByEntranceId: A } = QM(r3, t3), { floorsById: k, floorsByExternalId: B, mvfFloorsById: G } = KM(r3, t3), { floorStacksById: V, floorStacksByExternalId: W, mvfFloorStacksById: $, facadesById: U, facadesBySpaceId: ie } = eT(r3, t3), { doorsById: Z, doorsByExternalId: Ee2, doorsByNodeId: ue, mvfEntrancesById: ge, mvfEntrancesByFloorId: xe2 } = rT(r3, t3), { annotationsById: hr, mvfAnnotationsById: kt2, mvfAnnotationsByFloorId: dt } = sT(r3, t3), { areasById: nt, areasByExternalId: bi, mvfAreasById: io } = lT(r3, t3);
  oT(r3, b, F), iT(r3, b, F), nT(r3, b), aT(r3, b, F);
  let { locationCategoriesByParentId: ae2, locationProfilesById: de2, locationCategoriesById: Ue, locationProfilesByExternalId: ht, locationProfilesByCategoryId: fr, locationProfilesByAttachedFeatureId: oo } = qM(r3, t3);
  return { spacesById: p, spacesByExternalId: d, nodesById: e2, nodesByExternalId: i, objectsById: M2, objectsByExternalId: D, floorsById: k, floorsByExternalId: B, floorStacksById: V, floorStacksByExternalId: W, facadesById: U, facadesBySpaceId: ie, connectionsById: y, doorsById: Z, doorsByExternalId: Ee2, doorsByNodeId: ue, poisById: g, poisByExternalId: v2, annotationsById: hr, areasById: nt, areasByExternalId: bi, spaceIdsByDestinationNodeId: f, objectEntranceNodeIdsByObstructionId: C, obstructionIdByEntranceId: A, connectionIdsByLatLon: S, locationProfilesById: de2, locationCategoriesById: Ue, locationProfilesByExternalId: ht, locationProfilesByCategoryId: fr, locationCategoriesByParentId: ae2, mvfSpacesById: b, mvfNodesById: o, mvfObstructionById: F, mvfFloorsById: G, mvfFloorStacksById: $, mvfConnectionsById: s2, mvfConnectionsByNodeId: c2, mvfEntrancesById: ge, mvfAnnotationsById: kt2, mvfNodesByFloorId: n, mvfSpacesByFloorId: T, mvfPoisByFloorId: w2, mvfAreasById: io, mvfEntrancesByFloorId: xe2, mvfAnnotationsByFloorId: dt, locationProfilesByAttachedFeatureId: oo, mvfConnectionIdsByLatLon: l };
};
c();
var cT = /* @__PURE__ */ new Set(["polygons"]);
var Pr;
var Oe;
var Rt;
var pc;
var cc = class cc2 extends ze2 {
  constructor(e2, i) {
    super(i.mvfData.externalId);
    t(this, "__type", cc2.__type);
    t(this, "description");
    t(this, "name", "");
    t(this, "amenity");
    t(this, "externalId", "");
    t(this, "extra");
    t(this, "gallery");
    t(this, "instances");
    t(this, "logo");
    t(this, "operationHours");
    t(this, "phone");
    t(this, "picture");
    t(this, "shortName");
    t(this, "showFloatingLabelWhenImagePresent");
    t(this, "showLogo");
    t(this, "siblingGroups");
    t(this, "social");
    t(this, "sortOrder", -1);
    t(this, "states");
    t(this, "tags");
    t(this, "type", "");
    v(this, Pr);
    v(this, Oe, {});
    v(this, Rt);
    v(this, pc);
    w(this, Pr, e2), w(this, Rt, i.mvfData), w(this, pc, i.categoryIds || []), this.instances = i.locationInstances || [];
    for (let o in i.mvfData) !cT.has(o) && !Object.getOwnPropertyDescriptor(Object.getPrototypeOf(this), o) && Object.defineProperty(this, o, { enumerable: true, get() {
      if (i.parentId) {
        let n = u(this, Pr).locationsById[i.parentId];
        return u(this, Rt)[o] != null ? u(this, Pr).getPropTranslation(this.__type, o, u(this, Rt).id, u(this, Rt)[o]) : u(this, Pr).getPropTranslation(this.__type, o, u(this, Rt).id, n[o]);
      }
      return u(this, Pr).getPropTranslation(this.__type, o, u(this, Rt).id, u(this, Rt)[o]);
    } });
  }
  static is(e2) {
    return e2.__type === cc2.__type;
  }
  get focusTarget() {
    return this.spaces;
  }
  get categories() {
    return u(this, Oe).categories ? u(this, Oe).categories : (u(this, Oe).categories = (u(this, pc).map((e2) => u(this, Pr).getById("enterprise-category", e2)) || []).filter(Boolean), u(this, Oe).categories);
  }
  get coordinates() {
    if (u(this, Oe).coordinates) return u(this, Oe).coordinates;
    u(this, Oe).coordinates = [];
    for (let e2 = 0; e2 < this.nodes.length; e2++) u(this, Oe).coordinates.push(this.nodes[e2].coordinate);
    return u(this, Oe).coordinates;
  }
  get nodes() {
    if (u(this, Oe).nodes) return u(this, Oe).nodes;
    u(this, Oe).nodes = [];
    for (let e2 = 0; e2 < u(this, Rt).nodes.length; e2++) {
      let i = u(this, Pr).getById("node", u(this, Rt).nodes[e2].id);
      i && u(this, Oe).nodes.push(i);
    }
    return u(this, Oe).nodes;
  }
  get spaces() {
    if (u(this, Oe).spaces) return u(this, Oe).spaces;
    u(this, Oe).spaces = [];
    for (let e2 = 0; e2 < u(this, Rt).polygons.length; e2++) {
      let i = u(this, Pr).getById("space", u(this, Rt).polygons[e2].id);
      i && u(this, Oe).spaces.push(i);
    }
    return u(this, Oe).spaces;
  }
  toJSON() {
    return { id: this.id, name: this.name };
  }
  destroy() {
    for (let e2 of Object.keys(u(this, Oe))) delete u(this, Oe)[e2];
  }
};
Pr = /* @__PURE__ */ new WeakMap(), Oe = /* @__PURE__ */ new WeakMap(), Rt = /* @__PURE__ */ new WeakMap(), pc = /* @__PURE__ */ new WeakMap(), t(cc, "__type", "enterprise-location");
var ey2 = cc;
var Li = ey2;
c();
var pT = /* @__PURE__ */ new Set();
var Vn2;
var Pt2;
var ii;
var uc = class uc2 extends ze2 {
  constructor(e2, i) {
    super(i.mvfData.externalId);
    t(this, "__type", uc2.__type);
    t(this, "name", "");
    t(this, "color");
    t(this, "externalId", "");
    t(this, "extra");
    t(this, "icon");
    t(this, "iconFromDefaultList");
    t(this, "sortOrder", -1);
    t(this, "picture");
    v(this, Vn2);
    v(this, Pt2, {});
    v(this, ii);
    w(this, Vn2, e2), w(this, ii, i.mvfData);
    for (let o in i.mvfData) !pT.has(o) && !Object.getOwnPropertyDescriptor(Object.getPrototypeOf(this), o) && Object.defineProperty(this, o, { get() {
      return u(this, Vn2).getPropTranslation(this.__type, o, u(this, ii).id, u(this, ii)[o]);
    } });
  }
  static is(e2) {
    return e2.__type === uc2.__type;
  }
  get children() {
    if (u(this, Pt2).children) return u(this, Pt2).children;
    u(this, Pt2).children = [];
    for (let e2 = 0; e2 < u(this, ii).children.length; e2++) {
      let i = u(this, Vn2).getById("enterprise-category", u(this, ii).children[e2]);
      i && u(this, Pt2).children.push(i);
    }
    return u(this, Pt2).children;
  }
  get locations() {
    if (u(this, Pt2).locations) return u(this, Pt2).locations;
    u(this, Pt2).locations = [];
    for (let e2 = 0; e2 < u(this, ii).locations.length; e2++) {
      let i = u(this, Vn2).getById("enterprise-location", u(this, ii).locations[e2]);
      i && u(this, Pt2).locations.push(i);
    }
    return u(this, Pt2).locations;
  }
  toJSON() {
    return { id: this.id, name: this.name };
  }
  destroy() {
    for (let e2 of Object.keys(u(this, Pt2))) delete u(this, Pt2)[e2];
  }
};
Vn2 = /* @__PURE__ */ new WeakMap(), Pt2 = /* @__PURE__ */ new WeakMap(), ii = /* @__PURE__ */ new WeakMap(), t(uc, "__type", "enterprise-category");
var ty2 = uc;
var Nd = ty2;
c();
var uT = /* @__PURE__ */ new Set();
var hc;
var fc;
var dc = class dc2 extends ze2 {
  constructor(e2, i) {
    super(i.mvfData.externalId);
    t(this, "__type", dc2.__type);
    t(this, "countrycode");
    t(this, "externalId", "");
    t(this, "defaultLanguage", { code: "en", name: "English" });
    t(this, "defaultMap");
    t(this, "extra");
    t(this, "icon");
    t(this, "languages", []);
    t(this, "links", []);
    t(this, "logo");
    t(this, "mappedinWebUrl");
    t(this, "slug", "");
    t(this, "topLocations");
    t(this, "tzid");
    v(this, hc, {});
    v(this, fc);
    w(this, fc, i.mvfData);
    for (let o in i.mvfData) !uT.has(o) && !Object.getOwnPropertyDescriptor(Object.getPrototypeOf(this), o) && (this[o] = i.mvfData[o]);
  }
  static is(e2) {
    return e2.__type === dc2.__type;
  }
  get name() {
    var e2;
    return (e2 = u(this, fc).name) != null ? e2 : "";
  }
  toJSON() {
    return { id: this.id, name: this.name };
  }
  destroy() {
    for (let e2 of Object.keys(u(this, hc))) delete u(this, hc)[e2];
  }
};
hc = /* @__PURE__ */ new WeakMap(), fc = /* @__PURE__ */ new WeakMap(), t(dc, "__type", "enterprise-venue");
var ry2 = dc;
var iy2 = ry2;
c();
function oy2(r3) {
  var o, n, s2, c2, l, p;
  let t3 = ((n = (o = r3.enterprise) == null ? void 0 : o.locations) == null ? void 0 : n.reduce((d, f) => (d[f.id] = f, d), {})) || {};
  for (let d of ((s2 = r3.enterprise) == null ? void 0 : s2.locationInstances) || []) t3[d.id] = d;
  let e2 = {};
  for (let d of r3["floorstack.json"] || []) e2[d.id] = d;
  let i = {};
  for (let d of ((c2 = r3["floor.geojson"]) == null ? void 0 : c2.features) || []) d.properties && d.properties.id && (i[d.properties.id] = d.properties);
  return { type: "downloaded", data: r3, optimized: { "enterprise-location": t3, "enterprise-category": ((p = (l = r3.enterprise) == null ? void 0 : l.categories) == null ? void 0 : p.reduce((d, f) => (d[f.id] = f, d), {})) || {}, "floor-stack": e2, floor: i } };
}
function A4(r3) {
  return /^https?:\/\/cdn\.mappedin\.com/.test(r3);
}
function F4(r3) {
  let t3 = r3.split("?")[1];
  return !!(t3 != null && t3.includes("sv="));
}
c();
c();
c();
c();
c();
c();
c();
var jn2 = class {
  constructor({ origin: t3, destination: e2, distance: i = 0, angle: o = 0, pathWeight: n = 0, multiplicativeDistanceWeightScaling: s2 = true }) {
    t(this, "origin");
    t(this, "destination");
    t(this, "distance");
    t(this, "angle");
    t(this, "weight");
    if (this.origin = t3, this.destination = e2, this.distance = i, this.angle = o, this.weight = n || 0, s2 ? t3.properties.floor === e2.properties.floor && (this.weight = (this.weight >= 0 ? this.distance * this.weight : 0) + this.distance) : t3.properties.map === e2.properties.map && (this.weight = this.weight >= 0 ? this.distance + this.weight : 0), isNaN(this.angle)) throw new Error("Invalid angle: Expected a numeric value, but received NaN.");
  }
};
c();
c();
c();
function ki2(r3, t3, e2) {
  if (e2 === void 0 && (e2 = {}), !r3) throw new Error("point is required");
  if (!t3) throw new Error("polygon is required");
  var i = er(r3), o = Ha(t3), n = o.type, s2 = t3.bbox, c2 = o.coordinates;
  if (s2 && dT(i, s2) === false) return false;
  n === "Polygon" && (c2 = [c2]);
  for (var l = false, p = 0; p < c2.length && !l; p++) if (k4(i, c2[p][0], e2.ignoreBoundary)) {
    for (var d = false, f = 1; f < c2[p].length && !d; ) k4(i, c2[p][f], !e2.ignoreBoundary) && (d = true), f++;
    d || (l = true);
  }
  return l;
}
function k4(r3, t3, e2) {
  var i = false;
  t3[0][0] === t3[t3.length - 1][0] && t3[0][1] === t3[t3.length - 1][1] && (t3 = t3.slice(0, t3.length - 1));
  for (var o = 0, n = t3.length - 1; o < t3.length; n = o++) {
    var s2 = t3[o][0], c2 = t3[o][1], l = t3[n][0], p = t3[n][1], d = r3[1] * (s2 - l) + c2 * (l - r3[0]) + p * (r3[0] - s2) === 0 && (s2 - r3[0]) * (l - r3[0]) <= 0 && (c2 - r3[1]) * (p - r3[1]) <= 0;
    if (d) return !e2;
    var f = c2 > r3[1] != p > r3[1] && r3[0] < (l - s2) * (r3[1] - c2) / (p - c2) + s2;
    f && (i = !i);
  }
  return i;
}
function dT(r3, t3) {
  return t3[0] <= r3[0] && t3[1] <= r3[1] && t3[2] >= r3[0] && t3[3] >= r3[1];
}
c();
c();
function Bi2([r3, t3], [e2, i]) {
  let o = t3 - i, n = r3 - e2;
  return (Math.atan2(n, o) + Math.PI * 3) % (Math.PI * 2);
}
c();
var hT = 63710088e-1;
function Mr(r3, t3) {
  let [e2, i] = r3.map((d) => d * Math.PI / 180), [o, n] = t3.map((d) => d * Math.PI / 180), s2 = n - i, c2 = o - e2, l = Math.sin(s2 / 2) * Math.sin(s2 / 2) + Math.cos(i) * Math.cos(n) * Math.sin(c2 / 2) * Math.sin(c2 / 2), p = 2 * Math.atan2(Math.sqrt(l), Math.sqrt(1 - l));
  return hT * p;
}
c();
c();
function Vd(r3, t3, e2, i) {
  let [o, n] = r3, [s2, c2] = t3, [l, p] = e2, [d, f] = i;
  if (n === c2 && o === s2 || p === f && l === d) return null;
  let g = (d - l) * (c2 - n) - (f - p) * (s2 - o);
  if (g === 0) return null;
  let v2 = ((f - p) * (o - l) - (d - l) * (n - p)) / g, b = ((c2 - n) * (o - l) - (s2 - o) * (n - p)) / g;
  if (v2 < 0 || v2 > 1 || b < 0 || b > 1) return null;
  let C = n + v2 * (c2 - n);
  return [o + v2 * (s2 - o), C];
}
c();
function ny2(r3, t3, e2, i) {
  let o = vn(r3, e2 / 1e3, i), n = vn(t3, e2 / 1e3, i);
  return [o.geometry.coordinates, n.geometry.coordinates];
}
c();
function ay2(r3) {
  let t3 = r3 * (180 / Math.PI);
  return t3 = t3 % 360, t3 > 180 ? t3 -= 360 : t3 < -180 && (t3 += 360), Object.is(t3, -0) ? 0 : t3;
}
var B4 = 111e3;
function _4(r3, t3, e2 = [], i = 0) {
  let o = true, n = r3.geometry.coordinates, s2 = t3.geometry.coordinates, c2 = ay2(Bi2(n, s2) - Math.PI / 2), l = ay2(Bi2(n, s2) + Math.PI / 2), p = i / B4, d = i / (B4 * Math.cos(n[1] * Math.PI / 180)), f = Math.min(n[1], s2[1]) - p, g = Math.max(n[1], s2[1]) + p, v2 = Math.min(n[0], s2[0]) - d, b = Math.max(n[0], s2[0]) + d;
  for (let C of e2) if (!(Math.max(C[0][1], C[1][1]) < f || Math.min(C[0][1], C[1][1]) > g || Math.max(C[0][0], C[1][0]) < v2 || Math.min(C[0][0], C[1][0]) > b)) {
    if (i > 0) {
      let y = ny2(n, s2, i, c2), S = ny2(n, s2, i, l);
      if (Vd(y[0], y[1], C[0], C[1]) || Vd(S[0], S[1], C[0], C[1])) {
        o = false;
        return;
      }
    } else if (Vd(n, s2, C[0], C[1])) {
      o = false;
      return;
    }
  }
  return o;
}
var Un;
var lt;
var sy2;
var R4;
var N4;
var G4;
var V4;
var j4;
var U4;
var Ud;
var jd = class {
  constructor({ nodes: t3, groupBy: e2, multiplicativeDistanceWeightScaling: i }) {
    v(this, lt);
    t(this, "edges", {});
    t(this, "nodesById");
    t(this, "nodesByGroup", /* @__PURE__ */ new Map());
    v(this, Un);
    v(this, Ud, (t4, e3) => {
      let i2 = 0;
      for (let o2 of e3) (!o2[u(this, Un)] || o2[u(this, Un)] === t4.properties[u(this, Un)]) && ki2(t4.geometry.coordinates, o2.geometry.geometry) && (i2 += Math.max(0, o2.cost));
      return i2;
    });
    w(this, Un, e2);
    let { features: o } = t3;
    this.nodesById = x(this, lt, R4).call(this, o), x(this, lt, N4).call(this), x(this, lt, G4).call(this, o, e2, { multiplicativeDistanceWeightScaling: i });
  }
  getShortestEuclideanDistance(t3, e2) {
    return e2.reduce((i, o) => {
      let n = Mr(t3.geometry.coordinates, o.geometry.coordinates);
      return Math.min(i, n);
    }, Number.MAX_VALUE);
  }
  aStar({ originIds: t3, destinationNodeIds: e2, excludedNodeIds: i, disabledConnectionNodeIds: o, zones: n }) {
    let s2 = x(this, lt, sy2).call(this, t3), c2 = x(this, lt, sy2).call(this, e2);
    if (s2.length === 0 || c2.length === 0) return [];
    let { frontier: l, cameFrom: p, costSoFar: d } = x(this, lt, V4).call(this, s2, c2);
    for (; l.length > 0; ) {
      let f = l.shift();
      if (!f) break;
      if (x(this, lt, j4).call(this, f.origin, c2)) return x(this, lt, U4).call(this, p, f.origin.properties.id);
      for (let g of this.edges[f.origin.properties.id]) {
        if (o != null && o.has(g.origin.properties.id) && g.destination.properties.map !== g.origin.properties.map) continue;
        let v2 = d[f.origin.properties.id] + g.weight + u(this, Ud).call(this, g.destination, n);
        if (!(v2 === 1 / 0 || i != null && i.has(g.destination.properties.id)) && (d[g.destination.properties.id] == null || v2 < d[g.destination.properties.id])) {
          let b = v2 + this.getShortestEuclideanDistance(g.destination, c2);
          d[g.destination.properties.id] = v2, p[g.destination.properties.id] = g, l.push({ origin: g.destination, priority: b });
        }
      }
      l.sort((g, v2) => g.priority - v2.priority);
    }
    return [];
  }
};
Un = /* @__PURE__ */ new WeakMap(), lt = /* @__PURE__ */ new WeakSet(), sy2 = function(t3) {
  return t3.map((e2) => this.nodesById[e2]).filter(Boolean);
}, R4 = function(t3) {
  return t3.reduce((e2, i) => (e2[i.properties.id] = i, e2), {});
}, N4 = function() {
  for (let t3 in this.nodesById) this.nodesById.hasOwnProperty(t3) && (this.nodesById[t3].properties.neighbors = this.nodesById[t3].properties.neighbors.filter(({ id: e2 }) => !!this.nodesById[e2]));
}, G4 = function(t3, e2, i) {
  t3.forEach((o) => {
    let n = e2 === "default" ? e2 : o.properties[e2];
    this.nodesByGroup.has(n) || this.nodesByGroup.set(n, []), this.nodesByGroup.get(n).push(o), this.edges[o.properties.id] = o.properties.neighbors.map(({ id: s2, weight: c2 }) => {
      let l = this.nodesById[s2], p = Mr(o.geometry.coordinates, l.geometry.coordinates), d = Bi2(o.geometry.coordinates, l.geometry.coordinates);
      return new jn2({ origin: o, destination: l, pathWeight: c2, distance: p, angle: d, multiplicativeDistanceWeightScaling: i == null ? void 0 : i.multiplicativeDistanceWeightScaling });
    });
  });
}, V4 = function(t3, e2) {
  let i = [], o = {}, n = {};
  return t3.forEach((s2) => {
    let c2 = this.getShortestEuclideanDistance(s2, e2);
    i.push({ origin: s2, priority: c2 }), o[s2.properties.id] = null, n[s2.properties.id] = 0;
  }), i.sort((s2, c2) => s2.priority - c2.priority), { frontier: i, cameFrom: o, costSoFar: n };
}, j4 = function(t3, e2) {
  return e2.some((i) => i.properties.id === t3.properties.id);
}, U4 = function(t3, e2) {
  let i = [], o = t3[e2];
  for (; o; ) i.push(o), o = t3[o.origin.properties.id];
  return i.reverse();
}, Ud = /* @__PURE__ */ new WeakMap();
var fT = 0.4;
var ms = class {
  constructor({ nodes: t3, geojsonCollection: e2, groupBy: i = "default", multiplicativeDistanceWeightScaling: o }) {
    t(this, "groupBy");
    t(this, "graph");
    t(this, "geometryEdgesByMapId", /* @__PURE__ */ new Map());
    t(this, "generatePath", (t4) => {
      let { destination: e3 } = t4[t4.length - 1], i2 = { type: "FeatureCollection", features: [] };
      for (let n = 0; n < t4.length; n++) {
        let { origin: s2, destination: c2 } = t4[n], l = { id: s2.properties.id, angle: t4[n].angle, distance: t4[n].distance, destination: c2.properties.id, edges: this.graph.edges[s2.properties.id] };
        this.groupBy !== "default" && (l.groupBy = s2.properties[this.groupBy]), i2.features.push({ type: "Feature", geometry: { type: "Point", coordinates: [s2.geometry.coordinates[0], s2.geometry.coordinates[1]] }, properties: l });
      }
      let o2 = { id: e3.properties.id, edges: this.graph.edges[e3.properties.id] };
      return this.groupBy !== "default" && (o2.groupBy = e3.properties[this.groupBy]), i2.features.push({ type: "Feature", geometry: { type: "Point", coordinates: [e3.geometry.coordinates[0], e3.geometry.coordinates[1]] }, properties: o2 }), i2;
    });
    t(this, "getDistance", (t4, e3) => Mr(t4, e3));
    t(this, "getAngle", (t4, e3) => Bi2(t4, e3));
    this.groupBy = i, this.graph = new jd({ nodes: t3, groupBy: this.groupBy, multiplicativeDistanceWeightScaling: o }), ((e2 == null ? void 0 : e2.features) || []).forEach((s2) => {
      let c2 = null;
      if (s2.geometry.type === "LineString" ? c2 = s2.geometry.coordinates : s2.geometry.type === "Polygon" && (c2 = s2.geometry.coordinates.flat()), c2) {
        let l = this.groupBy === "default" ? this.groupBy : s2.properties[this.groupBy];
        this.geometryEdgesByMapId.has(l) || this.geometryEdgesByMapId.set(l, []), c2.forEach((p, d) => {
          this.geometryEdgesByMapId.get(l).push([p, c2[d + 1] || c2[0]]);
        });
      }
    });
  }
  getDirections({ zones: t3, originIds: e2, destinationNodeIds: i, excludedNodeIds: o, disabledConnectionNodeIds: n, simplify: s2, multiplicativeDistanceWeightScaling: c2 }) {
    var f, g;
    let l = (f = s2 == null ? void 0 : s2.enabled) != null ? f : true, p = t3 != null ? t3 : [], d = this.graph.aStar({ originIds: e2, destinationNodeIds: i, zones: p, excludedNodeIds: new Set(o), disabledConnectionNodeIds: new Set(n) });
    return d.length === 0 ? { type: "FeatureCollection", features: [] } : (l && (d = this.simplifyAllSteps(d, (g = s2 == null ? void 0 : s2.bufferRadius) != null ? g : fT, c2)), this.generatePath(d));
  }
  simplifyAllSteps(t3, e2, i) {
    var p, d;
    let o = [], n = [t3[0]];
    for (let f = 1; f < t3.length; f++) if (this.groupBy !== "default" && t3[f].origin.properties[this.groupBy] !== t3[f - 1].origin.properties[this.groupBy]) {
      let g = t3[f - 1].origin.properties[this.groupBy], v2 = (p = this.geometryEdgesByMapId.get(g)) != null ? p : [];
      o.push(...this.simplifySteps(n, v2, e2, i)), n = [t3[f]];
    } else n.push(t3[f]);
    let s2 = t3[t3.length - 1], c2 = this.groupBy === "default" ? this.groupBy : s2.origin.properties[this.groupBy], l = (d = this.geometryEdgesByMapId.get(c2)) != null ? d : [];
    return o.push(...this.simplifySteps(n, l, e2, i)), o;
  }
  simplifySteps(t3, e2, i, o) {
    if (t3.length < 3) return t3;
    let n = [t3[0]], s2 = 1;
    for (let c2 = s2 + 2; c2 < t3.length; c2++) if (t3[s2].origin.properties.preventSmoothing || !_4(t3[s2].origin, t3[c2].origin, e2, i)) {
      let l = c2 - 1;
      n.push(new jn2({ ...t3[s2], destination: t3[l].origin, distance: Mr(t3[s2].origin.geometry.coordinates, t3[l].origin.geometry.coordinates), angle: Bi2(t3[s2].origin.geometry.coordinates, t3[l].origin.geometry.coordinates) })), s2 = l;
    }
    return n.push(new jn2({ ...t3[s2], destination: t3[t3.length - 1].origin, distance: Mr(t3[s2].origin.geometry.coordinates, t3[t3.length - 1].origin.geometry.coordinates), angle: Bi2(t3[s2].origin.geometry.coordinates, t3[t3.length - 1].origin.geometry.coordinates), multiplicativeDistanceWeightScaling: o }), t3[t3.length - 1]), n;
  }
};
c();
function sr(r3) {
  return r3.verticalOffset === 0 ? [r3.longitude, r3.latitude] : [r3.longitude, r3.latitude, r3.verticalOffset];
}
function mT(r3) {
  return new Map(r3.map((t3) => {
    let { properties: e2 } = t3, { id: i } = e2;
    return [i, t3];
  }));
}
var ly2 = (r3, t3) => {
  let e2 = mT(t3), i = { entrances: { type: "FeatureCollection", features: [] }, walls: { type: "Feature", properties: { id: r3[0].properties.id }, geometry: { type: "MultiLineString", coordinates: [] } } };
  for (let o of r3) {
    let n = [o.geometry.coordinates], s2 = (o.properties.entrances || []).reduce((c2, l) => (e2.has(l) && c2.push(e2.get(l)), c2), []);
    if (s2.length) {
      let { entrances: c2, obstructions: l } = Ag(o, s2);
      n = l.map((p) => p.geometry.coordinates), i.entrances.features.push(...c2);
    }
    i.walls.geometry.coordinates.push(...n);
  }
  return i;
};
function H4(r3, t3) {
  let e2 = { options: {} };
  if (!e2.options) throw new Error("options should exist");
  return r3.text && (e2.text = r3.text), r3.appearance && (e2.options.appearance = r3.appearance), r3.rank != null && (r3.rank === "initial" ? e2.options.rank = t3.initialRank || 2 : e2.options.rank = r3.rank), r3.enabled !== void 0 && (e2.enabled = r3.enabled), r3.interactive !== null && (e2.options.interactive = r3.interactive), r3.enabled !== null && (e2.enabled = r3.enabled), e2;
}
function W4(r3, t3) {
  let e2 = { options: {} };
  if (!e2.options) throw new Error("options should exist");
  return r3.rank != null && (r3.rank === "initial" ? e2.options.rank = t3.initialRank || 2 : e2.options.rank = r3.rank), r3.enabled != null && (e2.enabled = r3.enabled), r3.interactive != null && (e2.options.interactive = r3.interactive), r3.enabled !== null && (e2.enabled = r3.enabled), e2;
}
function Hd(r3, t3) {
  var i, o;
  let e2 = {};
  return t3 == null || (r3.color && (r3.color === "initial" ? e2.color = t3.initialColor : e2.color = r3.color), r3.topColor && (r3.topColor === "initial" ? e2.topColor = t3.initialTopColor : e2.topColor = r3.topColor), r3.visible !== void 0 && (e2.visible = r3.visible), ((i = r3.texture) == null ? void 0 : i.url) !== void 0 && (e2.texture = r3.texture.url), ((o = r3.topTexture) == null ? void 0 : o.url) !== void 0 && (e2.topTexture = r3.topTexture.url), r3.opacity !== void 0 && (e2.opacity = r3.opacity)), e2;
}
function cy2(r3, t3) {
  var i, o;
  let e2 = {};
  return t3 == null || (r3.color && (r3.color === "initial" ? e2.color = t3.initialColor : e2.color = r3.color), r3.topColor && (r3.topColor === "initial" ? e2.topColor = t3.initialTopColor : e2.topColor = r3.topColor), r3.visible !== void 0 && (e2.visible = r3.visible), ((i = r3.texture) == null ? void 0 : i.url) !== void 0 && (e2.texture = r3.texture.url), ((o = r3.topTexture) == null ? void 0 : o.url) !== void 0 && (e2.topTexture = r3.topTexture.url), r3.height !== void 0 && (e2.height = r3.height), r3.opacity !== void 0 && (e2.opacity = r3.opacity)), e2;
}
function X4(r3, t3) {
  var i, o;
  let e2 = {};
  return t3 == null || (r3.color && (r3.color === "initial" ? e2.color = t3.initialColor : e2.color = r3.color), r3.topColor && (r3.topColor === "initial" ? e2.topColor = t3.initialTopColor : e2.topColor = r3.topColor), r3.visible !== void 0 && (e2.visible = r3.visible), ((i = r3.texture) == null ? void 0 : i.url) !== void 0 && (e2.texture = r3.texture.url), ((o = r3.topTexture) == null ? void 0 : o.url) !== void 0 && (e2.topTexture = r3.topTexture.url), r3.hoverColor !== void 0 && (e2.hoverColor = r3.hoverColor), r3.interactive !== void 0 && (e2.interactive = r3.interactive), r3.height !== void 0 && (e2.height = r3.height), r3.opacity !== void 0 && (e2.opacity = r3.opacity), r3.flipImageToFaceCamera !== void 0 && (e2.flipImageToFaceCamera = r3.flipImageToFaceCamera)), e2;
}
function Y4(r3) {
  let t3 = {};
  return r3.opacity !== void 0 && (t3.opacity = r3.opacity), t3;
}
function Z4(r3, t3) {
  return ((t3 - r3 + Math.PI) % (Math.PI * 2) + Math.PI * 2) % (Math.PI * 2) - Math.PI;
}
function z4(r3, t3) {
  let e2 = "Left";
  return r3 <= -Math.PI / 4 ? e2 = "Right" : r3 <= -t3 ? e2 = "SlightRight" : r3 <= t3 ? e2 = "Straight" : r3 <= Math.PI / 4 ? e2 = "SlightLeft" : e2 = "Left", e2;
}
function q4(r3) {
  let t3 = {};
  for (let e2 in r3) {
    let i = r3[e2];
    if (i != null) {
      if (i.id = e2, "polygons" in i) for (let o of i.polygons) t3[o] = i;
      else if ("lineStrings" in i) for (let o of i.lineStrings) t3[o] = i;
      else if ("points" in i) for (let o of i.points) t3[o] = i;
    }
  }
  return t3;
}
function Wd(r3, t3) {
  return r3.reduce((e2, i) => {
    let o = t3[i.properties.id];
    if (o == null) return e2;
    if ("textures" in i.properties && Array.isArray(i.properties.textures) && i.properties.textures.length > 0) {
      let n = { ...o, id: o.id + "-textures" };
      e2.set(n, [i]);
    } else e2.has(o) || e2.set(o, []), e2.get(o).push(i);
    return e2;
  }, /* @__PURE__ */ new Map());
}
function gs2(r3, t3 = {}) {
  var o, n, s2, c2, l, p, d;
  let e2 = { ...r3, flipImageToFaceCamera: (o = t3 == null ? void 0 : t3.flipImagesToFaceCamera) != null ? o : true }, i = (s2 = (n = t3 == null ? void 0 : t3.style) == null ? void 0 : n.shading) != null ? s2 : t3 == null ? void 0 : t3.shadingAndOutlines;
  if (i === true ? e2.shading = { start: 0.1, end: 0.15, intensity: 0.4 } : typeof i == "object" && (e2.shading = { start: i.start, end: i.end, intensity: i.intensity }), e2.outline = (l = (c2 = t3 == null ? void 0 : t3.style) == null ? void 0 : c2.outlines) != null ? l : t3 == null ? void 0 : t3.shadingAndOutlines, "lineStrings" in r3) {
    let f = (d = (p = t3 == null ? void 0 : t3.style) == null ? void 0 : p.wallTopColor) != null ? d : t3 == null ? void 0 : t3.wallTopColor;
    f != null && (e2.topColor = f);
  }
  return e2;
}
var $4 = (r3, t3) => {
  var o;
  let i = ((o = t3.currentMap) == null ? void 0 : o.currentFloor).layers.get(we);
  switch (r3) {
    case "interior-walls":
      return i == null ? void 0 : i.layers.get(Do);
    case "exterior-walls":
      return i == null ? void 0 : i.layers.get(ei);
    case "interior-doors":
      return i == null ? void 0 : i.layers.get(ss);
    case "exterior-doors":
      return i == null ? void 0 : i.layers.get(ls);
    default:
      return typeof r3 == "string" ? r3 : r3.id;
  }
};
function py2(r3) {
  return new Promise((t3) => {
    r3.onComplete(t3), r3.onStop(t3);
  });
}
function Xd(r3) {
  return r3.bbox ? r3.bbox : tl2(r3);
}
function J4(r3, t3) {
  return [Math.min(r3[0], t3[0]), Math.min(r3[1], t3[1]), Math.max(r3[2], t3[2]), Math.max(r3[3], t3[3])];
}
function Q4(r3) {
  return [...new Set(r3)];
}
function uy2(r3, t3, e2) {
  return r3.floorId && t3.has(r3.floorId) ? t3.get(r3.floorId) : e2;
}
var K4 = Math.PI * 0.1;
var Ve;
var bt;
var Mt;
var Hn;
var Wn;
var _i;
var Xn;
var bs;
var lr;
var e5;
var ys;
var t5;
var zd = class {
  constructor(t3, e2, i, o) {
    v(this, lr);
    v(this, Ve, {});
    v(this, bt);
    v(this, Mt);
    v(this, Hn);
    v(this, Wn);
    v(this, _i);
    v(this, Xn);
    v(this, bs);
    w(this, bt, e2), w(this, Mt, t3.features), w(this, Hn, i), w(this, Wn, o);
  }
  get path() {
    return u(this, Mt).map((t3) => u(this, bt).getById("node", t3.properties.id)).filter(Boolean);
  }
  get departure() {
    if (u(this, Ve).departure) return u(this, Ve).departure;
    let t3 = u(this, Mt)[0].properties.id, e2 = u(this, Hn)[0];
    if (u(this, Hn).length > 1) {
      for (let i of u(this, Hn)) if (mc(i, u(this, bt)).includes(t3)) {
        e2 = i;
        break;
      }
    }
    return u(this, Ve).departure = e2, e2;
  }
  get destination() {
    if (u(this, Ve).destination) return u(this, Ve).destination;
    let t3 = u(this, Mt)[u(this, Mt).length - 1].properties.id, e2 = u(this, Wn)[0];
    if (u(this, Wn).length > 1) {
      for (let i of u(this, Wn)) if (mc(i, u(this, bt)).includes(t3)) {
        e2 = i;
        break;
      }
    }
    return u(this, Ve).destination = e2, e2;
  }
  get coordinates() {
    return u(this, Ve).coordinates ? u(this, Ve).coordinates : (u(this, Ve).coordinates = u(this, Mt).map((t3) => new K2(t3.geometry.coordinates[1], t3.geometry.coordinates[0], t3.properties.groupBy)), u(this, Ve).coordinates);
  }
  get distance() {
    return u(this, Ve).distance ? u(this, Ve).distance : (u(this, Ve).distance = u(this, Mt).reduce((t3, e2) => t3 + (e2.properties.distance || 0), 0), u(this, Ve).distance);
  }
  get instructions() {
    if (u(this, Mt).length < 2) return [];
    if (u(this, Ve).instructions) return u(this, Ve).instructions;
    let t3 = [], e2 = 0;
    for (let i = 0; i < u(this, Mt).length; i++) {
      let o = u(this, Mt)[i], n = u(this, Mt)[i - 1], s2 = u(this, Mt)[i + 1], c2 = new K2(o.geometry.coordinates[1], o.geometry.coordinates[0], o.properties.groupBy), l = x(this, lr, e5).call(this, { prevDirection: n, direction: o, nextDirection: s2 });
      e2 += (n == null ? void 0 : n.properties.distance) || 0;
      for (let p of l) p && (t3.push({ action: p, distance: e2, coordinate: c2, node: u(this, bt).getById("node", o.properties.id) }), e2 = 0);
    }
    return u(this, Ve).instructions = t3, u(this, Ve).instructions;
  }
};
Ve = /* @__PURE__ */ new WeakMap(), bt = /* @__PURE__ */ new WeakMap(), Mt = /* @__PURE__ */ new WeakMap(), Hn = /* @__PURE__ */ new WeakMap(), Wn = /* @__PURE__ */ new WeakMap(), _i = /* @__PURE__ */ new WeakMap(), Xn = /* @__PURE__ */ new WeakMap(), bs = /* @__PURE__ */ new WeakMap(), lr = /* @__PURE__ */ new WeakSet(), e5 = function(t3) {
  var b, C;
  let { prevDirection: e2, direction: i, nextDirection: o } = t3, n = e2 && u(this, bt).getById("floor", e2.properties.groupBy), s2 = u(this, bt).getById("floor", i.properties.groupBy), c2 = o && u(this, bt).getById("floor", o.properties.groupBy), l = [];
  e2 || l.push({ type: "Departure" });
  let p = u(this, bt).getMVFFeatureByNodeId("connection", i.properties.id), d = p ? u(this, bt).getById("connection", p.id) : void 0, f = p && p.nodes.length > 1, g = u(this, bt).enterpriseMode && (!i.properties.destination || !(p != null && p.nodes.includes(i.properties.destination)) || !(p != null && p.nodes.includes(i.properties.id)));
  if (p && !(!f || g)) if (!u(this, _i) || u(this, _i) === "exit") l.push(x(this, lr, ys).call(this, "TakeConnection", s2, c2, d, p)), w(this, _i, "take"), w(this, Xn, d), w(this, bs, p);
  else {
    let y = u(this, bt).getMVFFeatureByNodeId("connection", (b = e2 == null ? void 0 : e2.properties.id) != null ? b : ""), S = u(this, bt).getById("connection", (C = y == null ? void 0 : y.id) != null ? C : "");
    l.push(x(this, lr, ys).call(this, "ExitConnection", s2, n, S, y)), w(this, _i, "exit"), w(this, Xn, d), w(this, bs, p);
  }
  else u(this, _i) === "take" ? (l.push(x(this, lr, ys).call(this, "ExitConnection", s2, n, u(this, Xn), u(this, bs))), w(this, _i, "exit"), w(this, Xn, d)) : c2 && s2.id !== c2.id ? l.push(x(this, lr, ys).call(this, "TakeConnection", s2, c2, d)) : n && n.id !== s2.id ? l.push(x(this, lr, ys).call(this, "ExitConnection", s2, n, d)) : l.push(x(this, lr, t5).call(this, e2, i));
  return o || l.push({ type: "Arrival" }), l;
}, ys = function(t3, e2, i, o, n) {
  var l, p;
  let s2 = "none";
  if (e2.elevation != null && (i == null ? void 0 : i.elevation) != null) {
    let d = e2.elevation - i.elevation;
    d > 0 ? s2 = "down" : d < 0 && (s2 = "up");
  }
  let c2 = (p = (l = o == null ? void 0 : o.type) != null ? l : n == null ? void 0 : n.type) != null ? p : "stairs";
  return { type: t3, fromFloor: e2, toFloor: i, direction: s2, connection: o, connectionType: c2 };
}, t5 = function(t3, e2) {
  let i = e2.properties.edges;
  if (!i || i.filter((s2) => s2.destination.properties.id !== (t3 == null ? void 0 : t3.properties.id) && s2.destination.properties.id !== e2.properties.destination).length === 0) return null;
  let n = t3 ? -Z4(t3.properties.angle, e2.properties.angle) : 0;
  return Math.abs(n) >= K4 ? { type: "Turn", bearing: z4(n, K4), referencePosition: "At" } : null;
};
var qd = class {
  constructor({ nodes: t3, geojsonCollection: e2, connections: i, groupBy: o, multiplicativeDistanceWeightScaling: n }) {
    t(this, "navigator");
    t(this, "connections");
    t(this, "getDirections", (t4, e3, i2, o2) => {
      let { accessible: n2, smoothing: { enabled: s2, radius: c2 } } = i2, l = t4.flatMap((b) => mc(b, o2)), p = e3.flatMap((b) => mc(b, o2)), d = this.getExcludedNodeIds(i2.excludedConnections).filter((b) => !l.includes(b) && !p.includes(b)), f = this.getDisabledConnectionNodeIds(n2).filter((b) => !l.includes(b) && !p.includes(b)), g = this.navigator.getDirections({ zones: i2.zones.map((b) => {
        var C;
        return { geometry: b.geometry, cost: b.cost, map: (C = b.floor) == null ? void 0 : C.id };
      }), originIds: l, destinationNodeIds: p, excludedNodeIds: d, disabledConnectionNodeIds: f, simplify: { enabled: s2, bufferRadius: c2 }, multiplicativeDistanceWeightScaling: !o2.enterpriseMode });
      this.addCoordinateDirections(g, t4, e3);
      let v2 = new zd(g, o2, t4, e3);
      if (!(v2.distance === 0 && (/* @__PURE__ */ new Set([...l, ...p])).size === l.length + p.length)) return v2;
    });
    t(this, "getExcludedNodeIds", (t4) => {
      if (t4.length === 0) return [];
      let e3 = new Set(t4.map((i2) => i2.id));
      return this.connections.reduce((i2, o2) => e3.has(o2.id) ? i2.concat(o2.nodes) : i2, []);
    });
    t(this, "getDisabledConnectionNodeIds", (t4) => t4 === false ? [] : this.connections.reduce((e3, i2) => i2.accessible ? e3 : e3.concat(i2.nodes), []));
    t(this, "addCoordinateDirections", (t4, [e3], [i2]) => {
      if (t4.features.length) {
        if (K2.is(e3)) {
          let o2 = this.createDirectionFeature(e3, this.navigator.getAngle([e3.longitude, e3.latitude], t4.features[0].geometry.coordinates), this.navigator.getDistance([e3.longitude, e3.latitude], t4.features[0].geometry.coordinates));
          t4.features.splice(0, 0, o2);
        }
        if (K2.is(i2)) {
          let o2 = this.createDirectionFeature(i2, 0, 0), n2 = t4.features[t4.features.length - 1];
          n2.properties.distance = this.navigator.getDistance(n2.geometry.coordinates, [i2.longitude, i2.latitude]), n2.properties.angle = this.navigator.getAngle(n2.geometry.coordinates, [i2.longitude, i2.latitude]), t4.features.push(o2);
        }
      }
    });
    t(this, "createDirectionFeature", (t4, e3, i2) => ({ type: "Feature", geometry: { type: "Point", coordinates: [t4.longitude, t4.latitude] }, properties: { groupBy: t4.floorId, id: t4.id, angle: e3, distance: i2, edges: [] } }));
    this.navigator = new ms({ nodes: t3, geojsonCollection: this.createCollection(e2), groupBy: o, multiplicativeDistanceWeightScaling: n }), this.connections = i;
  }
  createCollection(t3) {
    return { type: "FeatureCollection", features: Object.entries(t3).reduce((e2, [i, o]) => e2.concat(o.features.map((n) => (n.properties.map = i, n))), []) };
  }
};
function mc(r3, t3) {
  var e2, i, o, n;
  if (fs2.is(r3)) return r3.navigationTarget.flatMap((s2) => mc(s2, t3));
  if (wo.is(r3)) {
    let s2 = t3.Query.nearest(r3, { types: ["node"] });
    return (e2 = s2 == null ? void 0 : s2[0]) != null && e2.feature.id ? [s2[0].feature.id] : [];
  } else if (K2.is(r3)) {
    let s2 = t3.Query.nearest(r3, { types: ["node"] });
    return (i = s2 == null ? void 0 : s2[0]) != null && i.feature.id ? [s2[0].feature.id] : [];
  } else if (To.is(r3)) {
    let s2 = t3.Query.nearest(r3, { types: ["node"] });
    return (o = s2 == null ? void 0 : s2[0]) != null && o.feature.id ? [s2[0].feature.id] : [];
  } else if (Qr.is(r3)) {
    let s2 = t3 == null ? void 0 : t3.getMVFFeatureById("entrance", r3.id);
    return s2 != null && s2.properties.node ? [s2 == null ? void 0 : s2.properties.node] : [];
  } else if (Po.is(r3)) {
    let s2 = t3 == null ? void 0 : t3.getMVFFeatureById("area", r3.id);
    return (n = s2 == null ? void 0 : s2.properties.destinationNodes) != null ? n : [];
  } else if (He.is(r3)) {
    let s2 = t3 == null ? void 0 : t3.getMVFFeatureById("space", r3.id);
    return s2 == null ? [] : s2.properties.destinationNodes;
  } else {
    if (Fn.is(r3)) return r3.coordinates.reduce((s2, c2) => {
      var p;
      let l = t3.Query.nearest(c2, { types: ["node"] });
      return (p = l == null ? void 0 : l[0]) != null && p.feature.id && s2.push(l[0].feature.id), s2;
    }, []);
    if (zt.is(r3)) {
      let s2 = t3 == null ? void 0 : t3.objectEntranceNodeIdsByObstructionId[r3.id];
      return s2 != null ? s2 : [];
    } else return xr.is(r3) ? r3.spaces.flatMap((s2) => {
      var c2, l;
      return (l = (c2 = t3 == null ? void 0 : t3.getMVFFeatureById("space", s2.id)) == null ? void 0 : c2.properties.destinationNodes) != null ? l : [];
    }).filter((s2) => typeof s2 == "string") : Li.is(r3) ? r3.nodes.map((s2) => s2.id) : xo.is(r3) ? [r3.id] : [];
  }
}
c();
c();
c();
c();
c();
c();
function r5(r3) {
  let t3 = +this._x.call(null, r3), e2 = +this._y.call(null, r3);
  return i5(this.cover(t3, e2), t3, e2, r3);
}
function i5(r3, t3, e2, i) {
  if (isNaN(t3) || isNaN(e2)) return r3;
  var o, n = r3._root, s2 = { data: i }, c2 = r3._x0, l = r3._y0, p = r3._x1, d = r3._y1, f, g, v2, b, C, y, S, T;
  if (!n) return r3._root = s2, r3;
  for (; n.length; ) if ((C = t3 >= (f = (c2 + p) / 2)) ? c2 = f : p = f, (y = e2 >= (g = (l + d) / 2)) ? l = g : d = g, o = n, !(n = n[S = y << 1 | C])) return o[S] = s2, r3;
  if (v2 = +r3._x.call(null, n.data), b = +r3._y.call(null, n.data), t3 === v2 && e2 === b) return s2.next = n, o ? o[S] = s2 : r3._root = s2, r3;
  do
    o = o ? o[S] = new Array(4) : r3._root = new Array(4), (C = t3 >= (f = (c2 + p) / 2)) ? c2 = f : p = f, (y = e2 >= (g = (l + d) / 2)) ? l = g : d = g;
  while ((S = y << 1 | C) === (T = (b >= g) << 1 | v2 >= f));
  return o[T] = n, o[S] = s2, r3;
}
function o5(r3) {
  var t3, e2, i = r3.length, o, n, s2 = new Array(i), c2 = new Array(i), l = 1 / 0, p = 1 / 0, d = -1 / 0, f = -1 / 0;
  for (e2 = 0; e2 < i; ++e2) isNaN(o = +this._x.call(null, t3 = r3[e2])) || isNaN(n = +this._y.call(null, t3)) || (s2[e2] = o, c2[e2] = n, o < l && (l = o), o > d && (d = o), n < p && (p = n), n > f && (f = n));
  if (l > d || p > f) return this;
  for (this.cover(l, p).cover(d, f), e2 = 0; e2 < i; ++e2) i5(this, s2[e2], c2[e2], r3[e2]);
  return this;
}
c();
function n5(r3, t3) {
  if (isNaN(r3 = +r3) || isNaN(t3 = +t3)) return this;
  var e2 = this._x0, i = this._y0, o = this._x1, n = this._y1;
  if (isNaN(e2)) o = (e2 = Math.floor(r3)) + 1, n = (i = Math.floor(t3)) + 1;
  else {
    for (var s2 = o - e2 || 1, c2 = this._root, l, p; e2 > r3 || r3 >= o || i > t3 || t3 >= n; ) switch (p = (t3 < i) << 1 | r3 < e2, l = new Array(4), l[p] = c2, c2 = l, s2 *= 2, p) {
      case 0:
        o = e2 + s2, n = i + s2;
        break;
      case 1:
        e2 = o - s2, n = i + s2;
        break;
      case 2:
        o = e2 + s2, i = n - s2;
        break;
      case 3:
        e2 = o - s2, i = n - s2;
        break;
    }
    this._root && this._root.length && (this._root = c2);
  }
  return this._x0 = e2, this._y0 = i, this._x1 = o, this._y1 = n, this;
}
c();
function a5() {
  var r3 = [];
  return this.visit(function(t3) {
    if (!t3.length) do
      r3.push(t3.data);
    while (t3 = t3.next);
  }), r3;
}
c();
function s5(r3) {
  return arguments.length ? this.cover(+r3[0][0], +r3[0][1]).cover(+r3[1][0], +r3[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
}
c();
c();
function rt(r3, t3, e2, i, o) {
  this.node = r3, this.x0 = t3, this.y0 = e2, this.x1 = i, this.y1 = o;
}
function l5(r3, t3, e2) {
  var i, o = this._x0, n = this._y0, s2, c2, l, p, d = this._x1, f = this._y1, g = [], v2 = this._root, b, C;
  for (v2 && g.push(new rt(v2, o, n, d, f)), e2 == null ? e2 = 1 / 0 : (o = r3 - e2, n = t3 - e2, d = r3 + e2, f = t3 + e2, e2 *= e2); b = g.pop(); ) if (!(!(v2 = b.node) || (s2 = b.x0) > d || (c2 = b.y0) > f || (l = b.x1) < o || (p = b.y1) < n)) if (v2.length) {
    var y = (s2 + l) / 2, S = (c2 + p) / 2;
    g.push(new rt(v2[3], y, S, l, p), new rt(v2[2], s2, S, y, p), new rt(v2[1], y, c2, l, S), new rt(v2[0], s2, c2, y, S)), (C = (t3 >= S) << 1 | r3 >= y) && (b = g[g.length - 1], g[g.length - 1] = g[g.length - 1 - C], g[g.length - 1 - C] = b);
  } else {
    var T = r3 - +this._x.call(null, v2.data), w2 = t3 - +this._y.call(null, v2.data), M2 = T * T + w2 * w2;
    if (M2 < e2) {
      var D = Math.sqrt(e2 = M2);
      o = r3 - D, n = t3 - D, d = r3 + D, f = t3 + D, i = v2.data;
    }
  }
  return i;
}
c();
function c5(r3) {
  if (isNaN(d = +this._x.call(null, r3)) || isNaN(f = +this._y.call(null, r3))) return this;
  var t3, e2 = this._root, i, o, n, s2 = this._x0, c2 = this._y0, l = this._x1, p = this._y1, d, f, g, v2, b, C, y, S;
  if (!e2) return this;
  if (e2.length) for (; ; ) {
    if ((b = d >= (g = (s2 + l) / 2)) ? s2 = g : l = g, (C = f >= (v2 = (c2 + p) / 2)) ? c2 = v2 : p = v2, t3 = e2, !(e2 = e2[y = C << 1 | b])) return this;
    if (!e2.length) break;
    (t3[y + 1 & 3] || t3[y + 2 & 3] || t3[y + 3 & 3]) && (i = t3, S = y);
  }
  for (; e2.data !== r3; ) if (o = e2, !(e2 = e2.next)) return this;
  return (n = e2.next) && delete e2.next, o ? (n ? o.next = n : delete o.next, this) : t3 ? (n ? t3[y] = n : delete t3[y], (e2 = t3[0] || t3[1] || t3[2] || t3[3]) && e2 === (t3[3] || t3[2] || t3[1] || t3[0]) && !e2.length && (i ? i[S] = e2 : this._root = e2), this) : (this._root = n, this);
}
function p5(r3) {
  for (var t3 = 0, e2 = r3.length; t3 < e2; ++t3) this.remove(r3[t3]);
  return this;
}
c();
function u5() {
  return this._root;
}
c();
function d5() {
  var r3 = 0;
  return this.visit(function(t3) {
    if (!t3.length) do
      ++r3;
    while (t3 = t3.next);
  }), r3;
}
c();
function h5(r3) {
  var t3 = [], e2, i = this._root, o, n, s2, c2, l;
  for (i && t3.push(new rt(i, this._x0, this._y0, this._x1, this._y1)); e2 = t3.pop(); ) if (!r3(i = e2.node, n = e2.x0, s2 = e2.y0, c2 = e2.x1, l = e2.y1) && i.length) {
    var p = (n + c2) / 2, d = (s2 + l) / 2;
    (o = i[3]) && t3.push(new rt(o, p, d, c2, l)), (o = i[2]) && t3.push(new rt(o, n, d, p, l)), (o = i[1]) && t3.push(new rt(o, p, s2, c2, d)), (o = i[0]) && t3.push(new rt(o, n, s2, p, d));
  }
  return this;
}
c();
function f5(r3) {
  var t3 = [], e2 = [], i;
  for (this._root && t3.push(new rt(this._root, this._x0, this._y0, this._x1, this._y1)); i = t3.pop(); ) {
    var o = i.node;
    if (o.length) {
      var n, s2 = i.x0, c2 = i.y0, l = i.x1, p = i.y1, d = (s2 + l) / 2, f = (c2 + p) / 2;
      (n = o[0]) && t3.push(new rt(n, s2, c2, d, f)), (n = o[1]) && t3.push(new rt(n, d, c2, l, f)), (n = o[2]) && t3.push(new rt(n, s2, f, d, p)), (n = o[3]) && t3.push(new rt(n, d, f, l, p));
    }
    e2.push(i);
  }
  for (; i = e2.pop(); ) r3(i.node, i.x0, i.y0, i.x1, i.y1);
  return this;
}
c();
function m5(r3) {
  return r3[0];
}
function g5(r3) {
  return arguments.length ? (this._x = r3, this) : this._x;
}
c();
function y5(r3) {
  return r3[1];
}
function b5(r3) {
  return arguments.length ? (this._y = r3, this) : this._y;
}
function gc(r3, t3, e2) {
  var i = new dy2(t3 == null ? m5 : t3, e2 == null ? y5 : e2, NaN, NaN, NaN, NaN);
  return r3 == null ? i : i.addAll(r3);
}
function dy2(r3, t3, e2, i, o, n) {
  this._x = r3, this._y = t3, this._x0 = e2, this._y0 = i, this._x1 = o, this._y1 = n, this._root = void 0;
}
function v5(r3) {
  for (var t3 = { data: r3.data }, e2 = t3; r3 = r3.next; ) e2 = e2.next = { data: r3.data };
  return t3;
}
var Tt = gc.prototype = dy2.prototype;
Tt.copy = function() {
  var r3 = new dy2(this._x, this._y, this._x0, this._y0, this._x1, this._y1), t3 = this._root, e2, i;
  if (!t3) return r3;
  if (!t3.length) return r3._root = v5(t3), r3;
  for (e2 = [{ source: t3, target: r3._root = new Array(4) }]; t3 = e2.pop(); ) for (var o = 0; o < 4; ++o) (i = t3.source[o]) && (i.length ? e2.push({ source: i, target: t3.target[o] = new Array(4) }) : t3.target[o] = v5(i));
  return r3;
};
Tt.add = r5;
Tt.addAll = o5;
Tt.cover = n5;
Tt.data = a5;
Tt.extent = s5;
Tt.find = l5;
Tt.remove = c5;
Tt.removeAll = p5;
Tt.root = u5;
Tt.size = d5;
Tt.visit = h5;
Tt.visitAfter = f5;
Tt.x = g5;
Tt.y = b5;
var qt;
var ko;
var $d = class {
  constructor(t3) {
    v(this, qt, {});
    v(this, ko);
    w(this, ko, t3);
  }
  getTreeByType(t3, e2, i) {
    var s2;
    if (u(this, qt)[t3] || (u(this, qt)[t3] = {}), u(this, qt)[t3][e2] && u(this, qt)[t3][e2][i]) return u(this, qt)[t3][e2][i];
    u(this, qt)[t3][e2] || (u(this, qt)[t3][e2] = {}), u(this, qt)[t3][e2][i] || (u(this, qt)[t3][e2][i] = gc());
    let o = u(this, qt)[t3][e2][i];
    o.x((c2) => c2.geometry.coordinates[1]), o.y((c2) => c2.geometry.coordinates[0]);
    let n = [];
    switch (t3) {
      case "node":
        n = ((s2 = u(this, ko).directions.navigator.graph.nodesByGroup.get(i)) == null ? void 0 : s2.filter((c2) => c2.properties.neighbors.length > 0)) || [];
        break;
      case "point-of-interest":
        n = u(this, ko).mvfPoisByFloorId[i] || [];
        break;
      case "door":
        n = u(this, ko).mvfEntrancesByFloorId[i] || [];
        break;
      case "annotation":
        n = u(this, ko).mvfAnnotationsByFloorId[i] || [];
        break;
    }
    return (n == null ? void 0 : n.length) > 0 && o.addAll(n), o;
  }
};
qt = /* @__PURE__ */ new WeakMap(), ko = /* @__PURE__ */ new WeakMap();
var gT = K.object({ limit: K.enum(["same-floor", "same-elevation"]).optional(), radius: K.number().optional(), types: K.array(K.enum(["node", "point-of-interest"])).min(1) });
var oi;
var bc;
var yc = class {
  constructor(t3) {
    v(this, oi);
    v(this, bc);
    w(this, oi, t3), w(this, bc, new $d(u(this, oi)));
  }
  nearest(t3, e2) {
    try {
      gT.parse(e2);
    } catch (s2) {
      Lt.error(s2);
      return;
    }
    let i = $l(t3);
    if (!i) return;
    let o = i.floorId ? [i.floorId] : [];
    if (i.floorId == null) for (let s2 of u(this, oi).getByType("floor-stack")) {
      let c2 = s2.defaultFloor;
      c2 && o.push(c2.id);
    }
    else if (e2.limit === "same-elevation") {
      let s2 = u(this, oi).floorsById[i.floorId];
      if (s2) {
        let c2 = s2 == null ? void 0 : s2.elevation;
        c2 && (o = u(this, oi).getByType("floor-stack").map((l) => {
          var p;
          return (p = l.floors.find((d) => d.elevation === c2)) == null ? void 0 : p.id;
        }).filter(Boolean));
      }
    }
    let n = [];
    for (let s2 of Q4(e2.types)) for (let c2 of o) {
      let l = u(this, bc).getTreeByType(s2, u(this, oi).mapName, c2).find(i.latitude, i.longitude, e2.radius);
      if (l) {
        let p = u(this, oi).getById(s2, l == null ? void 0 : l.properties.id);
        p && n.push({ distance: Mr([i.longitude, i.latitude], l.geometry.coordinates), feature: p });
      }
    }
    return n.sort((s2, c2) => s2.distance - c2.distance);
  }
};
oi = /* @__PURE__ */ new WeakMap(), bc = /* @__PURE__ */ new WeakMap();
c();
c();
var vc;
var Jd = class {
  constructor(t3) {
    v(this, vc);
    w(this, vc, t3 || []);
  }
  get raw() {
    return u(this, vc);
  }
};
vc = /* @__PURE__ */ new WeakMap();
var ct;
var H;
var Pe2;
var Cc = class Cc2 extends ze2 {
  constructor(e2, i) {
    super(i.mvfData.id);
    t(this, "__type", Cc2.__type);
    t(this, "id", "loc_");
    t(this, "name", "");
    t(this, "externalId");
    t(this, "description");
    t(this, "logo");
    t(this, "phone");
    t(this, "social", []);
    t(this, "images", []);
    t(this, "links", []);
    t(this, "website");
    t(this, "icon");
    v(this, ct);
    v(this, H, {});
    v(this, Pe2);
    w(this, ct, e2), w(this, Pe2, i.mvfData);
    for (let o in i.mvfData) o === "links" ? this.links = i.mvfData.links.map((n) => new Pn({ mvfData: n })) : o === "pictures" ? this.images = i.mvfData.pictures.map((n) => {
      var s2;
      return n.url ? new Mn({ mvfData: { ...n, url: (s2 = n.url) != null ? s2 : "" }, mapData: u(this, ct) }) : void 0;
    }).filter((n) => n != null) : o === "website" ? i.mvfData.website && (this.website = new Pn({ mvfData: i.mvfData.website })) : o === "icon" ? i.mvfData.icon && (this.icon = new Mn({ mvfData: { url: i.mvfData.icon }, mapData: u(this, ct) })) : Object.getOwnPropertyDescriptor(Object.getPrototypeOf(this), o) || Object.defineProperty(this, o, { enumerable: true, get() {
      return u(this, Pe2)[o];
    } });
  }
  static is(e2) {
    return e2.__type === Cc2.__type;
  }
  get spaces() {
    if (u(this, H).spaces) return u(this, H).spaces;
    if (u(this, Pe2).spaces == null) return u(this, H).spaces = [], u(this, H).spaces;
    u(this, H).spaces = [];
    for (let e2 = 0; e2 < u(this, Pe2).spaces.length; e2++) {
      let i = u(this, ct).getById("space", u(this, Pe2).spaces[e2].id);
      i && u(this, H).spaces.push(i);
    }
    return u(this, H).spaces;
  }
  get points() {
    if (u(this, H).points) return u(this, H).points;
    if (u(this, Pe2).spaces == null) return u(this, H).points = [], u(this, H).points;
    u(this, H).points = [];
    for (let e2 = 0; e2 < u(this, Pe2).spaces.length; e2++) {
      let i = u(this, ct).getById("point-of-interest", u(this, Pe2).spaces[e2].id);
      i && u(this, H).points.push(i);
    }
    return u(this, H).points;
  }
  get doors() {
    if (u(this, H).doors) return u(this, H).doors;
    if (u(this, Pe2).entrances == null) return u(this, H).doors = [], u(this, H).doors;
    u(this, H).doors = [];
    for (let e2 = 0; e2 < u(this, Pe2).entrances.length; e2++) {
      let i = u(this, ct).getById("door", u(this, Pe2).entrances[e2].id);
      i && u(this, H).doors.push(i);
    }
    return u(this, H).doors;
  }
  get connections() {
    var i;
    if (u(this, H).connections) return u(this, H).connections;
    if (u(this, Pe2).connections == null) return u(this, H).connections = [], u(this, H).connections;
    let e2 = /* @__PURE__ */ new Set();
    for (let o = 0; o < u(this, Pe2).connections.length; o++) {
      let n = u(this, Pe2).connections[o], s2 = u(this, ct).mvfConnectionsById[n], l = (s2 == null ? [] : s2.nodes).map((p) => u(this, ct).getById("node", p)).filter(Boolean);
      for (let p of l) {
        if (p == null) continue;
        let d = Jr2([p.coordinate.longitude, p.coordinate.latitude]), g = ((i = u(this, ct).connectionSpaceIdsByLatLon[d]) != null ? i : []).map((v2) => u(this, ct).connectionsById[v2]).filter((v2) => v2 != null);
        for (let v2 of g) e2.add(v2);
      }
    }
    return u(this, H).connections = Array.from(e2), u(this, H).connections;
  }
  get annotations() {
    if (u(this, H).annotations) return u(this, H).annotations;
    if (u(this, Pe2).annotations == null) return u(this, H).annotations = [], u(this, H).annotations;
    u(this, H).annotations = [];
    for (let e2 = 0; e2 < u(this, Pe2).annotations.length; e2++) {
      let i = u(this, ct).getById("annotation", u(this, Pe2).annotations[e2].id);
      i && u(this, H).annotations.push(i);
    }
    return u(this, H).annotations;
  }
  get categories() {
    return u(this, H).categories ? u(this, H).categories : u(this, Pe2).categories == null ? (u(this, H).categories = [], u(this, H).categories) : (u(this, H).categories = u(this, Pe2).categories.map((e2) => u(this, ct).getById("location-category", e2)).filter((e2) => e2 != null), u(this, H).categories);
  }
  get mapObjects() {
    return u(this, H).mapObjects ? u(this, H).mapObjects : u(this, Pe2).obstructions == null ? (u(this, H).mapObjects = [], u(this, H).mapObjects) : (u(this, H).mapObjects = u(this, Pe2).obstructions.map((e2) => u(this, ct).getById("object", e2.id)).filter((e2) => e2 != null), u(this, H).mapObjects);
  }
  get areas() {
    return u(this, H).areas ? u(this, H).areas : u(this, Pe2).areas == null ? (u(this, H).areas = [], u(this, H).areas) : (u(this, H).areas = u(this, Pe2).areas.map((e2) => u(this, ct).getById("area", e2.id)).filter((e2) => e2 != null), u(this, H).areas);
  }
  get focusTarget() {
    if (u(this, H).focusTarget) return u(this, H).focusTarget;
    let e2 = [];
    for (let i of this.spaces) e2.push(i);
    for (let i of this.connections) e2.push(...i.coordinates);
    for (let i of this.doors) e2.push(i.focusTarget);
    for (let i of this.mapObjects) e2.push(i.focusTarget);
    for (let i of this.annotations) e2.push(i.focusTarget);
    return u(this, H).focusTarget = e2, e2;
  }
  get openingHours() {
    var e2;
    return u(this, H).openingHours ? u(this, H).openingHours : (u(this, H).openingHours = new Jd((e2 = u(this, Pe2).openingHoursSpecification) != null ? e2 : []), u(this, H).openingHours);
  }
  get navigationTarget() {
    if (u(this, H).navigationTarget) return u(this, H).navigationTarget;
    let e2 = [];
    for (let i of this.spaces) e2.push(i);
    for (let i of this.connections) e2.push(...i.coordinates);
    for (let i of this.doors) e2.push(i.focusTarget);
    for (let i of this.mapObjects) e2.push(i.focusTarget);
    for (let i of this.annotations) e2.push(i.focusTarget);
    for (let i of this.points) e2.push(i.focusTarget);
    return u(this, H).navigationTarget = e2, e2;
  }
  toJSON() {
    return { id: this.id, name: this.name };
  }
};
ct = /* @__PURE__ */ new WeakMap(), H = /* @__PURE__ */ new WeakMap(), Pe2 = /* @__PURE__ */ new WeakMap(), t(Cc, "__type", "location-profile");
var hy2 = Cc;
var fs2 = hy2;
c();
var Bo;
var Nt2;
var Yn;
var Sc = class Sc2 extends ze2 {
  constructor(e2, i) {
    super(i.mvfData.id);
    t(this, "__type", Sc2.__type);
    t(this, "id", "cat_");
    t(this, "name", "");
    t(this, "icon", "");
    v(this, Bo);
    v(this, Nt2, {});
    v(this, Yn);
    w(this, Bo, e2), w(this, Yn, i.mvfData);
    for (let o in i.mvfData) Object.getOwnPropertyDescriptor(Object.getPrototypeOf(this), o) || Object.defineProperty(this, o, { enumerable: true, get() {
      return u(this, Yn)[o];
    } });
  }
  static is(e2) {
    return e2.__type === Sc2.__type;
  }
  get parent() {
    return u(this, Nt2).parent ? u(this, Nt2).parent : (u(this, Nt2).parent = u(this, Yn).parent ? u(this, Bo).getById("location-category", u(this, Yn).parent) : void 0, u(this, Nt2).parent);
  }
  get children() {
    return u(this, Nt2).children ? u(this, Nt2).children : (u(this, Nt2).children = u(this, Bo).locationCategoriesByParentId[this.id] || [], u(this, Nt2).children);
  }
  get locationProfiles() {
    if (u(this, Nt2).locationProfiles) return u(this, Nt2).locationProfiles;
    let e2 = [];
    for (let i of u(this, Bo).locationProfilesByCategoryId[this.id] || []) {
      let o = u(this, Bo).getById("location-profile", i.id);
      o && e2.push(o);
    }
    return u(this, Nt2).locationProfiles = e2, e2;
  }
  toJSON() {
    return { id: this.id, name: this.name };
  }
};
Bo = /* @__PURE__ */ new WeakMap(), Nt2 = /* @__PURE__ */ new WeakMap(), Yn = /* @__PURE__ */ new WeakMap(), t(Sc, "__type", "location-category");
var fy2 = Sc;
var Gd = fy2;
var q2;
var Qd;
var C5;
var vs2;
var Cs = class extends _n {
  constructor(e2, i) {
    var c2, l, p, d, f;
    super();
    v(this, Qd);
    t(this, "Analytics");
    v(this, q2, {});
    t(this, "Query");
    t(this, "mvf");
    t(this, "outdoorViewToken");
    t(this, "spaceIdsByDestinationNodeId");
    t(this, "objectEntranceNodeIdsByObstructionId");
    t(this, "obstructionIdByEntranceId");
    t(this, "venue");
    t(this, "tokenManager");
    t(this, "directions");
    t(this, "enterpriseMode", false);
    t(this, "nodesById");
    t(this, "spacesById");
    t(this, "floorsById");
    t(this, "floorStacksById");
    t(this, "facadesById");
    t(this, "facadesBySpaceId");
    t(this, "connectionsById");
    t(this, "objectsById");
    t(this, "doorsById");
    t(this, "pointsOfInterestById");
    t(this, "annotationsById");
    t(this, "areasById");
    t(this, "locationProfilesById");
    t(this, "locationCategoriesById");
    t(this, "locationProfilesByExternalId");
    t(this, "locationsById");
    t(this, "locationProfilesByCategoryId");
    t(this, "locationCategoriesByParentId");
    t(this, "categoriesById");
    t(this, "doorsByNodeId");
    t(this, "mvfLocationsBySpaceId");
    t(this, "locationIdsByNodeId");
    t(this, "spaceIdsByNodeId");
    t(this, "mvfAnnotationsById");
    t(this, "mvfConnectionsById");
    t(this, "mvfConnectionsByNodeId");
    t(this, "mvfConnectionIdsByLatLon");
    t(this, "mvfEntrancesById");
    t(this, "mvfNodesById");
    t(this, "mvfObstructionById");
    t(this, "mvfSpacesById");
    t(this, "mvfFloorsById");
    t(this, "mvfFloorStacksById");
    t(this, "mvfAreasById");
    t(this, "connectionSpaceIdsByLatLon");
    t(this, "locationProfilesByAttachedFeatureId");
    t(this, "spacesByExternalId");
    t(this, "nodesByExternalId");
    t(this, "objectsByExternalId");
    t(this, "poisByExternalId");
    t(this, "floorsByExternalId");
    t(this, "floorStacksByExternalId");
    t(this, "doorsByExternalId");
    t(this, "areasByExternalId");
    t(this, "connectionsByExternalId");
    t(this, "locationsByExternalId");
    t(this, "categoriesByExternalId");
    t(this, "mvfNodesByFloorId");
    t(this, "mvfSpacesByFloorId");
    t(this, "mvfPoisByFloorId");
    t(this, "mvfEntrancesByFloorId");
    t(this, "mvfAnnotationsByFloorId");
    t(this, "localePacksUrls");
    t(this, "currentLanguage");
    t(this, "languagePacks", {});
    t(this, "tilesets", {});
    t(this, "binaryBundle");
    t(this, "envControl");
    t(this, "getMapDataOptions");
    v(this, vs2);
    t(this, "getDirectionsMultiDestination", (e3, i2, o2) => this.getDirections(e3, i2, { ...o2, multiDestination: true }));
    t(this, "getDirections", (e3, i2, o2) => {
      let { accessible: n2 = false, smoothing: s4 = true, multiDestination: c3 = false } = o2 || {}, l2 = typeof s4 == "object" ? s4.enabled : s4, p3 = typeof s4 == "object" ? s4.radius : void 0, d2 = (o2 == null ? void 0 : o2.zones) || [], f3 = { accessible: n2, zones: d2, smoothing: { enabled: l2 != null ? l2 : true, radius: p3 != null ? p3 : 0.75 }, excludedConnections: (o2 == null ? void 0 : o2.excludedConnections) || [] };
      if (c3 && Array.isArray(i2)) {
        let g = Array.isArray(e3) ? e3 : [e3], v2 = [];
        for (let b of i2) {
          let C = Array.isArray(b) ? b : [b], y = this.directions.getDirections(g, C, f3, this);
          if (!y) {
            Lt.error("getDirections failed due to missing directions for one of the segments");
            return;
          }
          g = C, v2.push(y);
        }
        return v2;
      } else {
        let g = Array.isArray(e3) ? e3 : [e3], v2 = Array.isArray(i2) ? i2 : [i2];
        if (Array.isArray(v2[0])) {
          Lt.error("getDirections does not support multi-destination without multisegment option");
          return;
        }
        return g[0].id && v2[0].id && this.Analytics.sendGetDirectionsEvent(g[0].id, v2[0].id), this.directions.getDirections(g, v2, f3, this);
      }
    });
    t(this, "transformImageRequest", async (e3) => {
      var o2;
      if (this.enterpriseMode || !this.getMapDataOptions) return { url: e3 };
      if (!A4(e3)) return { url: e3 };
      if (F4(e3)) return { url: e3 };
      let i2 = Bd(e3);
      if (!i2) return { url: e3 };
      try {
        let n2 = await ((o2 = this.tokenManager) == null ? void 0 : o2.getSasTokensAsync()), s4 = n2 == null ? void 0 : n2[i2.mapId];
        if (s4 == null) throw new Error("SAS token not found");
        let [c3] = e3.split("?");
        return { url: "".concat(c3, "?").concat(s4.token) };
      } catch (n2) {
        return Lt.error("Failed to append SAS token to image request. Requests for private images may fail.", n2), { url: e3 };
      }
    });
    let o = (c2 = i == null ? void 0 : i.env) != null ? c2 : bn2();
    if (this.envControl = o, this.binaryBundle = i == null ? void 0 : i.binaryBundle, this.Analytics = new Ga(), this.localePacksUrls = (l = i == null ? void 0 : i.localePacksUrls) != null ? l : {}, this.mvf = e2, this.outdoorViewToken = i == null ? void 0 : i.outdoorViewToken, this.getMapDataOptions = i == null ? void 0 : i.getMapDataOptions, ((p = e2["tileset.json"]) == null ? void 0 : p.default) != null && (this.tilesets[e2["tileset.json"].default.key] = e2["tileset.json"].default, o.updateTileServerBaseUrl(e2["tileset.json"].default.url), e2["tileset.json"].others != null)) for (let g of e2["tileset.json"].others) this.tilesets[g.key] = g;
    this.enterpriseMode = (d = i == null ? void 0 : i.enterprise) != null ? d : false, this.tokenManager = i == null ? void 0 : i.tokenManager;
    let n = L4(e2, this);
    this.nodesById = n.nodesById, this.spacesById = n.spacesById, this.floorsById = n.floorsById, this.floorStacksById = n.floorStacksById, this.facadesById = n.facadesById, this.facadesBySpaceId = n.facadesBySpaceId, this.connectionsById = n.connectionsById, this.objectsById = n.objectsById, this.doorsById = n.doorsById, this.pointsOfInterestById = n.poisById, this.annotationsById = n.annotationsById, this.areasById = n.areasById, this.locationProfilesById = n.locationProfilesById, this.locationCategoriesById = n.locationCategoriesById, this.locationProfilesByCategoryId = n.locationProfilesByCategoryId, this.locationCategoriesByParentId = n.locationCategoriesByParentId, this.spacesByExternalId = n.spacesByExternalId, this.nodesByExternalId = n.nodesByExternalId, this.objectsByExternalId = n.objectsByExternalId, this.floorsByExternalId = n.floorsByExternalId, this.locationProfilesByExternalId = n.locationProfilesByExternalId, this.floorStacksByExternalId = n.floorStacksByExternalId, this.poisByExternalId = n.poisByExternalId, this.doorsByExternalId = n.doorsByExternalId, this.areasByExternalId = n.areasByExternalId, this.mvfAnnotationsById = n.mvfAnnotationsById, this.mvfConnectionsById = n.mvfConnectionsById, this.mvfConnectionsByNodeId = n.mvfConnectionsByNodeId, this.mvfConnectionIdsByLatLon = n.mvfConnectionIdsByLatLon, this.mvfEntrancesById = n.mvfEntrancesById, this.mvfNodesById = n.mvfNodesById, this.mvfObstructionById = n.mvfObstructionById, this.mvfSpacesById = n.mvfSpacesById, this.mvfFloorsById = n.mvfFloorsById, this.mvfFloorStacksById = n.mvfFloorStacksById, this.mvfNodesByFloorId = n.mvfNodesByFloorId, this.mvfSpacesByFloorId = n.mvfSpacesByFloorId, this.mvfPoisByFloorId = n.mvfPoisByFloorId, this.mvfEntrancesByFloorId = n.mvfEntrancesByFloorId, this.mvfAnnotationsByFloorId = n.mvfAnnotationsByFloorId, this.mvfAreasById = n.mvfAreasById, this.doorsByNodeId = n.doorsByNodeId, this.spaceIdsByDestinationNodeId = n.spaceIdsByDestinationNodeId, this.objectEntranceNodeIdsByObstructionId = n.objectEntranceNodeIdsByObstructionId, this.obstructionIdByEntranceId = n.obstructionIdByEntranceId;
    let s2 = O4(e2, this);
    if (this.locationsById = s2.locationsById, this.categoriesById = s2.categoriesById, this.mvfLocationsBySpaceId = s2.mvfLocationsBySpaceId, this.locationIdsByNodeId = s2.locationIdsByNodeId, this.connectionSpaceIdsByLatLon = n.connectionIdsByLatLon, this.locationProfilesByAttachedFeatureId = n.locationProfilesByAttachedFeatureId, this.spaceIdsByNodeId = s2.spaceIdsByNodeId, this.connectionsByExternalId = s2.connectionsByExternalId, this.locationsByExternalId = s2.locationsByExternalId, this.categoriesByExternalId = s2.categoriesByExternalId, s2.venue.name != null) {
      this.venue = new iy2(this, { mvfData: s2.venue });
      let g = {};
      for (let v2 in s2.mvfLocationsById) g[v2] = s2.mvfLocationsById[v2];
      for (let v2 in s2.locationInstancesById) g[v2] = s2.locationInstancesById[v2];
      this.languagePacks[this.venue.defaultLanguage.code] = { type: "initial", optimized: { "enterprise-location": g, "enterprise-category": s2.mvfCategoriesById, "floor-stack": n.mvfFloorStacksById, floor: n.mvfFloorsById } }, (f = i == null ? void 0 : i.languagePacks) == null || f.forEach(({ language: v2, localePack: b }) => {
        this.languagePacks[v2.code] = oy2(b);
      }), this.currentLanguage = this.venue.defaultLanguage;
    }
    this.Query = new yc(this), this.directions = new qd({ nodes: e2["node.geojson"], geojsonCollection: e2.enterprise ? e2.space : e2.obstruction, connections: e2["connection.json"], groupBy: "map", multiplicativeDistanceWeightScaling: !this.enterpriseMode });
  }
  getEnv() {
    let e2 = this;
    return { get baseUri() {
      var i;
      return e2.envControl.getBaseUri((i = e2.enterpriseMode) != null ? i : false);
    }, get baseAuthUri() {
      return e2.envControl.getBaseAuthUri();
    }, get analyticsBaseUri() {
      return e2.envControl.getAnalyticsBaseUri();
    }, get tileServerUri() {
      return e2.envControl.getTileServerUri();
    } };
  }
  get mapName() {
    return this.mvf["manifest.geojson"].features[0].properties.name;
  }
  get organizationId() {
    var e2;
    return (e2 = this.mvf["manifest.geojson"].features[0].properties.org_id) != null ? e2 : "";
  }
  get mapCenter() {
    return new K2(this.mvf["manifest.geojson"].features[0].geometry.coordinates[1], this.mvf["manifest.geojson"].features[0].geometry.coordinates[0]);
  }
  get naturalBearing() {
    var e2;
    return (e2 = this.mvf["manifest.geojson"].features[0].properties.naturalBearing) != null ? e2 : 0;
  }
  get spaces() {
    return u(this, q2).spaces == null && (u(this, q2).spaces = globalThis.Object.values(this.spacesById)), u(this, q2).spaces;
  }
  get objects() {
    return u(this, q2).objects == null && (u(this, q2).objects = globalThis.Object.values(this.objectsById)), u(this, q2).objects;
  }
  get connections() {
    return u(this, q2).connections == null && (u(this, q2).connections = globalThis.Object.values(this.connectionsById)), u(this, q2).connections;
  }
  get floors() {
    return u(this, q2).floors == null && (u(this, q2).floors = globalThis.Object.values(this.floorsById)), u(this, q2).floors;
  }
  get floorStacks() {
    return u(this, q2).floorStacks == null && (u(this, q2).floorStacks = globalThis.Object.values(this.floorStacksById)), u(this, q2).floorStacks;
  }
  get facades() {
    return u(this, q2).facades == null && (u(this, q2).facades = globalThis.Object.values(this.facadesById)), u(this, q2).facades;
  }
  get doors() {
    return u(this, q2).doors == null && (u(this, q2).doors = globalThis.Object.values(this.doorsById)), u(this, q2).doors;
  }
  get pointsOfInterest() {
    return u(this, q2).pointsOfInterest == null && (u(this, q2).pointsOfInterest = globalThis.Object.values(this.pointsOfInterestById)), u(this, q2).pointsOfInterest;
  }
  get annotations() {
    return u(this, q2).annotations == null && (u(this, q2).annotations = globalThis.Object.values(this.annotationsById)), u(this, q2).annotations;
  }
  get areas() {
    return u(this, q2).areas == null && (u(this, q2).areas = globalThis.Object.values(this.areasById)), u(this, q2).areas;
  }
  get nodes() {
    return u(this, q2).nodes == null && (u(this, q2).nodes = globalThis.Object.values(this.nodesById)), u(this, q2).nodes;
  }
  get locations() {
    return u(this, q2).locations == null && (u(this, q2).locations = globalThis.Object.values(this.locationsById)), globalThis.Object.values(this.locationsById);
  }
  get categories() {
    return u(this, q2).categories == null && (u(this, q2).categories = globalThis.Object.values(this.categoriesById)), globalThis.Object.values(this.categoriesById);
  }
  get locationProfiles() {
    return u(this, q2).locationProfiles == null && (u(this, q2).locationProfiles = globalThis.Object.values(this.locationProfilesById)), u(this, q2).locationProfiles;
  }
  get locationCategories() {
    return u(this, q2).locationCategories == null && (u(this, q2).locationCategories = globalThis.Object.values(this.locationCategoriesById)), u(this, q2).locationCategories;
  }
  get mvfFloors() {
    return u(this, q2).mvfFloors == null && (u(this, q2).mvfFloors = globalThis.Object.values(this.mvfFloorsById)), u(this, q2).mvfFloors;
  }
  get mvfFloorStacks() {
    return u(this, q2).mvfFloorStacks == null && (u(this, q2).mvfFloorStacks = globalThis.Object.values(this.mvfFloorStacksById)), u(this, q2).mvfFloorStacks;
  }
  getByType(e2) {
    switch (e2) {
      case "location-profile":
        return this.locationProfiles;
      case "location-category":
        return this.locationCategories;
      case "area":
        return this.areas;
      case "node":
        return this.nodes;
      case "space":
        return this.spaces;
      case "door":
        return this.doors;
      case "floor":
        return this.floors;
      case "floor-stack":
        return this.floorStacks;
      case "connection":
        return this.connections;
      case "object":
        return this.objects;
      case "point-of-interest":
        return this.pointsOfInterest;
      case "annotation":
        return this.annotations;
      case "enterprise-location":
        return this.locations;
      case "enterprise-category":
        return this.categories;
      case "enterprise-venue":
        return this.venue;
      case "facade":
        return this.facades;
      default:
        return [];
    }
  }
  getById(e2, i) {
    switch (e2) {
      case "location-profile":
        return this.locationProfilesById[i];
      case "location-category":
        return this.locationCategoriesById[i];
      case "space":
        return this.spacesById[i];
      case "floor":
        return this.floorsById[i];
      case "floor-stack":
        return this.floorStacksById[i];
      case "facade":
        return this.facadesById[i];
      case "node":
        return this.nodesById[i];
      case "door":
        return this.doorsById[i];
      case "connection":
        let o = this.connectionsById[i];
        return o == null && (o = x(this, Qd, C5).call(this, this.mvfConnectionsById[i])), o;
      case "object":
        return this.objectsById[i];
      case "point-of-interest":
        return this.pointsOfInterestById[i];
      case "annotation":
        return this.annotationsById[i];
      case "area":
        return this.areasById[i];
      case "enterprise-location":
        return this.locationsById[i];
      case "enterprise-category":
        return this.categoriesById[i];
      default:
        return;
    }
  }
  getByExternalId(e2, i) {
    var o, n, s2, c2, l, p, d, f, g, v2, b, C;
    switch (e2) {
      case "location-profile":
        return (o = this.locationProfilesByExternalId[i]) != null ? o : [];
      case "location-category":
        return [];
      case "space":
        return (n = this.spacesByExternalId[i]) != null ? n : [];
      case "floor":
        return (s2 = this.floorsByExternalId[i]) != null ? s2 : [];
      case "floor-stack":
        return (c2 = this.floorStacksByExternalId[i]) != null ? c2 : [];
      case "node":
        return (l = this.nodesByExternalId[i]) != null ? l : [];
      case "door":
        return (p = this.doorsByExternalId[i]) != null ? p : [];
      case "connection":
        return (d = this.connectionsByExternalId[i]) != null ? d : [];
      case "object":
        return (f = this.objectsByExternalId[i]) != null ? f : [];
      case "point-of-interest":
        return (g = this.poisByExternalId[i]) != null ? g : [];
      case "area":
        return (v2 = this.areasByExternalId[i]) != null ? v2 : [];
      case "enterprise-location":
        return (b = this.locationsByExternalId[i]) != null ? b : [];
      case "enterprise-category":
        return (C = this.categoriesByExternalId[i]) != null ? C : [];
      default:
        return [];
    }
  }
  getMapDataById(e2) {
    var i, o, n, s2, c2, l, p, d, f, g;
    return (g = (f = (d = (p = (l = (c2 = (s2 = (n = (o = (i = this.spacesById[e2]) != null ? i : this.floorsById[e2]) != null ? o : this.floorStacksById[e2]) != null ? n : this.facadesById[e2]) != null ? s2 : this.nodesById[e2]) != null ? c2 : this.doorsById[e2]) != null ? l : this.connectionsById[e2]) != null ? p : this.objectsById[e2]) != null ? d : this.pointsOfInterestById[e2]) != null ? f : this.annotationsById[e2]) != null ? g : this.areasById[e2];
  }
  getMVFFeatureById(e2, i) {
    switch (e2) {
      case "space":
        return this.mvfSpacesById[i];
      case "node":
        return this.mvfNodesById[i];
      case "obstruction":
        return this.mvfObstructionById[i];
      case "floor":
        return this.mvfFloorsById[i];
      case "floor-stack":
        return this.mvfFloorStacksById[i];
      case "connection":
        return this.mvfConnectionsById[i];
      case "entrance":
        return this.mvfEntrancesById[i];
      case "annotation":
        return this.mvfAnnotationsById[i];
      case "area":
        return this.mvfAreasById[i];
      default:
        throw new Error("Unknown MVF feature type: ".concat(e2));
    }
  }
  getMVFFeatureByNodeId(e2, i) {
    switch (e2) {
      case "connection":
        return this.mvfConnectionsByNodeId[i];
      default:
        throw new Error("Unsupported MVF feature type: ".concat(e2));
    }
  }
  getMVFFeatureByType(e2) {
    switch (e2) {
      case "floor-stack":
        return this.mvfFloorStacks;
      case "floor":
        return this.mvfFloors;
      default:
        throw new Error("Unsupported MVF feature type: ".concat(e2));
    }
  }
  getPropTranslation(e2, i, o, n) {
    var l, p;
    if (!this.currentLanguage) return n;
    let { code: s2 } = this.currentLanguage, c2 = (p = (l = this.languagePacks[s2]) == null ? void 0 : l.optimized) == null ? void 0 : p[e2];
    if (c2) {
      let d = c2[o];
      if (d != null && d[i] !== void 0) return d[i];
    }
    return n;
  }
  async changeLanguage(e2) {
    var c2;
    let i = e2.toLowerCase();
    if (!i) {
      Lt.error("language code must be defined");
      return;
    }
    if (!this.currentLanguage) {
      Lt.error("languageCode feature is not supported");
      return;
    }
    let o = this.currentLanguage.code, n = (c2 = this.venue) == null ? void 0 : c2.languages.find(({ code: l }) => l.toLowerCase() === i.toLowerCase());
    if (!n) {
      Lt.warn("language not found");
      return;
    }
    if (o === n.code) return;
    let s2 = this.languagePacks[n.code];
    if (!s2) {
      let l = this.localePacksUrls[n.code];
      if (!l) {
        Lt.error("locale packs url not found for ".concat(n.code));
        return;
      }
      u(this, vs2) && u(this, vs2).abort();
      let p = new AbortController();
      w(this, vs2, p);
      let d;
      try {
        d = await hb(l, { signal: p.signal });
      } catch (f) {
        Lt.error("failed downloading language pack", f);
        return;
      }
      if (!d || p.signal.aborted) return;
      s2 = oy2(d), this.languagePacks[n.code] = s2;
    }
    this.Analytics.sendChangeLanguageEvent({ fromLanguage: this.currentLanguage.code }), this.currentLanguage = n, this.publish("language-change", this.currentLanguage);
  }
  getDistance(e2, i) {
    let o = $l(e2), n = $l(i);
    return Mr([o.longitude, o.latitude], [n.longitude, n.latitude]);
  }
  async toJSONBundle({ downloadLanguagePacks: e2 = true } = {}) {
    var o;
    let i = [];
    if (e2 && this.enterpriseMode) {
      let n = new AbortController();
      for (let s2 of ((o = this.venue) == null ? void 0 : o.languages) || []) try {
        if (this.localePacksUrls[s2.code]) {
          let c2 = await Gf(this.localePacksUrls[s2.code], { signal: n.signal }), l = await Ua(c2);
          l && i.push({ language: { code: s2.code, name: s2.name }, localePack: l });
        }
      } catch (c2) {
        Lt.warn("failed downloading language pack", c2);
      }
    }
    return { type: "json", options: { enterprise: this.enterpriseMode }, languagePacks: i, main: this.mvf };
  }
  async toBinaryBundle({ downloadLanguagePacks: e2 = true } = {}) {
    var o;
    if (!this.binaryBundle) {
      Lt.error("binary bundle not found");
      return;
    }
    let i = [];
    if (e2 && this.enterpriseMode) {
      let n = new AbortController();
      for (let s2 of ((o = this.venue) == null ? void 0 : o.languages) || []) try {
        if (this.localePacksUrls[s2.code]) {
          let c2 = await Gf(this.localePacksUrls[s2.code], { signal: n.signal });
          c2 && i.push({ language: { code: s2.code, name: s2.name }, localePack: c2 });
        }
      } catch (c2) {
        Lt.warn("failed downloading language pack", c2);
      }
    }
    return { type: "binary", options: { enterprise: this.enterpriseMode }, languagePacks: i, main: this.binaryBundle };
  }
  destroy() {
    for (let e2 of globalThis.Object.keys(u(this, q2))) u(this, q2)[e2] = null;
  }
};
q2 = /* @__PURE__ */ new WeakMap(), Qd = /* @__PURE__ */ new WeakSet(), C5 = function(e2) {
  var c2;
  let i = (c2 = e2 == null ? void 0 : e2.nodes) == null ? void 0 : c2[0], o = this.getById("node", i);
  if (o == null) return;
  let n = Jr2([o.coordinate.longitude, o.coordinate.latitude]), s2 = this.connectionSpaceIdsByLatLon[n];
  return s2 == null ? void 0 : s2.map((l) => this.connectionsById[l]).find((l) => l != null);
}, vs2 = /* @__PURE__ */ new WeakMap();
c();
c();
c();
c();
c();
c();
(function() {
  typeof globalThis != "object" && (Object.defineProperty(Object.prototype, "__magic__", { get: function() {
    return this;
  }, configurable: true }), __magic__.globalThis = __magic__, delete Object.prototype.__magic__);
})();
var S5 = "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAkGBwgHBgkICAgKCgkLDhcPDg0NDhwUFREXIh4jIyEeICAlKjUtJScyKCAgLj8vMjc5PDw8JC1CRkE6RjU7PDn/2wBDAQoKCg4MDhsPDxs5JiAmOTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTn/wgARCAIABAADAREAAhEBAxEB/8QAGwABAAMBAQEBAAAAAAAAAAAAAAECAwQFBgf/xAAWAQEBAQAAAAAAAAAAAAAAAAAAAQL/2gAMAwEAAhADEAAAAP3EAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAIAAAJAFAAAAAAAAAAAAAAAAAAAAAAAAABAgAAEgCgAAAAAAAAAAAAAAAAAAAABERLSM1zM4zXMzjMoUIqCCSSS8XNC9mpoaVomharWTQAAAAAAAAAAAAAAAAEREtIoZrnGZkucUKFStQQSTFixdNDStF0TWrmiWqbJoAAAAAAAAAAAAAIgiWkZy4HNLzHLXKcxzpzmFYmRkUKFSCCSSxcuampsbR0HSdK9R1R1HTZvWll0mlAAAAAAAAAAAIiKLnLjHNLynLXKcycxzmNYmJmUKFSCAWLFy5qamxvHQvSdJ0nVHUdFm1aparWKAjNWSKAAAAARBEtYzlyXnjmOSuM4U4q4jjOM5a5k5zAyMjOqFCCCCSSS5c0jU1NzoOk6pew7TtjuO1e0646jezWr2WSaUAAAAAECIqtZco55eY464zhTirhOI5Dks5jAwMTIzqhUqQASWLFzSNTY3Og6V646zsO2O47V7DrjqNzWy9nlZ1c0LlrLEk0EQQVipRczIyMU5q5F4U8+vOPOrgThOOuU5jAxMjMzKpUggigJiSSxY0XQ1Njc6TqjtO49CX0D0T0Y7l7E6JdzU1NEvViSalBAWIqVKLSMjIxOauM4U86vPPOrz04TjrkOYwMTIzKJQqQQCKmBJJYutzQ1Njc6TrOyO475fRPRPQjuXsToXWPn6kkkEkhCkEAgggqVMjlrzzzDy7PMPPrhOQ5jBMqoVIIIAAIAJAAJJJLFzWN16TsO49CPTPUl9Q9A6o1LFiSSSSQpCwQQCCCpVMjlrzzyzy7PMPPrhOM5kwM6zKlQQAAQASAASCxY0NI3XpOw7j0I9M9SX0z0DqjU+UqpQqVIBFgEyixJYuWLFDkrzE8o8yvOONOasipBAAAAAAAAAAABJJY2OiO1fQPUj1T0pewuVKlCCqQsBIUSSSSWLlyTM5K808pPLrzziTnrEqQQAAAAAAAAAAASSWNjojtX0D1I9VfSOuND4uzMzqhQqVIALEli5c1jUuQc1vnp5pwJzVmQQAAAAAAAAAAAAAASSaHTHevpHoHTFjMyM6zKlSpABJJcsaGkamhU5q88804E5qzIIAAAAAAAAAAAAAAJJNDpjvX0j0Dqix8dVDMolSpAqCYElixc0XU0IMjlTlrIqAAAAAAAAAAAAAAAAAWNTqjqXYGZkZpUoQQRSFIsSXLroaGhBkcqctZFQAAAAAAAAAAAAAAAACxqdUdS7EngWQCAAQASACSSSwKlSCAAAAAAAAAAAAAAAAAACSSxYFSCCAACCQACSSSwKlSCAAAAAAAAAAAAAAAAAACSSxYGIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABIAJAJAJBAAIAIABAAAAAAAAAAAAAAAAAAAABIAJAJAJBAAIAIABAAAAJABAAAAAAAAAJBILEli5Y0LlzQ0Lly5csWLAkgFSChUoUMyhmUMyhQqVKkEEAEAAAAAAAAAkEgsSWLljQuXNDQuXLlyxYsCSAVIKFShQzKGZQzKFCpUqQe+ZmZkUKFCpUEEAAkksWLFzQ0NTU2NzY3Og3NzoNzc2NjU1NS5csSAQVKmZmZGRiYmBgYHOYGBgYGBiZGRkUMypUqQCAASSWLFi5oaGpqbG5sbnQbm50G5ubGxqampcuWJAIIKGZmZGRiYmBgYHOYGBgYGR+jmBzmBzmJiZGZQoQQSSWLmhqbGxudB0nSdJ1HSdR1HSdJ0G5qamhcsWJJJBIIIBUqVKFDIyMDA5jmOU5TlOY5TmOc5znMTEyMyhQggFixc0NTY2NzoOk6TpOo6TqOo6TpOg3NTU0LlixJJIJBAIKkFChQyMjAwOY5jlOU5jnP00yMTnOc5zAwMjMoVIJJLmhqbmx0HQdBubmxqXLkkgAAAAAAAAAAAAAEEFTMzMTEwOc5znMDAyMyhUgkkuaGpsbnQdB0G5ubGpcuSSAAAAAAAAAAAAAAQQVKGZ1gAEEEEFSCACSSxJJJIAAAAAAAAAAAAAAAAAAAAAAABBBBBUggAkkksSSSAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQCCpBUqQVIKggAkFiSSxYksSSSSAAAAAAAAAAAAAAAAAAQCCpBUqQVIKggAkFiSSxYksSWBIAAKFiQAAAAAAAAACCpUoUMzIyMzMzMyhQoVKkEEAgkEkklixYuXNDQ0NTQ1NC5cuWJAAAAAAAAAAIKlShQzMjIzMzMzKFChUqQQQCCQSSSWLFyxoXNDQ1NDU0LljUkkAAAAAAAAAAggggEEAgAAAAAAAAAAAAAEkgkkkkkAAAAAAAAAAgggggEAgAAAAAEgEAAAAAAEkgkkuAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADyyCCCCCCCCAQASCSQWJJJJLEkkkkkgkkEgkAEgAAEAAgEAggEEEEEEEFSCCCCCCAQASCSQWJJJJLEkkkkkgkkEgEgEgAAEAAgEAggEEEEEH5AQQQQVBBAIAAJBIJJJLEkkkkliSSSSSQSSCQSAAAQAQQCCCCCCCCCpBBBBBUEEEAgAAkEgkkksSSSSSWJJJJJJBJIJBIAABABBAIIIIIIIIKg/LCAQCACAAAACQCQSCQSASSASCQCQAAAAAAQCAQAQCAQAQQCACAAAACQCQSCQSASSASCQCQAAAAAAQCAQAQCAQfPgAAAAAAAAAAAAAAkAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAkAAAAAAAAAAAAAAgAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH/xAApEAAABQUBAQACAwACAwAAAAABAgQFFQMGERQWEhNAUAAgMGCAkKCw/9oACAEBAAECAP8AwTZznOf3mc5/YZE41xVivFyM6i7C8C8C8zMzMzMyDyDyDyDwV4K7ldSuZV5VgVwqZ/SCca4qxXmcjOouwvAvEzMzMzMzMyDyDyDwV4K7ldSuRVwKgrgf88TDWMrO4VHOo61Hao7ndzvB3k7yZ5M8i8i8zMzMzMyDyDyDyV5K8keSPJHmm8U3em70nam603Mi8qotUDfk5GqZUdfUc6jrUdqjvUeDvB3kzyZ5M8i8i8zMzMzMzMg8g8leSvJHkjyR5pvFN4pu9N2pOtNzIvKqLWA39PX+/saplJlh1tRfVcKrlVdKrrVdqrvVdzu53Y7sZ2M6mdRdRdBdJSUk5SUB0B0B1K6kdSOxHam7Unek70nei7UXWi6UXKk40l9NaRWWuB8/75E41zKjraq+q41nOq6VXas7VXeq71Hc7ud2O7GdRdRdZQXSUlJSUlAdCugOpXUjqR2I7U3em70nek70nai60XSk5UnGkvItIrKoCsC0FwLgXAuBbube3ubm7uiuFcZcZaZYdZUWVl1dwruVdzrulZ0qulVzqOR3EzgZeZcZcK0Vm3t7W1tbW1tgrBYC0q0q4q8jgRxpuVJzoulB0oOlBzoOVBworqa0iwi0i0q4FwLQWAr2trZ2trb3RWiuFcZaZadbUW1l1ZwruVd0rulZ0qulVzqOR3E7gZeZeK4VorNzb29ra2tsFe2CwFpVxVxV5HAjjTcqTnRdKDpQdKDnQcqDhRXU1pFhVm/ISUnKSkrLSsrKyspJyUhvitOtrLq69Q4qHGu41nGqvqLjrDKhUDW+nv1nP+Oc+vYVArFUEVEWUl1FfQcU7imckzinX0VxFoLgXyMlJykrLS0tLS0rKSclI74rjraq6uvUuKhxruNdxqr6i46wysVA1vp79Zz/AI5z6A4VArFUEVkWUl1FfQcU7imcUzinX0VxFoLZKTlJWVlpaXl5eWlpWUB0BzBxkDr669SvUr666stqqz1xqes/j5AxahFFJXRWp1yZemX0F5HCQkpOUlZaWlpeXl5aWB2lQdAcwcZE7hWcFLgpXqF1ZbVVnUDU9Z/HyBi1CV6SuitTrky9MvoLyL5AXEXEXIXIXKSkpKSkpIHIHIHIrkVxK4yJnCsvrra6uqpPVE354GJVpKaCtOtoryuEiZxM5C5C5C5SUnJSclJSQOQORXIrkVxBxM4VV9dbXV1VJ6om/PAxKtFTQVp1tFeRwkRWitFYKvb2tra2draBUCsFgLCrSrQWitOsqqT1RN+jAxKtJTTWFWitMtMtFYKzb29ra2tnaBUCsFZVhVpVoLRWnWVFJ6om/RgYlWkpprAW73v36zn++c+gOFQKv1GoJv04GCp9Rq/T36zn++c+gOFT7fUagm/TgYKn1+3/AKEeMefHjx8/n8vl8vn8/Hjx5xj9bjHnx48fP5/L5fL5/Px48ecY/wAvOPxceQIFIKIJgSAiBAVuK2FaitINAM4MwMwMsJCQkJCQkJCwosws4tAtItQtgtot4oRSCm+Hy8ecfi48gQKQUQTAkBECArcVsK1FaQaAZwZgZgZYSEhISEhISFhRZhZxaBaRahbBbRbxQikFN8BpfMWgWozWLaLcKAUWpq62vr/DX19YEoJARAhBvK2laytRGgjORlIyEYiMJLfJbxLdJbhLbJbRLaJbJbZLbAWxzHMcxzHMcxzHMDbBrYNbJraNbRrbPbh7dPbx7fOwHYjsZ2UzMZoM0maxbRbhQCi1NXW19fX19fW1QSAiBCDeVtK1laiNBGYjKRkIxEYSW+S3iW6S3CW2S2iW0S2S2yW2AtgLY5jmOY5jmOY5gbYNbJrZNbRraPbZ7cPbp7ePb52A7EdjOymZjW4e3D26e3j2+ZgMwmYhYxY4SEhISEBjKxlYiMJGAjAS3iW9TtynblO26dtUrap2zTtmnbNO2SW2S3isRWYGkG0EAItTW1/h8Phr6+rp6AtwtQs5mI9vntw9tHtk9s1LZqWzUto9tnts9uHt09vHt8zAZhMxCxixwkJCQkIDGVjKxEYSMBGAlvEt6nblO3Kdt0rap21TtmnbNO2SWyS2yW8ViKzA1A2ggBFqa2v8Ph8NfW1dPRFuFqMzGYjW+e3D20e2T2zUtk9tHto1tCzHYj2+e3T24e3D24a3DW4Nuc5znOc4FuBbhbcLbhLcJblO3CW4S3iMRGcrYVECcKYB+cJBoCjM2maDsZ7fPbp7cPbh7cNbhrcG3Oc5znOcC3C24W3C24S3CW5TtwluEt4jERnK2FRAnCmAfnCQaAoxb/7ePl8NbU09PT1NYKHy8Y/ZePl8NbU09PT1NYKHy8Y/4Z6+g1tjb3d+Rk5SVlZWVlZSTkd8Fu3s/b6es/pvX0Gtsbe7vyMnKSkrKysrKSciC8Fu3s/YKnrP9gqAb8X0NQawqBVCrMrMqMoGuNUTiYf4ICT5/L4/H4fD4fH4hSCmBAAP4AgctUtYqgqoqsqsqoFIVwqAb8X0NQawqBVCrMrMqMoGuNUTiYf4ICT5/L4/H4fD4fH4hSCmBAAP4AgctUtYqgqkqsqsqsFIV/Hn8XHj5/H4a+traurq6mpqampqampqampqampqampqampqamrq62tr/D4/Lx5/Fx4+fx+Gvra2rq6upqampqampqamrq6upqampqampqamrq6utra/w+Py/wCgEzNTc5OTs7PT09PT8/Pz09PT07Ozk3Ng9TMxLy0rKSclJSMhIb+9vbu9u7u7u7u7u729vb2/vyEjJSUnKSstLzEzNTc5OTs7Oz09PT8/Pz09PT07Ozk5NzUzMS8tKyknJSUjISG/v727vbu7u7u7u7u9u729v78hIyUlJykrLS8x0nR9H0fR9H0XRdF0XRdD0PQ9F0XRdF0XRdF0fR9H0nSdJ0vS9L0vTdN03TdP0/T9P0/T9P0/T9P0/T9R0/T9P0/T9P0/TdN03S9L0vS9J0nSdJ0fR9H0XRdF0PRdD0PQ9D0PRdF0XRdF0XR9H0fSdJ0nS9L0vS9N03TdN0/T9P0/T9P0/T9P0/T9P1HT9P0/T9P0/T9N03TdL0vS9L0vSS8tLy0tLS0rKysrKysrKysrKystLS0vLS8vLy8vMTExMTExMzMzMTMzMzM1NTUzMzMzMzMzMzExMTExMS8vLy8vLy8tKy0tKysrKysrKysrKysrLS0tLy0vLy8vLzExMTExMTMzMzEzMzMzNTU1MzMzMzMzMzMxMTExMTEvLy8vnOc5znOc5znOc5znOc5znOc59ZznPr169evXr169evXr169evXr16znOfWc5znOc5znOc5znOc5znOc5znOc59ZznPr169evXr169evXr169evXr16znOfWc5z/9YD//xAArEAEAAgIDAQABBAICAQUAAAAAAVICYgNRYQRBEEBQUzFCIDARYICQoLD/2gAIAQEAAz8A/wDgmhCEI/nYQj+RhjH5ccflxw44YMe0dtmzZs2bNmzZs2bIsjtiwlxy45/Ljn8se0fwuPbjj8uOPy44YQxR2izZs2bNmzZs2bNkWR2xYS45cc/lhP5Y9/wEQwj8sIRD1s2bNmzZs2bNmzZs2bNmzZs2bNmzZs2bNmyLMZYZMZ/KJ/dRDCPywhjCI/LZs2bNmzZs2bNmzZs2bNmzZs2bNmzZs2bNkWYywlhP5RP/ABj9hDGGMIh69bNmzZs2bNmzZsmybJsmybJsmybJsmybJsmybJs2bNmzZs2bNmzZ7+mMsZYyj9hDGGMIj9NmzZs2bNmzZs2bJsmybJsmybJs2TZNk2TZNk2bJs2bNmzZs2bNmzZ6iWMsXr16hiwYMGDBgwYo/T169/T162bNmzZs2TZNk2T2ntPae09pSlKUpSlPae09p7T2mybJsmzZs2bNmz17+nr16hiwYOPtx9uPtx9sO2DBih69evXr1s2bNmzZsmybJsmye09p7T2lKUpSlKU9p7T2ntNk2TZNmzZs2bNmz17+vr1s2bNmzZs2bNmzZs2evXr169bNmye09p7SlKUp/wC6UpSlKe09p7etmzZs9evWzZs2bNmzZs2bNmzZs2bPXr1s9bNmye09p7SlKUp/7pSlKUp7T29bPWz169evWzZs2bNmzZs2bNmzZs2bNmzZs2evU9plM/vJhMJ7T29bNnrZ62bNmzZs2bNmzZs2bNmzZs2bNnr39J7TKZ/eTCYT3+nr162bNnrZs2bJsntNk2TZPabNmzZs2etnr39JlM/wUwmP09etmzZs2bNk2TZNk2TZNk2bNmzZs2bNnv6TKZ/gphMfp69etk9p7T2ntKUpSlKUp7T2nt69e/pMpn+GmH/j9PXr1Pae09pSySlklKU9p7T29evf0mUz/DTCY/T16lP/AHSlKU/xUpSlP/dKUpT/ABUpT/8AQllKWTJl0y6ZdMumXTLpl0y6ZJSn+QlKWTJl0y6ZdMumXTLpl0y6ZJSn/sn9xKWXTLpn0z6Z9M+mXTLplVlVlVlVlVlVlVlVlVlVlRlVlVlRlVlVlVlVlVlVlVl0z6Z9M4/DPpn0z6ZdMkp/byll0y6Z9M+mfTPpn0y6ZVZVZVZVZVZVZVZVZUZVZUZVZVZVZVZVZVZVZVZVZVZdM+mfTOPwz6Z9M+mTJlVlVlVl0yZ9M2fTPpn0z6Z9M+mbPpn0z6Z9M2fTPpl0yqyqyqyqyqyomiaJomiaJomiaJomjRo0aNGjRo0aNGjRNE0TRNE0TRNE0TRNE0ZVZVZVZVZVZVZM+mbPpn0z6Z9M+mfTNn0z6Z9M+mfTPpl0y6ZVZVZVTVlVlRNE0TRlRNE0TRNE0TRo0aNGjRo0aNGjRomiaJomiaJomiaJomqaJqyq0TRNE0TRNE0TVNE1TVNU1TRNE1TVNU0TRNE0TRNGjRo0aNGjRhWHFHTgh88Pmj8Pnj/V89HBRwf1w4f64cNMXFSHFTFxUxcVIcP9cOGkOCkPno+ej55/D55cEuKemHUIo0aNGjRo0TRNE0TRNE0TVNE0TVNE1TVNE1TRNU0TRNE0TRNGjRo0aNGjRhWHFHThh88Pnj8Pnq+ejgo4P64cP9cOKkOKkOKmLipi4aYuH+uHBSHBSHz0fPR88/h88uCXFNWHUIo0aNGjRo4ZcU9MOoRRFGjRo0aNGjRo0aNGjRo0RRhVxR04IcGP4cGP+jij/GEMI/xjCP3+M/5xhxT/AJwhwT/o4Mv9XBk4p6YdQiiKNGjRo0aNGjRo0aNGjRoijGsOKOnBi4Mfw4I/0cUf4whhH+MYR+/xn/OMOKf84Q4J/wBHBP8Ar/zxrDCsOKkOKjhq4auGrhq4auGjipDjpDGsI/k8awwrDipDio4aOGrhq4auGrho4qQ46QxrCP8A0bHcMLQ47w4rw4buCzgs4O3A4HA4XA4HA4HA4O3BZwWcN3Fdx3hhaGNoR/Dx3DC0OO8OK8OG7gs4LODtwOBwOFwOBwOBwODtwWcFnDdxXcd4YWhjaEf88UftoQh4y6ZuRyuVzOZzeudz+uf1z+uf1z+uf1z+uf1zuf1z+uf1z+uf1z+udzR25nM5o7c3rlcrlZsniOkSj9tCEPGXTNyuVy+uZzOb1z+uf1z+uf1z+uf1z+uf1z+udz+uf1z+uf1z+uf1z+ueO3O5nM5vXK5XKzZPEdMUftoYsemHTDpx9OPpxVcVXDVw1cNXDVw0cNHDRw0cNHDRw0cNHDRw0cNHDRw0cNHDRw0cNHDVw1cNXFVxVcVXFVx9OPph0w6Yo/bQxY9MOnH04+nH04quKrhq4auGrhq4aOGjho4aOGjho4aOGkOGkOGkOGjho4aOGjho4aOGjhq4auGriq4quKriq4+nH0w6Ydf+wHgcLhcLicTjYdww7hh3DDuGPcMe4Y9ww7hh3DDuGHcONxuJxOFwuBwOB8753z2fPZ89nz3fNd893zXfPd893z3fP/Y+e757uC75/wCyHz/2Q+f+yHBd893z3fPd893z3fPd893zXfNd893z2fPZ8/b5+3zvncDgcLhcLicTjYdww7hh3DDuGHcMe4Ydww7hh3DDuGHcONxuJxOFwuBwPnfO+d89nz2fPZ893zXfPd813z3fPd893z/2Pnu+e7gu+f8Ash8/9kPn/shwXcF3z3fPd893z3fPd893zXfNd893z2fPZ8/b5+3zvncDdu3bt03bt26bpum6bpum6bt27du3bt26bt26bpum6bpum6bpum6bt03TdN26bpum6bpum7dN03TdN03TdN03TdN03Tdum7dum7dN27dum6bpum6bpum6bpum7du3bt03bpu3bpum6bpum6bpum6bpu3TdN03bpum6bpum6bt03TdN03TdN03TdN03TdN03TduysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysmzKzKzKybMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrJT+2lKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSn9tKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpT/wDrA//EAB0RAAMBAAMBAQEAAAAAAAAAAAABERIwQFAgkMD/2gAIAQIBAT8A/COlKioqKioqKi+zSoqKioqL59Ro0aKyvpVlZWaNFXiVGkaNFZWV9CsrNGjRpFXepo0V8c69Zo0u1pGilfVnJWaNF+NFXNUaNFfmU0aReamkaNPzNM19VlZWaKysrK/XrKzTNGjRWaKyv+u0/8QAHREBAQACAQUAAAAAAAAAAAAAEQBAUCAQITCQwP/aAAgBAwEBPwD1NkRER07eYiIiNMRERGARERGgIiNAREZRERoCIjiYBERqiIwiI1REcCIiIiIjbkREREREfXZ//9k=";
c();
c();
var x5 = false;
function I5() {
  x5 = true;
}
function P5() {
  return x5;
}
var Kd = class {
  constructor(t3) {
    t(this, "backgroundAlpha", 1);
    t(this, "backgroundColor", new Nt());
    t(this, "width", 0);
    t(this, "height", 0);
    t(this, "options", {});
    t(this, "renderer");
    t(this, "enabledLayers", /* @__PURE__ */ new Set([0, 1]));
    t(this, "handleWebGLContextCreationError", (t4) => {
      var e3, i2;
      (i2 = (e3 = this.options).onWebGLContextCreationError) == null || i2.call(e3, t4);
    });
    t(this, "handleWebGLContextLost", (t4) => {
      var e3, i2;
      (i2 = (e3 = this.options).onWebGLContextLost) == null || i2.call(e3, t4);
    });
    t(this, "handleWebGLContextRestored", (t4) => {
      var e3, i2;
      (i2 = (e3 = this.options).onWebGLContextRestored) == null || i2.call(e3, t4);
    });
    var e2, i, o, n, s2;
    try {
      this.options = t3, P5() ? (this.renderer = { setSize: () => {
      }, state: { reset: () => {
      } }, properties: { get: () => {
      } }, getSize: () => ({ width: window.innerWidth, height: innerHeight }), getDrawingBufferSize: () => ({ width: window.innerWidth, height: innerHeight }), getClearAlpha: () => 1, getClearColor: () => new Nt(), autoUpdate: true, shadowMap: { autoUpdate: true }, getContext: () => ({ getContextAttributes() {
        return { alpha: true, antialias: false, depth: true, stencil: false };
      } }), readRenderTargetPixelsAsync: () => Promise.resolve([]), setRenderTarget: () => {
      }, setClearColor: () => {
      }, clear: () => {
      }, render: () => {
      }, domElement: document.createElement("canvas"), capabilities: { isWebGL2: true } }, this.renderer.domElement.style.width = "1920px", Object.defineProperty(this.renderer.domElement, "clientWidth", { value: 1920 }), this.renderer.domElement.style.height = "1080px", Object.defineProperty(this.renderer.domElement, "clientHeight", { value: 1080 })) : this.renderer = new Nu({ canvas: t3.canvas, alpha: t3.alpha || false, stencil: false, antialias: typeof t3.antialias == "boolean" ? t3.antialias : true, powerPreference: "high-performance", preserveDrawingBuffer: true }), this.backgroundColor = new Nt((e2 = t3.backgroundColor) != null ? e2 : "#ffffff"), this.backgroundAlpha = (i = t3.backgroundAlpha) != null ? i : 1;
    } catch (c2) {
      Lt.error(c2), t3.onWebGLRendererError && t3.onWebGLRendererError(c2);
    }
    (o = this.domElement()) == null || o.addEventListener("webglcontextlost", this.handleWebGLContextLost), (n = this.domElement()) == null || n.addEventListener("webglcontextrestored", this.handleWebGLContextRestored), (s2 = this.domElement()) == null || s2.addEventListener("webglcontextcreationerror", this.handleWebGLContextCreationError);
  }
  destroy() {
    var t3, e2, i, o, n;
    this.renderer && ((e2 = (t3 = this.renderer).dispose) == null || e2.call(t3)), (i = this.domElement()) == null || i.removeEventListener("webglcontextlost", this.handleWebGLContextLost), (o = this.domElement()) == null || o.removeEventListener("webglcontextrestored", this.handleWebGLContextRestored), (n = this.domElement()) == null || n.removeEventListener("webglcontextcreationerror", this.handleWebGLContextCreationError);
  }
  render(t3, e2) {
    if (this.renderer) {
      this.renderer.state.reset();
      for (let i of this.enabledLayers.values()) e2.layers.enable(i);
      this.renderer.autoClear = false, this.renderer.setRenderTarget(null), this.renderer.render(t3, e2), this.renderer.state.reset();
    }
  }
  clear() {
    this.renderer && (this.renderer.setClearColor(this.backgroundColor, this.backgroundAlpha), this.renderer.clear());
  }
  setBufferSize(t3, e2) {
    e.env.NODE_ENV === "test" || !this.renderer || (this.width = t3, this.height = e2, this.renderer.setSize(t3, e2, false));
  }
  setBackgroundColor(t3, e2) {
    this.backgroundColor = t3, this.backgroundAlpha = e2;
  }
  domElement() {
    var t3;
    return (t3 = this.renderer) == null ? void 0 : t3.domElement;
  }
};
c();
c();
var M5 = '"use strict";(()=>{var G=Object.defineProperty;var J=(n,e,t)=>e in n?G(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t;var l=(n,e,t)=>J(n,typeof e!="symbol"?e+"":e,t);function M(n,e){return e.x+e.w<n.x+n.w&&e.x>n.x&&e.y>n.y&&e.y+e.h<n.y+n.h}function j(n,e){let[t,i]=e;return t>=n.x&&t<=n.x+n.w&&i>=n.y&&i<=n.y+n.h}function q(n,e){let t=e.x,i=e.y,o=e.x+e.w,h=e.y+e.h,k=n.x,p=n.y,f=n.x+n.w,g=n.y+n.h;return t<f&&k<o&&i<g&&p<h}function c(n,e){for(let t=0;t<e.length;t++)n.push(e[t])}var s=class{constructor(e,t,i,o,h){l(this,"x");l(this,"y");l(this,"w");l(this,"h");l(this,"userData");this.userData=typeof h>"u"?null:h,this.x=e,this.y=t,this.w=i,this.h=o}contains(e){return e===this?!1:M(this,e)}intersects(e){return q(this,e)}intersectsPoint(e){return j(this,e)}draw(e){e.fillStyle="rgba(123,222,26, 0.8)",e.fillRect(this.x,this.y,this.w,this.h)}};var w=class n{constructor(e,t){l(this,"topLeft");l(this,"topRight");l(this,"bottomLeft");l(this,"bottomRight");l(this,"divided",!1);l(this,"boundary");l(this,"capacity",16);l(this,"objects",[]);l(this,"parent");this.parent=t,this.boundary=e}getSize(){return this.divided?this.objects.length+this.topLeft.getSize()+this.topRight.getSize()+this.bottomLeft.getSize()+this.bottomRight.getSize():this.objects.length}subdivide(){let{x:e,y:t,w:i,h:o}=this.boundary;this.topLeft=new n(new s(e,t,i/2,o/2),this),this.topRight=new n(new s(e+i/2,t,i/2,o/2),this),this.bottomLeft=new n(new s(e,t+o/2,i/2,o/2),this),this.bottomRight=new n(new s(e+i/2,t+o/2,i/2,o/2),this),this.divided=!0}queryRect(e){let t=[];if(this.boundary.intersects(e))t.push(...this.objects);else return[];return this.divided&&(c(t,this.topLeft.queryRect(e)),c(t,this.topRight.queryRect(e)),c(t,this.bottomLeft.queryRect(e)),c(t,this.bottomRight.queryRect(e))),t}queryPoint(e){let t=[];if(this.boundary.intersectsPoint(e))t.push(...this.objects);else return[];return this.divided&&(c(t,this.topLeft.queryPoint(e)),c(t,this.topRight.queryPoint(e)),c(t,this.bottomLeft.queryPoint(e)),c(t,this.bottomRight.queryPoint(e))),t}insert(e){return(this.parent?!this.boundary.contains(e):!this.boundary.intersects(e))?!1:this.objects.length<this.capacity?(this.objects.push(e),!0):(this.divided||this.subdivide(),(this.topLeft.insert(e)||this.topRight.insert(e)||this.bottomLeft.insert(e)||this.bottomRight.insert(e))===!1&&this.objects.push(e),!0)}drawObjects(e){this.objects.forEach(t=>t.draw(e)),this.divided&&(this.topLeft.drawObjects(e),this.topRight.drawObjects(e),this.bottomLeft.drawObjects(e),this.bottomRight.drawObjects(e))}draw(e){e.rect(this.boundary.x,this.boundary.y,this.boundary.w,this.boundary.h),this.divided&&(this.topLeft.draw(e),this.topRight.draw(e),this.bottomLeft.draw(e),this.bottomRight.draw(e)),e.strokeStyle="black",e.lineWidth=4,e.stroke()}};var d=200,S=10;function z(n,e,t,i,o,h,k="-1"){let p=1/0,f=1/0,g=-1/0,P=-1/0,O=new s(-S,0,5,t),K=new s(-S,0,e,5),W=new s(e-5,0,e+S,t),V=new s(0,t-5,e,t+S),Q=Z(e,t,i,o,h),Y=[O,K,W,V],E=new s(-d,-d,e+d*2,t+d*2);for(let r of n){let R,T;for(let u=0;u<r.bboxes.length;u++){if(r.bboxes[u]==null||(R=r.bboxes[u].boundingBox,T=r.bboxes[u].index,r.lockedToStrategyIndex!==-1&&T!==r.lockedToStrategyIndex))continue;let[I,a,b,N]=R,[m,F,D,U]=[r.y-I,r.y+a,r.x-b,r.x+N],B=D,L=m,A=U-D,_=F-m;p=Math.min(p,B)-d,f=Math.min(f,L)-d,g=Math.max(g,B+A)+d,P=Math.max(P,L+_)+d,r.bboxes[u].boundingRect=new s(B,L,A,_)}}let y={msgId:k,colliders:new Array(n.length),debug:[]},C=new w(new s(p,f,g-p,P-f)),x;for(let r=0;r<n.length;r++)if(x=n[r],y.colliders[r]=[-1,0],x.enabledAndVisible){let[R,T,u]=[1/0,-1,void 0];for(let{index:I,boundingRect:a}of x.bboxes){if(a==null)continue;let b=[];if(b=C.queryRect(a).filter(m=>a.intersects(m)),x.shouldCollideWithScreenEdges&&Y.forEach(m=>{a.intersects(m)&&b.push(m)}),a.intersects(Q)){y.colliders[r]=[-1,0,a];break}if(b.length<=R&&(u=a,T=I,R=b.length),b.length===0){C.insert(a),y.colliders[r]=[I,E.contains(a)?0:1,a];break}}x.rank===5&&u!=null&&(C.insert(u),y.colliders[r]=[T,E.contains(u)?0:1,u])}else y.colliders[r]=[-1,0];return y}function Z(n,e,t,i,o){switch(o){case"top-right":return new s(n-t,0,t,i);case"bottom-left":return new s(0,e-i,t,i);case"bottom-right":return new s(n-t,e-i,t,i);case"top-left":return new s(0,0,t,i)}}function X(n){let e=n[0].map(t=>{let i=t[0].map(o=>({index:o[4],boundingBox:[o[0],o[1],o[2],o[3]]}));return{enabledAndVisible:t[1]===1,rank:t[2]===1?5:0,x:t[3],y:t[4],shouldCollideWithScreenEdges:t[5]===1,bboxes:i,lockedToStrategyIndex:t[6]}});return{msgId:"-1",totalWidth:n[3],totalHeight:n[2],watermarkWidth:n[4],watermarkHeight:n[5],watermarkPosition:n[6],colliders:e,devicePixelRatio:n[1]}}self.onmessage=n=>{let e=X(n.data);self.postMessage(z(e.colliders,e.totalWidth,e.totalHeight,e.watermarkWidth,e.watermarkHeight,e.watermarkPosition,e.msgId))};})();\n';
c();
c();
c();
c();
c();
function T5(r3, t3) {
  return t3.x + t3.w < r3.x + r3.w && t3.x > r3.x && t3.y > r3.y && t3.y + t3.h < r3.y + r3.h;
}
c();
function w5(r3, t3) {
  let [e2, i] = t3;
  return e2 >= r3.x && e2 <= r3.x + r3.w && i >= r3.y && i <= r3.y + r3.h;
}
c();
function D5(r3, t3) {
  let e2 = t3.x, i = t3.y, o = t3.x + t3.w, n = t3.y + t3.h, s2 = r3.x, c2 = r3.y, l = r3.x + r3.w, p = r3.y + r3.h;
  return e2 < l && s2 < o && i < p && c2 < n;
}
c();
function Ri(r3, t3) {
  for (let e2 = 0; e2 < t3.length; e2++) r3.push(t3[e2]);
}
c();
var qe = class {
  constructor(t3, e2, i, o, n) {
    t(this, "x");
    t(this, "y");
    t(this, "w");
    t(this, "h");
    t(this, "userData");
    this.userData = typeof n > "u" ? null : n, this.x = t3, this.y = e2, this.w = i, this.h = o;
  }
  contains(t3) {
    return t3 === this ? false : T5(this, t3);
  }
  intersects(t3) {
    return D5(this, t3);
  }
  intersectsPoint(t3) {
    return w5(this, t3);
  }
  draw(t3) {
    t3.fillStyle = "rgba(123,222,26, 0.8)", t3.fillRect(this.x, this.y, this.w, this.h);
  }
};
var ni = class r2 {
  constructor(t3, e2) {
    t(this, "topLeft");
    t(this, "topRight");
    t(this, "bottomLeft");
    t(this, "bottomRight");
    t(this, "divided", false);
    t(this, "boundary");
    t(this, "capacity", 16);
    t(this, "objects", []);
    t(this, "parent");
    this.parent = e2, this.boundary = t3;
  }
  getSize() {
    return this.divided ? this.objects.length + this.topLeft.getSize() + this.topRight.getSize() + this.bottomLeft.getSize() + this.bottomRight.getSize() : this.objects.length;
  }
  subdivide() {
    let { x: t3, y: e2, w: i, h: o } = this.boundary;
    this.topLeft = new r2(new qe(t3, e2, i / 2, o / 2), this), this.topRight = new r2(new qe(t3 + i / 2, e2, i / 2, o / 2), this), this.bottomLeft = new r2(new qe(t3, e2 + o / 2, i / 2, o / 2), this), this.bottomRight = new r2(new qe(t3 + i / 2, e2 + o / 2, i / 2, o / 2), this), this.divided = true;
  }
  queryRect(t3) {
    let e2 = [];
    if (this.boundary.intersects(t3)) e2.push(...this.objects);
    else return [];
    return this.divided && (Ri(e2, this.topLeft.queryRect(t3)), Ri(e2, this.topRight.queryRect(t3)), Ri(e2, this.bottomLeft.queryRect(t3)), Ri(e2, this.bottomRight.queryRect(t3))), e2;
  }
  queryPoint(t3) {
    let e2 = [];
    if (this.boundary.intersectsPoint(t3)) e2.push(...this.objects);
    else return [];
    return this.divided && (Ri(e2, this.topLeft.queryPoint(t3)), Ri(e2, this.topRight.queryPoint(t3)), Ri(e2, this.bottomLeft.queryPoint(t3)), Ri(e2, this.bottomRight.queryPoint(t3))), e2;
  }
  insert(t3) {
    return (this.parent ? !this.boundary.contains(t3) : !this.boundary.intersects(t3)) ? false : this.objects.length < this.capacity ? (this.objects.push(t3), true) : (this.divided || this.subdivide(), (this.topLeft.insert(t3) || this.topRight.insert(t3) || this.bottomLeft.insert(t3) || this.bottomRight.insert(t3)) === false && this.objects.push(t3), true);
  }
  drawObjects(t3) {
    this.objects.forEach((e2) => e2.draw(t3)), this.divided && (this.topLeft.drawObjects(t3), this.topRight.drawObjects(t3), this.bottomLeft.drawObjects(t3), this.bottomRight.drawObjects(t3));
  }
  draw(t3) {
    t3.rect(this.boundary.x, this.boundary.y, this.boundary.w, this.boundary.h), this.divided && (this.topLeft.draw(t3), this.topRight.draw(t3), this.bottomLeft.draw(t3), this.bottomRight.draw(t3)), t3.strokeStyle = "black", t3.lineWidth = 4, t3.stroke();
  }
};
c();
function O5(r3, t3, e2) {
  let i, o, n, s2 = null, c2 = 0;
  e2 || (e2 = {});
  let l = function() {
    c2 = e2.leading === false ? 0 : Date.now(), s2 = null, n = r3.apply(i, o), s2 || (i = o = null);
  };
  return function() {
    let p = Date.now();
    !c2 && e2.leading === false && (c2 = p);
    let d = t3 - (p - c2);
    return i = globalThis, o = arguments, d <= 0 || d > t3 ? (s2 && (clearTimeout(s2), s2 = null), c2 = p, n = r3.apply(i, o), s2 || (i = o = null)) : !s2 && e2.trailing !== false && (s2 = setTimeout(l, d)), n;
  };
}
var Zn = false;
var bT = 150;
var eh = class extends _n {
  constructor(e2, i, o = new Worker(URL.createObjectURL(new Blob([M5], { type: "text/javascript" })))) {
    super();
    t(this, "worker");
    t(this, "debugContext");
    t(this, "debugCanvas");
    t(this, "collidersDirty", true);
    t(this, "packedMessage", [[], 0, 0, 0, 0, 0, "bottom-left"]);
    t(this, "visibleCollidersQTree", new ni(new qe(0, 0, 0, 0)));
    t(this, "interactiveCollidersQTree", new ni(new qe(0, 0, 0, 0)));
    t(this, "coreState");
    t(this, "postMessage");
    t(this, "showCollisionBoxes", () => {
      Zn = true, this.debugCanvas.style.display = "block";
    });
    t(this, "hideCollisionBoxes", () => {
      Zn = false, this.debugContext.clearRect(0, 0, this.debugCanvas.width, this.debugCanvas.height), this.debugCanvas.style.display = "none";
    });
    t(this, "currentMsgId", "");
    t(this, "working", false);
    t(this, "_postMessage", () => {
      this.worker.postMessage(this.packedMessage);
    });
    t(this, "componentArray", []);
    t(this, "update", (e3, i2, o2 = "bottom-left", n = false) => {
      let s2 = false;
      if (this.collidersDirty) {
        this.packedMessage = [[], 0, 0, 0, 0, 0, "bottom-left"], this.componentArray = [];
        let c2;
        for (let l of this.coreState.geometry2DIdsInScene) {
          let p = this.coreState.geometry2DMap.get(l);
          p && (c2 = p.components[0], this.componentArray.push(c2));
        }
        this.resize(e3, i2, o2), this.collidersDirty = false, s2 = true;
      } else s2 = this.componentArray.some((c2) => c2.collisionDirty === true);
      s2 && this.componentArray.sort((c2, l) => l.rank - c2.rank);
      for (let c2 = 0; c2 < this.componentArray.length; c2++) if (this.packedMessage) {
        let l = this.componentArray[c2].toPackedMessage(n && !s2);
        this.packedMessage[0][c2] == null && (this.packedMessage[0][c2] = []), this.packedMessage[0][c2][0] == null && (this.packedMessage[0][c2][0] = []), this.packedMessage[0][c2][0] = l.bboxes, this.packedMessage[0][c2][1] = l.enabled && this.componentArray[c2].visible && !this.componentArray[c2].isOccluded ? 1 : 0, this.packedMessage[0][c2][2] = l.rank === 5 ? 1 : 0, this.packedMessage[0][c2][3] = l.x, this.packedMessage[0][c2][4] = l.y, this.packedMessage[0][c2][5] = l.shouldCollideWithScreenEdges ? 1 : 0, this.packedMessage[0][c2][6] = l.lockedToStrategyIndex;
      }
      this.working || this.postMessage();
    });
    t(this, "resolve", (e3) => {
      if (this.working = false, this.collidersDirty || !e3.data) return;
      let i2 = e3.data.colliders, o2 = -1, n, s2, c2;
      Zn && (this.visibleCollidersQTree = new ni(new qe(0, 0, this.debugCanvas.width, this.debugCanvas.height))), this.interactiveCollidersQTree = new ni(new qe(0, 0, this.debugCanvas.width, this.debugCanvas.height));
      for (let l = 0; l < this.componentArray.length; l++) {
        let p = this.componentArray[l];
        i2[l] != null && (o2 = i2[l][0], n = i2[l][2], p.offscreen = i2[l][1] === 1, o2 !== -1 && n != null ? (c2 = new qe(n.x, n.y, n.w, n.h, { entityId: p.id }), Zn && this.visibleCollidersQTree.insert(c2), s2 = this.coreState.geometry2DMap.get(p.id), (s2 == null ? void 0 : s2.components[1]) != null && this.interactiveCollidersQTree.insert(new qe(n.x, n.y, n.w, n.h, { entityId: p.id })), (p.canShow === false || p.visibilityNeedsUpdate !== false) && "visibilityNeedsUpdate" in p && (p.visibilityNeedsUpdate = "show"), o2 !== -1 && o2 !== p.currentStrategyIndex && (p.activeBoundingBox = c2, p.onStrategySelected(o2))) : ((p.canShow === true || p.visibilityNeedsUpdate !== false) && "visibilityNeedsUpdate" in p && (p.visibilityNeedsUpdate = "hide"), o2 !== -1 && o2 !== p.currentStrategyIndex && p.onStrategySelected(o2)));
      }
      Zn && this.drawDebug(), this.publish("visibility-changed");
    });
    t(this, "drawDebug", () => {
      Zn && this.visibleCollidersQTree && (this.debugContext.clearRect(0, 0, this.debugCanvas.width, this.debugCanvas.height), this.debugContext.beginPath(), this.visibleCollidersQTree.drawObjects(this.debugContext));
    });
    t(this, "destroy", () => {
      this.worker.terminate();
    });
    this.coreState = i, this.debugCanvas = e2, this.debugContext = e2.getContext("2d"), this.worker = o, this.worker.onmessage = (n) => this.resolve(n), this.postMessage = O5(this._postMessage, bT, false), Zn ? this.showCollisionBoxes() : this.hideCollisionBoxes();
  }
  resize(e2, i, o) {
    this.packedMessage[6] = o, this.packedMessage[5] = i, this.packedMessage[4] = e2, this.packedMessage[3] = this.debugCanvas.width, this.packedMessage[2] = this.debugCanvas.height;
  }
};
c();
c();
c();
c();
var th = class {
  constructor(t3) {
    t(this, "type");
    t(this, "event");
    this.type = 0, this.event = t3;
  }
  get timestamp() {
    return this.event.timeStamp;
  }
};
var rh = class {
  constructor() {
    t(this, "taps", []);
  }
  add(t3) {
    this.lastPointerDown && t3.timestamp - this.lastPointerDown.timestamp < 50 ? this.lastPointerDown.type = 1 : this.taps.push(t3);
  }
  get lastPointerDown() {
    return this.taps.length >= 1 ? this.taps[this.taps.length - 1] : void 0;
  }
  get isSingleTapWithTwoFingers() {
    var t3;
    return this.isSingleTap && ((t3 = this.lastPointerDown) == null ? void 0 : t3.type) === 1;
  }
  get isSingleTapWithOneFinger() {
    var t3;
    return this.isSingleTap && ((t3 = this.lastPointerDown) == null ? void 0 : t3.type) === 0;
  }
  get isDoubleTapWithOneFinger() {
    var t3, e2;
    return this.isDoubleTap && ((t3 = this.taps[0]) == null ? void 0 : t3.type) === 0 && ((e2 = this.taps[1]) == null ? void 0 : e2.type) === 0;
  }
  get isSingleTap() {
    return this.taps.length === 1;
  }
  get isDoubleTap() {
    return this.taps.length === 2;
  }
  discardOutsideOfWaitWindow(t3) {
    this.taps = this.taps.filter((e2) => t3 - e2.timestamp < 300);
  }
  flush() {
    this.taps = [];
  }
  get _taps() {
    return this.taps;
  }
  destroy() {
    this.flush();
  }
};
c();
function A5(r3) {
  let t3 = /* @__PURE__ */ new Set();
  for (let e2 of r3) {
    let i = e2.object;
    for (; i.parent && !t3.has(i.parent); ) i = i.parent, i instanceof mt && i.type === "group-container" && i.visible && i.components[1] && t3.add(i);
  }
  return Array.from(t3);
}
function F5(r3, t3) {
  if (r3 == null || t3 == null) return r3 === t3;
  if (r3.length !== t3.length) return false;
  for (let e2 = 0; e2 < r3.length; e2++) if (r3[e2] !== t3[e2]) return false;
  return true;
}
var Ss;
var xc = class extends _n {
  constructor(e2, i, o, n, s2) {
    super();
    t(this, "raycaster", new Tl());
    t(this, "state", { hovered3DEntity: void 0, hovered2DEntity: void 0, hovered3DContainers: void 0, lastHover: void 0, interaction: { mouseDownStart: void 0, distanceFromMouseDown: void 0, isPanning: false } });
    t(this, "coreState");
    t(this, "camera");
    t(this, "worldPlane");
    t(this, "_quadtree", new ni(new qe(0, 0, 0, 0)));
    t(this, "_container");
    t(this, "lastPointerEvent");
    t(this, "cursor", "grab");
    t(this, "touchesCount", 0);
    t(this, "isUserInteracting");
    t(this, "hasTouched", false);
    v(this, Ss);
    t(this, "onPointerMoveRaf", (e3) => {
      this.lastPointerEvent = e3, u(this, Ss) && cancelAnimationFrame(u(this, Ss)), w(this, Ss, requestAnimationFrame(() => {
        this.onPointerMove(e3);
      }));
    });
    t(this, "onPointerMove", (e3) => {
      e3.preventDefault(), this.updateInteractionStateIfPanning(e3), (e3.pointerType !== "touch" || e3.pointerType === void 0 && this.hasTouched) && this.handleHover(e3), this.handleCursor();
    });
    t(this, "tapsControl", new rh());
    t(this, "onPointerDown", (e3) => {
      e3.target === this._container && (this._container.addEventListener("pointerup", this.onPointerUp, false), this._container.addEventListener("pointercancel", this.onPointerUp, false), this.state.interaction.mouseDownStart = { time: Date.now(), timestamp: e3.timeStamp, clientX: e3.clientX, clientY: e3.clientY }, this.lastPointerEvent = e3, this.state.interaction.distanceFromMouseDown = 0, this.handleCursor(), e3.pointerType === "touch" && (this.tapsControl.add(new th(e3)), this.touchesCount = Math.max(0, this.touchesCount + 1)));
    });
    t(this, "clickTimeout");
    t(this, "onPointerUp", (e3) => {
      this.tapsControl.discardOutsideOfWaitWindow(e3.timeStamp), this.lastPointerEvent = e3, this.touchesCount = Math.max(0, this.touchesCount - 1), this.touchesCount === 0 && (this._container.removeEventListener("pointerup", this.onPointerUp, false), this._container.removeEventListener("pointercancel", this.onPointerUp, false)), this.updateInteractionStateIfPanning(e3);
      let { mouseDownStart: i2 } = this.state.interaction;
      !i2 || this.state.interaction.distanceFromMouseDown == null || (Date.now() < i2.time + 300 && (this.tapsControl.isSingleTapWithTwoFingers || this.state.interaction.distanceFromMouseDown <= 15) && (e3.pointerType === "touch" ? this.tapsControl.isSingleTapWithTwoFingers ? (this.publish("singletap-with-twofinger", e3), this.flush()) : this.tapsControl.isSingleTapWithOneFinger && this.touchesCount === 0 ? (this.clickTimeout && clearTimeout(this.clickTimeout), this.clickTimeout = window.setTimeout(() => {
        this.handleClick(e3), this.flush();
      }, 300)) : this.tapsControl.isDoubleTapWithOneFinger && (this.publish("doubletap-with-onefinger", e3), this.flush()) : this.handleClick(e3)), this.state.interaction.mouseDownStart = void 0, this.state.interaction.distanceFromMouseDown = void 0, this.state.interaction.isPanning = false, this.handleCursor());
    });
    t(this, "dirty3D", true);
    t(this, "cachedHitBoxes", { entities: [], groups: [] });
    t(this, "ndcPoint", new at());
    t(this, "debugPanel");
    this.isUserInteracting = s2, this.raycaster.layers.enableAll(), this.raycaster.layers.disable(1), this.camera = o, this._container = e2, this.coreState = i, this.worldPlane = n, this._container.addEventListener("pointerdown", this.onPointerDown, false), this._container.addEventListener("pointermove", this.onPointerMoveRaf, false), this._container.classList.add("mappedin-interactive");
  }
  updateQuadtree(e2) {
    this._quadtree = e2;
  }
  setHovered3DEntityInteractionComponentDirty() {
    if (this.state.hovered3DEntity) {
      let e2 = this.state.hovered3DEntity.components[2];
      e2 && (e2.dirty = true);
    }
  }
  getThreeDIntersectsFromXY(e2) {
    return this.raycaster.setFromCamera(e2, this.camera), this.raycaster.layers.enable(0), this.raycaster.intersectObjects(this._hitBoxes.entities, false).filter((o) => {
      var n, s2;
      return ((n = o.object) == null ? void 0 : n.name) === "worldPlane" || ((s2 = o.object) == null ? void 0 : s2.visible);
    });
  }
  getGroupContainerIntersectsFromXY(e2) {
    this.raycaster.setFromCamera(e2, this.camera), this.raycaster.layers.enable(0);
    let i = this.raycaster.intersectObjects(this._hitBoxes.groups, true).filter((n) => n.object.visible), o;
    return i != null && i.length > 0 && (o = A5(i)), o;
  }
  flush() {
    this.tapsControl.flush(), this.clickTimeout != null && (clearTimeout(this.clickTimeout), this.clickTimeout = void 0);
  }
  handleHover(e2) {
    let i = e2 || this.lastPointerEvent;
    if (this.state.interaction.mouseDownStart || !i || this.isUserInteracting()) return;
    let { entity3D: o, entity2D: n, position: s2, groupContainers: c2 } = this.intersect(i);
    (this.detect3DEntityHover(o) || this.detect2DEntityHover(n) || this.detect3DContainerHover(c2)) && (this.state.hovered3DEntity = o, this.state.lastHover = o, this.state.hovered2DEntity = n, this.state.hovered3DContainers = c2, this.publish("hover", { entity2D: this.state.hovered2DEntity, entity3D: this.state.hovered3DEntity, position: s2, groupContainers: c2 })), this.handleCursor();
  }
  handleCursor() {
    var s2;
    let e2 = !!(this.state.hovered3DEntity && ((s2 = this.state.hovered3DEntity) != null && s2.components[2]) || this.state.hovered2DEntity), i = !!this.state.interaction.mouseDownStart, o = this.state.interaction.isPanning, n = ST(e2, o, i);
    this.cursor !== n && (this.cursor = n, n === "pointer" ? this._container.classList.add("mappedin-interaction-hover") : this._container.classList.remove("mappedin-interaction-hover"));
  }
  detect2DEntityHover(e2) {
    return this.state.hovered2DEntity !== e2;
  }
  handleClick(e2) {
    let i = this.intersect(e2);
    this.publish("click", { entity2D: i.entity2D, entity3D: i.entity3D, position: i.position, groupContainers: i.groupContainers, pointerEvent: { button: e2.button } });
  }
  get _hitBoxes() {
    if (this.dirty3D) {
      this.cachedHitBoxes.entities = [], this.cachedHitBoxes.groups = [];
      let e2;
      for (let i of this.coreState.geometry3DIdsInScene) e2 = this.coreState.geometry3DMap.get(i), (e2 == null ? void 0 : e2.type) === "geometry" || (e2 == null ? void 0 : e2.type) === "model" || (e2 == null ? void 0 : e2.type) === "path" || (e2 == null ? void 0 : e2.type) === "custom-geometry" ? e2.components[0].mesh && !this.cachedHitBoxes.entities.includes(e2.components[0].mesh) && this.cachedHitBoxes.entities.push(e2.components[0].mesh) : (e2 == null ? void 0 : e2.type) === "group-container" && e2.components[1] && !this.cachedHitBoxes.groups.includes(e2) && this.cachedHitBoxes.groups.push(e2);
      return this.dirty3D = false, this.cachedHitBoxes.entities.push(this.worldPlane), this.cachedHitBoxes;
    }
    return this.cachedHitBoxes;
  }
  intersect(e2) {
    var y, S, T, w2, M2;
    let i = [e2.offsetX, e2.offsetY], o = this._quadtree.queryPoint(i), [n] = o.filter((D) => D.intersectsPoint(i)), s2 = this.coreState.containerOffset[0], c2 = this.coreState.containerOffset[1];
    this.ndcPoint.x = (e2.clientX - c2) / this._container.clientWidth * 2 - 1, this.ndcPoint.y = -((e2.clientY - s2) / this._container.clientHeight) * 2 + 1;
    let l = this.getThreeDIntersectsFromXY(this.ndcPoint), p = (y = l[0]) == null ? void 0 : y.point, d = [], f = [];
    for (let D of l.filter((F) => F.object.name !== "worldPlane")) D.object instanceof ve && D.object.material.depthTest === false ? d.push(D) : f.push(D);
    let g = (T = (S = d[0]) != null ? S : f[0]) != null ? T : void 0, v2, b;
    if (g != null) {
      if (v2 = IT(g.object, this.coreState.geometry3DMap), !v2) {
        let D = (w2 = g == null ? void 0 : g.instanceId) != null ? w2 : g == null ? void 0 : g.batchId;
        v2 = D != null && (g != null && g.object.userData.entities) ? this.coreState.geometry3DMap.get(g == null ? void 0 : g.object.userData.entities[D]) : this.coreState.geometry3DMap.get(g == null ? void 0 : g.object.userData.entityId);
      }
      v2 != null && v2.components[2] && (b = v2);
    }
    let C = this.getGroupContainerIntersectsFromXY(this.ndcPoint);
    return { entity2D: ((M2 = n == null ? void 0 : n.userData) == null ? void 0 : M2.entityId) === "watermark" ? { id: "watermark" } : this.coreState.geometry2DMap.get(n == null ? void 0 : n.userData.entityId), entity3D: b, position: p, groupContainers: C };
  }
  detect3DEntityHover(e2) {
    return this.state.lastHover !== e2 && (this.state.lastHover && B5(this.state.lastHover, false, this.coreState), e2 && B5(e2, true, this.coreState)), this.state.hovered3DEntity !== e2;
  }
  detect3DContainerHover(e2) {
    return !F5(this.state.hovered3DContainers, e2);
  }
  updateInteractionStateIfPanning(e2) {
    this.state.interaction.mouseDownStart && (this.state.interaction.distanceFromMouseDown = Math.sqrt(Math.pow(e2.clientX - this.state.interaction.mouseDownStart.clientX, 2) + Math.pow(e2.clientY - this.state.interaction.mouseDownStart.clientY, 2)), !this.state.interaction.isPanning && this.state.interaction.distanceFromMouseDown > 15 && (this.state.interaction.isPanning = true));
  }
  getMouseRayIntersects() {
    return this.raycaster.intersectObjects([this.worldPlane], false);
  }
  destroy() {
    this._container.removeEventListener("pointerdown", this.onPointerDown, false), this._container.removeEventListener("pointermove", this.onPointerMoveRaf, false), this._container.removeEventListener("pointerup", this.onPointerUp, false), this._container.removeEventListener("pointercancel", this.onPointerUp, false);
  }
  enableDebug() {
    let e2 = document.createElement("div");
    e2.style.position = "absolute", e2.style.top = "0", e2.style.right = "0", e2.style.backgroundColor = "white", e2.style.padding = "10px", document.body.append(e2), e2.id = "interaction-debug-panel", this.debugPanel = e2, this.on("doubletap-with-onefinger", () => {
      this.queueDebugMessage("doubletap-with-onefinger", "#ffadad");
    }), this.on("singletap-with-twofinger", () => {
      this.queueDebugMessage("singletap-with-twofinger", "#ffd6a5");
    }), this.on("click", (i) => {
      var o, n, s2;
      this.queueDebugMessage("CLICK \n3D: ".concat((o = i.entity3D) == null ? void 0 : o.id, " \n2D: ").concat((n = i.entity2D) == null ? void 0 : n.id, " \nPos: ").concat((s2 = i.position) == null ? void 0 : s2.toArray().join(", ")), "#fdffb6");
    }), this.on("hover", (i) => {
      var o, n, s2;
      this.queueDebugMessage("HOVER \n3D: ".concat((o = i.entity3D) == null ? void 0 : o.id, " \n2D: ").concat((n = i.entity2D) == null ? void 0 : n.id, " \nPos: ").concat((s2 = i.position) == null ? void 0 : s2.toArray().join(", ")), "#caffbf");
    });
  }
  get _state() {
    return this.state;
  }
  queueDebugMessage(e2, i) {
    var n;
    let o = document.createElement("pre");
    o.style.maxWidth = "300px", o.style.transition = "opacity 500ms cubic-bezier(0.4, 0, 0.2, 1)", o.style.backgroundColor = i, o.textContent = e2, (n = this.debugPanel) == null || n.prepend(o), setTimeout(() => {
      o.style.opacity = "0", setTimeout(() => {
        o.remove();
      }, 500);
    }, 2500);
  }
  getCursor() {
    return this.cursor;
  }
};
Ss = /* @__PURE__ */ new WeakMap();
function B5(r3, t3, e2) {
  var s2;
  let i = r3.components[2];
  i && i.hover !== true && (i.hover = t3 ? "user-interaction" : false, i.dirty = true);
  let o = (s2 = r3.components[0].textMesh) == null ? void 0 : s2.userData.entityId;
  if (!o) return;
  let n = e2.geometry3DMap.get(o);
  (n == null ? void 0 : n.type) === "text3d" && (n.components[1].hoverByPolygon = t3, n.components[1].dirty = true);
}
function ST(r3, t3, e2) {
  return t3 ? "grabbing" : r3 ? "pointer" : e2 ? "grabbing" : "grab";
}
function xT(r3) {
  let t3 = r3;
  for (; t3 != null && t3.parent; ) {
    if (t3 instanceof Ho) return;
    if (t3.userData.isSingleModel) return t3;
    t3 = t3.parent;
  }
}
function IT(r3, t3) {
  let e2 = xT(r3);
  return e2 ? t3.get(e2.userData.entityId) : void 0;
}
c();
c();
var zn2;
var ai;
var ih;
var Ro;
var _5;
var Pc;
var oh;
var R5;
var N5;
var Mc;
var nh;
var Tc;
var wc;
var ah;
var Ic = class {
  constructor(t3) {
    v(this, Ro);
    v(this, zn2, null);
    v(this, ai);
    t(this, "getCurrentSceneGLTF", async (t4) => {
      let e2 = { onlyVisible: true, binary: true, light: true, scale: 1, ...t4 }, i = await x(this, Ro, _5).call(this), o = u(this, ih).call(this, e2), n = await i.parseAsync(o, { trs: false, maxTextureSize: 1 / 0, onlyVisible: e2.onlyVisible, binary: e2.binary, scale: e2.scale }), s2;
      if (n instanceof ArrayBuffer) s2 = new Blob([n], { type: "application/octet-stream" });
      else {
        let c2 = JSON.stringify(n, null, 2);
        s2 = new Blob([c2], { type: "text/plain" });
      }
      return s2;
    });
    v(this, ih, (t4) => {
      let { scale: e2, light: i, onlyVisible: o } = t4, n = new Ho(), s2 = new Ie().setFromObject(u(this, ai).entityScene);
      if (u(this, Pc).call(this, u(this, ai).entityScene, n, o), i) {
        let c2 = new xl(16777215, 0.3 * Math.PI);
        c2.position.set(0, Math.max(s2.max.x, s2.max.y) * e2 * 0.5, s2.max.y * e2 * 4), c2.lookAt(0, 0, -1), c2.target.position.set(0, 0, -1), c2.add(c2.target), n.add(c2);
      }
      return n;
    });
    v(this, Pc, (t4, e2, i) => {
      t4.material && (t4 instanceof Jo ? x(this, Ro, R5).call(this, t4).forEach((o) => e2.add(o)) : t4 instanceof kr && e2.add(x(this, Ro, N5).call(this, t4))), t4.children.forEach((o) => {
        (!i || o.visible) && u(this, Pc).call(this, o, e2, i);
      });
    });
    v(this, oh, (t4, e2, i) => {
      let o = new Jr({ color: new Nt(t4), metalness: 0 });
      return o.opacity = e2, o.transparent = i, o;
    });
    v(this, Mc, (t4) => {
      let { geometry: e2, material: i, position: o, rotation: n, quaternion: s2, scale: c2 } = t4;
      if (!(e2 != null && e2.isBufferGeometry)) return t4;
      let l = e2.attributes.position, p = e2.attributes.normal, d = e2.attributes.uv;
      return u(this, nh).call(this, l, p), u(this, wc).call(this, o, c2, n, s2), d && u(this, ah).call(this, d), i != null && i.map && e2.type === "PlaneGeometry" && (t4.side = ln), t4;
    });
    v(this, nh, (t4, e2) => {
      let i = new R(), o = new R();
      for (let n = 0; n < t4.count; n++) i.fromBufferAttribute(t4, n), u(this, Tc).call(this, i), t4.setXYZ(n, i.x, i.y, i.z), e2 && (o.fromBufferAttribute(e2, n), u(this, Tc).call(this, o), e2.setXYZ(n, o.x, o.y, o.z));
    });
    v(this, Tc, (t4) => {
      let e2 = t4.y;
      t4.y = t4.z, t4.z = -e2;
    });
    v(this, wc, (t4, e2, i, o) => {
      let n = t4.y;
      t4.y = t4.z, t4.z = -n;
      let s2 = e2.y;
      if (e2.y = e2.z, e2.z = s2, i instanceof Ye) i.order = "YXZ", i.set(i.x, i.y, i.z, i.order);
      else {
        let c2 = o.y;
        o.set(o.x, o.z, -c2, o.w);
      }
    });
    v(this, ah, (t4) => {
      for (let e2 = 0; e2 < t4.count; e2++) {
        let i = t4.getX(e2), o = t4.getY(e2);
        t4.setXY(e2, i, o);
      }
    });
    w(this, ai, t3), u(this, ai).entityScene = t3.entityScene, u(this, ai).geometry3DMap = t3.geometry3DMap;
  }
  destroy() {
    w(this, zn2, null);
  }
};
zn2 = /* @__PURE__ */ new WeakMap(), ai = /* @__PURE__ */ new WeakMap(), ih = /* @__PURE__ */ new WeakMap(), Ro = /* @__PURE__ */ new WeakSet(), _5 = async function() {
  if (!u(this, zn2)) {
    let { GLTFExporter: t3 } = await import("./GLTFExporter-6UJSTWST-3AC2QJAZ.js");
    w(this, zn2, new t3());
  }
  return u(this, zn2);
}, Pc = /* @__PURE__ */ new WeakMap(), oh = /* @__PURE__ */ new WeakMap(), R5 = function(t3) {
  var s2, c2;
  let e2 = [], o = ((s2 = t3.userData) != null && s2.entities ? Object.values((c2 = t3.userData) == null ? void 0 : c2.entities) : []).map((l) => u(this, ai).geometry3DMap.get(l)), n = /* @__PURE__ */ new Map();
  return o.forEach((l) => {
    var v2;
    if (!l || !(l instanceof Pt)) return;
    let p = l.components[1], d = l.components[2];
    if (!p.visible || p instanceof Go && p.opacity === 0 || p instanceof fa || p instanceof da) return;
    let f = d != null && d.hover ? p.hoverColor || u(this, ai).hoverColor : p.color, g = "".concat(f, "-").concat(p.opacity, "-").concat(Number(p.visible));
    n.has(g) || n.set(g, []), (v2 = n.get(g)) == null || v2.push(l);
  }), n.forEach((l, p) => {
    let [d, f, g] = p.split("-"), v2 = l.reduce((S, T) => {
      if (T.type === "custom-geometry") return S;
      let w2 = T.components[0];
      return "geometry" in w2 && w2.geometry instanceof fe && S.push(w2.geometry), S;
    }, []), b = u(this, oh).call(this, d, Number(f), t3.material.transparent), C = M(v2, true), y = new ve(C, b);
    y.position.copy(t3.position), y.rotation.copy(t3.rotation), y.scale.copy(t3.scale), y.visible = !!g, u(this, wc).call(this, y.position, y.scale, y.rotation, y.quaternion), e2.push(u(this, Mc).call(this, y));
  }), e2;
}, N5 = function(t3) {
  let e2 = t3.geometry.clone(), i = t3.material, o = new fs({ color: i.color, side: ln });
  o.opacity = i.opacity, o.transparent = i.transparent;
  let n = new kr(e2, o);
  return n.position.copy(t3.position), n.rotation.copy(t3.rotation), n.scale.copy(t3.scale), n.visible = t3.visible, u(this, Mc).call(this, n);
}, Mc = /* @__PURE__ */ new WeakMap(), nh = /* @__PURE__ */ new WeakMap(), Tc = /* @__PURE__ */ new WeakMap(), wc = /* @__PURE__ */ new WeakMap(), ah = /* @__PURE__ */ new WeakMap();
c();
c();
c();
var by = s(z5());
function q5(r3) {
  this.name = "JSClipperError", this.message = r3, this.stack = new Error().stack;
}
q5.prototype = Error.prototype;
by.default.Error = function(r3) {
  throw new q5(r3);
};
var Je = by.default;
var g8 = "gray";
var y8 = 0.1;
var Oc = 100;
var vy2 = new Je.ClipperOffset();
function b8(r3, t3) {
  vy2.Clear(), t3 /= 2;
  let e2 = r3.map((o) => ({ X: o.x * Oc, Y: o.y * Oc }));
  vy2.AddPath(e2, Je.JoinType.jtMiter, Je.EndType.etClosedPolygon);
  let i = new Je.Paths();
  return vy2.Execute(i, t3 * Oc), i.length ? i.map((n) => n.map((s2) => ({ x: s2.X / Oc, y: s2.Y / Oc }))) : [r3];
}
function dh(r3, t3, e2) {
  var g, v2, b, C, y;
  let { color: i = g8, opacity: o = 1, altitude: n = 0, height: s2 = y8 } = e2 || {};
  Array.isArray(o) && (o = 1);
  let c2 = { min: { x: 1 / 0, y: 1 / 0, z: n }, max: { x: -1 / 0, y: -1 / 0, z: s2 + n }, center: { x: 0, y: 0, z: (s2 + n) / 2 } }, p = r3.geometry.coordinates[0].map((S) => {
    let T = t3(S[1], S[0]);
    return c2.min.x = Math.min(c2.min.x, T.x), c2.min.y = Math.min(c2.min.y, T.y), c2.max.x = Math.max(c2.max.x, T.x), c2.max.y = Math.max(c2.max.y, T.y), T;
  });
  ((v2 = (g = r3.properties) == null ? void 0 : g.style) == null ? void 0 : v2.edgeOffset) != null && r3.properties.style.edgeOffset !== 0 || ((b = r3.properties) == null ? void 0 : b.image) != null ? p = b8(p, ((y = (C = r3.properties) == null ? void 0 : C.style) == null ? void 0 : y.edgeOffset) || 0) : p = [p];
  let d = [];
  for (let S of p) {
    let T = new Zr();
    T.moveTo(S[0].x, S[0].y), S.slice(1).forEach((F) => T.lineTo(F.x, F.y)), T.lineTo(S[0].x, S[0].y);
    let w2 = r3.geometry.coordinates.slice(1);
    T.holes = w2.map((F) => {
      let A = F.map((B) => t3(B[1], B[0])), k = new ws();
      return k.moveTo(A[0].x, A[0].y), A.slice(1).forEach((B) => k.lineTo(B.x, B.y)), k.lineTo(A[0].x, A[0].y), k;
    });
    let M2 = { bevelEnabled: false, depth: s2 }, D = new sl(T, M2);
    D.userData = { style: { color: i, opacity: o } }, d.push(D);
  }
  if (d.length === 1) return d[0];
  let f = M(d);
  return f.userData = { style: { color: i, opacity: o }, _split: true }, f;
}
c();
var v8 = "gray";
var C8 = 0.1;
function hh(r3, t3, e2) {
  let { color: i = v8, opacity: o = 1, altitude: n = 0, height: s2 = C8 } = e2 || {};
  Array.isArray(o) && (o = 1);
  let c2 = { min: { x: 1 / 0, y: 1 / 0, z: n }, max: { x: -1 / 0, y: -1 / 0, z: s2 + n } }, l = { bevelEnabled: false, depth: s2 }, p = [];
  r3.geometry.coordinates.forEach((f) => {
    let g = new Zr(), v2 = f[0].map((y) => {
      let S = t3(y[1], y[0]);
      return c2.min.x = Math.min(c2.min.x, S.x), c2.min.y = Math.min(c2.min.y, S.y), c2.max.x = Math.max(c2.max.x, S.x), c2.max.y = Math.max(c2.max.y, S.y), S;
    });
    g.moveTo(v2[0].x, v2[0].y), v2.slice(1).forEach((y) => g.lineTo(y.x, y.y)), g.lineTo(v2[0].x, v2[0].y);
    let b = f.slice(1);
    g.holes = b.map((y) => {
      let S = y.map((w2) => t3(w2[1], w2[0])), T = new ws();
      return T.moveTo(S[0].x, S[0].y), S.slice(1).forEach((w2) => T.lineTo(w2.x, w2.y)), T.lineTo(S[0].x, S[0].y), T;
    });
    let C = new sl(g, l);
    p.push(C);
  });
  let d = M(p);
  return d.translate(0, 0, n || 0), d.userData = { style: { color: i, opacity: o } }, d;
}
c();
var S8 = "gray";
var Cy = new Je.ClipperOffset();
var Dt = 100;
function $5(r3, t3, e2) {
  let { color: i = S8, opacity: o = 1, width: n = 1, join: s2 = "round", cap: c2 = "round", height: l = 0.01, altitude: p = 0 } = e2 || {};
  Array.isArray(o) && (o = 0);
  let d = [];
  for (let C = 0; C < r3.geometry.coordinates.length - 1; C++) {
    let y = t3(r3.geometry.coordinates[C][1], r3.geometry.coordinates[C][0]), S = t3(r3.geometry.coordinates[C + 1][1], r3.geometry.coordinates[C + 1][0]);
    d.push([y, S]);
  }
  Cy.AddPaths(d.map((C) => C.map((y) => ({ X: y.x * Dt, Y: y.y * Dt }))), s2 === "round" ? Je.JoinType.jsRound : s2 === "miter" ? Je.JoinType.jsMiter : Je.JoinType.jsSquare, c2 === "round" ? Je.EndType.etOpenRound : c2 === "butt" ? Je.EndType.etOpenButt : Je.EndType.etOpenSquare);
  let f = new Je.PolyTree();
  Cy.Execute(f, n / 2 * Dt);
  let g = [], v2 = { bevelEnabled: false, depth: l };
  for (let C of f.m_AllPolys) {
    let y = new Zr();
    if (C.IsHole()) continue;
    let S = C.m_polygon;
    y.moveTo(S[0].X / Dt, S[0].Y / Dt), S.slice(1).forEach((T) => y.lineTo(T.X / Dt, T.Y / Dt)), y.lineTo(S[0].X / Dt, S[0].Y / Dt), y.holes = C.m_Childs.map((T) => {
      let w2 = new ws(), M2 = T.m_polygon;
      return w2.moveTo(M2[0].X / Dt, M2[0].Y / Dt), M2.slice(1).forEach((D) => w2.lineTo(D.X / Dt, D.Y / Dt)), w2.lineTo(M2[0].X / Dt, M2[0].Y / Dt), w2;
    }), g.push(new sl(y, v2));
  }
  let b = M(g);
  return b.translate(0, 0, p || 0), b.userData = { style: { color: i, opacity: o } }, Cy.Clear(), b;
}
c();
var Et = 100;
var x8 = 0.22;
var I8 = 0.01;
function J5(r3, t3, e2 = {}) {
  let { width: i = x8, height: o = I8, color: n = "gray", opacity: s2 = 1, altitude: c2 = 0 } = e2, l = { min: { x: 1 / 0, y: 1 / 0, z: c2 }, max: { x: -1 / 0, y: -1 / 0, z: c2 + o } }, p = { bevelEnabled: false, depth: o }, d = new Je.ClipperOffset(), f = r3.geometry.coordinates.map((C) => C.map((y) => t3(y[1], y[0])));
  d.AddPaths(f.map((C) => C.map((y) => ({ X: y.x * Et, Y: y.y * Et }))), Je.JoinType.jsMiter, Je.EndType.etOpenRound);
  let g = new Je.PolyTree();
  d.Execute(g, i / 2 * Et);
  let v2 = [];
  for (let C of g.m_AllPolys) {
    let y = new Zr();
    if (C.IsHole()) continue;
    l.min.x = Math.min(l.min.x, C.m_polygon[0].X), l.min.y = Math.min(l.min.y, C.m_polygon[0].Y), l.max.x = Math.max(l.max.x, C.m_polygon[0].X), l.max.y = Math.max(l.max.y, C.m_polygon[0].Y);
    let S = C.m_polygon;
    y.moveTo(S[0].X / Et, S[0].Y / Et), S.slice(1).forEach((T) => y.lineTo(T.X / Et, T.Y / Et)), y.lineTo(S[0].X / Et, S[0].Y / Et), y.holes = C.m_Childs.map((T) => {
      let w2 = new ws(), M2 = T.m_polygon;
      return w2.moveTo(M2[0].X / Et, M2[0].Y / Et), M2.slice(1).forEach((D) => w2.lineTo(D.X / Et, D.Y / Et)), w2.lineTo(M2[0].X / Et, M2[0].Y / Et), w2;
    }), v2.push(new sl(y, p));
  }
  let b = M(v2);
  return b.translate(0, 0, c2 || 0), b.userData = { style: { color: n, opacity: s2 } }, d.Clear(), b;
}
c();
c();
var Ps2 = K.object({ type: K.enum(["Point"]), coordinates: K.array(K.number()).min(2).max(3) });
var P8 = K.object({ rotation: K.array(K.number()).length(3).optional(), altitude: K.number().optional(), scale: K.array(K.number()).length(3).optional(), interactive: K.boolean().optional(), verticalOffset: K.number().optional(), id: K.union([K.number(), K.string()]).optional() });
var M8 = K.object({ type: K.enum(["Feature"]), geometry: Ps2, properties: P8 });
var T8 = K.object({ type: K.enum(["FeatureCollection"]), features: K.array(M8) });
var w8 = K.object({ color: K.string() });
var D8 = K.object({ url: K.string(), color: K.string().optional(), opacity: K.number().optional(), material: K.record(K.string(), w8).optional() });
function K5(r3, t3, e2) {
  K.union([K.number(), K.string()]).parse(r3), T8.parse(t3), D8.parse(e2);
}
var Lc;
var Ac;
var Vo = class {
  constructor(t3) {
    t(this, "mesh");
    t(this, "type", "model");
    t(this, "positionDirty", true);
    t(this, "outline");
    t(this, "geometry");
    t(this, "material");
    t(this, "feature");
    t(this, "instanceIndex", -1);
    t(this, "visible", true);
    t(this, "color", new Nt());
    t(this, "position", new R());
    v(this, Lc, 0);
    v(this, Ac, 1);
    this.feature = t3;
  }
  setOpacity() {
  }
  setColor() {
  }
  get altitude() {
    return u(this, Lc);
  }
  set altitude(t3) {
    this.mesh && (this.mesh.position.z = t3, w(this, Lc, t3));
  }
  getRotation() {
    return this.mesh ? [this.mesh.rotation.x, this.mesh.rotation.y, this.mesh.rotation.z] : void 0;
  }
  setRotation(t3) {
    this.mesh && this.mesh.rotation.set(md.degToRad(t3[0]), md.degToRad(t3[1]), md.degToRad(t3[2]));
  }
  getScale() {
    return this.mesh ? [this.mesh.scale.x, this.mesh.scale.y, this.mesh.scale.z] : void 0;
  }
  setScale(t3) {
    this.mesh && this.mesh.scale.set(t3[0], t3[1], t3[2]);
  }
  get opacity() {
    return u(this, Ac);
  }
  set opacity(t3) {
    var e2, i, o;
    if (this.mesh) {
      if (this.mesh.children[0] instanceof Yo) {
        for (let n of this.mesh.children) if (n instanceof Yo) {
          ((e2 = n.userData) == null ? void 0 : e2.originalOpacity) === void 0 && (n.userData.originalOpacity = n.material.opacity);
          let s2 = su(t3, 0, (i = n.userData) == null ? void 0 : i.originalOpacity, 0, 1);
          n.material.opacity = s2, n.material.transparent = s2 < 1, n.material.needsUpdate = true;
        }
      } else (o = this.mesh) == null || o.traverse((n) => {
        n instanceof ve && n.material && (Array.isArray(n.material) ? n.material.forEach((s2) => {
          Q5(s2, t3);
        }) : Q5(n.material, t3));
      });
      w(this, Ac, t3);
    }
  }
};
Lc = /* @__PURE__ */ new WeakMap(), Ac = /* @__PURE__ */ new WeakMap();
function Q5(r3, t3) {
  r3.opacity !== t3 && (t3 === 1 ? (r3.opacity = 1, r3.transparent = false) : (r3.opacity = t3, r3.transparent = true), r3.needsUpdate = true);
}
c();
function fh(r3) {
  var c2, l;
  let t3 = r3.components[0], e2 = r3.components[1];
  e2.opacity != null && e2.opacity !== t3.opacity && (t3.opacity = e2.opacity);
  let i = e2.material, o = e2.color;
  if (i || o) {
    let p = E8(o, i);
    (c2 = t3.mesh) == null || c2.traverse((d) => {
      d instanceof ve && d.material && (Array.isArray(d.material) ? d.material.forEach((f) => {
        p[f.name] ? f.color.set(p[f.name].color) : f.color.set(o);
      }) : p[d.material.name] ? d.material.color.set(p[d.material.name].color) : d.material.color.set(o));
    });
  }
  let n = (l = t3.feature.geometry.coordinates[2]) != null ? l : 0, s2 = e2.verticalOffset + n;
  t3.altitude !== s2 && (t3.altitude = s2), e2.visible !== t3.visible && (t3.visible = e2.visible), e2.rotation && t3.setRotation(e2.rotation), e2.scale && t3.setScale(e2.scale);
}
function E8(r3, t3) {
  let e2 = {};
  if (r3 && Object.assign(e2, { Default: { color: r3 }, Fabric: { color: r3 }, Mpdn_Logo: { color: r3 }, CouchLogo: { color: r3 } }), t3) for (let i in t3) t3[i].color && (e2[i] ? e2[i].color = t3[i].color : e2[i] = { color: t3[i].color });
  return e2;
}
function eS(r3, t3) {
  var s2, c2;
  let e2 = r3.components[0], o = (s2 = r3.components[1].verticalOffset) != null ? s2 : 0, n = e2.feature.geometry.coordinates.slice();
  n[2] = ((c2 = n[2]) != null ? c2 : 0) + o, e2.mesh ? e2.mesh.position.copy(t3(n)) : e2.position.copy(t3(n));
}
function O8(r3) {
  let { color: t3, opacity: e2, topColor: i, texture: o, topTexture: n } = r3;
  return "".concat(t3).concat(e2).concat(i || "").concat(o || "").concat(n || "");
}
var L8 = 1e4;
var mh = class extends _n {
  constructor(e2, i) {
    super();
    t(this, "state");
    t(this, "convertTo3DMapPosition");
    t(this, "loader");
    t(this, "optimizePromise", []);
    this.state = e2, this.convertTo3DMapPosition = i;
  }
  async getGLTFLoader() {
    if (this.loader) return this.loader;
    let { GLTFLoader: e2 } = await import("./GLTFLoader-VHKTUT76-W3XMDXLJ.js");
    return this.loader = new e2(), this.loader;
  }
  createEntityFromFeature(e2, i, o) {
    var c2, l;
    let n = new It(i), s2 = new Pt(n, new Go({ ...o, url: (l = (c2 = i.properties) == null ? void 0 : c2.image) == null ? void 0 : l.path }));
    return s2.id = e2, s2;
  }
  createModelFromFeature(e2, i, o) {
    let n = new Vo(i), s2 = { ...o };
    i.properties.verticalOffset != null && (s2.verticalOffset = i.properties.verticalOffset), i.properties.rotation != null && (s2.rotation = i.properties.rotation), i.properties.scale != null && (s2.scale = i.properties.scale);
    let c2 = new da(s2), l = new Pt(n, c2);
    return l.id = e2, l;
  }
  populateEntityMesh(e2, i) {
    let o = e2.components[0];
    o.geometry = i, o.currentHeight = e2.components[1].height, o.dirty = false;
  }
  async populateModelGroup(e2, i, o) {
    let n = new kt(), s2 = new Ye(), c2 = new bn(), l = new R(), p = new Er(), d = await this.getGLTFLoader(), f = new Promise((g) => {
      d.load(i, (v2) => {
        "entities3D" in o.userData && (o.userData.entities3D.size > 1 ? v2.scene.traverse((b) => {
          let C = b;
          if ("isMesh" in C && C.isMesh === true) {
            let y = new Yo(C.geometry, C.material, e2.size);
            y.userData = { entities: {} }, p.add(y), o.add(p);
          }
        }) : (v2.scene.traverse((b) => {
          "isMesh" in b && b.isMesh === true && (b.position.set(0, 0, 0), b.rotation.set(0, 0, 0), b.scale.set(1, 1, 1), b.updateMatrix());
        }), p.add(v2.scene), o.add(p), p.userData.isSingleModel = true, p.userData.entityId = e2.values().next().value, p.userData.type = "model")), g();
      });
    });
    return this.optimizePromise.push(f.then(() => {
      var b, C, y, S, T, w2, M2, D, F, A, k, B;
      let g = 0, v2;
      for (let G of e2.values()) {
        if (v2 = this.state.geometry3DMap.get(G), !v2 || (v2 == null ? void 0 : v2.type) !== "model") continue;
        let V = v2.components[0], W = v2.components[1], $ = v2.components[0].feature;
        V.mesh = p, V.instanceIndex = g, fh(v2), v2.components[1].dirty = false;
        let { x: U, y: ie } = this.convertTo3DMapPosition($.geometry.coordinates[1], $.geometry.coordinates[0], 0);
        V.position.set(U, ie, V.altitude), s2.set(md.degToRad((C = (b = W.rotation) == null ? void 0 : b[0]) != null ? C : Ep[0]), md.degToRad((S = (y = W.rotation) == null ? void 0 : y[1]) != null ? S : Ep[1]), md.degToRad((w2 = (T = W.rotation) == null ? void 0 : T[2]) != null ? w2 : Ep[2])), l.set((D = (M2 = W.scale) == null ? void 0 : M2[0]) != null ? D : Dp[0], (A = (F = W.scale) == null ? void 0 : F[1]) != null ? A : Dp[1], (B = (k = W.scale) == null ? void 0 : k[2]) != null ? B : Dp[2]), c2.setFromEuler(s2), n.compose(V.position, c2, l), p.children.forEach((Z) => {
          !v2 || (v2 == null ? void 0 : v2.type) !== "model" || !(Z instanceof Yo) || (Z.setMatrixAt(g, n), Z.userData.entities[g] = v2.id);
        }), V.mesh.userData.isSingleModel && (V.mesh.matrix.copy(n), V.mesh.matrix.decompose(V.mesh.position, V.mesh.quaternion, V.mesh.scale)), g++;
      }
      this.publish("model-loaded");
    })), p;
  }
  populateEntityGroup(e2) {
    var c2;
    let i, o, n, s2;
    for (let l of e2.values()) s2 = this.state.geometry3DMap.get(l), s2.components[0] instanceof It && (o = s2.components[0].feature, n = s2.components[1], o.geometry.type === "Polygon" ? (i = dh(o, this.convertTo3DMapPosition, n), (c2 = o.properties) != null && c2.textures && o.properties.textures.length > 0 && eb(i, o.properties.textures, this.state.naturalBearing, this.convertTo3DMapPosition), this.populateEntityMesh(s2, i)) : o.geometry.type === "MultiPolygon" ? (i = hh(o, this.convertTo3DMapPosition, n), this.populateEntityMesh(s2, i)) : o.geometry.type === "LineString" ? (i = $5(o, this.convertTo3DMapPosition, n), this.populateEntityMesh(s2, i)) : o.geometry.type === "MultiLineString" && (i = J5(o, this.convertTo3DMapPosition, n), this.populateEntityMesh(s2, i)));
    return e2;
  }
  optimize(e2) {
    var i;
    if (e2.visible && (e2 instanceof pt || e2 instanceof mt)) {
      for (let s2 of e2.children) this.optimize(s2);
      if (e2 instanceof mt || e2.userData.dirty === false) return;
      let o = {};
      if (!e2.userData.modelURL && e2.userData.dirty) try {
        this.populateEntityGroup(e2.userData.entities3D);
      } catch (s2) {
        Lt.warn(s2);
      }
      else e2.userData.modelURL && e2.userData.dirty && (this.populateModelGroup(e2.userData.entities3D, e2.userData.modelURL, e2), e2.userData.dirty = false);
      let n = 0;
      if (e2.userData.dirty) {
        let s2 = 0, c2;
        for (let l of e2.userData.entities3D.values()) {
          c2 = this.state.geometry3DMap.get(l);
          let p = c2 == null ? void 0 : c2.components[0];
          if ((c2 == null ? void 0 : c2.type) === "geometry") {
            let d = c2.components[1];
            s2++, s2 >= L8 && (s2 = 0, n++);
            let f = O8(d) + n;
            o[f] === void 0 && (o[f] = { style: d, entities: [] }), o[f].entities.push(c2);
          } else p && "mesh" in p && p.mesh && ((i = p.mesh) == null ? void 0 : i.parent) !== e2 && e2.add(p.mesh);
        }
        for (let l in o) {
          let p = $y(o[l].entities, o[l].style);
          e2.add(p), e2.userData.outlineDirty = true, e2.userData.dirty = false;
        }
        for (let l of e2.userData.entities3D.values()) if (c2 = this.state.geometry3DMap.get(l), c2 != null && c2.entities2D.size > 0) for (let p of c2.entities2D.values()) p && (c2.addEntity(p), this.publish("geometry-2d-added"));
      }
    }
  }
  update() {
    return this.optimizePromise = [], this.optimize(this.state.entityScene), this.optimizePromise.length > 0 ? Promise.all(this.optimizePromise) : void 0;
  }
};
c();
var gh = class {
  constructor(t3, e2) {
    t(this, "state");
    t(this, "dirty", true);
    t(this, "domTree");
    this.state = t3, this.domTree = e2;
  }
  update() {
    if (this.dirty) {
      let t3;
      for (let e2 of Array.from(this.domTree.children)) if (t3 = this.state.geometry2DMap.get(e2.userData.entityId), t3) {
        let i = t3.components[0];
        (!i.enabled || !i.visible || !this.state.geometry2DIdsInScene.has(e2.userData.entityId)) && this.domTree.removeChild(e2);
      } else this.domTree.removeChild(e2);
      for (let e2 of this.state.geometry2DIdsInScene) if (t3 = this.state.geometry2DMap.get(e2), t3) {
        let i = t3.components[0];
        i instanceof yl && i.enabled && i.containerEl && !this.domTree.contains(i.containerEl) && (i.containerEl.userData = { entityId: t3.id }, this.domTree.appendChild(i.containerEl), i.updateDimensions());
      }
      this.dirty = false;
    }
  }
};
c();
var yh = class {
  constructor(t3, e2) {
    t(this, "state");
    t(this, "project");
    this.state = t3, this.project = e2;
  }
  update() {
    let t3, e2 = 0, i = 0, o = true, n, s2;
    for (let c2 of this.state.geometry2DIdsInScene) if (t3 = this.state.geometry2DMap.get(c2), t3) {
      let l = this.state.geometry3DMap.get(t3.object3d.userData.parentEntityId);
      l instanceof Pt && (n = l.components[1], (n.dirty || t3.components[0].parentDirty) && (e2 = n.height, i = n.opacity, o = n.visible, s2 = t3.components[0], (i === 0 || o === false) && s2.visible === true ? t3.components[0].visible = false : s2.visible === false && (t3.components[0].visible = true), t3.setAltitude(e2))), this.project(t3.components[0].projection, t3.position), t3.components[0].parentDirty = false;
    }
  }
};
c();
c();
var A8 = /* @__PURE__ */ function() {
  let t3, e2;
  return (i) => {
    if ((!e2 || !e2) && (t3 = document.createElement("canvas"), t3.width = 500 * i, t3.height = 500 * i, t3.style.width = "500px", t3.style.height = "500px", e2 = t3.getContext("2d")), !e2) throw new Error("Could not get 2D context");
    return { measureCanvas: t3, measureCanvasContext: e2 };
  };
}();
var tS = ({ text: r3, size: t3, maxWidth: e2, pixelRatio: i, maxLines: o = 2, lineHeight: n = 1.2, options: s2 = { strokeText: true } }) => {
  let c2 = "bold ".concat(t3 * i, "px 'InterUI-Regular', Helvetica Neue, Arial, sans-serif"), { measureCanvasContext: l } = A8(i);
  l.font = c2;
  let p = [], d = r3.split(" "), f = 0, g = 0, v2 = 0;
  for (; g < d.length; ) {
    let S = d[g];
    if (f === o && f > 0) {
      p[f - 1] += "...";
      break;
    }
    if (p[f] == null && (p[f] = S, g++), d.length === 1) {
      p[f] = S;
      break;
    }
    if (d[g] == null) break;
    let { width: T } = l.measureText(p[f] + " " + d[g]);
    T <= e2 * i ? (p[f] += " " + d[g], g++) : f++;
  }
  p.forEach((S) => {
    let { width: T } = l.measureText(S);
    v2 = Math.max(T, v2);
  });
  let b = t3 * i * n, C = p.length * b;
  return { maxWidth: v2, maxHeight: C, lines: p.length, draw: (S, T, w2) => {
    p.length === 1 ? (s2.strokeText && S.strokeText(p[0], T, w2), S.fillText(p[0], T, w2)) : (s2.strokeText && (S.strokeText(p[0], T, w2 - b / 2), S.strokeText(p[1], T, w2 + b / 2)), S.fillText(p[0], T, w2 - b / 2), S.fillText(p[1], T, w2 + b / 2));
  } };
};
c();
function rS(r3) {
  let t3 = new Image();
  return r3 && (/<svg[\s\S]*>/i.test(r3) ? t3.src = "data:image/svg+xml;base64,".concat(btoa(r3)) : t3.src = r3), t3;
}
var F8 = 3.5;
var k8 = 2.5;
var B8 = 2;
var _8 = 5;
var Fc = 2.5;
var bh = class extends _n {
  constructor(e2, i, o) {
    super();
    t(this, "dirty", false);
    t(this, "state");
    t(this, "colliderContext");
    t(this, "colliderCanvas");
    t(this, "transformRequestFunc");
    t(this, "transformRequest", async (e3) => this.transformRequestFunc ? await this.transformRequestFunc(e3) : { url: e3 });
    t(this, "pinCache", {});
    t(this, "imageCache", {});
    t(this, "imagePromiseCache", {});
    t(this, "imageDimensionsCache", {});
    t(this, "textCache", {});
    t(this, "update", (e3) => {
      let i2 = this.state.pixelRatio;
      this.colliderContext.clearRect(0, 0, this.colliderCanvas.width, this.colliderCanvas.height);
      let o2, n, s2, c2, l, p, d;
      for (let f of this.state.geometry2DIdsInScene) if (d = this.state.geometry2DMap.get(f), d != null && (p = d.components[0], p instanceof vl2 && !d.disposed)) {
        if (l = p.appearance.marker.iconVisibleAtZoomLevel, p.appearance.marker.icon != null && l && e3 >= l !== p.iconVisible && (p.iconVisible = e3 >= l, p.dirty = true), (p.dirty || this.dirty) && p.calculateMarkerSize(), n = p.appearance.marker.foregroundColor, s2 = p.appearance.marker.backgroundColor, c2 = jp(p.markerSize, 2), o2 = "".concat(n.active, "-").concat(n.inactive, "-").concat(s2.active, "-").concat(s2.inactive, "-").concat(c2, "-").concat(p.iconVisible), p.labelCacheId = o2, this.pinCache[o2] || this.prepare(p, o2, this.colliderContext), p.appearance.marker.icon && (!p.imageHash || p.dirty) && this.cacheImage(p), this.textCache[p.id] == null || p.dirty || this.dirty) {
          p.collisionDirty = true, this.textCache[p.id] = {};
          let { textDrawFn: g, width: v2, height: b } = this.processText(p.text, p.appearance.text.size, p.appearance.text.maxWidth, p.appearance.text.numLines, p.appearance.text.lineHeight);
          ["left", "center", "right"].forEach((y) => {
            this.textCache[p.id][y] = this.textToCanvas(g, p.appearance.text.size, y, v2, b, p.appearance.text.foregroundColor, p.appearance.text.backgroundColor);
          }), p.dimensions = { width: Math.ceil(v2 / i2), height: Math.ceil(b / i2) }, p.currentStrategyIndex === -1 && (p.currentStrategyIndex = 0);
          let C = p.strategies[p.currentStrategyIndex];
          if (C) {
            C.onStrategySelected(p);
            let y = p.style;
            p.style = p.newStyle, p.newStyle = y;
          }
        }
        p.canShow && p.visible && (p.enabled || p.visibilityNeedsUpdate !== false) && this.draw(p, o2, this.colliderContext), p.dirty = false;
      }
      this.dirty = false;
    });
    t(this, "processText", (e3, i2, o2, n, s2) => {
      let c2 = this.state.pixelRatio, { draw: l, maxWidth: p, maxHeight: d } = tS({ text: e3, size: i2, pixelRatio: c2, maxWidth: o2, maxLines: n, lineHeight: s2 });
      return { textDrawFn: l, width: p + Fc * c2 * 2, height: d + Fc * c2 * 2 };
    });
    t(this, "textToCanvas", (e3, i2, o2, n, s2, c2, l) => {
      let p = this.state.pixelRatio, d, f = n, g = s2;
      window.OffscreenCanvas != null && !Tp() ? d = new OffscreenCanvas(f, g) : (d = document.createElement("canvas"), d.width = f, d.height = g, d.style.width = f + "px", d.style.height = g + "px");
      let v2 = d.getContext("2d", { willReadFrequently: true });
      if (!v2) return;
      v2.textAlign = o2, v2.font = "bold ".concat(i2 * p, "px 'InterUI-Regular', Helvetica Neue, Arial, sans-serif"), v2.textBaseline = "middle", v2.lineJoin = "miter", v2.miterLimit = 2, v2.strokeStyle = "white", v2.lineWidth = Fc * p, v2.fillStyle = c2, v2.strokeStyle = l;
      let b = o2 === "left" ? 0 : o2 === "center" ? f / 2 : f - Fc * p / 2;
      return e3(v2, b, (g + Fc * p / 2) / 2), d;
    });
    t(this, "cacheImage", (e3) => {
      if (!e3.appearance.marker.icon) return;
      let i2 = f0(e3.appearance.marker.icon);
      this.imagePromiseCache[i2] || (this.imagePromiseCache[i2] = new Promise((o2) => {
        this.transformRequest(e3.appearance.marker.icon).then((n) => {
          let s2 = rS(n.url);
          s2.onload = () => {
            this.imageCache[i2] = s2, this.publish("img:loaded"), o2(s2);
          };
        });
      })), e3.imageHash !== i2 && (e3.imageHash = i2, this.imagePromiseCache[i2].then(() => {
        e3.dirty = true;
      }));
    });
    t(this, "createPinCanvas", (e3, i2, o2, n) => {
      let s2, c2 = this.state.pixelRatio, l = e3.totalMarkerSize * 2 * c2;
      window.OffscreenCanvas != null ? s2 = new OffscreenCanvas(l, l) : (s2 = document.createElement("canvas"), s2.width = l, s2.height = l, s2.style.width = l / c2 + "px", s2.style.height = l / c2 + "px");
      let p = s2.getContext("2d");
      return p.shadowColor = "rgba(0,0,0,0.3)", p.shadowOffsetY = B8 * c2, p.shadowBlur = _8 * c2, p.beginPath(), p.arc(l / 2, l / 2, i2 / 2 + k8 * c2 / 2, 0, 2 * Math.PI), p.fillStyle = o2, p.fill(), p.beginPath(), p.arc(l / 2, l / 2, i2 / 2, 0, 2 * Math.PI), p.shadowColor = "transparent", p.fillStyle = n, p.fill(), s2;
    });
    t(this, "prepare", (e3, i2, o2) => {
      let n = this.state.pixelRatio;
      o2.lineWidth = 4 * n;
      let s2 = this.createPinCanvas(e3, e3.markerSize, e3.appearance.marker.backgroundColor.active, e3.appearance.marker.foregroundColor.active), c2 = this.createPinCanvas(e3, e3.iconVisible ? e3.markerSize : F8 * n, e3.appearance.marker.backgroundColor.inactive, e3.appearance.marker.foregroundColor.inactive);
      this.pinCache[i2] = [s2, c2];
    });
    this.state = e2, this.colliderCanvas = i, this.colliderContext = i.getContext("2d"), this.transformRequestFunc = o;
  }
  draw(e2, i, o) {
    var p, d;
    if (!e2.canShow || !e2.visible) return;
    o.save(), o.globalAlpha = e2.opacity;
    let n = this.state.pixelRatio, s2 = e2.projection.x * n, c2 = e2.projection.y * n, l = e2.style.pinVisibility === 1 ? this.pinCache[i][0] : this.pinCache[i][1];
    if (o.drawImage(l, s2 - e2.totalMarkerSize * n, c2 - e2.totalMarkerSize * n), e2.appearance.marker.icon && e2.iconVisible && e2.imageHash && e2.appearance.marker.iconSize && this.imageCache[e2.imageHash]) {
      let f = this.imageCache[e2.imageHash], g = (e2.appearance.marker.iconSize - e2.appearance.marker.iconPadding) * n, v2 = e2.appearance.marker.iconFit, b = g, C = g, y = "".concat(e2.imageHash, "_").concat(v2);
      if (this.imageDimensionsCache[y]) b = this.imageDimensionsCache[y].width, C = this.imageDimensionsCache[y].height;
      else {
        let S = f.width * n, T = f.height * n;
        if (v2 === "contain") {
          let w2 = Math.sqrt(S ** 2 + T ** 2), M2 = g / w2;
          b = S * M2, C = T * M2;
        }
        if (v2 === "cover") {
          let w2 = g / S, M2 = g / T, D = Math.max(w2, M2);
          b = S * D, C = T * D;
        }
      }
      o.save(), o.beginPath(), o.arc(s2, c2, g / 2, 0, 2 * Math.PI), o.closePath(), ((d = (p = e2 == null ? void 0 : e2.appearance) == null ? void 0 : p.marker) == null ? void 0 : d.iconOverflow) !== "visible" && o.clip(), o.drawImage(f, s2 - b / 2, c2 - C / 2, b, C), o.restore();
    }
    e2.style.textLabelVisible && e2.style.textAlign != null && e2.style.left && e2.style.top && o.drawImage(this.textCache[e2.id][e2.style.textAlign], s2 + e2.style.left * n, c2 + e2.style.top * n), o.restore();
  }
};
c();
c();
var Qn = class Qn2 {
  constructor() {
    t(this, "loader");
    this.loader = new dl();
  }
  static getInstance() {
    return Qn2.instance || (Qn2.instance = new Qn2()), Qn2.instance;
  }
  getLoader() {
    return this.loader;
  }
  load(t3) {
    return new Promise((e2, i) => {
      this.loader.load(t3, e2, void 0, i);
    });
  }
};
t(Qn, "instance");
var Sy = Qn;
var jo = Sy.getInstance();
function N8(r3, t3) {
  let e2 = r3.components[2], i = r3.components[1];
  return e2 != null && e2.hover ? [i.hoverColor || t3, i.hoverColor || t3] : [i.color, i.topColor || i.color];
}
var Kn;
var kc;
var vh = class extends _n {
  constructor(e2, i) {
    super();
    v(this, Kn);
    t(this, "state");
    t(this, "convertTo3DMapPosition");
    t(this, "textureLoadingCache", /* @__PURE__ */ new Map());
    this.convertTo3DMapPosition = i, this.state = e2;
  }
  setShading(e2, i) {
    e2.material && e2.material.setGradientShading(i.start, i.end, i.intensity);
  }
  processTextures(e2, i, o) {
    var n;
    if (i.texture !== e2.texture && i.texture !== "" && x(this, Kn, kc).call(this, i.texture, e2, "texture"), i.topTexture !== e2.topTexture && i.topTexture !== "" && x(this, Kn, kc).call(this, i.topTexture, e2, "topTexture"), (e2.texture == null || e2.topTexture == null) && Array.isArray((n = e2.feature.properties) == null ? void 0 : n.textures) && e2.feature.properties.textures.length > 0) for (let s2 of e2.feature.properties.textures) s2.face === "top" && e2.topTexture !== s2.path ? x(this, Kn, kc).call(this, s2.path, e2, "topTexture") : s2.face === "side" && e2.texture !== s2.path && x(this, Kn, kc).call(this, s2.path, e2, "texture"), e2.blendTexture = true;
    (e2.texture != null || e2.topTexture != null) && (o != null && o.hover && e2.texturesVisible ? e2.hideTextures() : e2.texturesVisible || e2.showTextures(), i.texture === "" && e2.removeSideTexture(), i.topTexture === "" && e2.removeTopTexture());
  }
  update() {
    var n, s2, c2, l, p, d, f, g;
    let e2, i, o;
    for (let v2 of this.state.geometry3DIdsInScene) if (o = this.state.geometry3DMap.get(v2), o instanceof pt && o.type === "geometry-group") {
      let b = o.components[0];
      if (o.userData.shadingDirty) {
        let C = o.userData.entities3D.values().next().value;
        if (C == null) continue;
        let y = this.state.geometry3DMap.get(C);
        y instanceof Pt && (y.type === "geometry" || y.type === "custom-geometry") && (e2 = y.components[0], o.userData.shadingDirty && b.shading && this.setShading(e2, b.shading));
        let S, T;
        for (let w2 of o.userData.entities3D.values()) S = this.state.geometry3DMap.get(w2), T = S.components[0], S.type === "geometry" && T.detached && o.userData.shadingDirty && b.shading && this.setShading(T, b.shading);
        o.userData.shadingDirty = false;
      }
      if (b.dirty) {
        let C = qr(o);
        C && C.material instanceof vs && (C.material.color.set(pp(b.color)), C.material.needsUpdate = true);
        let y = o.getfirstChildEntityId();
        if (y) {
          let T = this.state.geometry3DMap.get(y), w2 = T == null ? void 0 : T.components[0];
          w2 instanceof It && this.processTextures(w2, b);
        }
        let S = b.opacity * ua(o);
        o.getOpacity() !== S && o.setOpacity(S), b.dirty = false;
      }
    } else if (o && (o.type === "geometry" || o.type === "custom-geometry") && ((n = o.components[1]) != null && n.dirty || (s2 = o.components[2]) != null && s2.dirty)) {
      let b = o.components[0], C = o.components[1];
      i = o.components[2];
      let y = N8(o, this.state.hoverColor);
      if (b.setColor(y[0], y[1]), C.visible !== b.visible && (b.visible = C.visible, b instanceof It && b.textMesh)) {
        let T = this.state.geometry3DMap.get(b.textMesh.userData.entityId);
        (T == null ? void 0 : T.type) === "text3d" && T.components[0].polygonEntityId != null && (T.components[0].visible = C.visible);
      }
      C.altitude !== b.altitude && (b.altitude = C.altitude);
      let S = C.opacity * ua(o);
      S !== b.opacity && (b.opacity = S), C.renderOrder !== b.renderOrder && (b.renderOrder = C.renderOrder), C.dirty = false, b instanceof It && this.processTextures(b, C, i), o.components[2] && (o.components[2].dirty = false);
    } else if ((o == null ? void 0 : o.type) === "model") o.components[1].dirty && (fh(o), o.components[1].dirty = false), o.components[0].positionDirty && (eS(o, this.convertTo3DMapPosition), o.components[0].positionDirty = false);
    else if ((o == null ? void 0 : o.type) === "image" && ((c2 = o.components[1]) != null && c2.dirty)) {
      e2 = o.components[0];
      let b = o.components[1];
      b.visible !== e2.visible && (e2.visible = b.visible), b.dirty = false;
    } else if ((o == null ? void 0 : o.type) === "text3d" && ((l = o.components[1]) != null && l.dirty) && o.components[0].polygonEntityId != null) {
      e2 = o.components[0];
      let b = o.components[1];
      b.visible != null && b.visible !== e2.visible && (e2.visible = b.visible);
      let { textMesh: C } = e2;
      if (C) {
        Object.assign(C, b.getState());
        let y = (p = b.hoverColor) != null ? p : this.state.text3dHoverColor;
        C.color = b.hoverByPolygon ? y : (d = b.color) != null ? d : du.color, C.outlineColor = b.hoverByPolygon ? y : (f = b.outlineColor) != null ? f : du.outlineColor, C.strokeColor = b.hoverByPolygon ? y : (g = b.strokeColor) != null ? g : du.strokeColor;
      }
      b.dirty = false;
    }
  }
  destroy() {
    this.textureLoadingCache.forEach(async (e2) => {
      (await e2).dispose();
    }), this.textureLoadingCache.clear();
  }
};
Kn = /* @__PURE__ */ new WeakSet(), kc = async function(e2, i, o) {
  if (!(!e2 || !i.showTextures)) if (this.textureLoadingCache.has(e2)) {
    o === "topTexture" ? i.topTexture = await this.textureLoadingCache.get(e2) : i.texture = await this.textureLoadingCache.get(e2), i.showTextures();
    return;
  } else {
    let n = new Promise((s2, c2) => {
      jo.getLoader().load(e2, (l) => {
        o === "topTexture" ? i.topTexture = l : i.texture = l, i.showTextures(), this.publish("texture-loaded"), s2(l);
      }, void 0, () => {
        Lt.error("Failed to load texture: ".concat(e2)), c2("Failed to load texture: ".concat(e2));
      });
    });
    this.textureLoadingCache.set(e2, n);
  }
};
c();
var Ch = class extends _n {
  constructor(e2) {
    super();
    t(this, "state");
    t(this, "animating", /* @__PURE__ */ new Map());
    t(this, "isAnimating", false);
    t(this, "startTime", -1);
    t(this, "showDuration", 300);
    t(this, "hideDuration", 250);
    t(this, "update", () => {
      this.animating.clear();
      let e3, i;
      for (let o of this.state.geometry2DIdsInScene) e3 = this.state.geometry2DMap.get(o), e3 && (i = e3.components[0], i instanceof vl2 && (i.visibilityNeedsUpdate === "show" ? (i.canShow = true, this.animating.set(i, [i.opacity, 1])) : i.visibilityNeedsUpdate === "hide" && this.animating.set(i, [i.opacity, 0])));
      this.startTime = performance.now(), this.publish("animate:2d");
    });
    t(this, "playAnimations");
    this.state = e2, this.playAnimations = this._playAnimations;
  }
  _playAnimations() {
    let e2 = performance.now();
    for (let [i, [o, n]] of this.animating.entries()) {
      let s2 = n === 1 ? this.showDuration : this.hideDuration, c2 = (e2 - this.startTime) / s2;
      i.opacity = su(c2, 0, 1, o, n, n === 0 ? Cp : d0), e2 - this.startTime >= s2 && (n === 1 ? i.canShow = true : n === 0 && (i.canShow = false), i.visibilityNeedsUpdate = false, this.animating.delete(i));
    }
    this.publish("draw:2d"), this.animating.size > 0 && this.publish("animate:2d");
  }
};
c();
var Sh = class extends _n {
  constructor(e2, i, o, n, s2, c2, l) {
    super();
    t(this, "state");
    t(this, "renderer");
    t(this, "mode");
    t(this, "scene");
    t(this, "cameraObject");
    t(this, "viewCamera");
    t(this, "systems");
    t(this, "needs2DRecompute", false);
    t(this, "twoDdirty", true);
    t(this, "threeDdirty", true);
    t(this, "frameId", null);
    t(this, "twoDFrameId", null);
    t(this, "animationFrameId", null);
    t(this, "nextFrame", null);
    t(this, "update", (e3 = false) => {
      var i2;
      if (((i2 = this.renderer) == null ? void 0 : i2.renderer) == null) return Promise.resolve();
      if (e3) {
        let o2 = this.commitRenderState();
        return this.paint(), o2;
      } else return this.frameId ? Promise.resolve() : new Promise((o2) => {
        this.frameId = requestAnimationFrame(() => {
          var n2, s4;
          return ((n2 = this.renderer) == null ? void 0 : n2.renderer) == null ? o2() : this.mode === "standalone" ? (s4 = this.commitRenderState()) == null ? void 0 : s4.then(() => {
            this.paint(), o2();
          }) : o2();
        });
      });
    });
    t(this, "animate2D", () => {
      this.animationFrameId = requestAnimationFrame(() => {
        this.animationFrameId = null, this.systems.twoDVisiblitySystem.playAnimations();
      });
    });
    t(this, "drawEntities2D", () => {
      this.twoDFrameId || (this.twoDFrameId = requestAnimationFrame(() => {
        this.twoDFrameId = null, this.systems.twoDDrawSystem.update(this.systems.cameraSystem.getZoomLevel());
      }));
    });
    t(this, "updateEntities2D", () => {
      this.twoDFrameId && (cancelAnimationFrame(this.twoDFrameId), this.twoDFrameId = null), this.twoDFrameId = requestAnimationFrame(() => {
        this.twoDFrameId = null, this.systems.watermarkSystem.insertIntoQuadTree(this.systems.collisionSystem.interactiveCollidersQTree), this.systems.interactionSystem.updateQuadtree(this.systems.collisionSystem.interactiveCollidersQTree), this.systems.twoDVisiblitySystem.update(), this.systems.twoDDrawSystem.update(this.systems.cameraSystem.getZoomLevel()), this.systems.domDrawSystem.update(this.systems.cameraSystem.isUserInteracting());
      });
    });
    t(this, "commitRenderState", () => {
      try {
        let e3 = [];
        this.frameId = null, this.publish("pre-render"), this.state.tweenGroup.update(), (this.mode === "outdoors-interleaved" || this.mode === "standalone") && this.systems.cameraSystem.update(), this.scene.updateMatrixWorld(), this.state.shouldMeasureCanvas && (this.state.shouldMeasureCanvas = false, this.publish("measure-canvas")), this.twoDdirty && (this.state.geometry2DIdsInScene.clear(), wp(this.state.entityScene, this.state.geometry2DIdsInScene), this.systems.domVisiblitySystem.dirty = true, this.systems.collisionSystem.collidersDirty = true, this.systems.domMutationSystem.dirty = true, this.systems.panBoundsSystem.dirty = true, this.twoDdirty = false), this.threeDdirty && (this.state.geometry3DIdsInScene.clear(), kp(this.state.entityScene, this.state.geometry3DIdsInScene), this.threeDdirty = false, this.systems.interactionSystem.dirty3D = true, this.systems.panBoundsSystem.dirty = true, this.systems.outlineInterpolationSystem.geometries3DDirty = true, this.systems.geometryInFocusSystem.focusablesDirty = true);
        let i2 = this.systems.meshOptimizationSystem.update();
        i2 && e3.push(i2), this.systems.meshModificationSystem.update(), this.systems.meshDetachmentSystem.update(), this.systems.imageSystem.update(this.systems.cameraSystem.getRotation()), e3.push(this.systems.text3DSystem.update(this.systems.cameraSystem.getRotation())), this.systems.customGeometrySystem.update(), this.systems.panBoundsSystem.update(), this.systems.geometryInFocusSystem.update(this.systems.cameraSystem.isCameraMoving(), this.systems.cameraSystem.lastCameraStoppedMovingTime()), this.systems.stackSystem.update(), this.systems.outlineInterpolationSystem.update(this.systems.cameraSystem.getZoomLevel(), this.systems.cameraSystem.zoomDirty), this.systems.pathSystem.update(this.systems.cameraSystem.minZoomAltitude, this.systems.cameraSystem.maxZoomAltitude, this.systems.cameraSystem.getZoomAltitude()), this.systems.cameraSystem.postRender(), this.systems.domVisiblitySystem.update(), this.systems.domMutationSystem.update(), this.systems.twoDProjectionSystem.update(), this.systems.occlusion2DSystem.update(), this.systems.twoDDrawSystem.update(this.systems.cameraSystem.getZoomLevel()), this.systems.domDrawSystem.update(this.systems.cameraSystem.isUserInteracting()), this.systems.watermarkSystem.update();
        let o2 = this.needs2DRecompute;
        return this.nextFrame = requestAnimationFrame(() => {
          this.systems.collisionSystem.update(this.systems.watermarkSystem.width, this.systems.watermarkSystem.height, this.systems.watermarkSystem.options.position, !o2);
        }), this.systems.drawSystem.update(), this.systems.cameraSystem.dirty = false, this.systems.cameraSystem.zoomDirty = false, this.systems.cameraSystem.rotationDirty = false, this.publish("post-render"), Promise.all(e3);
      } catch (e3) {
        Lt.error("Render failed: ", e3);
      }
    });
    this.renderer = e2, this.state = i, this.mode = o, this.scene = n, this.cameraObject = s2, this.viewCamera = c2, this.systems = l, this.systems.collisionSystem.on("visibility-changed", this.updateEntities2D), this.systems.twoDVisiblitySystem.on("draw:2d", this.drawEntities2D), this.systems.twoDVisiblitySystem.on("animate:2d", this.animate2D), this.systems.cameraSystem.on("pan-start", () => this.needs2DRecompute = false), this.systems.cameraSystem.on("zoom-start", () => this.needs2DRecompute = false), this.systems.cameraSystem.on("zoom-end", () => this.needs2DRecompute = true), this.systems.cameraSystem.on("rotate-start", () => this.needs2DRecompute = false), this.systems.cameraSystem.on("rotate-end", () => this.needs2DRecompute = true);
  }
  paint() {
    var e2;
    (e2 = this.renderer) != null && e2.renderer && (this.mode === "standalone" ? (this.renderer.clear(), this.renderer.render(this.scene, this.cameraObject)) : this.renderer.render(this.scene, this.viewCamera));
  }
  destroy() {
    this.frameId && cancelAnimationFrame(this.frameId), this.twoDFrameId && cancelAnimationFrame(this.twoDFrameId), this.animationFrameId && cancelAnimationFrame(this.animationFrameId), this.nextFrame && cancelAnimationFrame(this.nextFrame), this.state.geometry2DIdsInScene.clear(), this.state.geometry3DIdsInScene.clear(), this.systems.domVisiblitySystem.dirty = true, this.systems.collisionSystem.collidersDirty = true, this.update(), this.systems.collisionSystem.off("visibility-changed", this.updateEntities2D), this.systems.twoDVisiblitySystem.off("draw:2d", this.drawEntities2D), this.systems.twoDVisiblitySystem.off("animate:2d", this.animate2D);
  }
};
c();
var G8 = K.object({ interactive: K.boolean().optional(), id: K.string().optional(), nearRadius: K.number().optional(), farRadius: K.number().optional(), accentColor: K.string().optional(), displayArrowsOnPath: K.boolean().optional(), animateArrowsOnPath: K.boolean().optional(), nearZoomLevel: K.number().optional(), farZoomLevel: K.number().optional() });
var V8 = K.object({ type: K.enum(["Feature"]), geometry: Ps2, properties: K.object({ parentId: K.any().optional() }) });
function iS(r3, t3) {
  K.object({ features: K.array(V8) }).parse(r3), G8.parse(t3);
}
var Bc;
var Uo = class {
  constructor(t3, e2) {
    t(this, "type", "path");
    t(this, "mesh", new Er());
    t(this, "material");
    t(this, "geometry");
    t(this, "outline");
    t(this, "feature");
    t(this, "options");
    t(this, "nearRadius", 0.2);
    t(this, "farRadius", 0.4);
    t(this, "nearZoomLevel");
    t(this, "farZoomLevel");
    t(this, "nearZoomAltitude");
    t(this, "farZoomAltitude");
    t(this, "accentColor", "blue");
    t(this, "completeFraction", 1);
    t(this, "altitudeAdjustment", 1);
    t(this, "displayArrowsOnPath", false);
    t(this, "animateArrowsOnPath", false);
    t(this, "isVertical", false);
    t(this, "dirty", true);
    t(this, "materialDirty", true);
    t(this, "position", new R());
    v(this, Bc, 0);
    var i, o, n, s2, c2;
    this.feature = t3, this.options = e2 || {}, this.accentColor = (i = e2 == null ? void 0 : e2.accentColor) != null ? i : this.accentColor, this.nearRadius = (o = e2 == null ? void 0 : e2.nearRadius) != null ? o : this.nearRadius, this.farRadius = (n = e2 == null ? void 0 : e2.farRadius) != null ? n : this.farRadius, this.nearZoomLevel = e2 == null ? void 0 : e2.nearZoomLevel, this.farZoomLevel = e2 == null ? void 0 : e2.farZoomLevel, this.displayArrowsOnPath = (s2 = e2 == null ? void 0 : e2.displayArrowsOnPath) != null ? s2 : this.displayArrowsOnPath, this.animateArrowsOnPath = (c2 = e2 == null ? void 0 : e2.animateArrowsOnPath) != null ? c2 : this.animateArrowsOnPath;
  }
  setColor() {
  }
  setOpacity() {
  }
  set visible(t3) {
    this.mesh && (this.mesh.visible = t3);
  }
  get visible() {
    return this.mesh ? this.mesh.visible : false;
  }
  get altitude() {
    return u(this, Bc);
  }
  set altitude(t3) {
    this.mesh && (this.mesh.position.z = t3, w(this, Bc, t3));
  }
  set complete(t3) {
    this.material && (this.material.uniforms.complete.value = t3, this.material.needsUpdate = true);
  }
};
Bc = /* @__PURE__ */ new WeakMap();
c();
var xh = class {
  constructor(t3) {
    t(this, "rendererState");
    this.rendererState = t3;
  }
  update() {
    let t3;
    for (let e2 of this.rendererState.geometry3DIdsInScene) if (t3 = this.rendererState.geometry3DMap.get(e2), t3 instanceof mt && t3.components[0]) {
      let i = t3.components[0];
      if (i.dirty) {
        for (let o of t3.children) (o instanceof pt || o instanceof mt) && (o.userData.entityId !== t3.components[0].activeId ? o.setVisible(false) : o.setVisible(true));
        i.dirty = false;
      }
    }
  }
};
c();
c();
c();
var Fe = Object.freeze({ Linear: Object.freeze({ None: function(r3) {
  return r3;
}, In: function(r3) {
  return r3;
}, Out: function(r3) {
  return r3;
}, InOut: function(r3) {
  return r3;
} }), Quadratic: Object.freeze({ In: function(r3) {
  return r3 * r3;
}, Out: function(r3) {
  return r3 * (2 - r3);
}, InOut: function(r3) {
  return (r3 *= 2) < 1 ? 0.5 * r3 * r3 : -0.5 * (--r3 * (r3 - 2) - 1);
} }), Cubic: Object.freeze({ In: function(r3) {
  return r3 * r3 * r3;
}, Out: function(r3) {
  return --r3 * r3 * r3 + 1;
}, InOut: function(r3) {
  return (r3 *= 2) < 1 ? 0.5 * r3 * r3 * r3 : 0.5 * ((r3 -= 2) * r3 * r3 + 2);
} }), Quartic: Object.freeze({ In: function(r3) {
  return r3 * r3 * r3 * r3;
}, Out: function(r3) {
  return 1 - --r3 * r3 * r3 * r3;
}, InOut: function(r3) {
  return (r3 *= 2) < 1 ? 0.5 * r3 * r3 * r3 * r3 : -0.5 * ((r3 -= 2) * r3 * r3 * r3 - 2);
} }), Quintic: Object.freeze({ In: function(r3) {
  return r3 * r3 * r3 * r3 * r3;
}, Out: function(r3) {
  return --r3 * r3 * r3 * r3 * r3 + 1;
}, InOut: function(r3) {
  return (r3 *= 2) < 1 ? 0.5 * r3 * r3 * r3 * r3 * r3 : 0.5 * ((r3 -= 2) * r3 * r3 * r3 * r3 + 2);
} }), Sinusoidal: Object.freeze({ In: function(r3) {
  return 1 - Math.sin((1 - r3) * Math.PI / 2);
}, Out: function(r3) {
  return Math.sin(r3 * Math.PI / 2);
}, InOut: function(r3) {
  return 0.5 * (1 - Math.sin(Math.PI * (0.5 - r3)));
} }), Exponential: Object.freeze({ In: function(r3) {
  return r3 === 0 ? 0 : Math.pow(1024, r3 - 1);
}, Out: function(r3) {
  return r3 === 1 ? 1 : 1 - Math.pow(2, -10 * r3);
}, InOut: function(r3) {
  return r3 === 0 ? 0 : r3 === 1 ? 1 : (r3 *= 2) < 1 ? 0.5 * Math.pow(1024, r3 - 1) : 0.5 * (-Math.pow(2, -10 * (r3 - 1)) + 2);
} }), Circular: Object.freeze({ In: function(r3) {
  return 1 - Math.sqrt(1 - r3 * r3);
}, Out: function(r3) {
  return Math.sqrt(1 - --r3 * r3);
}, InOut: function(r3) {
  return (r3 *= 2) < 1 ? -0.5 * (Math.sqrt(1 - r3 * r3) - 1) : 0.5 * (Math.sqrt(1 - (r3 -= 2) * r3) + 1);
} }), Elastic: Object.freeze({ In: function(r3) {
  return r3 === 0 ? 0 : r3 === 1 ? 1 : -Math.pow(2, 10 * (r3 - 1)) * Math.sin((r3 - 1.1) * 5 * Math.PI);
}, Out: function(r3) {
  return r3 === 0 ? 0 : r3 === 1 ? 1 : Math.pow(2, -10 * r3) * Math.sin((r3 - 0.1) * 5 * Math.PI) + 1;
}, InOut: function(r3) {
  return r3 === 0 ? 0 : r3 === 1 ? 1 : (r3 *= 2, r3 < 1 ? -0.5 * Math.pow(2, 10 * (r3 - 1)) * Math.sin((r3 - 1.1) * 5 * Math.PI) : 0.5 * Math.pow(2, -10 * (r3 - 1)) * Math.sin((r3 - 1.1) * 5 * Math.PI) + 1);
} }), Back: Object.freeze({ In: function(r3) {
  var t3 = 1.70158;
  return r3 === 1 ? 1 : r3 * r3 * ((t3 + 1) * r3 - t3);
}, Out: function(r3) {
  var t3 = 1.70158;
  return r3 === 0 ? 0 : --r3 * r3 * ((t3 + 1) * r3 + t3) + 1;
}, InOut: function(r3) {
  var t3 = 2.5949095;
  return (r3 *= 2) < 1 ? 0.5 * (r3 * r3 * ((t3 + 1) * r3 - t3)) : 0.5 * ((r3 -= 2) * r3 * ((t3 + 1) * r3 + t3) + 2);
} }), Bounce: Object.freeze({ In: function(r3) {
  return 1 - Fe.Bounce.Out(1 - r3);
}, Out: function(r3) {
  return r3 < 0.36363636363636365 ? 7.5625 * r3 * r3 : r3 < 0.7272727272727273 ? 7.5625 * (r3 -= 0.5454545454545454) * r3 + 0.75 : r3 < 0.9090909090909091 ? 7.5625 * (r3 -= 0.8181818181818182) * r3 + 0.9375 : 7.5625 * (r3 -= 0.9545454545454546) * r3 + 0.984375;
}, InOut: function(r3) {
  return r3 < 0.5 ? Fe.Bounce.In(r3 * 2) * 0.5 : Fe.Bounce.Out(r3 * 2 - 1) * 0.5 + 0.5;
} }), generatePow: function(r3) {
  return r3 === void 0 && (r3 = 4), r3 = r3 < Number.EPSILON ? Number.EPSILON : r3, r3 = r3 > 1e4 ? 1e4 : r3, { In: function(t3) {
    return Math.pow(t3, r3);
  }, Out: function(t3) {
    return 1 - Math.pow(1 - t3, r3);
  }, InOut: function(t3) {
    return t3 < 0.5 ? Math.pow(t3 * 2, r3) / 2 : (1 - Math.pow(2 - t3 * 2, r3)) / 2 + 0.5;
  } };
} });
var _c = function() {
  return performance.now();
};
var Iy = function() {
  function r3() {
    for (var t3 = [], e2 = 0; e2 < arguments.length; e2++) t3[e2] = arguments[e2];
    this._tweens = {}, this._tweensAddedDuringUpdate = {}, this.add.apply(this, t3);
  }
  return r3.prototype.getAll = function() {
    var t3 = this;
    return Object.keys(this._tweens).map(function(e2) {
      return t3._tweens[e2];
    });
  }, r3.prototype.removeAll = function() {
    this._tweens = {};
  }, r3.prototype.add = function() {
    for (var t3, e2 = [], i = 0; i < arguments.length; i++) e2[i] = arguments[i];
    for (var o = 0, n = e2; o < n.length; o++) {
      var s2 = n[o];
      (t3 = s2._group) === null || t3 === void 0 || t3.remove(s2), s2._group = this, this._tweens[s2.getId()] = s2, this._tweensAddedDuringUpdate[s2.getId()] = s2;
    }
  }, r3.prototype.remove = function() {
    for (var t3 = [], e2 = 0; e2 < arguments.length; e2++) t3[e2] = arguments[e2];
    for (var i = 0, o = t3; i < o.length; i++) {
      var n = o[i];
      n._group = void 0, delete this._tweens[n.getId()], delete this._tweensAddedDuringUpdate[n.getId()];
    }
  }, r3.prototype.allStopped = function() {
    return this.getAll().every(function(t3) {
      return !t3.isPlaying();
    });
  }, r3.prototype.update = function(t3, e2) {
    t3 === void 0 && (t3 = _c()), e2 === void 0 && (e2 = true);
    var i = Object.keys(this._tweens);
    if (i.length !== 0) for (; i.length > 0; ) {
      this._tweensAddedDuringUpdate = {};
      for (var o = 0; o < i.length; o++) {
        var n = this._tweens[i[o]], s2 = !e2;
        n && n.update(t3, s2) === false && !e2 && this.remove(n);
      }
      i = Object.keys(this._tweensAddedDuringUpdate);
    }
  }, r3;
}();
var Ms = { Linear: function(r3, t3) {
  var e2 = r3.length - 1, i = e2 * t3, o = Math.floor(i), n = Ms.Utils.Linear;
  return t3 < 0 ? n(r3[0], r3[1], i) : t3 > 1 ? n(r3[e2], r3[e2 - 1], e2 - i) : n(r3[o], r3[o + 1 > e2 ? e2 : o + 1], i - o);
}, Bezier: function(r3, t3) {
  for (var e2 = 0, i = r3.length - 1, o = Math.pow, n = Ms.Utils.Bernstein, s2 = 0; s2 <= i; s2++) e2 += o(1 - t3, i - s2) * o(t3, s2) * r3[s2] * n(i, s2);
  return e2;
}, CatmullRom: function(r3, t3) {
  var e2 = r3.length - 1, i = e2 * t3, o = Math.floor(i), n = Ms.Utils.CatmullRom;
  return r3[0] === r3[e2] ? (t3 < 0 && (o = Math.floor(i = e2 * (1 + t3))), n(r3[(o - 1 + e2) % e2], r3[o], r3[(o + 1) % e2], r3[(o + 2) % e2], i - o)) : t3 < 0 ? r3[0] - (n(r3[0], r3[0], r3[1], r3[1], -i) - r3[0]) : t3 > 1 ? r3[e2] - (n(r3[e2], r3[e2], r3[e2 - 1], r3[e2 - 1], i - e2) - r3[e2]) : n(r3[o ? o - 1 : 0], r3[o], r3[e2 < o + 1 ? e2 : o + 1], r3[e2 < o + 2 ? e2 : o + 2], i - o);
}, Utils: { Linear: function(r3, t3, e2) {
  return (t3 - r3) * e2 + r3;
}, Bernstein: function(r3, t3) {
  var e2 = Ms.Utils.Factorial;
  return e2(r3) / e2(t3) / e2(r3 - t3);
}, Factorial: /* @__PURE__ */ function() {
  var r3 = [1];
  return function(t3) {
    var e2 = 1;
    if (r3[t3]) return r3[t3];
    for (var i = t3; i > 1; i--) e2 *= i;
    return r3[t3] = e2, e2;
  };
}(), CatmullRom: function(r3, t3, e2, i, o) {
  var n = (e2 - r3) * 0.5, s2 = (i - t3) * 0.5, c2 = o * o, l = o * c2;
  return (2 * t3 - 2 * e2 + n + s2) * l + (-3 * t3 + 3 * e2 - 2 * n - s2) * c2 + n * o + t3;
} } };
var oS = function() {
  function r3() {
  }
  return r3.nextId = function() {
    return r3._nextId++;
  }, r3._nextId = 0, r3;
}();
var xy = new Iy();
var Gt = function() {
  function r3(t3, e2) {
    this._isPaused = false, this._pauseStart = 0, this._valuesStart = {}, this._valuesEnd = {}, this._valuesStartRepeat = {}, this._duration = 1e3, this._isDynamic = false, this._initialRepeat = 0, this._repeat = 0, this._yoyo = false, this._isPlaying = false, this._reversed = false, this._delayTime = 0, this._startTime = 0, this._easingFunction = Fe.Linear.None, this._interpolationFunction = Ms.Linear, this._chainedTweens = [], this._onStartCallbackFired = false, this._onEveryStartCallbackFired = false, this._id = oS.nextId(), this._isChainStopped = false, this._propertiesAreSetUp = false, this._goToEnd = false, this._object = t3, typeof e2 == "object" ? (this._group = e2, e2.add(this)) : e2 === true && (this._group = xy, xy.add(this));
  }
  return r3.prototype.getId = function() {
    return this._id;
  }, r3.prototype.isPlaying = function() {
    return this._isPlaying;
  }, r3.prototype.isPaused = function() {
    return this._isPaused;
  }, r3.prototype.getDuration = function() {
    return this._duration;
  }, r3.prototype.to = function(t3, e2) {
    if (e2 === void 0 && (e2 = 1e3), this._isPlaying) throw new Error("Can not call Tween.to() while Tween is already started or paused. Stop the Tween first.");
    return this._valuesEnd = t3, this._propertiesAreSetUp = false, this._duration = e2 < 0 ? 0 : e2, this;
  }, r3.prototype.duration = function(t3) {
    return t3 === void 0 && (t3 = 1e3), this._duration = t3 < 0 ? 0 : t3, this;
  }, r3.prototype.dynamic = function(t3) {
    return t3 === void 0 && (t3 = false), this._isDynamic = t3, this;
  }, r3.prototype.start = function(t3, e2) {
    if (t3 === void 0 && (t3 = _c()), e2 === void 0 && (e2 = false), this._isPlaying) return this;
    if (this._repeat = this._initialRepeat, this._reversed) {
      this._reversed = false;
      for (var i in this._valuesStartRepeat) this._swapEndStartRepeatValues(i), this._valuesStart[i] = this._valuesStartRepeat[i];
    }
    if (this._isPlaying = true, this._isPaused = false, this._onStartCallbackFired = false, this._onEveryStartCallbackFired = false, this._isChainStopped = false, this._startTime = t3, this._startTime += this._delayTime, !this._propertiesAreSetUp || e2) {
      if (this._propertiesAreSetUp = true, !this._isDynamic) {
        var o = {};
        for (var n in this._valuesEnd) o[n] = this._valuesEnd[n];
        this._valuesEnd = o;
      }
      this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat, e2);
    }
    return this;
  }, r3.prototype.startFromCurrentValues = function(t3) {
    return this.start(t3, true);
  }, r3.prototype._setupProperties = function(t3, e2, i, o, n) {
    for (var s2 in i) {
      var c2 = t3[s2], l = Array.isArray(c2), p = l ? "array" : typeof c2, d = !l && Array.isArray(i[s2]);
      if (!(p === "undefined" || p === "function")) {
        if (d) {
          var f = i[s2];
          if (f.length === 0) continue;
          for (var g = [c2], v2 = 0, b = f.length; v2 < b; v2 += 1) {
            var C = this._handleRelativeValue(c2, f[v2]);
            if (isNaN(C)) {
              d = false, console.warn("Found invalid interpolation list. Skipping.");
              break;
            }
            g.push(C);
          }
          d && (i[s2] = g);
        }
        if ((p === "object" || l) && c2 && !d) {
          e2[s2] = l ? [] : {};
          var y = c2;
          for (var S in y) e2[s2][S] = y[S];
          o[s2] = l ? [] : {};
          var f = i[s2];
          if (!this._isDynamic) {
            var T = {};
            for (var S in f) T[S] = f[S];
            i[s2] = f = T;
          }
          this._setupProperties(y, e2[s2], f, o[s2], n);
        } else (typeof e2[s2] > "u" || n) && (e2[s2] = c2), l || (e2[s2] *= 1), d ? o[s2] = i[s2].slice().reverse() : o[s2] = e2[s2] || 0;
      }
    }
  }, r3.prototype.stop = function() {
    return this._isChainStopped || (this._isChainStopped = true, this.stopChainedTweens()), this._isPlaying ? (this._isPlaying = false, this._isPaused = false, this._onStopCallback && this._onStopCallback(this._object), this) : this;
  }, r3.prototype.end = function() {
    return this._goToEnd = true, this.update(this._startTime + this._duration), this;
  }, r3.prototype.pause = function(t3) {
    return t3 === void 0 && (t3 = _c()), this._isPaused || !this._isPlaying ? this : (this._isPaused = true, this._pauseStart = t3, this);
  }, r3.prototype.resume = function(t3) {
    return t3 === void 0 && (t3 = _c()), !this._isPaused || !this._isPlaying ? this : (this._isPaused = false, this._startTime += t3 - this._pauseStart, this._pauseStart = 0, this);
  }, r3.prototype.stopChainedTweens = function() {
    for (var t3 = 0, e2 = this._chainedTweens.length; t3 < e2; t3++) this._chainedTweens[t3].stop();
    return this;
  }, r3.prototype.group = function(t3) {
    return t3 ? (t3.add(this), this) : (console.warn("tween.group() without args has been removed, use group.add(tween) instead."), this);
  }, r3.prototype.remove = function() {
    var t3;
    return (t3 = this._group) === null || t3 === void 0 || t3.remove(this), this;
  }, r3.prototype.delay = function(t3) {
    return t3 === void 0 && (t3 = 0), this._delayTime = t3, this;
  }, r3.prototype.repeat = function(t3) {
    return t3 === void 0 && (t3 = 0), this._initialRepeat = t3, this._repeat = t3, this;
  }, r3.prototype.repeatDelay = function(t3) {
    return this._repeatDelayTime = t3, this;
  }, r3.prototype.yoyo = function(t3) {
    return t3 === void 0 && (t3 = false), this._yoyo = t3, this;
  }, r3.prototype.easing = function(t3) {
    return t3 === void 0 && (t3 = Fe.Linear.None), this._easingFunction = t3, this;
  }, r3.prototype.interpolation = function(t3) {
    return t3 === void 0 && (t3 = Ms.Linear), this._interpolationFunction = t3, this;
  }, r3.prototype.chain = function() {
    for (var t3 = [], e2 = 0; e2 < arguments.length; e2++) t3[e2] = arguments[e2];
    return this._chainedTweens = t3, this;
  }, r3.prototype.onStart = function(t3) {
    return this._onStartCallback = t3, this;
  }, r3.prototype.onEveryStart = function(t3) {
    return this._onEveryStartCallback = t3, this;
  }, r3.prototype.onUpdate = function(t3) {
    return this._onUpdateCallback = t3, this;
  }, r3.prototype.onRepeat = function(t3) {
    return this._onRepeatCallback = t3, this;
  }, r3.prototype.onComplete = function(t3) {
    return this._onCompleteCallback = t3, this;
  }, r3.prototype.onStop = function(t3) {
    return this._onStopCallback = t3, this;
  }, r3.prototype.update = function(t3, e2) {
    var i = this, o;
    if (t3 === void 0 && (t3 = _c()), e2 === void 0 && (e2 = r3.autoStartOnUpdate), this._isPaused) return true;
    var n;
    if (!this._goToEnd && !this._isPlaying) if (e2) this.start(t3, true);
    else return false;
    if (this._goToEnd = false, t3 < this._startTime) return true;
    this._onStartCallbackFired === false && (this._onStartCallback && this._onStartCallback(this._object), this._onStartCallbackFired = true), this._onEveryStartCallbackFired === false && (this._onEveryStartCallback && this._onEveryStartCallback(this._object), this._onEveryStartCallbackFired = true);
    var s2 = t3 - this._startTime, c2 = this._duration + ((o = this._repeatDelayTime) !== null && o !== void 0 ? o : this._delayTime), l = this._duration + this._repeat * c2, p = function() {
      if (i._duration === 0 || s2 > l) return 1;
      var C = Math.trunc(s2 / c2), y = s2 - C * c2, S = Math.min(y / i._duration, 1);
      return S === 0 && s2 === i._duration ? 1 : S;
    }, d = p(), f = this._easingFunction(d);
    if (this._updateProperties(this._object, this._valuesStart, this._valuesEnd, f), this._onUpdateCallback && this._onUpdateCallback(this._object, d), this._duration === 0 || s2 >= this._duration) if (this._repeat > 0) {
      var g = Math.min(Math.trunc((s2 - this._duration) / c2) + 1, this._repeat);
      isFinite(this._repeat) && (this._repeat -= g);
      for (n in this._valuesStartRepeat) !this._yoyo && typeof this._valuesEnd[n] == "string" && (this._valuesStartRepeat[n] = this._valuesStartRepeat[n] + parseFloat(this._valuesEnd[n])), this._yoyo && this._swapEndStartRepeatValues(n), this._valuesStart[n] = this._valuesStartRepeat[n];
      return this._yoyo && (this._reversed = !this._reversed), this._startTime += c2 * g, this._onRepeatCallback && this._onRepeatCallback(this._object), this._onEveryStartCallbackFired = false, true;
    } else {
      this._onCompleteCallback && this._onCompleteCallback(this._object);
      for (var v2 = 0, b = this._chainedTweens.length; v2 < b; v2++) this._chainedTweens[v2].start(this._startTime + this._duration, false);
      return this._isPlaying = false, false;
    }
    return true;
  }, r3.prototype._updateProperties = function(t3, e2, i, o) {
    for (var n in i) if (e2[n] !== void 0) {
      var s2 = e2[n] || 0, c2 = i[n], l = Array.isArray(t3[n]), p = Array.isArray(c2), d = !l && p;
      d ? t3[n] = this._interpolationFunction(c2, o) : typeof c2 == "object" && c2 ? this._updateProperties(t3[n], s2, c2, o) : (c2 = this._handleRelativeValue(s2, c2), typeof c2 == "number" && (t3[n] = s2 + (c2 - s2) * o));
    }
  }, r3.prototype._handleRelativeValue = function(t3, e2) {
    return typeof e2 != "string" ? e2 : e2.charAt(0) === "+" || e2.charAt(0) === "-" ? t3 + parseFloat(e2) : parseFloat(e2);
  }, r3.prototype._swapEndStartRepeatValues = function(t3) {
    var e2 = this._valuesStartRepeat[t3], i = this._valuesEnd[t3];
    typeof i == "string" ? this._valuesStartRepeat[t3] = this._valuesStartRepeat[t3] + parseFloat(i) : this._valuesStartRepeat[t3] = this._valuesEnd[t3], this._valuesEnd[t3] = e2;
  }, r3.autoStartOnUpdate = false, r3;
}();
var gH = oS.nextId;
var si2 = xy;
var yH = si2.getAll.bind(si2);
var bH = si2.removeAll.bind(si2);
var vH = si2.add.bind(si2);
var CH = si2.remove.bind(si2);
var SH = si2.update.bind(si2);
c();
c();
c();
var nS = (r3, t3) => (t3 - r3 + Math.PI) % (Math.PI * 2) + Math.PI * 2 % (Math.PI * 2) - Math.PI;
var aS = (r3, t3) => new at(r3.clientX - t3.offsetLeft, r3.clientY - t3.offsetTop);
var Py = (r3, t3) => Math.atan2(t3.y - r3.y, t3.x - r3.x);
var Rc = (r3, t3) => Math.sqrt((t3.y - r3.y) ** 2 + (t3.x - r3.x) ** 2);
var My = (r3, t3) => new at((r3.x + t3.x) / 2, (r3.y + t3.y) / 2);
var Ty = (r3) => {
  let t3 = 0, { wheelDelta: e2, detail: i } = r3;
  return e2 !== void 0 ? t3 = e2 : i !== void 0 && (t3 = -i), t3;
};
var Ih = class {
  constructor(t3, e2) {
    t(this, "input1");
    t(this, "input2");
    t(this, "lastAngle");
    t(this, "lastDistance");
    t(this, "totalDistance");
    t(this, "first");
    t(this, "second");
    this.input1 = t3, this.input2 = e2, this.lastAngle = Py(t3, e2), this.lastDistance = Rc(t3, e2), this.totalDistance = 0, this.first = t3, this.second = e2;
  }
  update(t3, e2) {
    let i = Rc(t3, e2);
    this.input1 = t3, this.input2 = e2;
    let o = Py(t3, e2);
    this.lastAngle = o, this.lastDistance = i, this.totalDistance += (Rc(this.first, t3) + Rc(this.second, e2)) / 2, this.first = My(this.first, t3), this.second = My(this.second, e2);
  }
};
c();
var Nc = class {
  constructor(t3, e2, i) {
    t(this, "touch");
    t(this, "camera");
    t(this, "cameraPlane");
    t(this, "viewCoordinate");
    t(this, "snapHolderMatrix");
    t(this, "snapCamera");
    t(this, "cameraPosition");
    t(this, "raycaster");
    t(this, "worldCoordinate");
    t(this, "snapshotted", false);
    this.touch = t3, this.camera = e2, this.cameraPlane = i, this.viewCoordinate = { x: t3.x, y: t3.y }, this.camera.updateMatrixWorld(), this.camera.updateMatrix(), this.snapHolderMatrix = this.camera.matrixWorld.clone(), this.snapCamera = this.camera.clone(), this.snapshotCameraState();
  }
  snapshotCameraState() {
    this.camera.updateMatrix(), this.camera.updateMatrixWorld(), this.cameraPosition = this.camera.position.clone();
    let t3 = new at(this.viewCoordinate.x, this.viewCoordinate.y);
    this.raycaster = this.raycaster || new Tl(), this.raycaster.setFromCamera(t3, this.snapCamera);
    let e2 = this.raycaster.intersectObject(this.cameraPlane, true);
    this.worldCoordinate = e2 && e2.length > 0 ? e2[0].point : null, this.snapshotted = true;
  }
  updateAnchorState(t3, e2) {
    this.camera = t3, this.snapCamera = t3.clone(), this.snapHolderMatrix = t3.matrixWorld.clone(), this.updateViewCoordinate(e2), this.snapshotCameraState();
  }
  updateViewCoordinate(t3) {
    this.viewCoordinate = { x: t3.x, y: t3.y };
  }
  reUnproject() {
    var i, o;
    let t3 = new at(this.viewCoordinate.x, this.viewCoordinate.y);
    (i = this.raycaster) == null || i.setFromCamera(t3, this.snapCamera);
    let e2 = (o = this.raycaster) == null ? void 0 : o.intersectObject(this.cameraPlane, true)[0];
    return e2 ? e2.point : void 0;
  }
};
var ur2 = {};
r(ur2, { BLOCK_MERCATOR_ZOOM_LEVEL: () => U8, CLIPPING_RADIUS: () => Gc, CONTROL_OPTIONS: () => j8, DEFAULT_ANIMATION_DURATION: () => Ly, DEFAULT_BEARING: () => Z8, DEFAULT_MAX_ZOOM_LEVEL: () => X8, DEFAULT_MIN_ZOOM_LEVEL: () => Ay, DEFAULT_PITCH: () => Y8, DEFAULT_ZOOM_LEVEL: () => W8, EVENTS: () => wh, MAPLIBRE_TILE_SIZE: () => Ph, MAX_LAT: () => Dy, MAX_MERCATOR_ZOOM_LEVEL: () => Th, MIN_LAT: () => wy, MIN_MERCATOR_ZOOM_LEVEL: () => Mh, ROOM_MERCATOR_ZOOM_LEVEL: () => H8, TWO_PI: () => Ey, WHEEL_ZOOM_MULTIPLIER: () => Oy, ZRANGE: () => Ts });
c();
var Ph = 512;
var wy = -85.051129;
var Dy = 85.051129;
var Gc = 1e4;
var j8 = { chain: "chain", cancel: "cancel" };
var Ey = Math.PI * 2;
var Ts = 100;
var Oy = 1e4;
var Mh = 0;
var Th = 24;
var U8 = 17;
var H8 = 20;
var Ly = 200;
var wh = ["change", "pan-start", "pan-end", "rotate-start", "rotate-end", "zoom-start", "zoom-end", "multi-start", "multi-end", "multi-cancel", "pedestal-start", "pedestal-change", "pedestal-end", "user-pan-start", "user-pedestal-start", "user-rotate-start", "user-dolly-start", "user-zoom-start", "user-tilt-start", "user-pan-end", "user-pedestal-end", "user-rotate-end", "user-dolly-end", "user-zoom-end", "user-tilt-end", "position-updated", "zoom-updated", "tilt-updated", "rotation-updated"];
var W8 = 18;
var Ay = 12;
var X8 = 22;
var Y8 = 0;
var Z8 = 0;
var Dh = false;
var z8 = false;
var Eh;
var ea = class extends _n {
  constructor(e2, i, o, n, s2) {
    super();
    t(this, "dirty", false);
    t(this, "zoomDirty", false);
    t(this, "rotationDirty", false);
    t(this, "panDirty", false);
    v(this, Eh, Ay);
    t(this, "zoomSpeed", 5);
    t(this, "rotateSpeed", 100);
    t(this, "enabled", true);
    t(this, "enableZoom", true);
    t(this, "enablePan", true);
    t(this, "enablePedestal", false);
    t(this, "maxPedestal", 1 / 0);
    t(this, "minPedestal", 0);
    t(this, "enableRotate", true);
    t(this, "minZoomAltitude", 0);
    t(this, "maxZoomAltitude", 1 / 0);
    t(this, "ignoreZoomLimits", false);
    t(this, "zoomFactor", 1);
    t(this, "panBounds", { min: new R(1 / 0, 1 / 0), max: new R(-1 / 0, -1 / 0), center: new R(0, 0, 0), radius: 1 / 0 });
    t(this, "minTilt", 0);
    t(this, "maxTilt", 1.2);
    t(this, "MOUSE_BUTTONS", { ORBIT: Zu.RIGHT, ZOOM: Zu.MIDDLE, PAN: Zu.LEFT });
    t(this, "camera");
    t(this, "scene");
    t(this, "renderer");
    t(this, "elevation");
    t(this, "orbit");
    t(this, "cameraPlane");
    t(this, "raycaster", new Tl());
    t(this, "rendererState");
    t(this, "options");
    t(this, "state", -1);
    t(this, "intersection");
    t(this, "viewState", null);
    t(this, "tweens", /* @__PURE__ */ new Map());
    t(this, "clock", new bl(true));
    t(this, "coords", { mouse: new at(), rotateStart: new at(), rotateEnd: new at(), rotateDelta: new at(), panStart: new R(), panCameraStart: new R(), panEnd: new R(), panDelta: new R(), initialShiftPos: new at(), initialPedestal: 0, floorAnchor: new R() });
    t(this, "touch", { origin: { offsetLeft: 0, offsetTop: 0 }, touches: [], anchor1: null, anchor2: null, inputs: null });
    t(this, "scrollTimer", null);
    t(this, "lastWheelTime", 0);
    t(this, "resetZoom", false);
    t(this, "zoomStart");
    t(this, "pedestalScaleFactor", 1);
    t(this, "isUserZooming", false);
    t(this, "stayInsideBounds", true);
    t(this, "userInteracting", false);
    t(this, "cameraMoving", false);
    t(this, "lastCameraMoveTime", Date.now());
    t(this, "raycastToFloor", (e3) => {
      this.raycaster.setFromCamera(e3, this.camera);
      let i2 = this.raycaster.intersectObject(this.cameraPlane, false)[0];
      return i2 ? i2.point : new R();
    });
    t(this, "isUserInteracting", () => this.userInteracting);
    t(this, "getPosition", () => new R(this.orbit.position.x, this.orbit.position.y, this.orbit.position.z));
    t(this, "getPedestal", () => this.orbit.position.z);
    t(this, "pan", (e3, i2) => {
      isNaN(e3) || isNaN(i2) || (this.setPosition(this.orbit.position.x + e3, this.orbit.position.y + i2), this.publish("position-updated"));
    });
    t(this, "postRender", () => {
      (this.state === 2 || this.state === 6) && (this.raycaster.setFromCamera(this.coords.mouse, this.camera), this.intersection = this.raycaster.intersectObject(this.cameraPlane, false)[0], this.intersection && (this.coords.panStart.set(this.intersection.point.x, this.intersection.point.y, 0), this.coords.panCameraStart.set(this.orbit.position.x, this.orbit.position.y, 0))), this.state === 3 && this.resetZoom && (this.resetZoom = false, this.zoomStart = this.getZoomAltitude(), this.coords.floorAnchor = this.raycastToFloor(this.coords.mouse), this.coords.panCameraStart.set(this.orbit.position.x, this.orbit.position.y, 0)), this.state === 7 && this.isAnimating === false && (this.state = -1, this.publish("multi-end"));
    });
    t(this, "isCameraMoving", () => this.cameraMoving);
    t(this, "lastCameraStoppedMovingTime", () => this.lastCameraMoveTime);
    t(this, "setPosition", (e3, i2) => {
      e3 === void 0 || i2 === void 0 || isNaN(e3) || isNaN(i2) || (this.state === -1 && this.publish("pan-start"), this.updateCameraPosition(e3, i2), this.publish("position-updated"), this.publish("change"), this.state === -1 && this.publish("pan-end"), this.dirty = true);
    });
    t(this, "updateCameraPosition", (e3, i2) => {
      let o2 = e3 - this.panBounds.center.x, n2 = i2 - this.panBounds.center.y, s4 = Math.sqrt(o2 * o2 + n2 * n2);
      if (this.stayInsideBounds && s4 > this.panBounds.radius) {
        let c2 = Math.atan2(n2, o2), l = { x: Math.cos(c2) * this.panBounds.radius + this.panBounds.center.x, y: Math.sin(c2) * this.panBounds.radius + this.panBounds.center.y };
        this.orbit.position.x = l.x, this.orbit.position.y = l.y;
      } else this.orbit.position.x = e3, this.orbit.position.y = i2;
    });
    t(this, "tilt", (e3) => {
      if (isNaN(e3)) return;
      this.state === -1 && this.publish("rotate-start");
      let i2 = this.stayInsideBounds ? Math.max(Math.min(e3 + this.getTilt(), this.maxTilt), this.minTilt) : e3 + this.getTilt();
      i2 !== this.elevation.rotation.x && (this.elevation.rotation.x = i2, this.publish("tilt-updated")), this.publish("change"), this.state === -1 && this.publish("rotate-end");
    });
    t(this, "zoomIn", (e3, i2, o2) => {
      let n2 = this.getZoomAltitude();
      this.animateCamera({ zoom: n2 / 1.5 }, e3, i2, o2);
    });
    t(this, "zoomOut", (e3, i2, o2) => {
      let n2 = this.getZoomAltitude();
      this.animateCamera({ zoom: n2 * 1.5 }, e3, i2, o2);
    });
    t(this, "getRotation", () => (-this.orbit.rotation.z + Math.PI * 2) % (Math.PI * 2));
    t(this, "cancelAnimation", () => {
      let e3 = Array.from(this.tweens.keys()), i2 = e3[e3.length - 1];
      i2.state === 7 && this.publish("multi-cancel", { zooming: true, rotating: true, tilting: true }), this.completeTween(i2);
    });
    t(this, "animateCamera", (e3, i2, o2, n2, s4, c2) => {
      let l = { interruptible: true, ...c2 }, p = {}, d = {}, f = this.getPosition();
      if (e3.position != null && (e3.position.x !== void 0 && (p.x = f.x, d.x = e3.position.x), e3.position.y !== void 0 && (p.y = f.y, d.y = e3.position.y), e3.position.z !== void 0 && (p.z = f.z, d.z = e3.position.z)), e3.zoom !== void 0 && (p.zoom = this.stayInsideBounds ? Math.min(Math.max(this.getZoomAltitude(), this.getZoomScaledMin()), this.getZoomScaledMax()) : this.getZoomAltitude(), this.viewState === "multi_floor" || !this.stayInsideBounds ? d.zoom = e3.zoom : d.zoom = Math.min(Math.max(e3.zoom, this.getZoomScaledMin()), this.getZoomScaledMax())), e3.rotation !== void 0) {
        let { start: w2, end: M2 } = Wp(this.getRotation(), e3.rotation);
        p.rotation = w2, d.rotation = M2;
      }
      e3.tilt !== void 0 && (p.tilt = this.getTilt(), this.viewState === "multi_floor" || !this.stayInsideBounds ? d.tilt = e3.tilt : d.tilt = Math.max(Math.min(e3.tilt, this.maxTilt), this.minTilt));
      let g = p.zoom !== d.zoom, v2 = p.rotation !== d.rotation, b = p.tilt !== d.tilt, C = new Gt(p).to(d, e.env.TESTING ? 0 : i2).onUpdate((w2) => {
        this.setMulti({ x: w2.x, y: w2.y, z: w2.z }, w2.zoom, w2.rotation, w2.tilt);
      }).onComplete(() => {
        this.completeTween(C), this.publish("multi-end", { zooming: g, rotating: v2, tilting: b }), n2 && n2();
      }).onStart(() => {
        this.state !== 7 && (this.state = 7, C.state = 7, this.publish("multi-start", { zooming: g, rotating: v2, tilting: b })), this.publish("change");
      });
      this.rendererState.tweenGroup.add(C);
      let y = Array.from(this.tweens.entries()), S = y[y.length - 1], T = false;
      return S != null && (S[1].interruptible ? (typeof S[1].cancelledCallback == "function" && S[1].cancelledCallback(), this.completeTween(S[0])) : (T = true, S[0].chain(C))), this.tweens.set(C, { cancelledCallback: s4, interruptible: l.interruptible }), o2 ? C.easing(o2) : C.easing(Fe.Quadratic.In), !e3.doNotAutoStart && !T && (C.start(), this.publish("change")), C.cameraAnimation = true, C;
    });
    t(this, "setMulti", (e3, i2, o2, n2, s4 = true) => {
      this.state === -1 && this.publish("multi-start");
      let c2 = false;
      e3 != null && (e3.x !== void 0 && !isNaN(e3.x) && e3.y !== void 0 && !isNaN(e3.y) && (this.updateCameraPosition(e3.x, e3.y), c2 = true), e3.z !== void 0 && !isNaN(e3.z) && (this.setPedestal(e3.z, true), c2 = true)), c2 && this.publish("position-updated");
      let l = { zooming: false, tilting: !!i2, rotating: false };
      if (i2 !== void 0 && !isNaN(i2)) {
        let p = this.stayInsideBounds ? Math.min(Math.max(i2, this.getZoomScaledMin()), this.getZoomScaledMax()) : i2;
        p !== this.camera.position.z && (l.zooming = true, this.camera.position.z = p, this.publish("zoom-updated"), this.zoomDirty = true, this.viewState === "multi_floor" ? i2 > Gc && (this.camera.near = i2 - Gc, this.camera.far = i2 + Gc) : (this.camera.near = i2 / Ts, this.camera.far = i2 * Ts), this.camera.updateProjectionMatrix());
      }
      if (o2 !== void 0 && !isNaN(o2) && o2 !== this.getRotation() && (l.rotating = true, this.orbit.rotation.z = -o2, this.publish("rotation-updated")), n2 !== void 0 && !isNaN(n2)) {
        let p = this.stayInsideBounds ? Math.max(Math.min(n2, this.maxTilt), this.minTilt) : n2;
        p !== this.elevation.rotation.x && (l.tilting = true, this.elevation.rotation.x = p, this.publish("tilt-updated"));
      }
      s4 && this.publish("change"), this.state === -1 && this.publish("multi-end", l);
    });
    t(this, "getZoomScaledMin", () => this.minZoomAltitude * this.zoomFactor);
    t(this, "getZoomScaledMax", () => {
      let e3 = this.minZoomAltitude * this.zoomFactor;
      return Math.max(this.maxZoomAltitude, e3);
    });
    t(this, "setRotation", (e3, i2) => {
      if (isNaN(e3)) return;
      this.state === -1 && !i2 && this.publish("rotate-start");
      let o2 = -(e3 % Ey);
      o2 !== this.orbit.rotation.z && (this.orbit.rotation.z = o2, i2 || this.publish("rotation-updated")), i2 || this.publish("change"), this.state === -1 && !i2 && this.publish("rotate-end"), this.dirty = true, this.rotationDirty = true;
    });
    t(this, "setZoomAltitude", (e3) => {
      if (isNaN(e3)) return;
      this.state === -1 && this.publish("zoom-start");
      let i2 = this.stayInsideBounds ? Math.min(Math.max(e3, this.getZoomScaledMin()), this.getZoomScaledMax()) : e3;
      i2 !== this.camera.position.z && (this.camera.position.z = i2, this.publish("zoom-updated"), this.zoomDirty = true), this.camera.near = i2 / Ts, this.camera.far = i2 * Ts, this.camera.updateProjectionMatrix(), this.publish("change"), this.state === -1 && this.publish("zoom-end"), this.dirty = true;
    });
    t(this, "setZoomLevel", (e3) => {
      this.setZoomAltitude(this.convertZoomLevelToAltitude(e3));
    });
    t(this, "getZoomAltitude", () => this.camera.position.z);
    t(this, "getZoomLevel", () => this.convertAltitudeToZoomLevel(this.getZoomAltitude()));
    t(this, "setTilt", (e3, i2) => {
      if (isNaN(e3)) return;
      this.state === -1 && !i2 && this.publish("rotate-start");
      let o2 = this.stayInsideBounds ? Math.max(Math.min(e3, this.maxTilt), this.minTilt) : e3;
      o2 !== this.elevation.rotation.x && (this.elevation.rotation.x = o2, i2 || this.publish("tilt-updated")), i2 || this.publish("change"), this.state === -1 && !i2 && this.publish("rotate-end"), this.dirty = true;
    });
    t(this, "getTilt", () => this.elevation.rotation.x);
    t(this, "setCameraPlaneElevation", (e3) => {
      this.cameraPlane.position.z = e3;
    });
    t(this, "zoom", (e3) => {
      if (isNaN(e3)) return;
      this.state === -1 && this.publish("zoom-start");
      let i2 = this.getZoomAltitude() - e3;
      this.camera.position.z = this.stayInsideBounds ? Math.min(Math.max(i2, this.minZoomAltitude * this.zoomFactor), this.maxZoomAltitude * this.zoomFactor) : i2, this.publish("zoom-updated"), this.zoomDirty = true, this.publish("change"), this.state === -1 && this.publish("zoom-end");
    });
    t(this, "getProjectionScaleFactor", (e3, i2, o2) => h0(e3, i2, o2));
    t(this, "update", () => {
      this.lastWheelTime > 0 && this.state === 3 && this.clock.getElapsedTime() - this.lastWheelTime > 0.2 && (this.lastWheelTime = 0, this.state = -1, this.publish("zoom-end"), this.removeMouseMoveEventListeners());
    });
    t(this, "setPedestal", (e3, i2 = false) => {
      typeof e3 == "number" && !isNaN(e3) && (this.orbit.position.z = e3, i2 && (this.publishPedestalChangeEvent(e3), this.publish("pedestal-change", { pedestal: e3 })), this.publish("change"), this.dirty = true);
    });
    t(this, "dispose", () => {
      for (let e3 of wh) e3.endsWith("start") ? (this.off(e3, this.setCameraMoving), e3.startsWith("user") && this.off(e3, this.setUserInteracting)) : (e3.endsWith("end") || e3.endsWith("cancel")) && (this.off(e3, this.unsetCameraMoving), e3.startsWith("user") && this.off(e3, this.unsetUserInteracting));
      this.removeEventListeners(), this.scene.remove(this.cameraPlane);
    });
    t(this, "createCameraPlane", () => {
      let e3 = Dh ? 2e3 : 1e10, i2 = Dh ? 100 : 1, o2 = new Ps(e3, e3, i2, i2), n2 = new fs({ color: 0, wireframe: Dh, visible: Dh }), s4 = new ve(o2, n2);
      return this.scene.add(s4), s4;
    });
    t(this, "addEventListeners", () => {
      let { domElement: e3 } = this.renderer;
      for (let i2 of wh) i2.endsWith("start") ? (this.on(i2, this.setCameraMoving), i2.startsWith("user") && this.on(i2, this.setUserInteracting)) : (i2.endsWith("end") || i2.endsWith("cancel")) && (this.on(i2, this.unsetCameraMoving), i2.startsWith("user") && this.on(i2, this.unsetUserInteracting));
      e3.addEventListener("contextmenu", this.onContextMenu, false), e3.addEventListener("mousedown", this.onMouseDown, false), e3.addEventListener("wheel", this.onMouseWheel, { passive: false }), e3.addEventListener("touchstart", this.onTouchStart, false), e3.addEventListener("touchend", this.onTouchEnd, false), e3.addEventListener("touchmove", this.onTouchMove, false);
    });
    t(this, "addMouseEventListeners", () => {
      this.addMouseMoveEventListeners(), window.addEventListener("mouseup", this.onMouseUp, false), window.addEventListener("mouseout", this.onMouseUp, false);
    });
    t(this, "addMouseMoveEventListeners", () => {
      this.renderer.domElement.addEventListener("mousemove", this.onMouseMove, false);
    });
    t(this, "removeMouseMoveEventListeners", () => {
      this.renderer.domElement.removeEventListener("mousemove", this.onMouseMove, false);
    });
    t(this, "removeEventListeners", () => {
      let { domElement: e3 } = this.renderer;
      e3.removeEventListener("contextmenu", this.onContextMenu, false), e3.removeEventListener("mousedown", this.onMouseDown, false), e3.removeEventListener("wheel", this.onMouseWheel, false), e3.removeEventListener("touchstart", this.onTouchStart, false), e3.removeEventListener("touchend", this.onTouchEnd, false), e3.removeEventListener("touchmove", this.onTouchMove, false), e3.removeEventListener("mousemove", this.onMouseMove, false), window.removeEventListener("mouseup", this.onMouseUp, false), window.removeEventListener("mouseout", this.onMouseUp, false);
    });
    t(this, "removeMouseUpEventListeners", () => {
      this.renderer.domElement.removeEventListener("mousemove", this.onMouseMove, false), window.removeEventListener("mouseup", this.onMouseUp, false), window.removeEventListener("mouseout", this.onMouseUp, false);
    });
    t(this, "onContextMenu", (e3) => {
      e3.preventDefault();
    });
    t(this, "onMouseUp", () => {
      if (this.enabled !== false) {
        switch (this.removeMouseUpEventListeners(), this.state) {
          case 2:
            this.publish("pan-end"), this.publish("user-pan-end");
            break;
          case 1:
            this.publish("zoom-end"), this.publish("user-dolly-end");
            break;
          case 0:
            this.publish("rotate-end"), this.publish("user-rotate-end");
            break;
          case 8:
            this.publish("pedestal-end"), this.publish("user-pedestal-end");
            break;
        }
        this.state = -1, this.panDirty = false;
      }
    });
    t(this, "onMouseMove", (e3) => {
      if (this.enabled !== false) if (e3.preventDefault(), this.mouseToScene(e3), this.state === 0) {
        if (this.enableRotate === false) return;
        this.handleMouseMoveRotate(e3);
      } else if (this.state === 2) {
        if (this.enablePan === false) return;
        this.handleMouseMovePan();
      } else this.state === 3 ? (this.resetZoom = true, this.state = -1) : this.state === 8 && this.handleMouseMovePedestal(e3);
    });
    t(this, "onTouchStart", (e3) => {
      if (this.enabled !== false) {
        switch (this.updateTouchOrigin(), this.touchToScene(e3), e3.touches.length) {
          case 1:
            this.enablePedestal ? (this.handleTouchStartPedestal(e3), this.state = 9) : this.enablePan && (this.handleTouchStartPan(e3), this.state = 6);
            break;
          case 2:
            this.touch.inputs = new Ih(this.touch.touches[0], this.touch.touches[1]);
            break;
          default:
            this.state = -1;
        }
        this.state;
      }
    });
    t(this, "onTouchMove", (e3) => {
      if (this.enabled !== false) switch (this.touchToScene(e3), e3.touches.length) {
        case 2:
          e3.preventDefault(), e3.stopPropagation();
          let i2 = { ...this.touch.inputs.first }, o2 = { ...this.touch.inputs.second }, n2 = new at(this.touch.touches[0].x, this.touch.touches[0].y), s4 = new at(this.touch.touches[1].x, this.touch.touches[1].y);
          if (this.touch.inputs.update(this.touch.touches[0], this.touch.touches[1]), this.enableRotate && this.state === 4) this.handleTouchMoveTilt(e3);
          else if (this.state === 5) this.handleTouchMoveDolly();
          else if (this.state !== 5 && this.touch.inputs.totalDistance > 0.05) {
            let c2 = i2.y < n2.y && o2.y < s4.y, l = i2.y > n2.y && o2.y > s4.y;
            this.enableRotate && this.state !== 4 && (l || c2) ? (this.handleTouchStartTilt(e3), this.state = 4) : (this.handleTouchStartDolly(), this.state = 5);
          }
          break;
        case 1:
          (this.enablePedestal || this.enablePan) && (e3.preventDefault(), e3.stopPropagation()), this.enablePedestal && this.state === 9 ? this.handleTouchMovePedestal(e3) : this.enablePan && this.state === 6 && this.handleTouchMovePan(e3);
          break;
        default:
          this.state = -1;
      }
    });
    t(this, "onTouchEnd", (e3) => {
      if (this.enabled !== false) {
        switch (this.handleTouchEnd(), this.state) {
          case 2:
          case 6:
            this.publish("user-pan-end");
            break;
          case 4:
            this.publish("pan-end"), this.publish("user-tilt-end");
            break;
          case 1:
          case 5:
            this.publish("zoom-end"), this.publish("user-dolly-end");
            break;
          case 0:
            this.publish("rotate-end"), this.publish("user-rotate-end");
            break;
          case 8:
          case 9:
            this.publish("pedestal-end"), this.publish("user-pedestal-end");
            break;
        }
        e3.touches.length ? this.onTouchStart(e3) : this.state = -1;
      }
    });
    t(this, "handleTouchMovePan", (e3) => {
      let i2 = Object.hasOwn(e3, "x") ? new at(e3.x, e3.y) : this.touch.touches[0], o2 = this.raycastToFloor(i2);
      this.coords.panEnd.set(o2.x, o2.y, 0), this.coords.panDelta.subVectors(this.coords.panEnd, this.coords.panStart), this.setPosition(this.coords.panCameraStart.x - this.coords.panDelta.x, this.coords.panCameraStart.y - this.coords.panDelta.y), this.publish("change"), this.panDirty = true;
    });
    t(this, "handleTouchStartDolly", () => {
      let e3 = this.touch.touches[0].x - this.touch.touches[1].x, i2 = this.touch.touches[0].y - this.touch.touches[1].y;
      this.zoomStart = this.getZoomAltitude();
      let o2 = new at(this.touch.touches[0].x - e3 / 2, this.touch.touches[0].y - i2 / 2);
      this.coords.floorAnchor = this.raycastToFloor(o2), this.orbit.updateMatrixWorld(), this.touch.anchor1 = new Nc(this.touch.touches[0], this.camera, this.cameraPlane), this.touch.anchor2 = new Nc(this.touch.touches[1], this.camera, this.cameraPlane), this.coords.panCameraStart.set(this.orbit.position.x, this.orbit.position.y, 0), this.publish("user-dolly-start"), this.publish("zoom-start"), this.publish("multi-start");
    });
    t(this, "handleMouseMovePan", () => {
      let e3 = this.raycastToFloor(this.coords.mouse);
      this.coords.panEnd.set(e3.x, e3.y, 0), this.coords.panDelta.subVectors(this.coords.panEnd, this.coords.panStart), this.setPosition(this.coords.panCameraStart.x - this.coords.panDelta.x, this.coords.panCameraStart.y - this.coords.panDelta.y), this.publish("change"), this.panDirty = true;
    });
    t(this, "handleTouchStartTilt", (e3) => {
      this.coords.rotateStart.set(e3.touches[1].clientX, e3.touches[1].clientY), this.publish("user-tilt-start"), this.publish("rotate-start");
    });
    t(this, "handleTouchMovePedestal", (e3) => {
      this.handleMouseMovePedestal(e3.touches[0]);
    });
    t(this, "handleTouchMoveTilt", (e3) => {
      this.coords.rotateEnd.set(e3.touches[1].clientX, e3.touches[1].clientY), this.coords.rotateDelta.subVectors(this.coords.rotateEnd, this.coords.rotateStart), this.setTilt(this.getTilt() - this.coords.rotateDelta.y / this.rotateSpeed), this.coords.rotateStart.copy(this.coords.rotateEnd);
    });
    t(this, "handleTouchMoveDolly", () => {
      let e3 = this.touch.inputs.first, i2 = this.touch.inputs.second;
      this.touch.anchor1.viewCoordinate = { x: e3.x, y: e3.y }, this.touch.anchor2.viewCoordinate = { x: i2.x, y: i2.y };
      let o2 = this.makeTransformFromTouchAnchors(this.touch.anchor1, this.touch.anchor2);
      o2 && this.setCameraFromTransformMatrix(o2), this.orbit.updateMatrixWorld(), this.touch.anchor1.updateAnchorState(this.camera, e3), this.touch.anchor2.updateAnchorState(this.camera, i2);
    });
    t(this, "handleTouchEnd", () => {
      this.state === 4 || this.state === 5 ? this.publish("multi-end") : this.state === 6 && this.publish("pan-end"), this.panDirty = false;
    });
    t(this, "handleTouchStartPan", (e3) => {
      let i2 = Object.hasOwn(e3, "x") ? new at(e3.x, e3.y) : this.touch.touches[0], o2 = this.raycastToFloor(i2);
      this.coords.panStart.set(o2.x, o2.y, 0), this.coords.panCameraStart.set(this.orbit.position.x, this.orbit.position.y, 0), this.publish("user-pan-start"), this.publish("pan-start");
    });
    t(this, "handleTouchStartPedestal", (e3) => {
      this.handleMouseDownPedestal(e3.touches[0]);
    });
    t(this, "onMouseDown", (e3) => {
      if (this.enabled !== false) {
        if (this.mouseToScene(e3), e3.preventDefault(), this.state === 3 && this.publish("zoom-end"), e3.button === this.MOUSE_BUTTONS.ORBIT) {
          if (this.enableRotate === false) return;
          this.handleMouseDownRotate(e3), this.state = 0;
        } else e3.button === this.MOUSE_BUTTONS.PAN && (this.enablePan ? (this.handleMouseDownPan(), this.state = 2) : this.enablePedestal && (this.handleMouseDownPedestal(e3), this.state = 8));
        this.state !== -1 && this.addMouseEventListeners();
      }
    });
    t(this, "onMouseWheel", (e3) => {
      this.enabled === false || this.enableZoom === false || this.state !== -1 && this.state !== 3 || (e3.preventDefault(), e3.stopPropagation(), this.mouseToScene(e3), this.canScrollZoom(e3) && (this.lastWheelTime = this.clock.getElapsedTime(), this.publishUserZoomEvent()), this.state !== 3 && this.canScrollZoom(e3) && (this.addMouseMoveEventListeners(), this.state = 3, this.zoomStart = this.getZoomAltitude(), this.coords.floorAnchor = this.raycastToFloor(this.coords.mouse), this.coords.panCameraStart.set(this.orbit.position.x, this.orbit.position.y, 0), this.publish("zoom-start")), this.scrollTimer != null && clearTimeout(this.scrollTimer), this.scrollTimer = setTimeout(() => {
        this.publish("zoom-end");
      }, 50), this.handleMouseWheel(e3));
    });
    t(this, "handleMouseWheel", (e3) => {
      if (this.publish("zoom-start"), !this.canScrollZoom(e3)) {
        this.lastWheelTime > 0 && this.publish("zoom-end"), this.lastWheelTime = 0, this.state = -1;
        return;
      }
      let i2 = this.getZoomAltitude(), o2 = i2 - Ty(e3) * i2 / Oy * this.zoomSpeed;
      if (this.setZoomAltitude(o2), this.enablePan) {
        let n2 = o2 / this.zoomStart;
        this.coords.panDelta.subVectors(this.coords.floorAnchor, this.coords.panCameraStart).multiplyScalar(1 - n2), this.setPosition(this.coords.panCameraStart.x + this.coords.panDelta.x, this.coords.panCameraStart.y + this.coords.panDelta.y);
      }
      this.publish("change");
    });
    t(this, "setCameraFromTransformMatrix", (e3) => {
      this.orbit.updateMatrixWorld();
      let i2 = new Ye();
      i2.setFromRotationMatrix(e3, "ZYX");
      let o2 = (e3.elements[14] - this.cameraPlane.position.z) / Math.cos(i2.x), n2 = i2.z, s4 = new R(0, 0, 1);
      s4.applyEuler(i2), s4.setLength(o2);
      let c2 = new R();
      c2.setFromMatrixPosition(e3), c2.sub(s4), this.enablePan && this.setPosition(c2.x, c2.y), this.enableZoom && this.setZoomAltitude(o2), this.enableRotate && this.setRotation(-n2);
    });
    t(this, "makeTransformFromTouchAnchors", (e3, i2) => {
      this.orbit.updateMatrixWorld(), this.camera.updateProjectionMatrix();
      let o2 = this.camera.projectionMatrix.clone(), n2 = e3.worldCoordinate, s4 = i2.worldCoordinate, c2 = e3.reUnproject(), l = i2.reUnproject();
      if (!c2 || !l || !n2 || !s4) return null;
      let p = e3.viewCoordinate, d = i2.viewCoordinate, f = s4.x - n2.x, g = s4.y - n2.y, v2 = Math.atan2(g, f), b = l.x - c2.x, C = l.y - c2.y, y = Math.atan2(C, b), S = nS(v2, y), T = new kt();
      T.makeRotationZ(-S);
      let w2 = T.clone();
      w2.multiply(e3.snapHolderMatrix);
      let M2 = (_x, Rx, Nx) => _x.elements[(Rx - 1) * 4 + Nx - 1], D = M2(o2, 1, 1) * M2(w2, 1, 1) - p.x * M2(o2, 3, 4) * M2(w2, 3, 1), F = M2(o2, 1, 1) * M2(w2, 1, 2) - p.x * M2(o2, 3, 4) * M2(w2, 3, 2), A = M2(o2, 1, 1) * M2(w2, 1, 3) - p.x * M2(o2, 3, 4) * M2(w2, 3, 3), k = n2.x * D + n2.y * F + n2.z * A, B = M2(o2, 2, 2) * M2(w2, 2, 1) - p.y * M2(o2, 3, 4) * M2(w2, 3, 1), G = M2(o2, 2, 2) * M2(w2, 2, 2) - p.y * M2(o2, 3, 4) * M2(w2, 3, 2), V = M2(o2, 2, 2) * M2(w2, 2, 3) - p.y * M2(o2, 3, 4) * M2(w2, 3, 3), W = n2.x * B + n2.y * G + n2.z * V, $ = M2(o2, 1, 1) * M2(w2, 1, 1) - d.x * M2(o2, 3, 4) * M2(w2, 3, 1), U = M2(o2, 1, 1) * M2(w2, 1, 2) - d.x * M2(o2, 3, 4) * M2(w2, 3, 2), ie = M2(o2, 1, 1) * M2(w2, 1, 3) - d.x * M2(o2, 3, 4) * M2(w2, 3, 3), Z = s4.x * $ + s4.y * U + s4.z * ie, Ee2 = M2(o2, 2, 2) * M2(w2, 2, 1) - d.y * M2(o2, 3, 4) * M2(w2, 3, 1), ue = M2(o2, 2, 2) * M2(w2, 2, 2) - d.y * M2(o2, 3, 4) * M2(w2, 3, 2), ge = M2(o2, 2, 2) * M2(w2, 2, 3) - d.y * M2(o2, 3, 4) * M2(w2, 3, 3), xe2 = s4.x * Ee2 + s4.y * ue + s4.z * ge, hr = Math.abs($ - D), kt2 = Math.abs(U - F), dt = Math.abs(ie - A), nt = Math.abs($ - B), bi = Math.abs(U - G), io = Math.abs(ie - V), ae2 = Math.abs(Ee2 - D), de2 = Math.abs(ue - F), Ue = Math.abs(ge - A), ht = Math.abs(Ee2 - B), fr = Math.abs(ue - G), oo = Math.abs(ge - V), cn2 = Math.min(hr + kt2 + dt, nt + bi + io), wa = Math.min(ae2 + de2 + Ue, ht + fr + oo);
      cn2 < wa && ($ = Ee2, U = ue, ie = ge, Z = xe2);
      let Qt = B * A - D * V, al2 = G * A - F * V, y1 = W * A - k * V, ff = $ * V - B * ie, mf = U * V - G * ie, b1 = Z * V - W * ie, Lx = (b1 * al2 - y1 * mf) / (ff * al2 - Qt * mf), Ax = (b1 * Qt - y1 * ff) / (mf * Qt - al2 * ff), v1 = G * D - F * B, Fx = V * D - A * B, kx = W * D - k * B, C1 = U * B - G * $, Bx = ie * B - V * $, S1 = ((Z * B - W * $) * v1 - kx * C1) / (Bx * v1 - Fx * C1), du2 = w2.clone();
      return du2.elements[12] = Lx, du2.elements[13] = Ax, du2.elements[14] = S1, S1 > 0 ? du2 : null;
    });
    t(this, "updateTouchOrigin", () => {
      let e3 = this.renderer.domElement;
      this.touch.origin.offsetLeft = e3.getBoundingClientRect().left, this.touch.origin.offsetTop = e3.getBoundingClientRect().top;
    });
    t(this, "touchToScene", (e3) => {
      this.touch.touches = [];
      for (let i2 = 0, o2 = e3.touches.length; i2 < o2; i2++) {
        let n2 = e3.touches[i2], s4 = aS(n2, this.touch.origin);
        this.touch.touches.push(new at(s4.x / this.renderer.domElement.width * this.rendererState.pixelRatio * 2 - 1, -(s4.y / this.renderer.domElement.height * this.rendererState.pixelRatio) * 2 + 1));
      }
      this.coords.mouse = this.touch.touches[0];
    });
    t(this, "canScrollZoom", (e3) => {
      let i2 = Ty(e3), o2 = this.getZoomAltitude();
      return !(i2 < 0 && o2 === this.getZoomScaledMax() || i2 > 0 && o2 === this.getZoomScaledMin());
    });
    t(this, "mouseToScene", (e3) => {
      let i2 = this.getMousePos(e3);
      return this.coords.mouse.x = i2.x / this.renderer.domElement.width * this.rendererState.pixelRatio * 2 - 1, this.coords.mouse.y = -(i2.y / this.renderer.domElement.height * this.rendererState.pixelRatio) * 2 + 1, this.coords.mouse;
    });
    t(this, "getMousePos", (e3) => ({ x: e3.offsetX, y: e3.offsetY }));
    t(this, "handleMouseDownRotate", (e3) => {
      this.coords.rotateStart.set(e3.clientX, e3.clientY), this.publish("rotate-start"), this.publish("user-rotate-start");
    });
    t(this, "handleMouseDownPan", () => {
      let e3 = this.raycastToFloor(this.coords.mouse);
      this.coords.panStart.set(e3.x, e3.y, 0), this.coords.panCameraStart.set(this.orbit.position.x, this.orbit.position.y, 0), this.publish("pan-start"), this.publish("user-pan-start");
    });
    t(this, "handleMouseDownPedestal", (e3) => {
      let i2 = new at(e3.clientX, e3.clientY);
      this.coords.initialShiftPos = i2, this.coords.initialPedestal = this.getPedestal(), this.pedestalScaleFactor = h0(this.camera.fov, this.renderer.domElement.clientHeight, this.getZoomAltitude()), this.publish("pedestal-start"), this.publish("user-pedestal-start");
    });
    t(this, "handleMouseMovePedestal", (e3) => {
      let i2 = { x: e3.clientX, y: e3.clientY }, o2 = this.coords.initialPedestal + this.pedestalScaleFactor * (i2.y - this.coords.initialShiftPos.y);
      this.stayInsideBounds && (o2 < this.minPedestal ? o2 = Math.max(o2, this.minPedestal) : o2 > this.maxPedestal && (o2 = Math.min(o2, this.maxPedestal))), o2 !== this.getPedestal() && this.setPedestal(o2, true);
    });
    t(this, "handleMouseMoveRotate", (e3) => {
      this.coords.rotateEnd.set(e3.clientX, e3.clientY), this.coords.rotateDelta.subVectors(this.coords.rotateEnd, this.coords.rotateStart), this.setRotation(this.getRotation() + this.coords.rotateDelta.x / this.rotateSpeed), this.setTilt(this.getTilt() - this.coords.rotateDelta.y / this.rotateSpeed), this.coords.rotateStart.copy(this.coords.rotateEnd), this.publish("change");
    });
    t(this, "publishUserZoomDebounced", bp(() => {
      this.isUserZooming = false, this.publish("user-zoom-end");
    }, 250));
    t(this, "publishUserZoomEvent", () => {
      this.isUserZooming ? this.publishUserZoomDebounced() : (this.publish("user-zoom-start"), this.isUserZooming = true, this.publishUserZoomDebounced());
    });
    t(this, "setCameraMoving", () => {
      this.cameraMoving = true;
    });
    t(this, "unsetCameraMoving", () => {
      this.cameraMoving = false, this.lastCameraMoveTime = Date.now();
    });
    t(this, "setUserInteracting", () => {
      this.userInteracting = true;
    });
    t(this, "unsetUserInteracting", () => {
      this.userInteracting = false;
    });
    t(this, "publishPedestalChangeEvent", (e3) => {
      this.publish("pedestal-change", { pedestal: e3, scrolledToTop: this.scrolledToTop, scrolledToBottom: this.scrolledToBottom, scrollPercent: this.scrollPercent });
    });
    t(this, "convertAltitudeToZoomLevel", (e3) => {
      let [, i2] = this.center, n2 = e3 * 2 * Math.tan(md.degToRad(this.camera.fov) / 2) / this.options.canvasHeight, s4 = Math.cos(md.degToRad(i2)) * 2 * Math.PI * ur / n2;
      return md.clamp(Math.log2(s4 / 512), Mh, Th);
    });
    t(this, "convertZoomLevelToAltitude", (e3) => {
      let [, i2] = this.center, o2 = md.clamp(e3, Mh, Th), n2 = Math.pow(2, o2), s4 = md.clamp(i2, wy, Dy), c2 = n2 * 512;
      return Math.cos(md.degToRad(s4)) * Math.PI * 2 * ur / c2 * this.options.canvasHeight / 2 / Math.tan(md.degToRad(this.camera.fov) / 2);
    });
    t(this, "completeTween", (e3) => {
      e3.isPlaying() && e3.stop(), this.rendererState.tweenGroup.remove(e3), this.tweens.delete(e3);
    });
    t(this, "debugContainer", new de());
    this.camera = e2, this.renderer = o, this.rendererState = n, this.scene = i, this.options = s2, this.elevation = e2.parent, this.orbit = this.elevation.parent, this.cameraPlane = this.createCameraPlane(), this.zoomStart = e2.position.z, s2.mode !== "outdoors-overlay" && this.addEventListeners();
  }
  get maxZoomLevel() {
    return this.convertAltitudeToZoomLevel(this.minZoomAltitude);
  }
  setMaxZoomLevel(e2) {
    this.minZoomAltitude = this.convertZoomLevelToAltitude(e2);
  }
  get defaultMinZoomLevel() {
    return u(this, Eh);
  }
  get minZoomLevel() {
    return this.convertAltitudeToZoomLevel(this.maxZoomAltitude);
  }
  setMinZoomLevel(e2) {
    this.maxZoomAltitude = this.convertZoomLevelToAltitude(e2);
  }
  get scrollPercent() {
    let e2 = this.minPedestal, i = this.maxPedestal, o = this.getPedestal();
    return o = Math.min(o, i), o = Math.max(o, e2), (o - e2) / (i - e2) * 100;
  }
  get fov() {
    return this.camera.fov;
  }
  get scrolledToBottom() {
    return this.minPedestal === 0 || Math.floor(this.getPedestal()) <= this.minPedestal;
  }
  get scrolledToTop() {
    return this.maxPedestal === 0 || Math.ceil(this.getPedestal()) >= this.maxPedestal;
  }
  get center() {
    var n, s2, c2, l;
    let e2 = this.getPosition(), { lat: i, lon: o } = s0((s2 = (n = this.rendererState.center) == null ? void 0 : n[1]) != null ? s2 : 0, (l = (c2 = this.rendererState.center) == null ? void 0 : c2[0]) != null ? l : 0, e2.x, e2.y);
    return [o, i];
  }
  setCenter(e2, i) {
    var s2, c2, l, p;
    let { x: o, y: n } = l0((c2 = (s2 = this.rendererState.center) == null ? void 0 : s2[1]) != null ? c2 : 0, (p = (l = this.rendererState.center) == null ? void 0 : l[0]) != null ? p : 0, i, e2);
    this.setPosition(o, n);
  }
  get isAnimating() {
    return this.rendererState.tweenGroup.getAll().some((e2) => e2.cameraAnimation);
  }
  getCameraFrameForCoordinates(e2, i) {
    let o = i.minZoom !== void 0 ? i.minZoom : this.minZoomAltitude, n = i.maxZoom !== void 0 ? i.maxZoom : this.maxZoomAltitude, s2 = this.options.canvasWidth, c2 = this.options.canvasHeight, l = this.getRotation(), p = this.getTilt(), d = this.getPosition();
    this.setRotation(i.rotation || l, true), this.setTilt(i.tilt || p, true);
    let f = sS(e2, { canvasWidth: s2, canvasHeight: c2, paddingOption: i.padding, verticalPadding: i.verticalPadding, minZoom: o, maxZoom: n, position: d, camera: this.camera, orbit: this.orbit });
    return this.setRotation(l, true), this.setTilt(p, true), { center: f.position, zoomLevel: this.convertAltitudeToZoomLevel(f.zoom) };
  }
  focusOn(e2, i) {
    if (z8) {
      this.debugContainer && ji(this.debugContainer);
      let y = new ki(4, 4, 4), S = new fs({ color: 65280, depthTest: false }), T = new Yo(y, S, e2.length), w2 = new kt();
      e2.forEach((M2, D) => {
        w2.setPosition(M2), T.setMatrixAt(D, w2);
      }), T.instanceMatrix.needsUpdate = true, this.debugContainer.add(T), this.scene.add(this.debugContainer);
    }
    let o = i.curve, n = i.callback, s2 = i.cancelledCallback, c2 = i.minZoom !== void 0 ? i.minZoom : this.minZoomAltitude, l = i.maxZoom !== void 0 ? i.maxZoom : this.maxZoomAltitude, p = this.options.canvasWidth, d = this.options.canvasHeight, f;
    i.duration !== void 0 ? f = i.duration : e.env.TESTING === "true" ? f = 0 : f = Ly;
    let g = i.padding, v2 = this.getRotation(), b = this.getTilt();
    i.rotation != null && this.setRotation(i.rotation), i.tilt != null && this.setTilt(i.tilt);
    let C = sS(e2, { canvasHeight: d, paddingOption: g, canvasWidth: p, minZoom: c2, maxZoom: l, camera: this.camera, orbit: this.orbit, position: this.getPosition(), verticalPadding: i.verticalPadding });
    this.setRotation(v2), this.setTilt(b), this.animateCamera({ position: C.position, tilt: i.tilt, rotation: i.rotation, zoom: C.zoom }, f, o, n, s2, i);
  }
  resize(e2, i) {
    this.options.canvasWidth = e2, this.options.canvasHeight = i;
  }
};
Eh = /* @__PURE__ */ new WeakMap(), t(ea, "CAMERA_FRAME_PADDING_SIDES", ["top", "bottom", "left", "right"]);
function sS(r3, { canvasWidth: t3, orbit: e2, paddingOption: i, verticalPadding: o = 0, canvasHeight: n, minZoom: s2, maxZoom: c2, camera: l, position: p }) {
  let d = { zoom: s2, position: p };
  if (r3.length === 0) return d;
  for (let Qt of ea.CAMERA_FRAME_PADDING_SIDES) typeof i[Qt] != "number" && (i[Qt] = 0);
  let f = i.type === "portion" ? { top: i.top * n, bottom: i.bottom * n, left: i.left * t3, right: i.right * t3, type: "pixel" } : i;
  if (f.left + f.right >= t3 || f.top + f.bottom >= n) return d;
  e2.updateMatrixWorld();
  let g = l.matrixWorldInverse, v2 = l.fov * (Math.PI / 180) / 2, b = v2, y = Math.atan(Math.tan(v2) * (t3 / n)), S = new R(1 / 0, 1 / 0, 1 / 0), T = new R(-1 / 0, -1 / 0, -1 / 0), w2 = new Ie(), M2 = new R();
  for (let Qt = 0, al2 = r3.length; Qt < al2; Qt++) M2.copy(r3[Qt]), w2.expandByPoint(M2), M2.applyMatrix4(g), S.min(M2), T.max(M2), M2.copy(r3[Qt]), M2.z -= o, M2.applyMatrix4(g), S.min(M2), T.max(M2), M2.copy(r3[Qt]), M2.z += o, M2.applyMatrix4(g), S.min(M2), T.max(M2);
  let D = T.x - S.x, F = T.y - S.y, A = t3 - f.left - f.right, k = n - f.top - f.bottom, B = (T.x + S.x) / 2, G = (T.y + S.y) / 2, V = D / A, W = F / k, $ = s2, U = c2, ie = $ * Math.tan(y) * 2, Z = U * Math.tan(y) * 2, Ee2 = ie / t3, ue = Z / t3, ge = Math.max(V, W);
  ge = md.clamp(ge, Ee2, ue);
  let xe2 = A * ge, hr = k * ge, kt2 = { min: { x: B - xe2 / 2 - f.left * ge, y: G - hr / 2 - f.bottom * ge }, max: { x: B + xe2 / 2 + f.right * ge, y: G + hr / 2 + f.top * ge } }, dt = (kt2.min.x + kt2.max.x) / 2, nt = (kt2.min.y + kt2.max.y) / 2, bi = w2.getCenter(new R()), io = Math.abs(dt - kt2.min.x), ae2 = Math.abs(nt - kt2.min.y), de2 = io / Math.tan(y), Ue = ae2 / Math.tan(b), ht = new R();
  ht.set(dt, nt, T.z + Math.max(de2, Ue)), ht.applyMatrix4(l.matrixWorld);
  let fr = new R();
  fr.set(dt, nt, T.z), fr.applyMatrix4(l.matrixWorld);
  let oo = new R().subVectors(fr, ht), cn2 = (bi.z - ht.z) / oo.z, wa = new R().copy(ht).add(oo.clone().multiplyScalar(cn2));
  return fr.set(wa.x, wa.y, wa.z), ht.sub(fr), { position: wa, zoom: ht.length() };
}
c();
var q8 = 300;
var Vc;
var jc;
var Oh = class {
  constructor(t3) {
    t(this, "state");
    v(this, Vc, new R());
    v(this, jc, new R());
    this.state = t3;
  }
  update(t3) {
    var o;
    let e2, i;
    this.state.cameraObject.getWorldPosition(u(this, jc));
    for (let n of this.state.geometry2DIdsInScene) if (e2 = this.state.geometry2DMap.get(n), e2 && (i = e2.components[0], i && "containerEl" in i && i.containerEl != null)) {
      if (i.visibilityNeedsUpdate !== false && (i.visibilityNeedsUpdate === "show" ? i.canShow = true : i.canShow = false), (i.canShow && i.visible === true || ((o = i.animation) == null ? void 0 : o.pending) === true) && !i.offscreen) if (i.options.zIndex != null) i.containerEl.style.transform = "translate3D(".concat(i.projection.x, "px, ").concat(i.projection.y, "px, ").concat(i.options.zIndex, "px)");
      else {
        e2.object3d.getWorldPosition(u(this, Vc));
        let s2 = u(this, jc).distanceTo(u(this, Vc));
        i.containerEl.style.transform = "translate3D(".concat(i.projection.x, "px, ").concat(i.projection.y, "px, ").concat(-s2, "px)");
      }
      if (i.canShow === true && i.visible === true ? i.containerEl.style.pointerEvents = t3 ? "none" : i.pointerEvents : i.containerEl.style.pointerEvents = "none", i.currentStrategyIndex === -1 && i.visible && i.visibilityNeedsUpdate === "show") continue;
      i.visibilityNeedsUpdate !== false && !i.offscreen && (i.visibilityNeedsUpdate === "show" && (i.containerEl.style.opacity = "0"), i.animation && i.animation.cancel(), i.animation = i.containerEl.animate([{ opacity: i.canShow && i.visible ? "1" : "0" }], { duration: q8, easing: "ease-in-out", fill: "forwards" }), i.visibilityNeedsUpdate = false);
    }
  }
};
Vc = /* @__PURE__ */ new WeakMap(), jc = /* @__PURE__ */ new WeakMap();
c();
var Lh = class {
  constructor() {
    t(this, "percentExpanded", 0);
    t(this, "activeId", "");
    t(this, "gap", 20);
    t(this, "dirty", true);
  }
};
c();
var Ah = class extends _n {
  constructor(e2, i) {
    super();
    t(this, "state");
    t(this, "dirty", true);
    t(this, "domTree");
    t(this, "observers", /* @__PURE__ */ new Map());
    t(this, "updateDimensions", (e3) => {
      e3.forEach((i2) => {
        let o = i2.target, n = o.getAttribute("data-marker-id");
        if (n) {
          let s2 = this.state.geometry2DMap.get(n);
          s2 && s2.components[0] instanceof yl && o.firstElementChild && (s2.components[0].updateDimensions(), s2.components[0].collisionDirty = true);
        }
      }), this.publish("dimensions-update");
    });
    this.state = e2, this.domTree = i;
  }
  setupObserver() {
    var i;
    if (this.observers) {
      for (let o of this.observers.values()) o.disconnect();
      this.observers.clear();
    }
    let e2;
    for (let o of this.domTree.children) {
      let n = o.getAttribute("data-marker-id");
      if (n != null && (e2 = this.state.geometry2DMap.get(n), (i = e2.components[0].options) != null && i.dynamicResize)) {
        let s2 = new ResizeObserver(this.updateDimensions);
        s2.observe(o), this.observers.set(o.userData.entityId, s2);
      }
    }
  }
  update() {
    this.dirty && (this.setupObserver(), this.dirty = false);
  }
  destroy() {
    for (let e2 of this.observers.values()) e2.disconnect();
    this.observers.clear();
  }
};
c();
var $8 = 0;
var J8 = 90;
var Q8 = (e.env.NODE_ENV === "test", false);
function Ni(r3, t3, e2, i) {
  return (r3 < t3 || r3 > e2) && Lt.warn(i), Math.min(e2, Math.max(t3, r3));
}
var ws2 = { linear: Fe.Linear.None, "ease-in": Fe.Quadratic.In, "ease-out": Fe.Quadratic.Out, "ease-in-out": Fe.Quadratic.InOut };
var K8 = -50;
var X;
var ee;
var Ho2;
var Uc;
var Hc;
var ky;
var Fh = class {
  constructor(t3, e2, i) {
    v(this, Hc);
    v(this, X);
    v(this, ee);
    v(this, Ho2);
    v(this, Uc);
    w(this, X, t3), w(this, ee, e2), w(this, Ho2, i), u(this, ee).cameraSystem.on("pedestal-change", ({ pedestal: o }) => {
      u(this, X).map && (u(this, X).map.transform.elevation = o, u(this, X).map.transform.minElevationForCurrentTile = K8, u(this, X).map.triggerRepaint()), u(this, ee).cameraSystem.setCameraPlaneElevation(o);
    });
  }
  get center() {
    return u(this, X).mode === "outdoors-overlay" && u(this, X).map ? u(this, X).map.getCenter().toArray() : u(this, ee).cameraSystem.center;
  }
  setCenter(t3) {
    var e2;
    if (u(this, X).mode === "outdoors-overlay" && u(this, X).map) {
      (e2 = u(this, X).map) == null || e2.setCenter(t3), u(this, ee).interactionSystem.handleHover();
      return;
    }
    u(this, ee).cameraSystem.setCenter(t3[0], t3[1]), u(this, ee).interactionSystem.handleHover();
  }
  get zoomLevel() {
    var t3;
    return u(this, X).mode === "outdoors-overlay" && u(this, X).map ? (t3 = u(this, X).map) == null ? void 0 : t3.getZoom() : u(this, ee).cameraSystem.getZoomLevel();
  }
  setZoomLevel(t3) {
    var e2;
    u(this, X).mode === "outdoors-overlay" && u(this, X).map && ((e2 = u(this, X).map) == null || e2.setZoom(t3)), u(this, ee).cameraSystem.setZoomLevel(Ni(t3, this.minZoomLevel, this.maxZoomLevel, "zoomLevel was clamped to minZoomLevel/maxZoomLevel bounds. Use mapView.Camera.setMinZoomLevel() and mapView.Camera.setMaxZoomLevel() to adjust limits."));
  }
  get isAnimating() {
    return u(this, ee).cameraSystem.isAnimating;
  }
  cancelAnimation() {
    u(this, ee).cameraSystem.cancelAnimation();
  }
  get maxZoomLevel() {
    return u(this, ee).cameraSystem.maxZoomLevel;
  }
  get minZoomLevel() {
    return u(this, ee).cameraSystem.minZoomLevel;
  }
  setAutoMinZoomLevel(t3) {
    u(this, ee).panBoundsSystem.autoMinZoomLevel = t3, t3 && (u(this, ee).panBoundsSystem.dirty = true, u(this, ee).panBoundsSystem.update());
  }
  get autoMinZoomLevel() {
    return u(this, ee).panBoundsSystem.autoMinZoomLevel;
  }
  setMinZoomLevel(t3, e2 = false) {
    var o;
    e2 && this.setAutoMinZoomLevel(false);
    let i = Ni(t3, ur2.MIN_MERCATOR_ZOOM_LEVEL, this.maxZoomLevel, "setMinZoomLevel was clamped. minZoomLevel must be between ".concat(ur2.MIN_MERCATOR_ZOOM_LEVEL, " and maxZoomLevel."));
    u(this, ee).cameraSystem.setMinZoomLevel(i), this.zoomLevel < i && this.setZoomLevel(i), (o = u(this, X).map) == null || o.setMinZoom(i);
  }
  setMaxZoomLevel(t3) {
    var i;
    let e2 = Ni(t3, this.minZoomLevel, ur2.MAX_MERCATOR_ZOOM_LEVEL, "setMaxZoomLevel was clamped. maxZoomLevel must be between minZoomLevel and ".concat(ur2.MAX_MERCATOR_ZOOM_LEVEL, "."));
    u(this, ee).cameraSystem.setMaxZoomLevel(e2), this.zoomLevel > e2 && this.setZoomLevel(e2), (i = u(this, X).map) == null || i.setMaxZoom(e2);
  }
  get maxPitch() {
    var t3;
    return u(this, X).mode === "outdoors-overlay" && u(this, X).map ? (t3 = u(this, X).map) == null ? void 0 : t3.getMaxPitch() : md.radToDeg(u(this, ee).cameraSystem.maxTilt);
  }
  get minPitch() {
    var t3;
    return u(this, X).mode === "outdoors-overlay" && u(this, X).map ? (t3 = u(this, X).map) == null ? void 0 : t3.getMinPitch() : md.radToDeg(u(this, ee).cameraSystem.minTilt);
  }
  setMinPitch(t3) {
    var i;
    let e2 = Math.max($8, t3);
    (i = u(this, X).map) == null || i.setMinPitch(e2), u(this, ee).cameraSystem.minTilt = md.degToRad(e2);
  }
  setMaxPitch(t3) {
    var i;
    let e2 = Math.min(J8, t3);
    (i = u(this, X).map) == null || i.setMaxPitch(e2), u(this, ee).cameraSystem.maxTilt = md.degToRad(e2);
  }
  get bearing() {
    var t3;
    return u(this, X).mode === "outdoors-overlay" && u(this, X).map ? (t3 = u(this, X).map) == null ? void 0 : t3.getBearing() : md.radToDeg(u(this, ee).cameraSystem.getRotation());
  }
  setBearing(t3) {
    var e2;
    if (u(this, X).mode === "outdoors-overlay" && u(this, X).map) {
      (e2 = u(this, X).map) == null || e2.setBearing(t3);
      return;
    }
    u(this, ee).cameraSystem.setRotation(md.degToRad(t3));
  }
  get pitch() {
    var t3;
    return u(this, X).mode === "outdoors-overlay" && u(this, X).map ? (t3 = u(this, X).map) == null ? void 0 : t3.getPitch() : md.radToDeg(u(this, ee).cameraSystem.getTilt());
  }
  setPitch(t3) {
    var e2;
    if (u(this, X).mode === "outdoors-overlay" && u(this, X).map) {
      (e2 = u(this, X).map) == null || e2.setPitch(t3);
      return;
    }
    u(this, ee).cameraSystem.setTilt(md.degToRad(Ni(t3, this.minPitch, this.maxPitch, "pitch was clamped to minPitch/maxPitch bounds. Use mapView.Camera.setMinPitch() and mapView.Camera.setMaxPitch() to adjust limits.")));
  }
  get elevation() {
    return u(this, ee).cameraSystem.getPedestal();
  }
  setElevation(t3) {
    u(this, ee).cameraSystem.setPedestal(t3, true);
  }
  animateElevation(t3, e2) {
    return u(this, Uc) && u(this, Uc).stop(), new Promise((i) => {
      var n;
      let o = u(this, ee).cameraSystem.getPosition();
      o.z = t3, u(this, ee).cameraSystem.animateCamera({ position: o }, (e2 == null ? void 0 : e2.duration) || 300, ws2[(e2 == null ? void 0 : e2.easing) || "ease-in-out"], i, i, { interruptible: (n = e2 == null ? void 0 : e2.interruptible) != null ? n : true });
    });
  }
  get insetsPadding() {
    return u(this, Ho2).insetsPadding;
  }
  get panMode() {
    return u(this, ee).cameraSystem.enablePan === false && u(this, ee).cameraSystem.enablePedestal === true ? "elevation" : "default";
  }
  setPanMode(t3) {
    if (t3 !== "default" && t3 !== "elevation") throw new Error("Invalid pan mode");
    t3 !== this.panMode && (t3 === "default" ? (u(this, ee).cameraSystem.enablePan = true, u(this, ee).cameraSystem.enablePedestal = false) : (u(this, ee).cameraSystem.enablePan = false, u(this, ee).cameraSystem.enablePedestal = true));
  }
  setInsetPadding(t3) {
    u(this, Ho2).insetsPadding = Object.assign({}, jy, t3);
  }
  animateTo(t3) {
    var s2, c2, l, p, d, f;
    if (u(this, X).mode === "outdoors-overlay" && u(this, X).map) return (f = u(this, X).map) == null || f.flyTo({ center: (s2 = t3.center) != null ? s2 : this.center, zoom: (c2 = t3.zoomLevel) != null ? c2 : this.zoomLevel, bearing: (l = t3.bearing) != null ? l : this.bearing, pitch: (p = t3.pitch) != null ? p : this.pitch, duration: (d = t3.duration) != null ? d : 600 }), Promise.resolve();
    let e2 = t3.center ? u(this, X).convertTo3DMapPosition(t3.center[1], t3.center[0], t3.center[2] || this.elevation) : void 0, i = t3.zoomLevel !== void 0 ? u(this, ee).cameraSystem.convertZoomLevelToAltitude(Ni(t3.zoomLevel, this.minZoomLevel, this.maxZoomLevel, "zoomLevel was clamped to minZoomLevel/maxZoomLevel bounds. Use mapView.Camera.setMinZoomLevel() and mapView.Camera.setMaxZoomLevel() to adjust limits.")) : void 0, o = t3.bearing !== void 0 ? md.degToRad(t3.bearing) : void 0, n = t3.pitch !== void 0 ? md.degToRad(Ni(t3.pitch, this.minPitch, this.maxPitch, "pitch was clamped to minPitch/maxPitch bounds. Use mapView.Camera.setMinPitch() and mapView.Camera.setMaxPitch() to adjust limits.")) : void 0;
    return new Promise((g) => {
      var v2;
      u(this, ee).cameraSystem.animateCamera({ position: e2, zoom: i, rotation: o, tilt: n }, t3.duration || 0, ws2[t3.easing || "ease-in-out"], () => {
        u(this, ee).interactionSystem.handleHover(), g();
      }, g, { interruptible: (v2 = t3 == null ? void 0 : t3.interruptible) != null ? v2 : true });
    });
  }
  getCameraFrameForCoordinates(t3, e2) {
    let i = x(this, Hc, ky).call(this, e2 || {}, () => Promise.resolve()), { pointCloud: o } = lS(t3, u(this, X), u(this, Ho2).geometry3DMap);
    if (o.length === 0) return Lt.error("No valid coordinates found in targets:", t3), { center: this.center, zoomLevel: this.zoomLevel };
    let { center: n, zoomLevel: s2 } = u(this, ee).cameraSystem.getCameraFrameForCoordinates(o, i);
    return { center: u(this, X).convert3DMapPositionToCoordinate(n), zoomLevel: s2 };
  }
  focusOn(t3, e2) {
    var s2, c2, l, p;
    let { pointCloud: i, geoBounds: o, firstPosition: n } = lS(t3, u(this, X), u(this, Ho2).geometry3DMap);
    return i.length === 0 ? (Lt.error("No valid coordinates found in targets:", t3), Promise.resolve()) : u(this, X).mode === "outdoors-overlay" && u(this, X).map ? (i.length === 1 && n ? (s2 = u(this, X).map) == null || s2.flyTo({ center: [n[0], n[1]], duration: (e2 == null ? void 0 : e2.duration) || u(this, X).map.getBearing(), animate: true, bearing: (e2 == null ? void 0 : e2.bearing) === void 0 ? u(this, X).map.getBearing() : e2 == null ? void 0 : e2.bearing, pitch: (e2 == null ? void 0 : e2.pitch) === void 0 ? u(this, X).map.getPitch() : e2 == null ? void 0 : e2.pitch, zoom: (e2 == null ? void 0 : e2.maxZoomLevel) || u(this, X).map.getMaxZoom() }) : (Q8 && ew(u(this, X), o), (p = u(this, X).map) == null || p.fitBounds(o, { duration: (c2 = e2 == null ? void 0 : e2.duration) != null ? c2 : ur2.DEFAULT_ANIMATION_DURATION, bearing: (e2 == null ? void 0 : e2.bearing) === void 0 ? u(this, X).map.getBearing() : e2 == null ? void 0 : e2.bearing, pitch: (e2 == null ? void 0 : e2.pitch) === void 0 ? u(this, X).map.getPitch() : e2 == null ? void 0 : e2.pitch, maxZoom: (l = e2 == null ? void 0 : e2.maxZoomLevel) != null ? l : u(this, X).map.getMaxZoom() })), u(this, ee).interactionSystem.handleHover(), Promise.resolve()) : new Promise((d) => {
      u(this, ee).cameraSystem.focusOn(i, x(this, Hc, ky).call(this, e2 || {}, d));
    });
  }
};
X = /* @__PURE__ */ new WeakMap(), ee = /* @__PURE__ */ new WeakMap(), Ho2 = /* @__PURE__ */ new WeakMap(), Uc = /* @__PURE__ */ new WeakMap(), Hc = /* @__PURE__ */ new WeakSet(), ky = function(t3, e2) {
  var i;
  return { minZoom: (t3 == null ? void 0 : t3.maxZoomLevel) === void 0 ? void 0 : u(this, ee).cameraSystem.convertZoomLevelToAltitude(Ni(t3.maxZoomLevel, this.minZoomLevel, this.maxZoomLevel, "maxZoomLevel was clamped to minZoomLevel/maxZoomLevel bounds. Use mapView.Camera.setMaxZoomLevel() to adjust limits.")), maxZoom: (t3 == null ? void 0 : t3.minZoomLevel) === void 0 ? void 0 : u(this, ee).cameraSystem.convertZoomLevelToAltitude(Ni(t3.minZoomLevel, this.minZoomLevel, this.maxZoomLevel, "minZoomLevel was clamped to minZoomLevel/maxZoomLevel bounds. Use mapView.Camera.setMinZoomLevel() to adjust limits.")), padding: t3 != null && t3.padding ? Object.assign({}, jy, t3 == null ? void 0 : t3.padding) : this.insetsPadding, curve: ws2[(t3 == null ? void 0 : t3.easing) || "ease-in-out"], rotation: (t3 == null ? void 0 : t3.bearing) === void 0 ? void 0 : md.degToRad(t3.bearing), tilt: (t3 == null ? void 0 : t3.pitch) !== void 0 ? md.degToRad(Ni(t3.pitch, this.minPitch, this.maxPitch, "pitch was clamped to minPitch/maxPitch bounds. Use mapView.Camera.setMinPitch() and mapView.Camera.setMaxPitch() to adjust limits.")) : void 0, duration: t3 == null ? void 0 : t3.duration, callback: () => {
    u(this, ee).interactionSystem.handleHover(), e2();
  }, cancelledCallback: e2, interruptible: (i = t3 == null ? void 0 : t3.interruptible) != null ? i : true, verticalPadding: t3 == null ? void 0 : t3.verticalPadding };
};
function Fy(r3, t3) {
  r3[0] = Math.min(r3[0], t3[0]), r3[1] = Math.min(r3[1], t3[1]), r3[2] = Math.max(r3[2], t3[0]), r3[3] = Math.max(r3[3], t3[1]);
}
function lS(r3, t3, e2) {
  var c2;
  let i = [], o = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n = null;
  if (!r3 || !Array.isArray(r3) || r3.length === 0) return { pointCloud: i, geoBounds: o, firstPosition: n };
  let s2 = t3.getSystems().renderSystem;
  (s2.threeDdirty || s2.twoDdirty) && t3.renderSync();
  for (let l of r3) if (typeof l == "string") {
    let p = e2.get(l);
    if (!p) {
      Lt.error("Entity not found with id:", l);
      continue;
    }
    let d = new Ie();
    Bb(t3, "userData" in p && (c2 = p.userData.entityId) != null ? c2 : p.id, i, d, p instanceof mt ? p.position.z : void 0);
    let f = t3.convert3DMapPositionToCoordinate(d.min), g = t3.convert3DMapPositionToCoordinate(d.max);
    Fy(o, f), Fy(o, g), n || (n = t3.convert3DMapPositionToCoordinate(d.getCenter(new R())));
  } else i.push(t3.convertTo3DMapPosition(l[1], l[0], l[2] || 0)), Fy(o, l), n || (n = l);
  return { pointCloud: i, geoBounds: o, firstPosition: n };
}
function ew(r3, t3) {
  var i, o, n, s2;
  let e2 = [[t3[0], t3[1]], [t3[0], t3[3]], [t3[2], t3[3]], [t3[2], t3[1]], [t3[0], t3[1]]];
  (i = r3.map) != null && i.getLayer("bounds-outline") && r3.map.removeLayer("bounds-outline"), (o = r3.map) != null && o.getSource("bounds-source") && r3.map.removeSource("bounds-source"), (n = r3.map) == null || n.addSource("bounds-source", { type: "geojson", data: { type: "Feature", properties: {}, geometry: { type: "LineString", coordinates: e2 } } }), (s2 = r3.map) == null || s2.addLayer({ id: "bounds-outline", type: "line", source: "bounds-source", layout: {}, paint: { "line-color": "#FF0000", "line-width": 2, "line-opacity": 0.8 } });
}
c();
var cS = "uniform vec4 uSize;\nvarying vec2 vUv;\nvoid main() {\n  vUv = uv;\n  // Scale the position by the size of the quad\n  // and shift to top left corner for 0,0\n	vec2 transformed = position.xy * uSize.xy - vec2(1.0, -1.0);\n  // Apply width .x and height .y of image\n  transformed += vec2(uSize.x, -uSize.y);\n  // Apply left .w and top .z offset\n  transformed += vec2(uSize.w, -uSize.z) * 2.0;\n  gl_Position = vec4(transformed, 1.0, 1.0);\n}";
var pS = "varying vec2 vUv;\nuniform sampler2D uTexture;\nuniform float uOpacity;\nvoid main() {\n  #ifndef debug\n  vec4 texture = texture2D(uTexture, vUv);\n  gl_FragColor = vec4(texture.rgb, texture.a * uOpacity);\n  #else\n  gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n  #endif\n}";
c();
var uS = 4.291666666666667;
var dS = 15;
var hS = 25;
var fS = 43 / 60;
c();
var mS = ["horizontal", "icon"];
var iw = /* @__PURE__ */ new Map([[mS[0], '<svg viewBox="0 0 206 48">\n      <path d="M27.2678 14.2261H22.3187C21.0695 14.2261 20.4695 14.7801 20.4695 15.9852V31.142L10.3966 15.5591C9.69665 14.4784 9.2475 14.2773 7.8475 14.2261H2.97462C1.67462 14.2261 1.07631 14.7801 1.07631 15.9852V44.7665C1.07631 45.9716 1.67462 46.5256 2.97462 46.5256H7.92377C9.22207 46.5256 9.82207 45.9716 9.82207 44.7665V29.6847L19.9441 45.1926C20.695 46.3244 21.095 46.5256 22.4933 46.5256H27.2933C28.5916 46.5256 29.1916 45.9716 29.1916 44.7665V15.9852C29.1407 14.7801 28.5424 14.2261 27.2678 14.2261Z"/>\n      <path d="M5.44915 10.9602C8.45863 10.9602 10.8983 8.50669 10.8983 5.48011C10.8983 2.45353 8.45863 0 5.44915 0C2.43967 0 0 2.45353 0 5.48011C0 8.50669 2.43967 10.9602 5.44915 10.9602Z"/>\n      <path d="M61.7899 25.0449C63.2306 23.1903 65.078 22.2051 67.556 22.2051C72.0526 22.2051 74.7611 25.3347 74.7611 29.4511V39.2489C74.8187 39.7125 74.5306 39.9443 74.0695 39.9443H72.5136C72.0526 39.9443 71.7645 39.7125 71.8221 39.2489V29.5091C71.8221 27.1909 69.9187 25.2187 67.4984 25.2187C65.1339 25.2187 63.2323 27.1329 63.2323 29.2773V39.2489C63.2899 39.7125 63.0018 39.9443 62.5407 39.9443H60.9831C60.5221 39.9443 60.2916 39.7125 60.2916 39.2489V29.4511C60.2916 27.1329 58.3899 25.2187 56.0255 25.2187C53.7204 25.2187 51.7594 27.075 51.7594 29.2773V39.3068C51.817 39.7705 51.5289 40.0023 51.0102 40.0023H49.5119C49.0509 40.0023 48.7628 39.7705 48.7628 39.3068V23.25C48.7051 22.7864 48.9933 22.4966 49.5119 22.4966H50.9526C51.356 22.4966 51.5289 22.6704 51.5289 23.0182V24.2352C52.7407 22.9602 54.239 22.2648 56.0255 22.2648C58.4475 22.2068 60.3492 23.192 61.7899 25.0466V25.0449ZM77.1255 31.2477C77.1255 26.3216 81.1018 22.2051 86.1187 22.2051C88.539 22.2051 90.6136 23.1903 92.3441 25.1608V23.1903C92.3441 22.7267 92.5746 22.5528 93.0357 22.5528H94.4187C94.8797 22.5528 95.1102 22.7847 95.1102 23.3062V39.3648C95.1102 39.8284 94.8797 40.0602 94.4187 40.0602H93.0357C92.5746 40.0602 92.3441 39.8284 92.3441 39.4227V37.4523C90.6712 39.3648 88.5967 40.35 86.1746 40.35C81.1018 40.2341 77.1238 36.1773 77.1238 31.2477H77.1255ZM92.1136 31.2477C92.1136 27.8284 89.4611 25.2187 86.0594 25.2187C82.7746 25.2187 80.1221 27.8864 80.1221 31.2477C80.1221 34.6687 82.7746 37.2784 86.1187 37.2784C86.9062 37.2789 87.6861 37.1232 88.4138 36.8202C89.1414 36.5173 89.8026 36.0731 90.3593 35.513C90.9161 34.9528 91.3577 34.2878 91.6587 33.556C91.9597 32.8241 92.1143 32.0397 92.1136 31.2477ZM100.992 37.3943V46.3807C101.049 46.8443 100.761 47.1341 100.298 47.1341H98.7424C98.2814 47.1341 97.9933 46.9023 97.9933 46.3807V23.1903C97.9933 22.7267 98.2238 22.4369 98.7424 22.4369H100.183C100.646 22.379 100.934 22.6687 100.934 23.0744V24.9869C102.605 23.0744 104.68 22.1472 107.044 22.1472C112.002 22.1472 116.037 26.2619 116.037 31.1898C116.037 36.1176 112.059 40.2341 107.044 40.2341C104.622 40.2341 102.603 39.3068 100.992 37.3943ZM106.987 25.2187C103.7 25.2187 101.049 27.8864 101.049 31.2477C101.049 34.6687 103.7 37.2784 107.044 37.2784C110.446 37.2784 113.039 34.6108 113.039 31.2477C113.039 27.8864 110.388 25.2187 106.987 25.2187ZM121.11 37.3943V46.3807C121.168 46.8443 120.88 47.1341 120.419 47.1341H118.861C118.4 47.1341 118.112 46.9023 118.112 46.3807V23.1903C118.112 22.7267 118.342 22.4369 118.861 22.4369H120.302C120.764 22.379 121.053 22.6687 121.053 23.0744V24.9869C122.724 23.0744 124.798 22.1472 127.163 22.1472C132.12 22.1472 136.156 26.2619 136.156 31.1898C136.156 36.1176 132.178 40.2341 127.163 40.2341C124.742 40.2341 122.781 39.3068 121.11 37.3943ZM127.105 25.2187C123.819 25.2187 121.168 27.8864 121.168 31.2477C121.168 34.6687 123.819 37.2784 127.163 37.2784C130.564 37.2784 133.158 34.6108 133.158 31.2477C133.158 27.8864 130.507 25.2187 127.107 25.2187H127.105ZM153.97 32.3506H141.054C141.342 35.2483 143.995 37.4523 147.164 37.4523C148.893 37.4523 150.393 37.0466 151.719 36.0597C152.007 35.8858 152.295 35.7699 152.353 35.7699C152.583 35.7699 152.756 35.8858 152.929 36.1773L153.505 37.1625C153.622 37.3364 153.68 37.4523 153.68 37.5682C153.68 37.8 153.507 38.0318 153.103 38.3216C151.258 39.5966 149.183 40.292 146.992 40.292C141.688 40.292 137.883 36.3511 137.883 31.2477C137.883 26.204 141.803 22.2051 146.703 22.2051C151.546 22.2051 154.717 25.7983 154.717 31.0176C154.717 31.5972 154.717 32.3506 153.968 32.3506H153.97ZM141.056 30.0324H151.72C151.432 26.8432 149.473 24.929 146.648 24.929C145.241 24.8904 143.875 25.3995 142.833 26.3501C141.791 27.3007 141.154 28.6194 141.056 30.0307V30.0324ZM156.332 31.2477C156.332 26.3216 160.31 22.2051 165.326 22.2051C167.748 22.2051 169.707 23.1324 171.32 25.0449V16.2324C171.263 15.7687 171.551 15.479 172.012 15.479H173.57C174.031 15.479 174.319 15.7108 174.319 16.2324V39.3068C174.319 39.7705 174.088 40.0023 173.57 40.0023H172.129C171.666 40.0602 171.378 39.7705 171.378 39.3648V37.3943C169.649 39.3068 167.632 40.292 165.268 40.292C160.31 40.2341 156.332 36.1773 156.332 31.2477ZM171.264 31.2477C171.264 27.8284 168.612 25.2187 165.21 25.2187C161.924 25.2187 159.273 27.8864 159.273 31.2477C159.273 34.6687 161.924 37.2784 165.268 37.2784C166.057 37.2838 166.839 37.1316 167.569 36.8304C168.299 36.5292 168.962 36.0852 169.52 35.5241C170.077 34.963 170.519 34.296 170.818 33.5619C171.117 32.8277 171.268 32.0411 171.263 31.2477H171.264ZM177.72 19.0739C177.715 18.8594 177.754 18.646 177.833 18.4468C177.912 18.2476 178.031 18.0667 178.182 17.915C178.333 17.7633 178.512 17.6439 178.71 17.5642C178.909 17.4845 179.121 17.446 179.334 17.4511C179.546 17.4507 179.756 17.4923 179.952 17.5737C180.148 17.6551 180.326 17.7746 180.476 17.9254C180.626 18.0762 180.745 18.2553 180.826 18.4523C180.907 18.6494 180.948 18.8606 180.948 19.0739C180.953 19.2884 180.914 19.5017 180.835 19.7009C180.756 19.9001 180.637 20.081 180.486 20.2327C180.335 20.3845 180.156 20.5038 179.957 20.5835C179.759 20.6633 179.547 20.7017 179.334 20.6966C178.412 20.7545 177.72 20.0591 177.72 19.0739ZM177.836 39.2489V23.1903C177.836 22.7267 178.066 22.4369 178.527 22.4369H180.083C180.544 22.4369 180.832 22.6687 180.775 23.1903V39.2489C180.832 39.7125 180.544 39.9443 180.083 39.9443H178.527C178.066 39.9443 177.836 39.7125 177.836 39.2489ZM186.944 23.0165V24.1756C188.212 22.8426 189.71 22.2051 191.497 22.2051C195.937 22.2051 198.646 25.2767 198.646 29.3932V39.2489C198.703 39.7125 198.415 39.9443 197.954 39.9443H196.398C195.936 39.9443 195.705 39.7125 195.705 39.2489V29.4511C195.705 27.1329 193.803 25.2187 191.439 25.2187C189.134 25.2187 187.175 27.075 187.175 29.2773V39.3068C187.232 39.7705 186.944 40.0023 186.424 40.0023H184.868C184.407 40.0023 184.119 39.7705 184.119 39.3068V23.1903C184.061 22.7267 184.349 22.4949 184.868 22.4949H186.309C186.712 22.4949 186.944 22.6687 186.944 23.0165Z"/>\n      <path d="M204 40C205.115 40 206 39.0857 206 38V37.9886C206 36.9029 205.126 36 204 36C202.885 36 202 36.9143 202 38V38.0114C202 39.0971 202.874 40 204 40ZM204 39.7829C202.989 39.7829 202.23 38.9829 202.23 38.0114V38C202.23 37.0286 203 36.2171 204 36.2171C205.011 36.2171 205.77 37.0171 205.77 37.9886V38C205.77 38.9714 205 39.7829 204 39.7829ZM203.218 38.9714H203.609V38.2743H204.034L204.517 38.9714H204.989L204.448 38.2057C204.724 38.1257 204.92 37.92 204.92 37.5886C204.92 37.1657 204.586 36.9486 204.138 36.9486H203.218V38.9714ZM203.609 37.9543V37.2914H204.103C204.368 37.2914 204.517 37.4057 204.517 37.6229C204.517 37.8171 204.368 37.9543 204.103 37.9543H203.609Z"/>\n    </svg>'], [mS[1], '<svg viewBox="0 0 43 60">\n      <path d="M14.0291 7.06645C14.0291 10.9691 10.8885 14.1329 7.01453 14.1329C3.14051 14.1329 0 10.9691 0 7.06645C0 3.16376 3.14051 0 7.01453 0C10.8885 0 14.0291 3.16376 14.0291 7.06645Z"/>\n      <path d="M28.7335 18.3468H35.1045C36.7455 18.3468 37.5178 19.0599 37.5821 20.6158V57.7309C37.5821 59.2868 36.8099 60 35.1367 60H28.9588C27.1569 60 26.642 59.7406 25.6767 58.282L12.6452 38.282V57.7309C12.6452 59.2868 11.8729 60 10.1997 60H3.82873C2.15554 60 1.3833 59.2868 1.3833 57.7309V20.6158C1.3833 19.0599 2.15554 18.3468 3.82873 18.3468H10.1032C11.9051 18.4116 12.4843 18.671 13.3852 20.0648L26.3524 40.162V20.6158C26.3524 19.0599 27.1247 18.3468 28.7335 18.3468Z"/>\n      <path d="M41.5 60C42.3362 60 43 59.3143 43 58.5V58.4914C43 57.6771 42.3448 57 41.5 57C40.6638 57 40 57.6857 40 58.5V58.5086C40 59.3229 40.6552 60 41.5 60ZM41.5 59.8371C40.7414 59.8371 40.1724 59.2371 40.1724 58.5086V58.5C40.1724 57.7714 40.75 57.1629 41.5 57.1629C42.2586 57.1629 42.8276 57.7629 42.8276 58.4914V58.5C42.8276 59.2286 42.25 59.8371 41.5 59.8371ZM40.9138 59.2286H41.2069V58.7057H41.5259L41.8879 59.2286H42.2414L41.8362 58.6543C42.0431 58.5943 42.1897 58.44 42.1897 58.1914C42.1897 57.8743 41.9397 57.7114 41.6034 57.7114H40.9138V59.2286ZM41.2069 58.4657V57.9686H41.5776C41.7759 57.9686 41.8879 58.0543 41.8879 58.2171C41.8879 58.3629 41.7759 58.4657 41.5776 58.4657H41.2069Z"/>\n    </svg>']]);
var ow = /<svg([^>]*)>/g;
function gS(r3, t3, e2, i) {
  let o = iw.get(r3);
  return o ? o.replace(ow, '<svg$1 width="'.concat(e2, '" height="').concat(i, '" xmlns="http://www.w3.org/2000/svg" style="fill: ').concat(t3, ';">')) : "";
}
var yS = false;
var Ce;
var Gi;
var Ds;
var vt;
var Ot;
var ta;
var Tr;
var li;
var kh = class extends _n {
  constructor(e2, i, o) {
    super();
    v(this, Ce, { padding: 16, scale: 1, iconOnly: false, position: "bottom-left", color: "dark", onClick: () => {
      window != null && window.open("https://www.mappedin.com");
    }, interactive: true, visible: true });
    v(this, Gi);
    v(this, Ds);
    v(this, vt);
    v(this, Ot);
    v(this, ta);
    v(this, Tr, 0);
    v(this, li, 0);
    t(this, "dirty", true);
    t(this, "getPositionAlignedCanvasCoordinates", (e3, i2) => ({ "top-left": { x: 0, y: 0 }, "top-right": { x: e3, y: 0 }, "bottom-left": { x: 0, y: i2 }, "bottom-right": { x: e3, y: i2 }, center: { x: e3 / 2, y: i2 / 2 }, top: { x: e3 / 2, y: 0 }, bottom: { x: e3 / 2, y: i2 }, left: { x: 0, y: i2 / 2 }, right: { x: e3, y: i2 / 2 } })[u(this, Ce).position]);
    t(this, "getPositionAlignedPadding", () => {
      var o2, n, s2, c2;
      let e3 = u(this, Ce).padding;
      if (typeof e3 == "number") return { "top-left": { x: e3, y: e3 }, "top-right": { x: -e3, y: e3 }, "bottom-left": { x: e3, y: -e3 }, "bottom-right": { x: -e3, y: -e3 }, center: { x: 0, y: 0 }, top: { x: 0, y: e3 }, bottom: { x: 0, y: -e3 }, left: { x: e3, y: 0 }, right: { x: -e3, y: 0 } }[u(this, Ce).position];
      let i2 = { top: (o2 = e3.top) != null ? o2 : 0, right: (n = e3.right) != null ? n : 0, bottom: (s2 = e3.bottom) != null ? s2 : 0, left: (c2 = e3.left) != null ? c2 : 0 };
      return { x: i2.left - i2.right, y: i2.top - i2.bottom };
    });
    o && Object.entries(o).forEach(([n, s2]) => {
      s2 !== void 0 && (u(this, Ce)[n] = s2);
    }), w(this, Ds, e2), w(this, Gi, i);
  }
  get color() {
    return u(this, Ce).color === "light" ? "white" : "#293136";
  }
  get iconName() {
    return u(this, Ce).iconOnly ? "icon" : "horizontal";
  }
  get minWidth() {
    return u(this, Ce).iconOnly ? dS : 75;
  }
  get defaultWidth() {
    return u(this, Ce).iconOnly ? hS : 150;
  }
  get aspectRatio() {
    return u(this, Ce).iconOnly ? fS : uS;
  }
  get options() {
    return { ...u(this, Ce) };
  }
  set options(e2) {
    var i;
    w(this, Ce, { padding: e2.padding || u(this, Ce).padding, position: e2.position || u(this, Ce).position, iconOnly: e2.iconOnly || u(this, Ce).iconOnly, color: e2.color || u(this, Ce).color, scale: e2.scale || u(this, Ce).scale, onClick: u(this, Ce).onClick, interactive: (i = e2.interactive) != null ? i : u(this, Ce).interactive, visible: e2.visible || u(this, Ce).visible });
  }
  get icon() {
    return gS(this.iconName, this.color, u(this, Tr) * u(this, Gi).pixelRatio, u(this, li) * u(this, Gi).pixelRatio);
  }
  setSize(e2, i) {
    u(this, Ot) && (u(this, Ot).uniforms.uSize.value.x = e2, u(this, Ot).uniforms.uSize.value.y = i);
  }
  setXY(e2, i) {
    u(this, Ot) && (u(this, Ot).uniforms.uSize.value.w = e2, u(this, Ot).uniforms.uSize.value.z = i);
  }
  get width() {
    return u(this, Tr);
  }
  get height() {
    return u(this, li);
  }
  getPositionAlignedOffset(e2, i) {
    return { "top-left": { x: 0, y: 0 }, "top-right": { x: -e2, y: 0 }, "bottom-left": { x: 0, y: -i }, "bottom-right": { x: -e2, y: -i }, center: { x: -(e2 / 2), y: -(i / 2) }, top: { x: -(e2 / 2), y: 0 }, bottom: { x: -(e2 / 2), y: -i }, left: { x: 0, y: -(i / 2) }, right: { x: -e2, y: -(i / 2) } }[u(this, Ce).position];
  }
  insertIntoQuadTree(e2) {
    u(this, ta) != null && typeof u(this, Ce).onClick == "function" && u(this, Ce).interactive && e2.insert(u(this, ta));
  }
  resize(e2, i) {
    if (u(this, Ce).visible !== true) return;
    let o = this.getPositionAlignedCanvasCoordinates(e2, i), n = this.getPositionAlignedPadding(), s2 = this.getPositionAlignedOffset(u(this, Tr), u(this, li)), c2 = Math.min(e2 - u(this, Tr), Math.max(0, o.x + n.x + s2.x)), l = Math.min(i - u(this, li), Math.max(0, o.y + n.y + s2.y));
    this.setSize(u(this, Tr) / e2, u(this, li) / i), this.setXY(c2 / e2, l / i), w(this, ta, new qe(c2, l, u(this, Tr), u(this, li), { entityId: "watermark" }));
  }
  update() {
    this.dirty && u(this, Ce).visible === true && (w(this, Tr, Math.min(u(this, Gi).canvasWidth, Math.max(this.minWidth, this.defaultWidth * u(this, Ce).scale))), w(this, li, u(this, Tr) / this.aspectRatio), jo.getLoader().load("data:image/svg+xml;base64,".concat(btoa(this.icon)), (e2) => {
      if (w(this, Ot, new nn({ uniforms: { uTexture: { value: e2 }, uSize: { value: new Jt(0, 0, 0, 0) }, uOpacity: { value: 0.7 } }, vertexShader: cS, fragmentShader: pS, depthWrite: false, depthTest: false, defines: { debug: yS }, wireframe: yS, transparent: true, visible: true })), u(this, vt)) u(this, vt).material = u(this, Ot), u(this, vt).material.needsUpdate = true;
      else {
        let i = new Ps(2, 2, 1, 1);
        w(this, vt, new ve(i, u(this, Ot))), u(this, vt).position.set(0, 0, -1), u(this, vt).frustumCulled = false, u(this, vt).renderOrder = 999;
        let o = new ki(1, 1, 1), n = new ve(o, new fs({ transparent: true, opacity: 0, depthTest: false, depthWrite: false }));
        n.frustumCulled = false, n.layers.set(1), u(this, vt).add(n), u(this, Ds).add(u(this, vt));
      }
      this.resize(u(this, Gi).canvasWidth, u(this, Gi).canvasHeight), this.publish("texture-loaded");
    })), this.dirty = false;
  }
  destroy() {
    u(this, vt) && (u(this, Ds).remove(u(this, vt)), ji(u(this, vt))), w(this, vt, void 0), u(this, Ot) && u(this, Ot).dispose(), w(this, Ot, void 0), w(this, ta, void 0);
  }
};
Ce = /* @__PURE__ */ new WeakMap(), Gi = /* @__PURE__ */ new WeakMap(), Ds = /* @__PURE__ */ new WeakMap(), vt = /* @__PURE__ */ new WeakMap(), Ot = /* @__PURE__ */ new WeakMap(), ta = /* @__PURE__ */ new WeakMap(), Tr = /* @__PURE__ */ new WeakMap(), li = /* @__PURE__ */ new WeakMap();
c();
var Bh = 100;
var sw = false;
var Rh = class extends _n {
  constructor(e2, i) {
    super();
    t(this, "currentTotalBoundingBox");
    t(this, "state");
    t(this, "cameraSystem");
    t(this, "debugMesh", null);
    t(this, "dirty", true);
    t(this, "autoMinZoomLevel", true);
    this.state = e2, this.cameraSystem = i;
  }
  update() {
    if (this.dirty) {
      this.currentTotalBoundingBox == null && (this.currentTotalBoundingBox = new Ie(), this.state.entityScene.children.length === 0 ? this.currentTotalBoundingBox.setFromCenterAndSize(new R(0, 0, 0), new R(Bh * 2, Bh * 2, 0)) : (this.currentTotalBoundingBox.setFromObject(this.state.entityScene), this.currentTotalBoundingBox.expandByScalar(Bh)));
      let e2 = new Ie().setFromObject(this.state.entityScene);
      this.currentTotalBoundingBox.union(e2);
      let i = e2.getSize(new R()), o = Math.max(i.x, i.y, i.z);
      for (let s2 of this.state.geometry2DMap.values()) s2.positionDirty === true && (this.currentTotalBoundingBox.expandByPoint(s2.position), s2.positionDirty = false);
      let n = _h.copy(this.currentTotalBoundingBox).expandByScalar(Math.max(o, Bh)).getBoundingSphere(lw).radius;
      if (this.cameraSystem.panBounds = { center: this.currentTotalBoundingBox.getCenter(new R()), min: _h.min, max: _h.max, radius: n }, this.publish("update"), this.cameraSystem.dirty = true, this.dirty = false, sw && this.state.entityScene.parent instanceof Ho) {
        this.debugMesh && (this.state.entityScene.parent.remove(this.debugMesh), this.debugMesh = null), this.debugMesh = new de(), this.debugMesh.add(new ve(new rl(this.cameraSystem.panBounds.radius), new fs({ color: 16711680, transparent: true, opacity: 0.2 }))), this.debugMesh.position.copy(this.cameraSystem.panBounds.center), this.state.entityScene.parent.add(this.debugMesh);
        let s2 = new R();
        _h.getSize(s2);
        let c2 = new ki(s2.x, s2.y, s2.z), l = new fs({ color: 65280, wireframe: true, transparent: true, opacity: 0.5 }), p = new ve(c2, l);
        p.position.copy(this.currentTotalBoundingBox.getCenter(new R())), this.debugMesh.add(p);
      }
    }
  }
};
var _h = new Ie();
var lw = new Te();
c();
var bS = "© Mappedin";
var cw = "https://info.mappedin.com/feedback";
var _y = ["top-left", "top-right", "bottom-left", "bottom-right"];
var pw = 640;
var uw = () => "<svg xmlns='http://www.w3.org/2000/svg' width='15' height='15' fill-rule='evenodd' viewBox='0 0 20 20'>\n						<circle cx='10' cy='10' r='5.9' style='fill:rgba(255,255,255,1);'/>\n						<path style='fill:rgba(0,0,0,0.7);' d='M4 10a6 6 0 1 0 12 0 6 6 0 1 0-12 0m5-3a1 1 0 1 0 2 0 1 1 0 1 0-2 0m0 3a1 1 0 1 1 2 0v3a1 1 0 1 1-2 0'/>\n					</svg>";
var By = { custom: [], position: "bottom-right", feedback: true };
var Nh = class {
  constructor(t3) {
    t(this, "controlContainerEl");
    t(this, "controlPositions");
    t(this, "compact");
    t(this, "attribContainerEl");
    t(this, "attribInnerEl");
    t(this, "attribButtonEl");
    t(this, "feedbackLinkEl");
    t(this, "attribHTML", bS);
    t(this, "customAttributions", []);
    t(this, "toggleAttribution", (t4) => {
      this.attribContainerEl != null && (t4.preventDefault(), this.attribContainerEl.classList.contains("mappedin-compact") && (this.attribContainerEl.classList.contains("mappedin-compact-show") ? (this.attribContainerEl.removeAttribute("open"), this.attribContainerEl.classList.remove("mappedin-compact-show")) : (this.attribContainerEl.classList.add("mappedin-compact-show"), this.attribContainerEl.setAttribute("open", ""))));
    });
    this.controlContainerEl = document.createElement("div"), this.controlContainerEl.classList.add("mappedin-control-container"), t3.appendChild(this.controlContainerEl), this.controlPositions = _y.reduce((e2, i) => {
      let o = document.createElement("div");
      return o.classList.add("mappedin-ctrl-".concat(i)), this.controlContainerEl.appendChild(o), e2[i] = o, e2;
    }, {});
  }
  addAttributionControl(t3 = By) {
    var o;
    let e2 = t3.position && _y.includes(t3.position) ? t3.position : By.position;
    this.attribContainerEl = document.createElement("details"), this.attribContainerEl.classList.add("mappedin-ctrl-attrib", "mappedin-ctrl-attrib-".concat(e2)), this.attribContainerEl.open = true, this.attribContainerEl.tabIndex = 0, this.attribContainerEl.ariaLabel = "Attribution", this.controlPositions[e2].appendChild(this.attribContainerEl), this.attribButtonEl = document.createElement("summary"), this.attribButtonEl.addEventListener("click", this.toggleAttribution), this.attribButtonEl.classList.add("mappedin-ctrl-attrib-button"), this.attribButtonEl.title = "Toggle attribution", this.attribButtonEl.ariaLabel = "Toggle attribution", this.attribButtonEl.tabIndex = 0, this.attribButtonEl.innerHTML = uw(), this.attribContainerEl.appendChild(this.attribButtonEl), this.attribInnerEl = document.createElement("div"), this.attribInnerEl.classList.add("mappedin-ctrl-attrib-inner"), this.attribInnerEl.innerHTML = this.attribHTML, this.attribContainerEl.appendChild(this.attribInnerEl), ((o = t3.feedback) != null ? o : By.feedback) && (this.feedbackLinkEl = document.createElement("a"), this.feedbackLinkEl.href = cw, this.feedbackLinkEl.target = "_blank", this.feedbackLinkEl.rel = "noopener", this.feedbackLinkEl.textContent = "Provide Feedback", this.feedbackLinkEl.classList.add("mappedin-ctrl-attrib-inner"), this.feedbackLinkEl.classList.add("mappedin-ctrl-attrib-inner-bold"), this.attribContainerEl.appendChild(this.feedbackLinkEl)), t3.custom && (this.customAttributions = t3.custom), this.updateAttributionDisplay();
  }
  updateAttribution(t3) {
    if (!t3.style || !this.attribInnerEl || !this.attribContainerEl) return;
    let e2 = [bS], i = t3.style.sourceCaches;
    for (let o in i) {
      let n = i[o];
      if (n.used || n.usedForTerrain) {
        let s2 = n.getSource();
        s2.attribution && e2.indexOf(s2.attribution) < 0 && e2.push(s2.attribution);
      }
    }
    e2 = e2.filter((o) => String(o).trim()), e2 = e2.filter((o, n) => {
      for (let s2 = n + 1; s2 < e2.length; s2++) if (e2[s2].indexOf(o) >= 0) return false;
      return true;
    }), this.attribHTML = e2.join(" "), this.updateAttributionDisplay();
  }
  updateAttributionDisplay() {
    let t3 = [.../* @__PURE__ */ new Set([this.attribHTML, ...this.customAttributions])].filter(Boolean).join(" ");
    this.attribInnerEl && (this.attribInnerEl.innerHTML = t3);
  }
  resizeAttribution(t3) {
    this.attribContainerEl && (t3 <= pw || this.compact ? this.compact === false ? this.attribContainerEl.setAttribute("open", "") : !this.attribContainerEl.classList.contains("mappedin-compact") && !this.attribContainerEl.classList.contains("mappedin-attrib-empty") && (this.attribContainerEl.setAttribute("open", ""), this.attribContainerEl.classList.add("mappedin-compact", "mappedin-compact-show")) : (this.attribContainerEl.setAttribute("open", ""), this.attribContainerEl.classList.contains("mappedin-compact") && this.attribContainerEl.classList.remove("mappedin-compact", "mappedin-compact-show")));
  }
  destroyAttributionControl() {
    this.attribButtonEl && this.attribButtonEl.removeEventListener("click", this.toggleAttribution), this.attribContainerEl && (this.attribContainerEl.remove(), this.attribContainerEl = void 0, this.attribInnerEl = void 0, this.attribButtonEl = void 0);
  }
  resize(t3) {
    this.resizeAttribution(t3);
  }
  updateData(t3) {
    this.updateAttribution(t3);
  }
  destroy() {
    this.destroyAttributionControl(), this.controlContainerEl.remove(), this.compact = void 0;
  }
};
c();
var Wc;
var Es = class {
  constructor(t3, e2) {
    t(this, "mesh");
    t(this, "type", "custom-geometry");
    t(this, "dirty", true);
    t(this, "feature");
    t(this, "builder");
    t(this, "outline");
    t(this, "color", new Nt());
    v(this, Wc, 0);
    this.mesh = new Er(), this.feature = t3, this.builder = e2;
  }
  get visible() {
    return this.mesh.visible;
  }
  set visible(t3) {
    this.mesh.visible = t3;
  }
  set opacity(t3) {
    Lt.warn("TODO: implement custom geometry opacity");
  }
  get opacity() {
    return Lt.warn("TODO: implement custom geometry opacity"), 0;
  }
  setColor() {
  }
  get position() {
    var t3;
    return (t3 = this.mesh) == null ? void 0 : t3.position;
  }
  get altitude() {
    return u(this, Wc);
  }
  set altitude(t3) {
    this.mesh && (this.mesh.position.z = t3, w(this, Wc, t3));
  }
  get renderOrder() {
    return Lt.warn("TODO: implement custom geometry opacity"), -1;
  }
  set renderOrder(t3) {
    Lt.warn("TODO: implement custom geometry render order");
  }
};
Wc = /* @__PURE__ */ new WeakMap();
c();
var Gh = class {
  constructor(t3, e2) {
    t(this, "state");
    t(this, "convertTo3DMapPosition");
    this.state = t3, this.convertTo3DMapPosition = e2;
  }
  update() {
    let t3, e2;
    for (let i of this.state.geometry3DIdsInScene) {
      let o = this.state.geometry3DMap.get(i);
      (o == null ? void 0 : o.type) === "custom-geometry" && (t3 = o.components[0], e2 = o.components[1], t3.dirty && e2.visible !== false && (t3.position.copy(this.convertTo3DMapPosition(t3.feature.geometry.coordinates[1], t3.feature.geometry.coordinates[0], e2.altitude)), t3.builder.setup(t3.mesh), t3.mesh.traverse((n) => {
        n.userData = { entityId: i, type: "custom-geometry" };
      }), t3.dirty = false), e2.visible !== false && t3.builder.update(t3.mesh));
    }
  }
};
c();
c();
var Vh = class extends ve {
  constructor() {
    super(...arguments);
    t(this, "userData", { entityId: "" });
  }
};
var dw = K.object({ flipImageToFaceCamera: K.boolean().optional(), url: K.string() });
var hw = K.object({ type: K.enum(["Feature"]), properties: K.object({ width: K.number(), height: K.number(), rotation: K.number().min(0).max(360).optional(), verticalOffset: K.number().optional() }), geometry: Ps2 });
function vS(r3, t3, e2) {
  K.union([K.number(), K.string()]).parse(r3), hw.parse(t3), dw.parse(e2);
}
var jh = class {
  constructor(t3) {
    t(this, "mesh", new Er());
    t(this, "imageMesh");
    t(this, "outline");
    t(this, "type", "image");
    t(this, "instanceIndex", -1);
    t(this, "geometry");
    t(this, "material");
    t(this, "feature");
    t(this, "position", new R());
    this.feature = t3;
  }
  get visible() {
    var t3, e2;
    return (e2 = (t3 = this.mesh) == null ? void 0 : t3.visible) != null ? e2 : false;
  }
  set visible(t3) {
    this.mesh && (this.mesh.visible = t3);
  }
};
c();
function Ry(r3, t3) {
  return { x: r3.x * Math.cos(t3) - r3.y * Math.sin(t3), y: r3.x * Math.sin(t3) + r3.y * Math.cos(t3) };
}
function fw(r3, t3) {
  return r3.map((e2) => Ry(e2, t3));
}
function mw(r3) {
  let t3 = 1 / 0, e2 = 1 / 0, i = -1 / 0, o = -1 / 0;
  for (let n of r3) t3 = Math.min(t3, n.x), e2 = Math.min(e2, n.y), i = Math.max(i, n.x), o = Math.max(o, n.y);
  return { minX: t3, minY: e2, maxX: i, maxY: o };
}
function gw(r3, t3) {
  let e2 = false;
  for (let i = 0, o = t3.length - 1; i < t3.length; o = i++) {
    let n = t3[i].x, s2 = t3[i].y, c2 = t3[o].x, l = t3[o].y;
    s2 > r3.y != l > r3.y && r3.x < (c2 - n) * (r3.y - s2) / (l - s2) + n && (e2 = !e2);
  }
  return e2;
}
function CS(r3, t3, e2, i, o) {
  for (let n = 0; n < o; n++) for (let s2 = 0; s2 < i; s2++) if (r3[e2 + n][t3 + s2] !== 1) return false;
  return true;
}
function yw(r3, t3, e2) {
  let i = r3.maxX - r3.minX, o = r3.maxY - r3.minY, n, s2, c2 = { ...r3 };
  return i / o > t3 ? (s2 = o / e2, n = s2 * t3, c2.minX += (i - n * e2) / 2) : (n = i / e2, s2 = n / t3, c2.minY += (o - s2 * e2) / 2), { dx: n, dy: s2, gridBounds: c2 };
}
function bw(r3, t3, e2, i, o) {
  let n = Array(e2).fill(0).map(() => Array(e2).fill(0));
  for (let s2 = 0; s2 < e2; s2++) for (let c2 = 0; c2 < e2; c2++) {
    let l = { x: t3.minX + c2 * i, y: t3.minY + s2 * o };
    gw(l, r3) && (n[s2][c2] = 1);
  }
  return n;
}
function vw(r3, t3) {
  let e2 = Array(t3).fill(0).map(() => Array(t3).fill(0));
  for (let i = 0; i < t3; i++) for (let o = 0; o < t3; o++) if (r3[i][o] === 1) {
    let n = 0;
    for (let s2 = 1; s2 <= Math.min(t3 - o, t3 - i) && CS(r3, o, i, s2, s2); s2++) n = s2;
    e2[i][o] = n;
  }
  return e2;
}
function Cw(r3, t3, e2, i, o, n) {
  let s2 = 0, c2 = 0, l = 0;
  for (let p = 0; p < i; p++) for (let d = 0; d < i; d++) if (r3[p][d] === 1) {
    let f = Math.pow(t3[p][d], 2), g = e2.minX + d * o, v2 = e2.minY + p * n;
    s2 += f, c2 += g * f, l += v2 * f;
  }
  return { x: c2 / s2, y: l / s2 };
}
function Sw(r3, t3, e2, i, o, n, s2) {
  let c2 = -1 / 0, l = null, p = r3.length, d = Math.sqrt(Math.pow(t3.maxX - t3.minX, 2) + Math.pow(t3.maxY - t3.minY, 2));
  for (let f = 0; f < p; f++) for (let g = 0; g < p; g++) if (r3[f][g] === 1) for (let v2 = 1; v2 <= p - g; v2++) {
    let b = v2;
    if (!(b > p - f) && CS(r3, g, f, v2, b)) {
      let C = v2 * b, y = t3.minX + (g + v2 / 2) * e2, S = t3.minY + (f + b / 2) * i, T = { x: y, y: S }, M2 = Math.sqrt(Math.pow(T.x - o.x, 2) + Math.pow(T.y - o.y, 2)) / d, D = C * (1 - n) - M2 * n * C;
      D > c2 && (c2 = D, l = { center: T, width: v2 * e2 * s2, height: v2 * i * s2 });
    }
  }
  return l;
}
function Ny(r3, t3, e2, i = {}) {
  let { scaleFactor: o = 0.9, centerPriority: n = 0.5, resolution: s2 = 100, minimumSizeRatio: c2 = 0.5 } = i, l = Jt2(e2), p = r3.width / r3.height, d = fw(t3, l), f = mw(d), { dx: g, dy: v2, gridBounds: b } = yw(f, p, s2), C = bw(d, b, s2, g, v2), y = vw(C, s2), S = Cw(C, y, b, s2, g, v2), T = Sw(C, b, g, v2, S, n, o);
  return !T || T.width < r3.width * c2 || T.height < r3.height * c2 ? r3 : { ...T, center: Ry(T.center, -l), rotation: e2, polygonCenter: Ry(S, -l) };
}
var Xc = Math.PI * 2;
var xw = Math.PI / 2;
var Iw = Math.PI * 1.5;
var Pw = jp(xw, 2);
var Mw = jp(Iw, 2);
var Tw = 0.01;
var SS = false;
var Uh = class extends _n {
  constructor(e2, i, o = 0, n = 0, s2 = {}) {
    super();
    t(this, "rendererState");
    t(this, "convertTo3DMapPosition");
    t(this, "initialBearing", 0);
    t(this, "naturalBearing", 0);
    t(this, "imagePlacementOptions");
    t(this, "imageLoadingCache", /* @__PURE__ */ new Map());
    this.rendererState = e2, this.convertTo3DMapPosition = i, this.initialBearing = o, this.naturalBearing = n, this.imagePlacementOptions = s2;
  }
  createImageMesh(e2, i, o, n = 0, s2, c2) {
    var b, C, y;
    let l = { width: o.width, height: o.height, center: this.convertTo3DMapPosition(s2), rotation: (b = o.rotation) != null ? b : 0 }, p = (C = this.imagePlacementOptions.mode) != null ? C : "default", d = (() => {
      switch (p) {
        case "fit-nearest-90":
          let S = (this.initialBearing - this.naturalBearing + 360) % 180;
          return S >= 45 && S <= 135 ? Ny(l, c2, l.rotation + 90, this.imagePlacementOptions) : l;
        case "fit-initial-bearing":
          return Ny(l, c2, this.initialBearing, this.imagePlacementOptions);
        case "default":
        case "none":
        default:
          return l;
      }
    })();
    if (SS && d.polygonCenter) {
      let S = new ve(new rl(1), new ll({ color: 65280 }));
      S.position.set(d.polygonCenter.x, d.polygonCenter.y, n), this.rendererState.entityScene.add(S);
    }
    let f = new ll({ transparent: true, depthWrite: false, side: ln }), g = new Ps(d.width, d.height), v2 = new Vh(g);
    if (v2.visible = false, (y = this.getOrDownloadImage(i)) == null || y.then((S) => {
      f.map = S, f.needsUpdate = true, f.map.colorSpace = ke, v2.visible = true, this.publish("image-loaded");
    }), v2.userData.entityId = e2, v2.material = f, SS) {
      let S = new ve(new Ps(o.width, o.height), new ll({ color: "gray" }));
      v2.add(S);
      let T = new Cl();
      v2.add(T), T.scale.set(10, 10, 10);
    }
    return v2.position.set(d.center.x, d.center.y, n + Tw), v2.rotation.z = (-md.degToRad(d.rotation) + Xc) % Xc, v2;
  }
  getOrDownloadImage(e2) {
    var i;
    if (this.imageLoadingCache.has(e2)) return (i = this.imageLoadingCache.get(e2)) == null ? void 0 : i.promise;
    {
      let o = new Promise((n) => {
        jo.getLoader().load(e2, (s2) => {
          let c2 = this.imageLoadingCache.get(e2);
          c2 && !c2.loaded && (c2.loaded = true), n(s2);
        });
      });
      return this.imageLoadingCache.set(e2, { loaded: false, promise: o }), o;
    }
  }
  flipIfNeeded(e2, i) {
    if (e2.imageMesh == null) return;
    let o = -i, n = e2.imageMesh.rotation.z, s2 = jp((n - o + Xc) % Xc, 2);
    s2 > Pw && s2 < Mw && (e2.imageMesh.rotation.z = (n + Math.PI) % Xc);
  }
  update(e2) {
    var s2, c2, l, p, d;
    let i, o, n;
    for (let f of this.rendererState.geometry3DIdsInScene) if (i = this.rendererState.geometry3DMap.get(f), (i == null ? void 0 : i.type) === "image") {
      if (o = i.components[0], n = i.components[1], n.url && o.imageMesh == null) {
        let g = this.convertTo3DMapPosition(o.feature.geometry.coordinates), v2 = { x: g.x, y: g.y };
        o.imageMesh = this.createImageMesh(i.id, n.url, o.feature.properties, o.feature.properties.verticalOffset, o.feature.geometry.coordinates, [v2]), o.mesh.add(o.imageMesh), o.position.copy(o.imageMesh.position);
      }
      o.imageMesh && n.flipImageToFaceCamera && this.flipIfNeeded(o, e2);
    } else if ((i == null ? void 0 : i.type) === "geometry") {
      if (o = i.components[0], n = i.components[1], n.showImage && ((s2 = o.feature.properties) != null && s2.image) && o.imageMesh == null && o.visible && o.mesh != null && o.mesh.parent != null && ((c2 = o.feature.properties) == null ? void 0 : c2.image.position) != null && o.feature.geometry.coordinates != null && o.feature.geometry.coordinates.length > 0) {
        let g = o.feature.geometry.coordinates[0].map((b) => {
          let C = this.convertTo3DMapPosition(b);
          return { x: C.x, y: C.y };
        }), v2 = this.createImageMesh(f, (l = o.feature.properties) == null ? void 0 : l.image.path, (p = o.feature.properties) == null ? void 0 : p.image, n.height, (d = o.feature.properties) == null ? void 0 : d.image.position, g);
        o.mesh.parent.add(v2), o.imageMesh = v2;
      }
      if (o.imageMesh) {
        if (!o.visible) o.imageMesh.visible = false;
        else if (n.showImage && !o.imageMesh.visible) if (n.url) {
          let g = this.imageLoadingCache.get(n.url);
          g && g.loaded && (o.imageMesh.visible = true);
        } else o.imageMesh.visible = true;
        else !n.showImage && o.imageMesh.visible && (o.imageMesh.visible = false);
        n.flipImageToFaceCamera && this.flipIfNeeded(o, e2);
      }
    }
  }
};
c();
var ww = 250;
var Wo;
var Hh = class extends _n {
  constructor(e2, i) {
    super();
    t(this, "cameraDirty", true);
    t(this, "focusablesDirty", true);
    t(this, "state");
    t(this, "camera");
    t(this, "debugEl", null);
    t(this, "raycasters", []);
    t(this, "collisions", /* @__PURE__ */ new Map());
    t(this, "focusableEntities", /* @__PURE__ */ new Set());
    t(this, "debugRaycasters", false);
    v(this, Wo);
    t(this, "update", (e3 = false, i2 = Date.now()) => {
      e3 || Date.now() - i2 > ww || (u(this, Wo) && cancelAnimationFrame(u(this, Wo)), w(this, Wo, requestAnimationFrame(() => {
        this.updateRaf();
      })));
    });
    this.state = e2, this.camera = i, this.buildRaycasters();
  }
  resize() {
    this.buildRaycasters();
  }
  buildRaycasters() {
    this.debugEl && this.debugEl.remove();
    let e2 = new at(this.state.canvasWidth / 2, this.state.canvasHeight / 2), i = new at(e2.x / 1.2, e2.y / 1.2), o = new at(e2.x + (e2.x - i.x), i.y), n = new at(i.x, e2.y + (e2.y - i.y)), s2 = new at(o.x, n.y), c2 = new at(e2.x, e2.y / 1.5), l = new at(e2.x, e2.y + (e2.y - c2.y));
    this.debugEl = document.createElement("div"), Object.assign(this.debugEl.style, { position: "absolute", top: "0", left: "0", width: "100%", height: "100%", pointerEvents: "none" }), document.body.append(this.debugEl), this.raycasters = [e2, c2, l, i, o, n, s2].map((p, d) => {
      if (this.debugRaycasters) {
        let C = document.createElement("div");
        C.style.position = "absolute", C.style.top = p.y + "px", C.style.left = p.x + "px", C.style.width = "10px", C.style.height = "10px", C.style.backgroundColor = "red", this.debugEl.append(C);
      }
      let f = p.x / this.state.canvasWidth * 2 - 1, g = -(p.y / this.state.canvasHeight) * 2 + 1, v2 = new at(f, g), b = new Tl();
      return b.setFromCamera(v2, this.camera), [b, v2, d === 0 ? 10 : d < 7 ? 2 : 1];
    });
  }
  updateFocusableEntities() {
    this.focusableEntities.clear();
    let e2, i;
    for (let o of this.state.geometry3DIdsInScene) if (i = this.state.geometry3DMap.get(o), i != null && (e2 = i.components[0], e2 instanceof It && e2.focusable && e2.geometry != null)) {
      if (e2.focusMesh == null) {
        let n = new ve(e2.geometry);
        n.userData = { entityId: i.id }, e2.focusMesh = n;
      }
      this.focusableEntities.add(e2.focusMesh);
    }
    this.focusablesDirty = false;
  }
  updateRaf() {
    if (!this.cameraDirty) return;
    if (this.focusablesDirty && this.updateFocusableEntities(), this.focusableEntities.size === 0) {
      this.publish("geometry-in-focus", []);
      return;
    }
    this.collisions.clear();
    for (let [i, o] of this.raycasters) i.setFromCamera(o, this.camera);
    for (let [i, o, n] of this.raycasters) i.intersectObjects(Array.from(this.focusableEntities.values())).forEach((c2) => {
      var l;
      if ((c2 == null ? void 0 : c2.object) != null && "isMesh" in c2.object && (c2 != null && c2.object.isMesh)) {
        let p = c2.object.userData.entityId, d = (l = this.collisions.get(p)) != null ? l : 0;
        this.collisions.set(p, d + n);
      }
    });
    let e2 = Array.from(this.collisions, ([i, o]) => ({ entityId: i, weight: o })).sort((i, o) => o.weight - i.weight).map(({ entityId: i }) => i);
    this.publish("geometry-in-focus", e2), this.cameraDirty = false;
  }
  showRaycasters() {
    this.debugRaycasters = true, this.buildRaycasters();
  }
  hideRaycasters() {
    this.debugRaycasters = false, this.buildRaycasters();
  }
  destroy() {
    u(this, Wo) && cancelAnimationFrame(u(this, Wo)), this.debugEl && this.debugEl.remove(), this.collisions.clear(), this.focusableEntities.clear(), this.raycasters = [];
  }
};
Wo = /* @__PURE__ */ new WeakMap();
c();
c();
c();
c();
function Wh(r3, t3) {
  t3 === void 0 && (t3 = {});
  var e2 = Ha(r3);
  switch (!t3.properties && r3.type === "Feature" && (t3.properties = r3.properties), e2.type) {
    case "Polygon":
      return Dw(e2, t3);
    case "MultiPolygon":
      return Ew(e2, t3);
    default:
      throw new Error("invalid poly");
  }
}
function Dw(r3, t3) {
  t3 === void 0 && (t3 = {});
  var e2 = Ha(r3), i = e2.coordinates, o = t3.properties ? t3.properties : r3.type === "Feature" ? r3.properties : {};
  return xS(i, o);
}
function Ew(r3, t3) {
  t3 === void 0 && (t3 = {});
  var e2 = Ha(r3), i = e2.coordinates, o = t3.properties ? t3.properties : r3.type === "Feature" ? r3.properties : {}, n = [];
  return i.forEach(function(s2) {
    n.push(xS(s2, o));
  }), wm(n);
}
function xS(r3, t3) {
  return r3.length > 1 ? Mm(r3, t3) : el(r3[0], t3);
}
function Ow(r3, t3) {
  var e2 = true;
  return Td(r3, function(i) {
    Td(t3, function(o) {
      if (e2 === false) return false;
      e2 = Lw(i.geometry, o.geometry);
    });
  }), e2;
}
function Lw(r3, t3) {
  switch (r3.type) {
    case "Point":
      switch (t3.type) {
        case "Point":
          return !Bw(r3.coordinates, t3.coordinates);
        case "LineString":
          return !IS(t3, r3);
        case "Polygon":
          return !ki2(r3, t3);
      }
      break;
    case "LineString":
      switch (t3.type) {
        case "Point":
          return !IS(r3, t3);
        case "LineString":
          return !Aw(r3, t3);
        case "Polygon":
          return !PS(t3, r3);
      }
      break;
    case "Polygon":
      switch (t3.type) {
        case "Point":
          return !ki2(t3, r3);
        case "LineString":
          return !PS(r3, t3);
        case "Polygon":
          return !Fw(t3, r3);
      }
  }
  return false;
}
function IS(r3, t3) {
  for (var e2 = 0; e2 < r3.coordinates.length - 1; e2++) if (kw(r3.coordinates[e2], r3.coordinates[e2 + 1], t3.coordinates)) return true;
  return false;
}
function Aw(r3, t3) {
  var e2 = ts(r3, t3);
  return e2.features.length > 0;
}
function PS(r3, t3) {
  for (var e2 = 0, i = t3.coordinates; e2 < i.length; e2++) {
    var o = i[e2];
    if (ki2(o, r3)) return true;
  }
  var n = ts(t3, Wh(r3));
  return n.features.length > 0;
}
function Fw(r3, t3) {
  for (var e2 = 0, i = r3.coordinates[0]; e2 < i.length; e2++) {
    var o = i[e2];
    if (ki2(o, t3)) return true;
  }
  for (var n = 0, s2 = t3.coordinates[0]; n < s2.length; n++) {
    var c2 = s2[n];
    if (ki2(c2, r3)) return true;
  }
  var l = ts(Wh(r3), Wh(t3));
  return l.features.length > 0;
}
function kw(r3, t3, e2) {
  var i = e2[0] - r3[0], o = e2[1] - r3[1], n = t3[0] - r3[0], s2 = t3[1] - r3[1], c2 = i * s2 - o * n;
  return c2 !== 0 ? false : Math.abs(n) >= Math.abs(s2) ? n > 0 ? r3[0] <= e2[0] && e2[0] <= t3[0] : t3[0] <= e2[0] && e2[0] <= r3[0] : s2 > 0 ? r3[1] <= e2[1] && e2[1] <= t3[1] : t3[1] <= e2[1] && e2[1] <= r3[1];
}
function Bw(r3, t3) {
  return r3[0] === t3[0] && r3[1] === t3[1];
}
var MS = Ow;
function Gy(r3, t3) {
  var e2 = false;
  return Td(r3, function(i) {
    Td(t3, function(o) {
      if (e2 === true) return true;
      e2 = !MS(i.geometry, o.geometry);
    });
  }), e2;
}
var Xh = class {
  constructor(t3) {
    t(this, "dirty", true);
    t(this, "map");
    t(this, "stylesheetId", "");
    t(this, "userHiddenLayers", /* @__PURE__ */ new Set());
    t(this, "hiddenLayersInStyle", /* @__PURE__ */ new Set());
    t(this, "centerPoint");
    t(this, "bbox");
    t(this, "polygons");
    t(this, "handleRender", async () => {
      if (!this.map || !this.dirty || !this.hiddenLayersInStyle || this.hiddenLayersInStyle.size === 0) return;
      let t4 = [];
      if (this.centerPoint) {
        let i = this.map.project(this.centerPoint), o = this.map.queryRenderedFeatures(i, { layers: Array.from(this.hiddenLayersInStyle) });
        for (var e2 of o) t4.push(["!=", ["id"], e2.id]);
      } else if (this.bbox && this.polygons) {
        let i = this.map.queryRenderedFeatures([this.map.project([this.bbox[0], this.bbox[1]]), this.map.project([this.bbox[2], this.bbox[3]])], { layers: Array.from(this.hiddenLayersInStyle) });
        if (i.length > 0) {
          for (let o of i) if (o.geometry != null && "coordinates" in o.geometry) {
            let n;
            if (o.geometry.type === "Polygon" ? n = km(o.geometry.coordinates) : o.geometry.type === "MultiPolygon" && (n = Cm(o.geometry.coordinates)), !n) continue;
            for (let s2 of this.polygons) if (Gy(s2, n)) {
              t4.push(["!=", ["id"], o.id]);
              break;
            }
          }
        }
      }
      t4.length > 0 && (this.hiddenLayersInStyle.forEach((i) => {
        this.map.setFilter(i, ["all", ...t4]);
      }), this.dirty = false);
    });
    t(this, "handleStyleChange", (t4) => {
      var e2, i;
      if (this.map && t4 && t4.dataType === "style" && t4.type === "styledata" && this.userHiddenLayers.size > 0) {
        let o = (i = (e2 = t4 == null ? void 0 : t4.style) == null ? void 0 : e2.stylesheet) == null ? void 0 : i.id;
        (!o || o !== this.stylesheetId) && (this.stylesheetId = o, this.filterStylesInMap(), this.dirty = true);
      }
    });
    t3 && (this.map = t3, this.map.on("styledata", this.handleStyleChange), this.map.on("render", this.handleRender));
  }
  hideLayersUnderPoint(t3, e2) {
    this.centerPoint = t3;
    for (let i of e2) this.userHiddenLayers.add(i);
    this.dirty = true, this.filterStylesInMap(), this.handleRender();
  }
  hideLayersIntersectingPolygons(t3, e2, i) {
    this.bbox = t3, this.polygons = e2.reduce((o, n) => {
      if (n.geometry.type === "Polygon") {
        let s2 = km(n.geometry.coordinates);
        o.push(s2);
      } else n.geometry.type === "MultiPolygon" && o.push(...n.geometry.coordinates.map((s2) => km(s2)));
      return o;
    }, []);
    for (let o of i) this.userHiddenLayers.add(o);
    this.dirty = true, this.filterStylesInMap(), this.handleRender();
  }
  filterStylesInMap() {
    if (this.hiddenLayersInStyle = /* @__PURE__ */ new Set(), this.map) for (let t3 of this.userHiddenLayers) this.map.getLayer(t3) && this.hiddenLayersInStyle.add(t3);
  }
  destroy() {
    this.map && (this.map.off("styledata", this.handleStyleChange), this.map.off("render", this.handleRender));
  }
};
c();
c();
c();
var Vy = "attribute float pathDistance;\nattribute vec3 pathNormal;\nattribute vec3 pathTangent;\n\nuniform vec2 uvScale;\nuniform float vertexes;\nuniform float complete;\nuniform float nearRadius;\nuniform float farRadius;\nuniform float nearZoom;\nuniform float farZoom;\nuniform float pulse;\nuniform float pulseLength;\nuniform bool pathIsVertical;\nuniform bool displayArrowsOnPath;\nuniform vec2 cameraParameters;\nuniform float flattenFactor;\n\nvarying float zoomLevel;\nvarying float radius;\nvarying vec2 fragTexcoord;\nvarying float fragTopTextureU;\nvarying float fragPathDistance;\n\n// Map the x value from the range [xMin, xMax] to the range [yMin, yMax] using\n// linear interpolation/extrapolation.\n//\n// This performs a pure linear mapping `y = mx + b` where\n// `m = (yMax - yMin) / (xMax - xMin)`,\n// `b = -xMin * (yMax - yMin) / (xMax - xMin) + yMin`.\nfloat remap(float x, float xMin, float xMax, float yMin, float yMax) {\n	return (x - xMin) / (xMax - xMin) * (yMax - yMin) + yMin;\n}\n\n// Map the x value from [xMin, xMax] to the range [yMin, yMax] using linear\n// interpolation, clamping result values outside [yMin, yMax].\nfloat clampRemap(float x, float xMin, float xMax, float yMin, float yMax) {\n	return clamp(remap(x, xMin, xMax, yMin, yMax), yMin, yMax);\n}\n\nvoid main() {\n	fragPathDistance = pathDistance;\n\n	// We can get an origin point for the cross-section of the path by\n	// subtracting the surface normal times the radius, since the surface normal\n	// points strictly away from the centre.\n	vec3 origin = position - nearRadius * normal;\n\n	// Inflate the path along its surface normal to increase its radius from\n	// `nearRadius` to `farRadius` when the camera is at `farZoom`.\n	vec3 adjustedPosition = position;\n	zoomLevel = clampRemap(cameraParameters.x, nearZoom, farZoom, 0.0, 1.0);\n	adjustedPosition += normal * (farRadius - nearRadius) * zoomLevel;\n\n	// Determine how far the path extends \"up\" or \"down\" in the direction of the\n	// path normal.\n	float height = dot(adjustedPosition - origin, pathNormal);\n\n	// Flatten the bottom half of the path entirely so that it's flat\n	// against the floor. This makes the path look nicer when it's\n	// semitransparent behind opaque geometry, so you don't see it\n	// peeking through.\n	float desiredHeight = max(height, 0.0);\n\n	desiredHeight = desiredHeight * flattenFactor;\n\n	float flattenMagnitude = height - desiredHeight;\n	adjustedPosition = adjustedPosition - pathNormal * flattenMagnitude;\n\n	// Transform the vertices into NDC.\n	vec4 mvPosition = modelViewMatrix * vec4(adjustedPosition, 1.0);\n	gl_Position = projectionMatrix * mvPosition;\n\n	fragTexcoord = uv;\n\n	// Compute a texture coordinate for mapping the arrow texture to the path.\n	// We don't want to use the u-value that Three.js provides, because the\n	// path may end up twisting arbitrarily -- but we want the arrow texture to\n	// always be on the top of the path.\n	vec3 bitangent = cross(normal, pathTangent);\n	fragTopTextureU = -dot(bitangent, pathNormal) * 0.5 + 0.5;\n\n	radius = mix(nearRadius, farRadius, zoomLevel);\n}\n";
var jy2 = '#define ARROW_FADING_POINT 0.15\n\nuniform float complete;\nuniform float nearRadius;\nuniform float farRadius;\nuniform vec2 resolution;\nuniform vec2 cameraParameters;\nuniform vec3 color;\nuniform float pathLength;\nuniform bool showPulse;\nuniform vec3 pulseColor;\nuniform float pulse;\nuniform float pulseLength;\nuniform bool pathIsVertical;\nuniform bool displayArrowsOnPath;\nuniform float arrowAnimationTimer;\nuniform float opacityMultiplier;\nuniform sampler2D arrowTexture;\n\nvarying float zoomLevel;\nvarying float radius;\nvarying vec2 fragTexcoord;\nvarying float fragTopTextureU;\nvarying float fragPathDistance;\n\n// How long the arrow should be, as a factor of `pathRadius`. Since we\'ve\n// mostly flattened the top of the path, values near 2.0 (the diameter)\n// will probably look best.\nconst float arrowLength = 2.0;\n\n// How much of a relative margin the arrow texture should have inside the\n// area laid out for it. Useful to pull the arrow away from the edges of the\n// path, which slope down.\nconst float arrowMargin = 0.1;\n\n// How many arrow-lengths of space should be between arrows on a short path.\nconst float arrowSpacingOnShortPath = 6.0;\n\n// How many arrow-lengths of space should be between arrows on a long path.\nconst float arrowSpacingOnLongPath = 7.5;\n\n// How long a path must be to be considered "long", as a factor of\n// the path radius.\nconst float longPathLength = 200.;\n\n// How long a path must be to be considered "short", as a factor of the\n// path radius.\nconst float shortPathLength = 75.;\n\n// How much of the path\'s length the fade-in should comprise when going from\n// zero opacity to full opacity.\nconst float completeLength = 0.1;\n\n// Map the x value from the range [xMin, xMax] to the range [yMin, yMax] using\n// linear interpolation/extrapolation.\n//\n// This performs a pure linear mapping `y = mx + b` where\n// `m = (yMax - yMin) / (xMax - xMin)`,\n// `b = -xMin * (yMax - yMin) / (xMax - xMin) + yMin`.\nfloat remap(float x, float xMin, float xMax, float yMin, float yMax) {\n	return (x - xMin) / (xMax - xMin) * (yMax - yMin) + yMin;\n}\n\n// Map the x value from [xMin, xMax] to the range [yMin, yMax] using linear\n// interpolation, clamping result values outside [yMin, yMax].\nfloat clampRemap(float x, float xMin, float xMax, float yMin, float yMax) {\n	return clamp(remap(x, xMin, xMax, yMin, yMax), yMin, yMax);\n}\n\nvoid main(void) {\n	// Compute the opacity of the path based on the distance from the current\n	// fragment to the `complete` value as it varies from 0.0 to 1.0.\n	// Fragments that are at the `complete` value or past it will be fully\n	// transparent, while fragments that are at `complete - completeLength`\n	// or before it will be fully opaque. However, we adjust the `complete`\n	// value here so that it overshoots by one full `completeLength`, so that\n	// the entire path will be opaque when the `complete` value is at 1.0.\n	float completeLocation = complete * (1.0 + completeLength);\n	float completeAmount = clampRemap(\n		fragPathDistance,\n		completeLocation - completeLength,\n		completeLocation,\n		0.0,\n		1.0\n	);\n	float opacity = 1.0 - smoothstep(0.0, 1.0, completeAmount);\n\n	// 2020/01/09 Terence Dickson\n	// When we render the background and overlay for the mapbox outdoor context\n	// behind everything else in single-buffer rendering, the fact that the path\n	// writes to the depth buffer means that the background and overlay will not\n	// be drawn behind the path even when the path is still fading in. The effect\n	// is subtle and is only visible in single-buffer rendering so this quick fix\n	// prevents writes to the depth buffer for zero opacity fragments, which gets\n	// rid of the most visually-offensive ghosting.\n	if (opacity <= 0.0) {\n		discard;\n	}\n\n	// Push in the texture coordinates so that they ramp up\n	// at `arrowMargin` instead of at zero; this remapping looks somewhat\n	// like this:\n	// 1 ^        ___\n	//   |       /\n	//   |      /\n	//   |     /\n	//   |    /\n	//   |___/\n	// 0 +---------->\n	//   0   ^      1\n	//       arrowMargin\n	// Making the arrows narrower on the path.\n	float u = fragTopTextureU;\n	u = clamp(\n		u * (1. / (1. - arrowMargin * 2.)) - (1. / (1. - arrowMargin * 2.) - 1.) / 2.,\n		0.0,\n		1.0\n	);\n\n	float arrowSpacing = clampRemap(\n		pathLength,\n		shortPathLength * radius,\n		longPathLength * radius,\n		arrowSpacingOnShortPath,\n		arrowSpacingOnLongPath\n	);\n\n	// Reduce the spacing between arrows when the camera zooms out, as increasing\n	// the path radius will increase the arrow size and thus be able to fit\n	// fewer arrows on in total, and this secondary movement of the arrows\n	// "zooming off" the end of the path is unpleasant\n	float expandAmount = mix(1.0, farRadius / nearRadius, zoomLevel);\n	float effectiveArrowSpacing =\n		arrowSpacing * 1.0 / expandAmount +\n		arrowMargin * 2.0;\n\n	float effectiveArrowLength = arrowLength * radius * (1. - arrowMargin * 2.0);\n\n	// Adjust the slope of the vertical texture coordinate so that it goes\n	// from 0 to 1 along the length of the arrow plus the spacing between\n	// arrows, and adjust its x-intercept so that one arrow moves to the\n	// exact position of the next arrow as `arrowAnimationTimer` goes\n	// from 0 to 1\n	float v = (\n		fragTexcoord.x * (pathLength / effectiveArrowLength)\n		- arrowAnimationTimer * (1. + effectiveArrowSpacing)\n	);\n\n	// Compute a "looping sawtooth" wave for determining the vertical texture\n	// coordinates of the arrow texture, roughly as follows:\n	// 3 ^              /\n	//   |          ___/\n	// 2 |         /\n	//   |     ___/\n	// 1 |    /\n	//   |___/\n	// 0 +--------------->\n	//   0   ^ ^\n	//   ^   |_|\n	//   |   effectiveArrowLength\n	//   |___|\n	//   effectiveArrowSpacing\n	//\n	// This is effectively equivalent to this sort of sawtooth wave:\n	//   ^\n	// 1 |    /    /    /\n	//   |___/ ___/ ___/\n	// 0 +--------------->\n	//\n	// Causing the image of the arrow to repeat, with dead space (the bottom\n	// edge of the texture stretched out) between the arrows at the provided\n	// spacing. The reason why the "looping" design is preferred is because\n	// it takes advantage of WebGL\'s `GL_REPEAT` texture wrapping behaviour\n	// to avoid the discontinuity that can end up causing visual artifacts.\n	if (mod(v, (1. + effectiveArrowSpacing)) < 1.) {\n		v = v - effectiveArrowSpacing * floor(v / (1. + effectiveArrowSpacing));\n	} else {\n		v = ceil(v / (1. + effectiveArrowSpacing));\n	}\n\n	// Use the r-component of the texture to determine whether the arrow covers\n	// this fragment or not\n	vec2 sampleTexcoord = vec2(u, v);\n	float arrowAmount = 0.0;\n	vec3 secondColor = pulseColor;\n\n	if (displayArrowsOnPath) {\n		arrowAmount = texture2D(arrowTexture, sampleTexcoord).r;\n		float delta = 1.0 - abs(fragPathDistance * 2.0 - 1.0);\n		secondColor = mix(color, pulseColor, 1.0 - smoothstep(ARROW_FADING_POINT, 0.0, delta));\n	}\n\n	if (showPulse) {\n		// Add the pulse color to the path by determining how far the current fragment\n		// is from `pulse`\n		float pulseLocation = remap(\n		pulse,\n		0.0,\n		1.0,\n		-pulseLength,\n		1.0 + pulseLength\n		);\n		float pulseDistance = smoothstep(\n		0.0,\n		pulseLength,\n		abs(fragPathDistance - pulseLocation)\n		);\n\n		// Blend the pulse color to the path based on how close this fragment is to\n		// the `pulse` value and whether it\'s covered by an arrow -- but if it\'s\n		// covered by *both*, then we go back to using the regular path color\n		// (making arrows look like "holes" when they\'re overlapping the pulse.)\n		float pulseLevel = abs(1.0 - pulseDistance - arrowAmount);\n\n		gl_FragColor = vec4(mix(color, secondColor, pulseLevel), opacity * opacityMultiplier);\n	} else if (displayArrowsOnPath) {\n		gl_FragColor = vec4(mix(color, pulseColor, arrowAmount), opacity * opacityMultiplier);\n	} else {\n		gl_FragColor = vec4(color, opacity * opacityMultiplier);\n	}\n	#include <colorspace_fragment>\n}';
var TS = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAAAAAB5Gfe6AAAQkHpUWHRSYXcgcHJvZmlsZSB0eXBlIGV4aWYAAHjarZpZciQ7rkT/uYpeAicQ5HI4mr0dvOX3ATOl0li3q3SVJkUqFMEBcHc4IuX2///fcf/hK7cSXRatpZXi+cott9h5U/3j63EMPt+fL1/h+fPdeff6NnJMHNPjD2U/7+qcl183aH6eH+/PO52PN7E+B3qZ+Tlgspkjb57X1edAKT7Oh+fvrj3v6/nNdp7ftd057abHnz78npVgLGG8FF3cKSTPz2oXJFaQWuocCz9D0mhnEu8Tx54k6dexc98F77vY+f48n96HwvnyvKB8iNHzfJCvY3cj9HZF4dfM7/6QZ4j+7deb2J2z6jn7sbueC5Eq7rmpl63cd1w4GCrd2wov5Vt4r/fVeFW2OMnYIpuD13ShhUi0T8hhhR5O2Pc4w2SJOe5IuGOMM6Z7rhL+FudNSrZXOFFJz3KpkqtJ1hKn4+tawp233flmqMy8AlfGwGCBOz693Fcn/+b1OtA5Bt0QfH2NFeuKFnCWYZmzn1xFQsJ5xlRufO/LvcGNf5PYRAblhrmywe7HY4gh4Re20s1z4jrx2fkHNYKu5wCEiLmFxYREBnwJSUIJXmPUEIhjJT+dlceU4yADQSSu4A65SamQnBptbu7RcK+NEh+nkRYSIZBGSQ0EIlk5C/jRXMFQlyTZiUgRlSpNekklFymlaDGN6po0q2hR1apNe001V6mlaq211d5iS0iYtNLUtdpa651JO0N37u5c0fuII408ZJSho442+gQ+M0+ZZeqss82+4koL+q+y1K262uo7bKC085Zdtu662+4HrJ108pFTjp562umvWXtm9X3WwofM/T5r4Zk1y1i+1+mvrHFa9WWIYHIiljMyFnMg42oZANDRcuZryDla5ixnvkVIIZGsBbHkrGAZI4N5hygnvObuV+Z+mzcn+Y/yFr/LnLPU/RuZc5a6Z+Y+5+2LrK1+K0q6CTIWWkx9OggbF+zaY+1Wk/766H46wF8ONFY+O8hBMEc7oc4Vdh+8JsE+PUSrVjr70Zz1+H56PH3o9sRR1ql5Ha8bUMQxpe89Tki8Sb0tE23cw3DcfEo+ugnj2G3WEmononVfoag71pVjR+EmAE53eT5tqYfEHl/7ThMusaI+St0jktFa9gKnreiQqCNpZ2mJdSkbaiK6DrovYR4/JhJfRsx5d5EVZnEIPetHnU5KynJPTSuCPuC0lOuXH7n1DNq7DpUtHbhM5lDA0c2bnDCJoOObMnyj+aPjPwx0yiDUxKKsg35VnRnBEVhonKwK5hOk5NttUrhr2+tMOXkPJb1RZ+iAelYjL2MuO3pGRQ78GdxwOOaTAcJZcewq7ilB1RJCSozUdSEdwVJVb6asiBsHH1Bqgbiv3Cmkkis6ktVnZGRRwMNJjUA3Ao2127YWdhAIblxF51hzMcZsVZc0r0dJo5Liqfn41Q+q193SGhhkMkgaLJRNnEpqBtyVvbcVffIk+LE9QPFBTMTQe0aWkMXMnx3dy5sfHreDE60Ql50E+SqRcmfK16L2p0Ol8JFATu3qASXy7SvmiGW2cdMBxsty44CvtLogfGlv7WkCSV0WId2270EaD5Ym40cs+SAwZuNjPSTywAvEfLmzQhtLDntfCnhl/fNmUNnzyA2g76Zn0SP+c+I6bCC0FONUQ4L50e95dif+DH/m9htQjBEhPPpOjYjmm2ChbfEMIUaYtAIxmWJHlilLU8ZRs9pCsHbDpFaRgZljz2QandjDIBPZDGTuoZW1KdlYh52ALzisKJRNWSQmLAWx8iv9mGttT15bBc2oxd57bZtVF98CYtK3UH22Yd/A7WaKa+ZjNTOXEzNhMJ5kmQOvfzsbxbZALJ2xwGBjX2HFQybhi7kpbA7DVpS3RxMJwFyHwGk5gs6a4lrRHVqhYT0QTJC9UZcC9Yrelkn6yXch68NKNtG7CiU3vf/zMZAYXPWdrR9XZ/ctMV1sJQ2wJEGxzaHs7LmmHIwnUwbwnNAapBY9xhE19DNJW3ua0dDk/AjwITacR0PqZxkbyJ+E5jYbxI84x1TBE+y90hwDCYZIM0tqAKPZfCzFrbH8kYCm3eqQkZ2+2GovcL8Suokyg8yyCJes6dcouSLiNSLb0ETJU+/N/WFsBBSOXBbm9Cwp4CzlOag7ro7R2vC19nSsCPmAjIEMiobFwaoVXhjTU2XMpgEsDH/L3Sx54OCTMUSXI/IIA2V4QcLQpwVz12pInI0bY56pIQ2BSGRLL+yLfZ7JkiimbK+aepsbwRStpokx5gCqe1hjdMAwcINbkk5jmedrNRAG5pUXPe0sZIoXy1h7lSDxApzheg24JeDNtDS1oBDBUC4iWZFilBPhZx0Kqx2lihpbG9q4sYidksCN4yRYhNM4nxfBbTi4E3AT6B3igbvs9Gv8ZkHsIfdlep+2HelEDbkJdNjqZQ90B7k6OIoFfkkPNoY+z0gzACa1f2qcBYxVJpT2QQgS19dKQlbC24S92xiEAFRKB5Uy1qrBgOtwIge55G0kRPfIytGx0tMOrGfrijB2FHOk/TKcMjDTMPeBo4FnXD5cQ8vtdgoAN0yuzZQHQI09wm/5vAB6RHyI9rYKiZ6YWC6rbaiLmDtoaToC1bViXQFNtgWsOfEEKCleC3GWPSfgQWRQWMgw/9FDgvOZrFAT3SmsA3DLbqlsSppQG5QeOjPXavUUkxF/qgLM05vW5o7UakuBqo2ZW8Nj0LB7imVJC9QSA+wd7RPztIUZ80xQZq0ROrc8CSVncWzkTA/RwmunldCPAQKjqVC7bhRuTIv0plbk7gOX4m5OAi2YesYZ0KBQRToG8iv9x8dgGtgECYRBeEU87OxoSc8epu+s7Mq/MN0VbBT19dii7ekO66UZwdAMtoAVQd13J5nwZe98OgGslmVqAGBkeLZNVNVlWpV18qihntXKnBZvrDIVgFpx4q5poLqREOVplMPSpTF2KvjBAzDpprkruXIaaUmUD4Xo2yrGWcYlixKIwRFjl0jPQhKznUXZAoSjlg9c/NwAI4p3Q/w5bCNfhUZS7bGfqesHqKAlyZZxZgNrhGevZXccaqBys4NEqB3Vqfptji9uUrhCL6yXFqxtm0hhLyYU3Tjd8I/HZaWD1oyVjnG5hhpCN5yHSf8BQUZlVNd00OP4M0TK+JSM7iqWi01SinFkCQXWxiZJLqqAHiEt3G3I2WYd46KU9pIJIOkoRQYCcEAAPguHo0Y4k8Hl6SW50MoW0uZU8jJOUghKo38Nl5ZSwsJNAUC2/lFZWkfMjrU8dFrTjHpJnUrLCILQIxINiYdQlDXaE/razQ4jjQluN5jW1Eh/S7yYvI5gigSjdLYU9TiFXAcHjISiLhQd9obb3OQmwY+YqVwiBMCkOGLXaK/ljBShh56c1g0uyIb2lBRKO7ZTAFncw5c5UGjGSy3CsI1Jt2mtruZkfhBZmbR+842Yu1eDiWEl0V6LZcGem6Ct+LW4Wy3oAjyNObazKBHomhJ3HMKEKHgiGksH+Ig1nTidfNMyA+oYHqVFaRGLiQreVLc9GvQgftKjW9cfUSKNYL80rqU7Um2rwqQJR1ai31Wq7vzKJEsFHDj0bAEMUKXgvfD5bWbaLPBTKz1Nk/Fg+GUZvUzFw80CLaKtPAACVAWrismh863FU4IJ0716SXBUNVb/SDMVvZgDt34CXoOq1JKvg0n08gPHTwXBNgD5W8pZZ8E9EVWcv1DZMB2NFysIwkqBSaH5QRmsAHdkHB+UANvLJvFpQKAahSmYTLEd2AFO+5rsqRRU6sVv5IP0wsSPLcWsbC1Y95mte71CUm6RJJWwkg6Q4k+xWMM0ByElJPQ6j2ED5hY42ALpZRytx9RlgQlJLijzhKi5eX5JBSIRGfo9o2xhd/0aWku8OS+4D9ZnovHDQMPaYo4qm2mlZbUnd7pR6oQj29Z2BqJ9n3LRT+MTLu3IR+ZP2TCPh3EDw8H1NHpoT7FibNYU8WHd9ESHcY12aDOQCUBddi4Ucp+4yuzz8ybcCCu1h8zvzXhDN4HYLq1R+U0xzUqg5QSA3iSBgdDouy55Ifx0DaeEhgezxBRGmoEJ6AJitVuzwtKPlUskHgU2F0LS7AFIwW5jPu0RUL7sp+fkNk0ee8P6uXYgl40WM+cdCOW21r13e0ivt0ff/mYcUfrQZWs2BiN6G+MDTGz1BKORmUTNQp9YGSHFxAeTkQrKd6FoVUogyytW25OLy3OpaO5oZCQp46aPzb5LnJiFEIwAKkmbYVYIjzVv3vj7rA6HignEeQAXTAHKDhoD7Uujh0QjtsB6fTP1NzO7T1Nzq4F1GnfHdXCG1Yxjwdtjf+PGRGTzEtEAUCz7KLfTdItLwCXuSOAzVjaZB6LvbUZhYGWmifSZlcMDnGHPd6gPeiK9erhpiw7ZP9ahTrMhFDa1J53m9ri2DloziqGETTcVSppCbTDDjExg6RrZ6cPEzB8XArEjQSB29odrUoLyoS/65RfM9fprGGjlHpbhGgbYD8MtmW1eFcAWX5dbcMHcl8sUI2k+H7GPW9VrArw3G+BefcCrCaAT/N53YLvP26Uy0kMFnDEZz0DJkmQqEOlL7SlKweYhH8gxpYeAYi0f9magqPbMYZuUI6007lSZQoyoGfYQHsNRzHXR3MMINTSMZpq1KD2A5MDJgtMLdRU6R4CEOJcKGiIJ7K6P/vAM6xpECHI8rRHsaEj6smkngAUjXTzrRoSI48ZpHOqgOY5OejKVdpnmiYUChQnVdIPa6ekGqRSRgEO119oDHOiIUQ5ciYVgaF1oG8Udo8WYtD+DEi8D/w8rAJE2k2PoyV0oMtpauxreaFjpujAvxFlwBhjuNqM9P0IfI5iD8Nh8y1kG4igjJkDNkOijnlLhItAd9lhRd670yNRTu95cR/Xuu0c5WO4DEFk5YQAPtLvU4TYPGRh4APPEDNiuuwR6SC21JoFbQBBMr+zJmT32QplNI6p16PbculN/pCX1wAyTWGTeJ774aln0gvQikw7TmkfsNbdQNs0adutYUDqNtGc0RqngUYdhUYuHSL1/eLrgvqDTC5neu++vufRkEgP9D2T64Kg/c4n+s7k3dDr3me8nOr0c72MRNmgF7D4WySPP0YAI/bI4eixwc7K13QiRiL85A8fnSsUj+mvTrsZtVUEQZ6sTpVafW8nYJZyaZS0U+0xIb6et9PhhtoObozQbjKAoDf6eiFgx1UUvpUYj1GweH0MNMrofhynfWn7+KYu7n5r83hN9aqm+6qjcH7dUlgvZVLV3xqq4fbP16qv+eofuTz43eomAqfS7GBAB9zEE31WJ37eVIPtdGN5A8nMYPvvLt8t2/V/6gM19G4g/hIL7UXf9JgbuLRZ+AoW//AzyMxTcWyz8BAruLRZ+AgX3r3y2+mT/PwfiN1DoVI+QT3CZDmvb8022JeYb6HiQPQpPPvboFB+i1MZdcqWZqthHmix6vttw0UAI1z8oEnGwVe++c7JamxslC+8xKJE41XJmug1npz+6CUAKyURd9gSxo+kWxvtZth848GBlws/0SKjYhmbZ9IiV+mcGBSdWHk8sqSr2zz5J7QME/0yD+z4Pe+JuGn1MV/vUyZwOHojWPlmPXgf9CuoeN9UAT+FGwaLg44v3dWe6QpvuL3Ln/p3k/2AgqNDcfwHgqUmIIqn+hwAAAAJiS0dEAACqjSMyAAAACXBIWXMAAAsSAAALEgHS3X78AAAAB3RJTUUH4wYRESAMujenGAAAB9FJREFUeNrtnWlsFVUUx899fS1gUoKioEY+WBRUEohGkUhAKxgEjSgGoRGB4AJCNKAIJBJZJSiyGYMKKkIoLlEUKhUraxFkKUE2kU1aCrRgW2jpg9f29R2/sBTo67v3zL2zvfP73MzM+XU6mf+5504BGIZhGIZhGIZhGIZhGMZGGq3JvSmR62++BXHH7Ylbf9ouRMT99yVq/e0PICIiHumUmPV3PooXOf5EItafXoCXOdUn8ep/pgjrUDY40ervX4JXUTEiocoXL5/FawiNEwlU/6hzeB3hqQljQIwJYT3UzEkQA2JiGOslsiAhDIgZ1RiD6NIEMBD8NIKxyQr6vv7FtdgQa31uILg0ig2zsZmv4//yePUj7rjNv/U3yUEJ/r7Xr/XfvBmlOPKwT+vfhpIUdvdj/Wm7UZpTz/mv/g4HUYGyQb5r/+SjEhXD/VV/j5OoSGisj16LRe9iVCY8xTcGxIulSKBmtk8MiKHlSMIn8ViMqkQivojHgfcuIJ0VAc/XPzmMVljrcQOBmdVojY1NvVx/8mcRtEqeh+NxypJatM6+ezxb/7Io6uBwR4/e/1moicJunvz956A2ip/1Xv3Nt6JGSgd6rf47/0KtlHssHrfZi5rxVDwWDx5C7XgoHotHC9AANbO8YqBXERohMt8bv/8X/kNDRDM9cA+IgWVojhWuNxAYXo4mWePyeBwYHUKz5Lo6HidNvICmybvVxfXPqEbz7Gvr2vrn1KAdHH7IpX//8yNoD8dcGY+TM6NoF26MxzLTL26Mx0majtM4q5ed7yhNulVsd5WAxqset/mGS6/d5CIBLXI62/7I6ZKyzjUC0rIfsP+hE3zkxt9c8vy7tPnJbiKfuyP+Xdn8ZDeuiMei+zF0juWOGyBNv+iMxw4bEBkl6CzOxmPx6ll0mryWDtb/ViU6z17H4rEYG0I3cMiheByYFEZ34Ew8Dn5UjW7BiXisY/rFDfGYmgWCCwcngXto0q08z1YBSUsy3NWgb5Qe2WSjgJRlfdy2RJPcNXm9bQIarexpsP5VdxHjcbMcm2Q3/5P64i71U8k/ELuLNsVjcct2cnST+rGg+Jo4XmhLPBZ376GOfoOkAIB5NWTHxuu/nzj9ElkA8gLgA+pLlvF43IU4/VI9G1QEAHnIPjfVaP1PnqRdVngKqAkActDMa2Hw/u9zijjjNg5UBcBr1FbD3jbG6h9QSruk8ovfyFESABnUWSNT8VgMI06/lF7aBqomAJ4n3m+G4nHgbeJfZfHljcCKAqDHcWo87m2g/gnE53LhlS+lqQqATv9S4/FL2u//qcT2T34XoAuAdvuJBspf11z/LOKbyYG6q4bqAqDVTqKByjFa21/U6ZfdaWBNADTdTDQQnqSv/pRMYjrZevVLCUUAiF+JBqpnaqv/J2I+zb3mxZwkAMTPDq8ep1A3P/1y3ZOEJABgiaPxuOnvxLN/B7oEwELq/sPl1utvSdz8VPsl6BMAn1AbBKut1t96F+3ENXOFTgFiehXRwAZL8Vi0JW5+qppW7+HIAgDGnyca2G4hHouOh2knvTARdAuAkedsj8cinTj9Ujka9AuAV87YHI/F08TNT2eHgQkB0I/aIDhGmuIU/YnnKxkAZgTAU8SGHC0eDyJufiqKfTKrAqBrPtFAiXo8HlFBO1VBA7ebZQHQifhUVo7H4p2QgQeOdQHQbp8t8Tg4idj+2dPgwJIGAdBqhw3xmDz9EuelQ4cASP3DeDwOziW+ecdbldEiACDbcDxOWkBs/8QNHpoEAPXjLNFMmfpv+IZ4+PjRU5cAWGwwHqcQNz/J2NUmAMgjavHjMfEPTGpvvz4BQH1MrzMkoHoW2CsAppEaBFskemQUA+HJYLcAeJfQINgpNVuvbiA0FuwXAG8qNwh2S07WqxqQ/saPXgEwRDGu7W8te2Q1A6XSH0HWLAD6nVa5zoPS9asZKJb/DLZuAdDzhPx1Hu2gkobkDRQq/J8w7QJAfstevuI3+WQN1F39dkAAtP9H7jpPdFVtiMgZOKC0Z9aAAEiT+mrbScLQjIyBXWngtABokRf/kKefonRF4xvYqrjmYEQApG6Md8SyvrS+eDwDG5QbzUYExL3QMxnUlZGGD5wFbhEADQ7YVwyhr401YCD6LbhHACyK3SA4N9TK6mhMA5EvwE0CYF6sBkFopLXl8exYq9/gLgHwYf3x+PxoqwMC9RoIvw9uE1D/gH3VeOsjItnSq9/OCqhvwL5qAoABA5XU28qsAHjj2tW8mukABgzEXP12WgAMvrpBEPkYwICB2KvfjguAvnUH7GvnARgwUGRhEt24gLoD9tGvAAwYKLDyySzzAqDzpQH76CIAAwYOWtqNYoMAaH9xwP57AAMG9ljbj2SHALhjJyLijwAGDGyzuCPNFgGQuhlxpfw1yR94dfAxi5cmojI/lRyx+rtaX9XDhADr2CVABc//JycWwAJYAAtgASyABbAAFsACWAALYAEsgAWwABbAAlgAC2ABLIAFsAAWwAJYAAtgASyABbAAFsACWAALYAEsgAWwABbAAlgAC2ABLIAFsAAWwAJYAAtgASyABbAAFsACWAALYAEsgAWwABbAAlgAC2ABLIAFsAAWwAJYAAtgASyABbAAFsACWIDToH8FyJUWtVWAALedDoFhGIZhGIZhGIZhGIYxyf+YwEMsIhMo/AAAAABJRU5ErkJggg==";
var Gw = new dl();
function wS(r3, t3, e2) {
  let { nearRadius: i, farRadius: o, accentColor: n, completeFraction: s2, isVertical: c2 } = t3, { color: l } = e2, p = true, d = 0, f = 1 / 0, g = t3.displayArrowsOnPath, v2 = !c2, b = true, C = g, y = i / 2 + Vw, S = 0;
  r3[0].z += y;
  for (let ae2 = 1; ae2 < r3.length; ++ae2) {
    r3[ae2].z += y;
    let de2 = r3[ae2].x - r3[ae2 - 1].x, Ue = r3[ae2].z - r3[ae2 - 1].z;
    if (c2) S += Math.sqrt(de2 * de2 + Ue * Ue);
    else {
      let ht = r3[ae2].y - r3[ae2 - 1].y;
      S += Math.sqrt(de2 * de2 + ht * ht + Ue * Ue);
    }
  }
  if (!c2) {
    let ae2 = r3[0], de2 = r3[r3.length - 1];
    r3.push(de2.clone().setZ(de2.z - 0.01)), r3.unshift(ae2.clone().setZ(ae2.z - 0.01));
  }
  let T = new Ae();
  C && (T = Gw.load(TS), T.colorSpace = ke);
  let w2 = new Nt(l), M2 = new Nt(n), D = { vertexes: { type: "f", value: 1 }, resolution: { type: "v2", value: new at(1, 1) }, cameraParameters: { type: "v2", value: new at(d, 0) }, complete: { type: "f", value: p ? 0 : 1 }, color: { type: "c", value: w2 }, pathLength: { type: "f", value: S }, nearRadius: { type: "f", value: i }, farRadius: { type: "f", value: o }, nearZoom: { type: "f", value: d }, farZoom: { type: "f", value: f }, pulseColor: { type: "c", value: M2 }, pulse: { type: "f", value: 0 }, pulseLength: { type: "f", value: 0.075 }, pathIsVertical: { type: "b", value: c2 }, arrowAnimationTimer: { type: "f", value: 0 }, arrowTexture: { type: "t", value: T }, displayArrowsOnPath: { type: "b", value: g }, flattenFactor: { type: "f", value: v2 ? 0.05 : 1 }, showPulse: { type: "b", value: b }, opacityMultiplier: { type: "f", value: 1 } }, F = new Gr(r3);
  F.curveType = "catmullrom", F.tension = 0;
  let A = 30, k = 8, B = A * r3.length, G = new al(F, B, i, k, false), V = new Float32Array(G.attributes.position.count);
  for (let ae2 = r3.length; ae2 < V.length; ae2++) V[ae2] = ae2;
  G.setAttribute("vertexIndex", new xe(V, 1));
  let W = new Float32Array(G.attributes.position.count), $ = new xe(W, 1);
  for (let ae2 = 0; ae2 <= B; ae2++) for (let de2 = 0; de2 <= k; ++de2) $.setX(ae2 * (k + 1) + de2, ae2 / B);
  G.setAttribute("pathDistance", $);
  let U = new Float32Array(G.attributes.normal.count * 3), ie = new xe(U, 3);
  for (let ae2 = 0; ae2 < B; ae2++) {
    let de2 = G.tangents[ae2];
    for (let Ue = 0; Ue <= k; ++Ue) ie.setXYZ(ae2 * (k + 1) + Ue, de2.x, de2.y, de2.z);
  }
  G.setAttribute("pathTangent", ie);
  let Z = new Float32Array(G.attributes.normal.count * 3), Ee2 = new xe(Z, 3);
  for (let ae2 = 0; ae2 < B; ae2++) {
    let de2 = G.tangents[ae2];
    var ue, ge, xe2;
    c2 ? (ue = de2.x * de2.y, ge = -1 + de2.y * de2.y, xe2 = de2.z * de2.y) : (ue = -de2.x * de2.z, ge = -de2.y * de2.z, xe2 = 1 - de2.z * de2.z);
    let Ue = Math.sqrt(ue * ue + ge * ge + xe2 * xe2);
    Ue === 0 && (Ue = 1);
    let ht = ue / Ue, fr = ge / Ue, oo = xe2 / Ue;
    for (let cn2 = 0; cn2 <= k; ++cn2) Ee2.setXYZ(ae2 * (k + 1) + cn2, ht, fr, oo);
  }
  G.setAttribute("pathNormal", Ee2);
  let hr = new nn({ uniforms: D, vertexShader: Vy, fragmentShader: jy2 });
  hr.transparent = true, hr.alphaTest = 0.5, D.resolution.value.x = 1, D.resolution.value.y = 1, D.vertexes.value = V.length, D.arrowTexture.value.wrapS = Cr, D.arrowTexture.value.wrapT = Cr, D.arrowTexture.value.anisotropy = 16, D.complete.value = s2;
  let kt2 = new ve(G, hr), dt = kt2.clone(), nt = { ...D, opacityMultiplier: { type: "f", value: 0.25 } };
  nt.complete.value = 1, dt.material = new nn({ uniforms: nt, vertexShader: Vy, fragmentShader: jy2 }), dt.material.transparent = true, dt.material.alphaTest = 0.5, dt.material.depthWrite = false, dt.material.depthTest = false, dt.renderOrder = 1, nt.resolution.value.x = 1, nt.resolution.value.y = 1, nt.vertexes.value = V.length, nt.arrowTexture.value.wrapS = Cr, nt.arrowTexture.value.wrapT = Cr, nt.arrowTexture.value.anisotropy = 16, nt.complete.value = s2, kt2.userData = dt.userData = t3.mesh.userData;
  let bi = t3.mesh;
  bi.add(kt2), bi.add(dt), G.computeBoundingBox();
  let io = new R();
  return G.boundingBox.getCenter(io), { mesh: bi, material: hr, center: io };
}
var Vw = 0.15;
var Yc = class extends _n {
  constructor(e2, i, o, n) {
    super();
    t(this, "rendererState");
    t(this, "altitudeDirty", true);
    t(this, "convertTo3DMapPosition");
    t(this, "getParentContainer");
    t(this, "convertZoomLevelToAltitude");
    this.rendererState = e2, this.convertTo3DMapPosition = i, this.getParentContainer = o, this.convertZoomLevelToAltitude = n;
  }
  update(e2, i, o) {
    let n, s2 = false;
    for (let c2 of this.rendererState.geometry3DIdsInScene) if (n = this.rendererState.geometry3DMap.get(c2), n && n.type === "path" && n.components[0].type === "path") {
      let l = n.components[0], p = n.components[1], d = l.isVertical && this.altitudeDirty;
      if (!(l instanceof Uo)) continue;
      if (l.dirty || d) {
        if (l.mesh.parent != null) for (let g = l.mesh.children.length - 1; g >= 0; g--) ji(l.mesh.children[0]);
        let f = [];
        if (l.feature.features.forEach((g) => {
          let v2 = g.geometry.coordinates[2] || 0, b;
          if (g.properties.parentId && (b = this.getParentContainer(g.properties.parentId, true), b != null && b.altitude != null && (v2 += b.altitude, l.isVertical = true)), !g.properties.parentId || b != null && b.visible) {
            let C = this.convertTo3DMapPosition(g.geometry.coordinates[1], g.geometry.coordinates[0], v2);
            f.push(C);
          }
        }), f.length > 1) {
          let { mesh: g, material: v2, center: b } = wS(f, l, { color: p.color });
          l.mesh = g, l.material = v2, l.position = b;
        }
        l.dirty && (l.nearZoomLevel != null && (l.nearZoomAltitude = this.convertZoomLevelToAltitude(l.nearZoomLevel)), l.farZoomLevel != null && (l.farZoomAltitude = this.convertZoomLevelToAltitude(l.farZoomLevel))), l.dirty = false;
      }
      p.dirty && (l.mesh.children.forEach((f) => {
        f.material.uniforms.color.value.set(p.color), f.material.needsUpdate = true;
      }), l.mesh.position.z = p.altitude, p.dirty = false), l.material && (l.mesh.children.forEach((f) => {
        var v2, b;
        let g = f.material.uniforms;
        g.nearZoom.value = (v2 = l.nearZoomAltitude) != null ? v2 : e2, g.farZoom.value = (b = l.farZoomAltitude) != null ? b : i, g.cameraParameters.value.x = o, l.materialDirty && (g.nearRadius.value = l.nearRadius, g.displayArrowsOnPath.value = l.displayArrowsOnPath, g.farRadius.value = l.farRadius, g.pulseColor.value.set(l.accentColor), g.complete.value = l.completeFraction), f.material.needsUpdate = true;
      }), l.displayArrowsOnPath && l.animateArrowsOnPath && (l.mesh.children.forEach((f) => {
        f.material.uniforms.arrowAnimationTimer.value = performance.now() / 3e3, f.material.needsUpdate = true;
      }), s2 = true), l.materialDirty = false);
    }
    this.altitudeDirty = false, s2 && this.publish("animate:path");
  }
};
c();
var Qe;
var Os;
var wr;
var Yh = class {
  constructor(t3) {
    t(this, "rendererState");
    t(this, "dirty", false);
    v(this, Qe);
    v(this, Os);
    v(this, wr);
    this.rendererState = t3;
  }
  updateOne(t3) {
    if (t3 instanceof Pt && t3.components[0] instanceof It && t3.components[1] instanceof Go && t3.parentObject3D instanceof pt && (w(this, Qe, t3.components[0]), w(this, wr, t3.components[1]), u(this, Qe).detached && u(this, Qe).dirty && u(this, Qe).geometry != null && u(this, Qe).material != null)) {
      w(this, Os, t3.parentObject3D), u(this, Qe).visible = false;
      let e2 = new Nt(u(this, wr).color), i = new Vn({ color: e2, side: ln, opacity: u(this, wr).opacity || 1, transparent: u(this, wr).opacity !== void 0 ? u(this, wr).opacity < 1 : false }, 1, u(this, Qe).material.repeatYFactor), o = new rr(1, u(this, Qe).geometry.attributes.position.count || 0, 0, i), n = o.addGeometry(u(this, Qe).geometry);
      o.addInstance(n), o.userData = { entities: { 0: t3.id }, detached: true }, u(this, Qe).instanceIndex = n, u(this, Qe).material.setColor(u(this, Qe).instanceIndex, e2, u(this, wr).topColor ? new Nt(u(this, wr).topColor) : e2), u(this, Qe).mesh = o, u(this, Qe).material = i, u(this, Os).add(o), u(this, Qe).dirty = false;
    }
  }
  update() {
    if (!this.dirty) return;
    let t3;
    for (let e2 of this.rendererState.geometry3DIdsInScene) t3 = this.rendererState.geometry3DMap.get(e2), this.updateOne(t3);
    this.dirty = false, this.cleanup();
  }
  cleanup() {
    w(this, Qe, void 0), w(this, Os, void 0), w(this, wr, void 0);
  }
};
Qe = /* @__PURE__ */ new WeakMap(), Os = /* @__PURE__ */ new WeakMap(), wr = /* @__PURE__ */ new WeakMap();
c();
c();
function DS(r3, t3, e2) {
  var i;
  if (r3.geometry != null) {
    let o = t3 || 1e-4, n = o / r3.currentHeight, s2 = o / e2;
    r3.geometry.scale(1, 1, n), r3.material && (r3.material.repeatYFactor = s2), (i = r3.mesh) == null || i.setGeometryAt(r3.instanceIndex, r3.geometry), r3.currentHeight = o;
  }
}
var ra;
var Xo;
var Zh = class {
  constructor(t3) {
    t(this, "rendererState");
    t(this, "dirty", false);
    v(this, ra);
    v(this, Xo);
    this.rendererState = t3;
  }
  updateOne(t3) {
    var e2;
    t3 instanceof Pt && t3.type === "geometry" && ((e2 = t3.components[1]) != null && e2.dirty) && (w(this, ra, t3.components[0]), w(this, Xo, t3.components[1]), t3.type === "geometry" && u(this, Xo).height !== u(this, ra).currentHeight && DS(u(this, ra), u(this, Xo).height, u(this, Xo).initialHeight));
  }
  update() {
    let t3;
    for (let e2 of this.rendererState.geometry3DIdsInScene) t3 = this.rendererState.geometry3DMap.get(e2), this.updateOne(t3);
    this.cleanup();
  }
  cleanup() {
    w(this, ra, void 0), w(this, Xo, void 0);
  }
};
ra = /* @__PURE__ */ new WeakMap(), Xo = /* @__PURE__ */ new WeakMap();
c();
var jw = { showPolygonLabelTextAreaMesh: false, showEnvMap: false };
var zh = class {
  constructor(t3) {
    t(this, "state", jw);
    t(this, "core");
    this.core = t3;
  }
  update(t3) {
    let e2 = {};
    for (let [i, o] of Object.entries(t3)) i in this.state && this.state[i] !== t3[i] && (this.state[i] = o, e2[i] = o);
    this.handleUpdate(e2);
  }
  handleUpdate(t3) {
    t3.showPolygonLabelTextAreaMesh != null && (t3.showPolygonLabelTextAreaMesh ? this.core.getSystems().text3DSystem.showTextAreaMesh() : this.core.getSystems().text3DSystem.hideTextAreaMesh()), t3.showEnvMap && (t3.showEnvMap ? this.core.setEnvironment("basic") : this.core.setEnvironment(false));
  }
};
c();
var Zc = 9;
var Uw = false;
var ES = 0.1;
function Hw(r3, t3, e2) {
  for (let i = 0; i < t3; i++) {
    let o = (e2 & 16711680) >> 16, n = (e2 & 65280) >> 8, s2 = e2 & 255;
    r3[i * 3] = o / 255, r3[i * 3 + 1] = n / 255, r3[i * 3 + 2] = s2 / 255;
  }
}
var qh = class {
  constructor(t3, e2, i) {
    t(this, "state");
    t(this, "renderer");
    t(this, "renderService");
    t(this, "pickingTexture");
    t(this, "pickingMaterial");
    t(this, "pixelBuffer");
    t(this, "width", 0);
    t(this, "height", 0);
    t(this, "scale", 1 / 2);
    t(this, "color", 1);
    t(this, "convertTo3DMapPosition");
    t(this, "destroyed", false);
    t(this, "enabled", false);
    t(this, "backgroundId", 16777215);
    t(this, "resize", () => {
      let t4 = this.state.pixelRatio;
      this.width = Math.floor(this.renderer.domElement.width / t4 * this.scale), this.height = Math.floor(this.renderer.domElement.height / t4 * this.scale), this.pixelBuffer = new Uint8Array(4 * this.width * this.height), this.pickingTexture = new an(this.width, this.height, { format: Pe, type: cn, internalFormat: "RGBA" });
    });
    t(this, "shouldShowByXY", (t4, e3, i2) => {
      if (this.pixelBuffer == null) return false;
      let o = t4 + (this.height - e3 - 1) * this.width, n = this.pixelBuffer[o * 4], s2 = this.pixelBuffer[o * 4 + 1], c2 = this.pixelBuffer[o * 4 + 2], l = n << 16 | s2 << 8 | c2;
      return l === i2 || l === this.backgroundId;
    });
    t(this, "activeOccluders", /* @__PURE__ */ new Set());
    t(this, "update", () => {
      if (!this.enabled || (this.activeOccluders.clear(), this.activeOccluders.add(this.backgroundId), !this.pickingTexture || !this.pixelBuffer)) return;
      let t4, e3;
      for (let o of this.state.geometry3DIdsInScene) {
        let n = this.state.geometry3DMap.get(o);
        if (n && n instanceof mt && n.userData.occluderFeature != null && n.userData.occluderId != null && (this.activeOccluders.add(n.userData.occluderId), n.userData.occluderDirty)) {
          if (t4 = n.userData.occluderFeature, t4.geometry.type === "Polygon") {
            let s2 = dh(t4, this.convertTo3DMapPosition, { color: "white", height: ES });
            e3 = this.createOccluderMesh(s2, n.userData.occluderId), n.add(e3);
          } else if (t4.geometry.type === "MultiPolygon") {
            let s2 = hh(t4, this.convertTo3DMapPosition, { color: "white", height: ES });
            e3 = this.createOccluderMesh(s2, n.userData.occluderId), n == null || n.add(e3);
          }
          n.userData.occluderDirty = false;
        }
      }
      this.renderer.setRenderTarget(this.pickingTexture);
      let i2 = new Nt(this.backgroundId);
      this.renderer.setClearColor(i2), this.renderer.clear(), this.state.cameraObject.layers.disableAll(), this.state.cameraObject.layers.enable(Zc), this.renderer.render(this.state.entityScene.parent, this.state.cameraObject), this.renderer.setRenderTarget(null), this.state.cameraObject.layers.disable(Zc), Uw ? this.renderService.enabledLayers.add(Zc) : this.renderService.enabledLayers.delete(Zc), this.renderer.readRenderTargetPixelsAsync(this.pickingTexture, 0, 0, this.width, this.height, this.pixelBuffer).then(() => {
        if (!this.destroyed) for (let o of this.state.geometry2DIdsInScene) {
          let n = this.state.geometry2DMap.get(o);
          if (n && (n == null ? void 0 : n.occluderId) != null && this.activeOccluders.has(n == null ? void 0 : n.occluderId)) {
            let s2 = n.components[0].projection, c2 = Math.floor(s2.x * this.scale), l = Math.floor(s2.y * this.scale), p = this.shouldShowByXY(c2, l, n.occluderId);
            n.components[0].isOccluded = !p;
          }
        }
      });
    });
    if (this.state = t3, this.convertTo3DMapPosition = e2, (i == null ? void 0 : i.renderer) == null) throw new Error("No Renderer");
    this.renderService = i, this.renderer = i.renderer, this.resize(), this.pickingMaterial = new nn({ glslVersion: Xl, vertexShader: "\n				attribute vec3 color;\n				varying vec3 vColor;\n				void main() {\n					vColor = color;\n					gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n				}\n			", fragmentShader: "\n				varying vec3 vColor;\n				out vec4 fragColor;\n\n				void main() {\n					fragColor = vec4(vColor, 1.0);\n				}\n			" });
  }
  applyId(t3, e2) {
    let i = t3.attributes.position, o = new Float32Array(i.count * 3);
    Hw(o, i.count, e2), t3.setAttribute("color", new xe(o, 3));
  }
  createOccluderMesh(t3, e2) {
    let i = new ve(t3, this.pickingMaterial);
    return i.layers.set(Zc), this.applyId(i.geometry, e2), i.userData.occluderId = e2, i;
  }
  reserveOccluderId() {
    return this.color++, this.color;
  }
  enable() {
    this.enabled = true;
  }
  disable() {
    this.enabled = false;
  }
  destroy() {
    var t3;
    this.destroyed = true, (t3 = this.pickingTexture) == null || t3.dispose(), this.pickingMaterial.dispose(), this.pickingTexture = void 0, this.pixelBuffer = void 0;
  }
};
var OS = new Tl();
var { DEFAULT_PITCH: Yy, DEFAULT_BEARING: Zy, DEFAULT_ZOOM_LEVEL: zy2, DEFAULT_MIN_ZOOM_LEVEL: Ww, DEFAULT_MAX_ZOOM_LEVEL: Xw } = ur2;
var Yw = md.radToDeg(0.6435011087932844);
var Re;
var ke2;
var ia;
var zc;
var Ls;
var Yo2;
var oa;
var As;
var pt2;
var Hy;
var L;
var be;
var Dr;
var Be;
var ci;
var it;
var O;
var qc;
var We;
var Se;
var LS;
var AS;
var FS;
var Zo;
var $c;
var Jc;
var Qc;
var Kc;
var $h;
var ep;
var tp;
var rp2;
var Fs;
var Wy;
var na;
var ip;
var Lt2;
var At;
var Xy;
var ks;
var op2;
var Uy = class extends _n {
  constructor(e2, i = {}) {
    var g, v2, b, C, y, S, T, w2, M2, D, F;
    super();
    v(this, pt2);
    t(this, "options");
    t(this, "container");
    t(this, "Debug");
    v(this, Re);
    v(this, ke2);
    v(this, ia);
    v(this, zc);
    v(this, Ls);
    v(this, Yo2);
    v(this, oa);
    v(this, As);
    t(this, "rendererDomElement");
    v(this, L, { geometry3DMap: /* @__PURE__ */ new Map(), geometry2DMap: /* @__PURE__ */ new Map(), geometry2DIdsInScene: /* @__PURE__ */ new Set(), geometry3DIdsInScene: /* @__PURE__ */ new Set(), entityScene: new mt("__scene"), hoverColor: "#f6efff", text3dHoverColor: "white", insetsPadding: jy, shouldMeasureCanvas: true, pixelRatio: this.resolutionScale, canvasWidth: 0, canvasHeight: 0, tweenGroup: new Iy(), cameraObject: new Ee(), naturalBearing: 0, containerOffset: [0, 0] });
    t(this, "camera");
    v(this, be);
    v(this, Dr);
    v(this, Be);
    v(this, ci);
    v(this, it);
    v(this, O, {});
    v(this, qc, window.matchMedia("screen and (min-resolution: 2dppx)"));
    t(this, "map");
    v(this, We, () => {
      u(this, O).renderSystem.twoDdirty = true;
    });
    v(this, Se, () => {
      u(this, O).renderSystem.threeDdirty = true;
    });
    v(this, Zo, "standalone");
    v(this, $c, (e3) => Math.trunc(e3 * 10) / 10);
    v(this, Jc, () => {
      u(this, O).twoDDrawSystem.dirty = true, x(this, pt2, Hy).call(this, yp()), u(this, O).watermarkSystem.dirty = true, u(this, O).occlusion2DSystem.resize(), this.render();
    });
    v(this, Qc, () => {
      u(this, Kc).call(this);
    });
    v(this, Kc, (e3, i2) => {
      let o2 = e3 != null ? e3 : this.rendererDomElement.clientWidth, n2 = i2 != null ? i2 : this.rendererDomElement.clientHeight;
      if (o2 === 0 || n2 === 0) return;
      u(this, L).canvasWidth = o2, u(this, L).canvasHeight = n2, x(this, pt2, Hy).call(this, yp()), u(this, Fs).call(this), x(this, pt2, FS).call(this), u(this, O).cameraSystem.resize(this.canvasWidth, this.canvasHeight), u(this, O).cameraSystem.dirty = true, u(this, O).watermarkSystem.resize(this.canvasWidth, this.canvasHeight), u(this, O).htmlControlsSystem.resize(this.canvasWidth), u(this, O).geometryInFocusSystem.resize(), u(this, O).occlusion2DSystem.resize();
      let { top: s4, left: c3 } = this.container.getBoundingClientRect();
      u(this, L).containerOffset = [s4, c3], this.publish("resize"), this.render();
    });
    v(this, $h, () => {
      this.renderSync();
    });
    v(this, ep, new R());
    v(this, tp, (e3, i2) => {
      let o2 = this.mode === "standalone" ? u(this, ke2) : this.viewCamera;
      if (u(this, ke2).position.z + this.camera.elevation > i2.z) {
        u(this, ep).copy(i2);
        let n2 = u(this, ep).project(o2), s4 = (n2.x + 1) / 2 * this.canvasWidth - 0 / 2, c3 = (-n2.y + 1) / 2 * this.canvasHeight - 0 / 2, l2 = u(this, $c).call(this, s4), p3 = u(this, $c).call(this, c3);
        e3.x = l2, e3.y = p3;
      } else e3.x = -1e3, e3.y = -1e3;
    });
    v(this, rp2, (e3, i2) => {
      u(this, it).setBufferSize(e3, i2), u(this, ke2).aspect = e3 / i2, u(this, ke2).updateProjectionMatrix(), u(this, ke2).updateMatrixWorld(true), u(this, Ls).x = e3, u(this, Ls).y = i2;
    });
    v(this, Fs, () => {
      var s4;
      let e3 = u(this, L).canvasWidth = this.rendererDomElement.clientWidth, i2 = u(this, L).canvasHeight = this.rendererDomElement.clientHeight, o2 = Math.floor(e3 * this.resolutionScale), n2 = Math.floor(i2 * this.resolutionScale);
      u(this, rp2).call(this, o2, n2), (s4 = this.map) == null || s4.resize(), u(this, L).shouldMeasureCanvas = false;
    });
    t(this, "getParentContainer", (e3, i2 = true) => {
      if (!e3) return i2 ? u(this, L).entityScene : void 0;
      if (typeof e3 == "string" || typeof e3 == "number") {
        let o2 = u(this, L).geometry3DMap.get(e3);
        return o2 instanceof mt ? o2 : (Lt.warn("Parent (".concat(typeof e3 == "object" ? e3.id : e3, ") is not a valid container, adding to scene")), i2 ? u(this, L).entityScene : void 0);
      } else if (e3.type === "group-container") {
        let o2 = u(this, L).geometry3DMap.get(e3.id);
        if (o2 instanceof mt) return o2;
      }
      return i2 ? u(this, L).entityScene : void 0;
    });
    t(this, "showCollisionBoxes", () => {
      u(this, O).collisionSystem.showCollisionBoxes(), this.render();
    });
    t(this, "hideCollisionBoxes", () => {
      u(this, O).collisionSystem.hideCollisionBoxes(), this.render();
    });
    t(this, "projectScreenXYToCoordinate", (e3, i2, o2 = false) => {
      var g2, v3;
      let n2 = u(this, L).containerOffset[0], s4 = u(this, L).containerOffset[1], c3 = (e3 - s4) / u(this, L).canvasWidth * 2 - 1, l2 = -((i2 - n2) / u(this, L).canvasHeight) * 2 + 1, p3 = new at(c3, l2), d2, f3;
      if (o2) OS.setFromCamera(p3, u(this, ke2)), d2 = (g2 = OS.intersectObject(u(this, Yo2), false)[0]) == null ? void 0 : g2.point;
      else {
        let b2 = u(this, O).interactionSystem.getThreeDIntersectsFromXY(p3);
        d2 = (v3 = b2 == null ? void 0 : b2[0]) == null ? void 0 : v3.point, f3 = u(this, O).interactionSystem.getGroupContainerIntersectsFromXY(p3);
      }
      if (d2) return { coordinate: this.convert3DMapPositionToCoordinate(d2), groupContainers: f3 };
    });
    t(this, "projectCoordinateToScreenXY", (e3) => {
      let i2 = this.convertTo3DMapPosition(e3[1], e3[0], e3[2] || 0), o2 = new at();
      return u(this, tp).call(this, o2, i2), { x: o2.x, y: o2.y };
    });
    t(this, "convert3DMapPositionToCoordinate", (e3) => {
      var n2, s4, c3, l2;
      let { lat: i2, lon: o2 } = s0((s4 = (n2 = u(this, L).center) == null ? void 0 : n2[1]) != null ? s4 : 0, (l2 = (c3 = u(this, L).center) == null ? void 0 : c3[0]) != null ? l2 : 0, e3.x, e3.y);
      return [o2, i2, e3.z];
    });
    t(this, "setBackgroundColor", (e3, i2) => {
      u(this, it).setBackgroundColor(e3, i2);
    });
    t(this, "getMetresPerPixel", () => {
      let e3 = this.container.clientWidth, i2 = this.container.clientHeight / 2, o2 = this.projectScreenXYToCoordinate(0, i2, true), n2 = this.projectScreenXYToCoordinate(e3, i2, true);
      return o2 == null || n2 == null ? void 0 : zp(o2.coordinate, n2.coordinate) / e3;
    });
    t(this, "hideOutdoorLayersUnderPoint", (e3, i2) => {
      !this.map || (i2 == null ? void 0 : i2.length) === 0 || (u(this, O).outdoorLayersSystem.hideLayersUnderPoint(e3, i2), this.render());
    });
    t(this, "hideOutdoorLayersIntersectingPolygons", (e3, i2, o2) => {
      u(this, O).outdoorLayersSystem.hideLayersIntersectingPolygons(e3, i2, o2), this.render();
    });
    v(this, na, new si());
    v(this, ip, new kt());
    t(this, "render", () => {
      var e3;
      if (((e3 = u(this, O)) == null ? void 0 : e3.renderSystem) != null) if (this.map && (this.mode === "outdoors-interleaved" || this.mode === "outdoors-overlay")) this.map.triggerRepaint();
      else return u(this, O).renderSystem.update();
    });
    t(this, "renderSync", () => u(this, O).renderSystem.update(true));
    v(this, Lt2, bp(() => {
      this.publish("user-interaction-start", void 0);
    }, 0, true));
    v(this, At, bp(() => {
      this.publish("user-interaction-end", void 0), this.render();
    }, 0, true));
    t(this, "on", (e3, i2) => {
      super.on(e3, i2), ["outdoor-view-loaded", "outdoor-style-loaded"].includes(e3) && this.mode === "standalone" && e.env.NODE_ENV !== "test" && (Lt.warn('"'.concat(e3, '" was subscribed to but outdoor view is disabled. The event has been triggered immediately. Enable outdoor view or remove the listener.')), this.publish(e3));
    });
    t(this, "off", (e3, i2) => {
      super.off(e3, i2);
    });
    t(this, "getCursor", () => u(this, O).interactionSystem.getCursor());
    t(this, "destroy", () => {
      var e3;
      u(this, O) && (u(this, O).cameraSystem.off("user-dolly-start", u(this, Lt2)), u(this, O).cameraSystem.off("user-pan-start", u(this, Lt2)), u(this, O).cameraSystem.off("user-rotate-start", u(this, Lt2)), u(this, O).cameraSystem.off("user-zoom-start", u(this, Lt2)), u(this, O).cameraSystem.off("user-tilt-start", u(this, Lt2)), u(this, O).cameraSystem.off("user-pedestal-start", u(this, Lt2)), u(this, O).cameraSystem.off("user-dolly-end", u(this, At)), u(this, O).cameraSystem.off("user-pan-end", u(this, At)), u(this, O).cameraSystem.off("user-rotate-end", u(this, At)), u(this, O).cameraSystem.off("user-zoom-end", u(this, At)), u(this, O).cameraSystem.off("user-tilt-end", u(this, At)), u(this, O).cameraSystem.off("user-pedestal-end", u(this, At)), u(this, O).renderSystem.off("measure-canvas", u(this, Fs)), u(this, O).meshOptimizationSystem.off("geometry-2d-added", this.render), u(this, O).meshOptimizationSystem.off("model-loaded", this.render), this.remove("__scene"), u(this, We).call(this), u(this, Se).call(this), this.renderSync(), u(this, O).renderSystem.destroy(), u(this, O).cameraSystem.off("change", this.render), u(this, O).pathSystem.off("animate:path", this.render), u(this, O).cameraSystem.dispose(), u(this, O).exporterSystem.destroy(), u(this, O).outdoorLayersSystem.destroy(), u(this, O).drawSystem.destroy(), window.removeEventListener("resize", u(this, Qc), false), u(this, qc).removeEventListener("change", u(this, Jc)), u(this, oa) && u(this, oa).disconnect(), this._subscribers = {}, u(this, it).destroy(), (e3 = u(this, Re)) == null || e3.traverse((i2) => {
        ji(i2), "dispose" in i2 && typeof i2.dispose == "function" && i2.dispose();
      }), w(this, Re, void 0), u(this, O).htmlControlsSystem.destroy(), u(this, O).collisionSystem.destroy(), u(this, O).interactionSystem.destroy(), u(this, O).domMutationSystem.destroy(), u(this, O).geometryInFocusSystem.destroy(), w(this, O, void 0), u(this, Zo) !== "outdoors-overlay" && (this.map && (this.map.transform.getElevation = void 0, this.map.remove()), this.container.contains(this.rendererDomElement) && this.container.removeChild(this.rendererDomElement)), this.container.removeChild(u(this, ci)), this.container.removeChild(u(this, be)), w(this, it, void 0));
    });
    v(this, ks, new R());
    v(this, op2, new R());
    if (u(this, L).naturalBearing = (g = i.naturalBearing) != null ? g : 0, this.convertTo3DMapPosition = this.convertTo3DMapPosition.bind(this), !e2.clientWidth || !e2.clientHeight) throw new Error("[MappedinJS] Container width and height must be greater than 0");
    this.convertTo3DMapPosition = this.convertTo3DMapPosition.bind(this), (i.mode === "outdoors-interleaved" || i.mode === "outdoors-overlay") && i.map && (w(this, Zo, i.mode), this.map = i.map), u(this, L).entityScene.addEventListener("childadded", () => {
      u(this, Se).call(this), u(this, We).call(this);
    }), u(this, L).entityScene.addEventListener("childremoved", () => {
      u(this, Se).call(this), u(this, We).call(this);
    }), u(this, L).geometry3DMap.set(u(this, L).entityScene.userData.entityId, u(this, L).entityScene), i.center && (u(this, L).center = i.center ? [...i.center] : [0, 0]), this.options = i, this.container = e2, x(this, pt2, LS).call(this), x(this, pt2, AS).call(this), u(this, O).htmlControlsSystem = new Nh(this.container), u(this, Zo) !== "outdoors-overlay" && u(this, O).htmlControlsSystem.addAttributionControl(this.options.attribution), window.MappedinDebug || (window.MappedinDebug = {}), e.env.NODE_ENV === "test" && (window.MappedinDebug.mapViewCoreInstance = this), w(this, it, new Kd({ antialias: typeof i.antialias == "boolean" ? i.antialias : true, alpha: false, canvas: this.mode !== "standalone" ? (v2 = i.gl) == null ? void 0 : v2.canvas : void 0, onWebGLContextCreationError: i.onWebGLContextCreationError, onWebGLContextLost: i.onWebGLContextLost, onWebGLContextRestored: (A) => {
      var k;
      (k = i.onWebGLContextRestored) == null || k.call(i, A), u(this, We).call(this), u(this, Se).call(this), this.render();
    }, onWebGLRendererError: i.onWebGLRendererError, backgroundColor: i.backgroundColor || "#ffffff", backgroundAlpha: (b = i.backgroundAlpha) != null ? b : 1 })), w(this, Re, new Ho()), u(this, Re).add(u(this, L).entityScene);
    let o = window.__THREE_DEVTOOLS__;
    e.env.NODE_ENV === "dev" && typeof o < "u" && (o.dispatchEvent(new CustomEvent("observe", { detail: u(this, Re) })), o.dispatchEvent(new CustomEvent("observe", { detail: u(this, it) }))), w(this, ke2, new Ee(Yw, this.aspect, 50, 1e5)), u(this, L).cameraObject = u(this, ke2), w(this, zc, new gs()), u(this, ke2).renderOrder = 999;
    let n = new de();
    n.add(u(this, ke2)), w(this, As, new de()), u(this, As).add(n), u(this, Re).add(u(this, As)), u(this, ke2).updateProjectionMatrix(), u(this, ke2).updateMatrixWorld(true), this.referenceMap = { scale: 1, latitude: 0, longitude: 0, getNorth: () => 0, georeference: [{ target: { x: 0, y: 0 } }, { target: { x: 0, y: 0 } }, { target: { x: 0, y: 0 } }, { target: { x: 0, y: 0 } }] }, this.rendererDomElement = u(this, it).domElement(), w(this, Ls, new at());
    let s2 = new Ps(1e6, 1e6), c2 = new fs({ color: 0, visible: false });
    w(this, Yo2, new ve(s2, c2)), u(this, Yo2).name = "worldPlane", u(this, Re).add(u(this, Yo2)), (C = i.gl) != null && C.canvas || e2.appendChild(this.rendererDomElement), window.addEventListener("resize", u(this, Qc), false), u(this, qc).addEventListener("change", u(this, Jc)), typeof ResizeObserver == "function" && ((y = e.env) == null ? void 0 : y.NODE_ENV) !== "test" && (w(this, oa, new ResizeObserver(Gu((A) => {
      u(this, Kc).call(this, A[0].contentRect.width, A[0].contentRect.height);
    }, 50))), (S = u(this, oa)) == null || S.observe(e2)), e2.classList.add("mappedin-map"), this.rendererDomElement.style.width = (T = globalThis.MappedinDebug) != null && T.TEST_IOS ? "1080px" : "100%", this.rendererDomElement.style.height = (w2 = globalThis.MappedinDebug) != null && w2.TEST_IOS ? "1920px" : "100%", e.env.NODE_ENV === "test" && this.rendererDomElement.setAttribute("data-testid", "mappedin-canvas"), u(this, L).canvasWidth = this.rendererDomElement.clientWidth, u(this, L).canvasHeight = this.rendererDomElement.clientHeight, this.rendererDomElement.style.touchAction = "manipulation";
    let l = this.canvasWidth, p = this.canvasHeight;
    u(this, O).watermarkSystem = new kh(u(this, ke2), u(this, L), i == null ? void 0 : i.watermark), u(this, O).watermarkSystem.on("texture-loaded", this.render), u(this, L).shouldMeasureCanvas = true, u(this, L).pixelRatio = this.resolutionScale, u(this, rp2).call(this, Math.floor(l * this.resolutionScale), Math.floor(p * this.resolutionScale));
    let d = new xl(16777215, 0.3 * Math.PI);
    d.position.set(-150, -150, 350), u(this, Re).add(d);
    let f = new vl(16777215, 0.741 * Math.PI);
    u(this, Re).add(f), u(this, O).cameraSystem = new ea(u(this, ke2), u(this, Re), u(this, it).renderer, u(this, L), { mode: this.mode, canvasHeight: p, canvasWidth: l }), u(this, O).cameraSystem.on("user-dolly-start", u(this, Lt2)), u(this, O).cameraSystem.on("user-pan-start", u(this, Lt2)), u(this, O).cameraSystem.on("user-rotate-start", u(this, Lt2)), u(this, O).cameraSystem.on("user-zoom-start", u(this, Lt2)), u(this, O).cameraSystem.on("user-tilt-start", u(this, Lt2)), u(this, O).cameraSystem.on("user-pedestal-start", u(this, Lt2)), u(this, O).cameraSystem.on("user-dolly-end", u(this, At)), u(this, O).cameraSystem.on("user-pan-end", u(this, At)), u(this, O).cameraSystem.on("user-rotate-end", u(this, At)), u(this, O).cameraSystem.on("user-zoom-end", u(this, At)), u(this, O).cameraSystem.on("user-tilt-end", u(this, At)), u(this, O).cameraSystem.on("user-pedestal-end", u(this, At)), u(this, O).cameraSystem.on("change", () => {
      this.publish("camera-change", this.camera), u(this, O).geometryInFocusSystem && (u(this, O).geometryInFocusSystem.cameraDirty = true), this.render();
    }), u(this, O).pathSystem = new Yc(u(this, L), this.convertTo3DMapPosition, this.getParentContainer, u(this, O).cameraSystem.convertZoomLevelToAltitude), u(this, O).pathSystem.on("animate:path", this.render), u(this, O).panBoundsSystem = new Rh(u(this, L), u(this, O).cameraSystem), u(this, O).panBoundsSystem.on("update", () => {
      let { panBounds: A, fov: k, convertAltitudeToZoomLevel: B } = u(this, O).cameraSystem;
      if (u(this, O).panBoundsSystem.autoMinZoomLevel) {
        if (A.radius <= 0) return;
        let G = Math.min(u(this, L).canvasWidth / u(this, L).canvasHeight, 1), V = k * Math.PI / 180 * G, W = Math.tan(V / 2), { radius: $, center: U } = u(this, O).cameraSystem.panBounds, ie = $ / W, Z = this.getThreeCamera().getWorldPosition(new R()), Ee2 = U.distanceTo(Z), ue = Math.abs(Z.z - U.z), ge = ie * ue / Ee2, xe2 = B(ge);
        m0(xe2, this.camera.minZoomLevel) && this.camera.setMinZoomLevel(xe2);
      }
    }), this.camera = new Fh(this, u(this, O), u(this, L)), this.camera.setZoomLevel((M2 = i.zoomLevel) != null ? M2 : zy2), this.camera.setBearing((D = i.bearing) != null ? D : Zy), this.camera.setPitch((F = i.pitch) != null ? F : Yy), this.camera.setMaxZoomLevel(Xw), this.camera.setMinZoomLevel(Ww), u(this, O).domVisiblitySystem = new gh(u(this, L), u(this, ci)), u(this, O).domMutationSystem = new Ah(u(this, L), u(this, ci)), u(this, O).domMutationSystem.on("dimensions-update", () => {
      u(this, O).collisionSystem.collidersDirty = true, this.render();
    }), u(this, O).domDrawSystem = new Oh(u(this, L)), u(this, O).collisionSystem = new eh(u(this, Dr), u(this, L)), u(this, O).twoDDrawSystem = new bh(u(this, L), u(this, Be), i.transformImageRequest), u(this, O).twoDDrawSystem.on("img:loaded", this.render), u(this, O).interactionSystem = new xc(this.rendererDomElement, u(this, L), u(this, ke2), u(this, Yo2), u(this, O).cameraSystem.isUserInteracting), u(this, O).interactionSystem.on("doubletap-with-onefinger", (A) => {
      var k;
      this.camera.animateTo({ center: (k = this.projectScreenXYToCoordinate(A.clientX, A.clientY)) == null ? void 0 : k.coordinate, zoomLevel: this.camera.zoomLevel + 1, duration: zy, easing: "ease-out" });
    }), u(this, O).interactionSystem.on("singletap-with-twofinger", () => {
      this.camera.animateTo({ zoomLevel: this.camera.zoomLevel - 1, duration: zy, easing: "ease-out" });
    }), u(this, O).interactionSystem.on("hover", this.render), u(this, O).interactionSystem.on("click", (A) => {
      var k, B, G, V, W, $;
      if (((k = A.entity2D) == null ? void 0 : k.id) === "watermark" && typeof u(this, O).watermarkSystem.options.onClick == "function" && u(this, O).watermarkSystem.options.interactive) {
        u(this, O).watermarkSystem.options.onClick();
        return;
      }
      this.publish("click", { coordinate: this.convert3DMapPositionToCoordinate(A.position), geometry: A.entity3D ? [(B = A.entity3D) == null ? void 0 : B.id] : [], paths: ((G = A.entity3D) == null ? void 0 : G.components[0]) instanceof Uo ? [A.entity3D.id] : [], markers: ((V = A.entity2D) == null ? void 0 : V.components[0]) instanceof yl ? [A.entity2D.id] : [], models: ((W = A.entity3D) == null ? void 0 : W.components[0]) instanceof Vo ? [A.entity3D.id] : [], labels: (($ = A.entity2D) == null ? void 0 : $.components[0]) instanceof vl2 ? [A.entity2D.id] : [], containers: Array.isArray(A.groupContainers) ? A.groupContainers.map((U) => U.userData.entityId) : [], pointerEvent: A.pointerEvent });
    }), u(this, O).interactionSystem.on("hover", (A) => {
      var k, B, G, V, W, $;
      A.position && ((k = A.entity2D) == null ? void 0 : k.id) !== "watermark" && this.publish("hover", { coordinate: this.convert3DMapPositionToCoordinate(A.position), geometry: A.entity3D ? [(B = A.entity3D) == null ? void 0 : B.id] : [], paths: ((G = A.entity3D) == null ? void 0 : G.components[0]) instanceof Uo ? [A.entity3D.id] : [], markers: ((V = A.entity2D) == null ? void 0 : V.components[0]) instanceof yl ? [A.entity2D.id] : [], models: ((W = A.entity3D) == null ? void 0 : W.components[0]) instanceof Vo ? [A.entity3D.id] : [], labels: (($ = A.entity2D) == null ? void 0 : $.components[0]) instanceof vl2 ? [A.entity2D.id] : [], containers: Array.isArray(A.groupContainers) ? A.groupContainers.map((U) => U.userData.entityId) : [] });
    }), u(this, O).geometryInFocusSystem = new Hh(u(this, L), u(this, ke2)), u(this, O).geometryInFocusSystem.on("geometry-in-focus", (A) => {
      this.publish("geometry-in-focus", A);
    }), u(this, O).twoDVisiblitySystem = new Ch(u(this, L)), u(this, O).drawSystem = new vh(u(this, L), this.convertTo3DMapPosition), u(this, O).drawSystem.on("texture-loaded", this.render), u(this, O).stackSystem = new xh(u(this, L)), u(this, O).twoDProjectionSystem = new yh(u(this, L), u(this, tp)), u(this, O).exporterSystem = new Ic(u(this, L)), u(this, O).meshOptimizationSystem = new mh(u(this, L), this.convertTo3DMapPosition), u(this, O).meshOptimizationSystem.on("model-loaded", this.render), u(this, O).meshOptimizationSystem.on("geometry-2d-added", this.render), u(this, O).meshDetachmentSystem = new Yh(u(this, L)), u(this, O).meshModificationSystem = new Zh(u(this, L)), u(this, O).customGeometrySystem = new Gh(u(this, L), this.convertTo3DMapPosition), u(this, O).outlineInterpolationSystem = new ca(u(this, L)), u(this, O).renderSystem = new Sh(u(this, it), u(this, L), this.mode, u(this, Re), u(this, ke2), this.viewCamera, u(this, O)), u(this, O).imageSystem = new Uh(u(this, L), this.convertTo3DMapPosition, i.bearing, i.naturalBearing, i.imagePlacementOptions), u(this, O).text3DSystem = new Jl(u(this, L), this.convertTo3DMapPosition), u(this, O).text3DSystem.on("render", this.render), u(this, O).imageSystem.on("image-loaded", this.render), u(this, O).renderSystem.on("pre-render", () => this.publish("pre-render")), u(this, O).renderSystem.on("post-render", () => this.publish("post-render")), u(this, O).renderSystem.on("measure-canvas", u(this, Fs)), u(this, O).outdoorLayersSystem = new Xh(this.map), u(this, O).occlusion2DSystem = new qh(u(this, L), this.convertTo3DMapPosition, u(this, it)), i.occlusionEnabled && u(this, O).occlusion2DSystem.enable(), this.Debug = new zh(this), i.environment !== false && w(this, ia, x(this, pt2, Xy).call(this)), u(this, $h).call(this);
  }
  get viewCamera() {
    return u(this, zc);
  }
  get canvasWidth() {
    return u(this, L).canvasWidth;
  }
  get canvasHeight() {
    return u(this, L).canvasHeight;
  }
  get resolutionScale() {
    var e2, i;
    return (i = (e2 = this.map) == null ? void 0 : e2._getClampedPixelRatio(this.canvasWidth, this.canvasHeight)) != null ? i : yp();
  }
  get aspect() {
    return this.canvasWidth / this.canvasHeight;
  }
  get mode() {
    return u(this, Zo);
  }
  addGroupContainer(e2, i, o) {
    if (!u(this, L).geometry3DMap.has(e2) && !u(this, L).geometry2DMap.has(e2)) {
      let n = new mt(e2);
      n.addEventListener("childadded", () => {
        u(this, Se).call(this), u(this, We).call(this);
      }), n.addEventListener("childremoved", () => {
        u(this, Se).call(this), u(this, We).call(this);
      }), (i == null ? void 0 : i.visible) !== void 0 && (n.visible = i.visible), (i == null ? void 0 : i.altitude) !== void 0 && n.setAltitude(i.altitude), (i == null ? void 0 : i.interactive) !== void 0 && jn(n, i.interactive, u(this, L)), u(this, L).geometry3DMap.set(e2, n);
      let s2 = this.getParentContainer(o);
      s2 instanceof mt && s2.addEntity(n), u(this, Se).call(this), this.render();
    } else Lt.error("Group container with ID '".concat(e2, "' already exists. The group container cannot be added."));
    return { id: e2, type: "group-container" };
  }
  addStackContainer(e2, i, o) {
    if (u(this, L).geometry3DMap.has(e2)) Lt.error("Stack container with ID '".concat(e2, "' already exists. The stack container cannot be added."));
    else {
      let n = new mt(e2);
      n.addEventListener("childadded", () => {
        u(this, Se).call(this), u(this, We).call(this);
      }), n.addEventListener("childremoved", () => {
        u(this, Se).call(this), u(this, We).call(this);
      }), n.components[0] = new Lh(), (i == null ? void 0 : i.visible) !== void 0 && (n.visible = i.visible), u(this, L).geometry3DMap.set(e2, n);
      let s2 = this.getParentContainer(o);
      s2 instanceof mt && s2.addEntity(n);
    }
    return { id: e2, type: "stack-container" };
  }
  addCustomGeometry(e2, i, o, n, s2) {
    if (u(this, L).geometry3DMap.has(e2)) Lt.error("Custom geometry with ID '".concat(e2, "' already exists. The custom geometry cannot be added."));
    else {
      let c2 = new Es(i, o), l = new Pt(c2, new Go(n));
      (n == null ? void 0 : n.interactive) !== void 0 && jn(l, n.interactive, u(this, L)), l.id = e2, c2.mesh.userData = { entityId: e2, type: "custom-geometry" }, u(this, L).geometry3DMap.set(l.id, l);
      let p = this.getParentContainer(s2);
      p instanceof mt && p.addEntity(l), u(this, Se).call(this), this.render();
    }
    return { id: e2, type: "custom-geometry" };
  }
  addGeometryGroup(e2, i, o, n) {
    var s2, c2;
    if (!u(this, L).geometry3DMap.has(e2) && !u(this, L).geometry2DMap.has(e2)) {
      let l = new pt(e2, new Ci(o));
      l.addEventListener("childadded", () => {
        u(this, Se).call(this), u(this, We).call(this);
      }), l.addEventListener("childremoved", () => {
        u(this, Se).call(this), u(this, We).call(this);
      }), l.userData.dirty = true, u(this, L).geometry3DMap.set(e2, l);
      for (let d of i.features) {
        if (d.geometry == null || !["Polygon", "MultiPolygon", "LineString", "MultiLineString"].includes(d.geometry.type)) continue;
        let f = (d == null ? void 0 : d.id) || ((s2 = d == null ? void 0 : d.properties) == null ? void 0 : s2.id) || tt(), { visible: g, ...v2 } = o || { color: Lo }, b = u(this, O).meshOptimizationSystem.createEntityFromFeature(f, d, v2);
        u(this, L).geometry3DMap.set(f, b), l.userData.entities3D.add(f);
      }
      l.setVisible((c2 = o == null ? void 0 : o.visible) != null ? c2 : true), (o == null ? void 0 : o.altitude) != null && l.setAltitude(o.altitude);
      let p = this.getParentContainer(n);
      p instanceof mt && p.addEntity(l), u(this, Se).call(this), this.render();
    } else Lt.error("Geometry group with ID '".concat(e2, "' already exists. The geometry group cannot be added."));
    return u(this, O).outlineInterpolationSystem.dirty = true, { id: e2, type: "geometry-group" };
  }
  addOccluder(e2, i) {
    let o = this.getParentContainer(i), n = u(this, O).occlusion2DSystem.reserveOccluderId();
    return o == null || o.addOccluderFeature(e2, n), n;
  }
  addImage(e2, i, o, n) {
    try {
      vS(e2, i, o);
    } catch (s2) {
      Lt.error(s2);
      return;
    }
    if (!u(this, L).geometry3DMap.has(e2) && !u(this, L).geometry2DMap.has(e2)) {
      let s2 = new jh(i), c2 = new Pt(s2, new Go(o));
      c2.id = e2 || tt(), s2.mesh.userData = { entityId: c2.id, type: "path" }, u(this, L).geometry3DMap.set(c2.id, c2);
      let l = this.getParentContainer(n);
      l instanceof mt && l.addEntity(c2), u(this, Se).call(this), this.render();
    } else Lt.error("Image with ID '".concat(e2, "' already exists. The image cannot be added."));
    return { id: e2, type: "image" };
  }
  addModelGroup(e2, i, o, { parent: n, onComplete: s2 } = {}) {
    var c2, l;
    try {
      K5(e2, i, o);
    } catch (p) {
      Lt.error(p);
      return;
    }
    if (!u(this, L).geometry3DMap.has(e2) && !u(this, L).geometry2DMap.has(e2)) {
      let p = new pt(e2, new Ci(o));
      p.addEventListener("childadded", () => {
        u(this, Se).call(this), u(this, We).call(this);
      }), p.addEventListener("childremoved", () => {
        u(this, Se).call(this), u(this, We).call(this);
      }), u(this, L).geometry3DMap.set(e2, p), p.userData.dirty = true, p.userData.modelURL = o.url;
      for (let f of i.features) {
        let g = f.id || f.properties.id || tt(), v2 = u(this, O).meshOptimizationSystem.createModelFromFeature(g, f, o);
        (f.properties.interactive !== void 0 || o.interactive != null) && jn(v2, (c2 = f.properties.interactive) != null ? c2 : o.interactive, u(this, L)), u(this, L).geometry3DMap.set(g, v2), p.userData.entities3D.add(g);
      }
      let d = this.getParentContainer(n);
      d instanceof mt && d.addEntity(p), u(this, Se).call(this), (l = this.render()) == null || l.then(s2);
    } else Lt.error("Model group with ID '".concat(e2, "' already exists. The model group cannot be added."));
    return { id: e2, type: "geometry-group" };
  }
  addMarker2D(e2, i, o, n) {
    var c2;
    let s2 = o == null ? void 0 : o.id;
    try {
      Og(e2, i, o || {});
    } catch (l) {
      Lt.error(l);
      return;
    }
    if (s2 === void 0 || !u(this, L).geometry2DMap.has(s2) && !u(this, L).geometry3DMap.has(s2)) {
      let l = x(this, pt2, Wy).call(this, e2, new yl(i, o), o == null ? void 0 : o.occluderId, o == null ? void 0 : o.verticalOffset);
      l.id = s2 || String(l.id), s2 = l.id, (o == null ? void 0 : o.interactive) != null && o.interactive !== "pointer-events-auto" && jn(l, o == null ? void 0 : o.interactive, u(this, L)), (c2 = this.getParentContainer(n)) == null || c2.addEntity(l), this.render();
    } else Lt.error("Marker2D with ID '".concat(s2, "' already exists. The marker cannot be added."));
    return { id: s2, type: "marker" };
  }
  addText3D(e2, i, o, n) {
    if (!u(this, L).geometry3DMap.has(e2) && !u(this, L).geometry2DMap.has(e2)) {
      let s2 = new Bi({ ...i, properties: { ...i.properties, id: e2, content: i.properties.text } }), c2 = new Pt(s2, new fa(o == null ? void 0 : o.appearance));
      c2.id = e2, s2.mesh.userData.entityId = e2.toString(), s2.mesh.userData.type = "text3d", u(this, L).geometry3DMap.set(e2, c2);
      let l = this.getParentContainer(n);
      l instanceof mt && l.addEntity(c2), u(this, Se).call(this), this.render();
    } else Lt.error("Text3D with ID '".concat(e2, "' already exists. The text3d cannot be added."));
    return { id: e2, type: "text3d" };
  }
  labelText3D(e2, i, o = {}) {
    var p, d;
    try {
      if (!i || !e2) throw new Error("content and meshGeometryId are required");
      Ov.parse(o);
    } catch (f) {
      Lt.error(f);
      return;
    }
    let n = u(this, L).geometry3DMap.get(e2);
    if ((n == null ? void 0 : n.type) !== "geometry") {
      Lt.error(".labelText3D failed: target incorrect");
      return;
    }
    let s2 = n == null ? void 0 : n.components[0];
    if (!s2.feature.properties.textArea) return;
    if (s2.textEntityId) {
      let f = u(this, L).geometry3DMap.get(s2.textEntityId);
      if ((f == null ? void 0 : f.type) !== "text3d") {
        Lt.error(".labelText3D failed: existing text3d not found");
        return;
      }
      return { id: f.id, type: f.type };
    }
    let c2 = new Bi({ type: "Feature", geometry: { coordinates: (p = s2.feature.properties.textArea) == null ? void 0 : p.position, type: "Point" }, properties: { textArea: s2.feature.properties.textArea, content: i, id: tt() } });
    c2.polygonEntityId = e2;
    let l = new Pt(c2, new fa(o == null ? void 0 : o.appearance));
    return s2.textEntityId = l.id.toString(), c2.mesh.userData.entityId = l.id.toString(), c2.mesh.userData.type = "text3d", u(this, L).geometry3DMap.set(l.id.toString(), l), o.parentId && ((d = this.getParentContainer(o.parentId)) == null || d.addEntity(l)), this.render(), { id: l.id, type: "text3d" };
  }
  addLabel2D(e2, i, o, n) {
    var c2;
    let s2 = o == null ? void 0 : o.id;
    try {
      xg(e2, i, o || {});
    } catch (l) {
      Lt.error(l);
      return;
    }
    if (s2 === void 0 || !u(this, L).geometry2DMap.has(s2) && !u(this, L).geometry3DMap.has(s2)) {
      let l = x(this, pt2, Wy).call(this, e2, new vl2(i, o || {}, u(this, L)), o == null ? void 0 : o.occluderId, o == null ? void 0 : o.verticalOffset);
      l.id = s2 || String(l.id), s2 = l.id, (o == null ? void 0 : o.interactive) != null && jn(l, o == null ? void 0 : o.interactive, u(this, L));
      let p = typeof n == "string" || typeof n == "number" ? u(this, L).geometry3DMap.get(n) : void 0;
      p instanceof Pt ? p.addEntity(l) : (c2 = this.getParentContainer(n)) == null || c2.addEntity(l), u(this, We).call(this), this.render();
    } else Lt.error("Label2D with ID '".concat(s2, "' already exists. The label cannot be added."));
    return { id: s2, type: "label" };
  }
  addPath(e2, i = {}, o) {
    var l;
    try {
      iS(e2, i || {});
    } catch (p) {
      Lt.error(p);
      return;
    }
    let n = new Uo(e2, np(i)), s2 = new Pt(n, new Go({ color: (l = i == null ? void 0 : i.color) != null ? l : "#ff834c" }));
    s2.id = (i == null ? void 0 : i.id) || tt(), n.mesh.userData = { entityId: s2.id, type: "path" }, u(this, L).geometry3DMap.set(s2.id, s2), (i == null ? void 0 : i.interactive) != null && jn(s2, i == null ? void 0 : i.interactive, u(this, L));
    let c2 = this.getParentContainer(o);
    return c2 instanceof mt && c2.addEntity(s2), u(this, Se).call(this), this.render(), { id: s2.id, type: "path" };
  }
  updateWatermark(e2) {
    u(this, O).watermarkSystem.options = e2, u(this, O).watermarkSystem.dirty = true, u(this, O).collisionSystem.collidersDirty = true, this.render();
  }
  remove(e2) {
    var o, n;
    let i;
    if (typeof e2 == "string" || typeof e2 == "number" ? (i = u(this, L).geometry2DMap.get(e2), i == null && (i = u(this, L).geometry3DMap.get(e2))) : typeof e2.id == "string" || typeof e2.id == "number" ? (i = u(this, L).geometry2DMap.get(e2.id), i == null && (i = u(this, L).geometry3DMap.get(e2.id))) : i = e2, i != null) {
      if (i.type === "custom-geometry") u(this, L).geometry3DMap.delete(i.id), i.object3d && ji(i.object3d);
      else if (i.type === "group-container") {
        u(this, L).geometry3DMap.delete(i.userData.entityId);
        for (let s2 of i.childrenIds.values()) this.remove(s2), i.userData.entities2D.delete(s2);
        ji(i);
      } else if (i.type === "geometry-group") {
        u(this, L).geometry3DMap.delete(i.userData.entityId);
        for (let s2 of i.userData.entities3D.values()) this.remove(s2), i.userData.entities3D.delete(s2);
        ji(i);
      } else if (i.type === "geometry" || i.type === "model" || i.type === "path") {
        let s2 = i.components[0];
        if (i.entities2D.size > 0) {
          for (let c2 of i.entities2D.values()) this.remove(c2);
          i.removeAllEntities();
        }
        i.object3d && (((o = i.parentObject3D) == null ? void 0 : o.type) === "geometry-group" && i.parentObject3D.userData.entities3D.delete(i.id), ji(i.object3d)), "outline" in s2 && s2.outline && ji(s2.outline), "focusMesh" in s2 && s2.focusMesh != null && ji(s2.focusMesh), "textMesh" in s2 && s2.textMesh != null && this.remove(s2.textMesh.userData.entityId), u(this, L).geometry3DMap.delete(i.id);
      } else if (i.type === "marker" || i.type === "label") {
        if (((n = i.parentObject3D) == null ? void 0 : n.type) === "geometry-group") {
          let s2 = i.object3d.userData.parentEntityId;
          if (s2) {
            let c2 = u(this, L).geometry3DMap.get(s2);
            c2 instanceof Pt && c2.removeEntity(i);
          }
        }
        i.object3d && ji(i.object3d), i.type === "label" && delete u(this, O).twoDDrawSystem.textCache[i.id], u(this, L).geometry2DMap.delete(i.id);
      } else if (i.type === "image") i.object3d && ji(i.object3d), u(this, L).geometry3DMap.delete(i.id);
      else if (i.type === "text3d") {
        ji(i.object3d);
        let { batchedText: s2, textMesh: c2, polygonEntityId: l } = i.components[0];
        if (c2 && (s2 && s2.removeText(c2), ji(c2)), l) {
          u(this, O).text3DSystem.remove(l);
          let p = u(this, L).geometry3DMap.get(l);
          (p == null ? void 0 : p.type) === "geometry" && (p.components[0].textMesh = void 0, p.components[0].textEntityId = void 0);
        }
        u(this, L).geometry3DMap.delete(i.id);
      }
      u(this, Se).call(this), u(this, We).call(this), this.render();
    }
  }
  getScene() {
    return this.getState("__scene");
  }
  getThreeScene() {
    return u(this, Re);
  }
  getThreeCamera() {
    return u(this, ke2);
  }
  async setEnvironment(e2) {
    if (u(this, Re)) if (e2 === "basic") {
      u(this, ia) || w(this, ia, x(this, pt2, Xy).call(this));
      let i = await u(this, ia);
      u(this, Re).environment = i;
    } else u(this, Re).environment = null;
  }
  getEnvironment() {
    var e2;
    return (e2 = u(this, Re)) != null && e2.environment ? "basic" : false;
  }
  getCurrentSceneGLTF(e2) {
    return u(this, O).exporterSystem.getCurrentSceneGLTF(e2);
  }
  getBoundingArea(e2) {
    (u(this, O).renderSystem.threeDdirty || u(this, O).renderSystem.twoDdirty) && this.renderSync();
    let i = new Ie();
    if (e2 == null) i.setFromObject(u(this, L).entityScene);
    else {
      let o = lu(u(this, L), e2);
      if ((o == null ? void 0 : o.type) === "geometry" && (o == null ? void 0 : o.object3d) != null) {
        let n = o.components[0], s2 = n instanceof It ? n.geometry : void 0;
        n.mesh instanceof Jo && s2 ? (s2.computeBoundingBox(), s2.boundingBox && i.union(s2.boundingBox)) : i.setFromObject(o.object3d);
      } else ((o == null ? void 0 : o.type) === "geometry-group" || (o == null ? void 0 : o.type) === "group-container") && (o == null ? void 0 : o.userData.entityId) != null && i.setFromObject(o);
    }
    if (wu(i)) return vp(i).map(this.convert3DMapPositionToCoordinate);
  }
  getState(e2) {
    var o, n, s2, c2, l, p, d, f, g, v2;
    if (e2 == null) return { type: "map-view", hoverColor: u(this, L).hoverColor, text3dHoverColor: u(this, L).text3dHoverColor };
    let i = lu(u(this, L), e2);
    if ((i == null ? void 0 : i.type) === "custom-geometry") {
      let b = i.components[0], C = i.components[1];
      return { id: i.id, type: "custom-geometry", visible: C.visible, altitude: C.altitude, parent: (o = i.parentObject3D) == null ? void 0 : o.userData.entityId, position: this.convert3DMapPositionToCoordinate(b.position) };
    } else if ((i == null ? void 0 : i.type) === "geometry-group") {
      let b = [];
      for (let y of i.userData.entities3D.values()) {
        let S = this.getState(y);
        ((S == null ? void 0 : S.type) === "geometry" || (S == null ? void 0 : S.type) === "model") && b.push(S);
      }
      let C = i.components[0];
      return { id: i.userData.entityId, type: "geometry-group", visible: i.visible, opacity: C.opacity, color: C.color, initialColor: C.initialColor, height: C.height, altitude: i.altitude, topColor: C.topColor, outline: C.outline, shading: C.shading, texture: C.texture, topTexture: C.topTexture, interactive: Array.from(i.userData.entities3D.values()).map((y) => u(this, L).geometry3DMap.get(y)).every((y) => y && y.components[2] != null), children: Array.from(i.userData.entities3D.values()).map((y) => this.getState(y)).filter(Boolean) };
    } else {
      if ((i == null ? void 0 : i.type) === "group-container") return { id: i.userData.entityId, type: "group-container", visible: i.visible, altitude: i.altitude, opacity: i.opacity, interactive: !!i.components[1], children: Array.from(i.childrenIds.values()).map((b) => this.getState(b)).filter(Boolean) };
      if ((i == null ? void 0 : i.type) === "label") {
        let b = i.components[0], C = i.object3d.parent, y = C == null ? void 0 : C.userData.entityId;
        return { id: i.id, type: "label", text: b.text || "", parent: { id: y, type: C == null ? void 0 : C.type }, position: this.convert3DMapPositionToCoordinate(i.position), enabled: b.enabled, visible: b.visible, initialRank: dg(b.initialRank), options: { rank: dg(b.rank), appearance: b.appearance, interactive: i.components[1] != null, verticalOffset: i.verticalOffset } };
      } else if ((i == null ? void 0 : i.type) === "marker") {
        let b = i.components[0], C = i.object3d.parent, y = C == null ? void 0 : C.userData.entityId;
        return { id: i.id, type: "marker", enabled: b.enabled, visible: b.visible, anchor: b.options.anchor, dynamicResize: b.options.dynamicResize, parent: { id: y, type: C == null ? void 0 : C.type }, position: this.convert3DMapPositionToCoordinate(i.position), element: b.containerEl, initialRank: dg(b.initialRank), options: { rank: dg(b.rank), interactive: i.components[1] != null || false, verticalOffset: i.verticalOffset } };
      } else if ((i == null ? void 0 : i.type) === "geometry") {
        let { color: b, hoverColor: C, initialColor: y, initialTopColor: S, topColor: T } = i.components[1], w2 = i.components[0], M2 = i.components[1], D = i.components[2], F = i.parentObject3D;
        return { id: i.id, type: "geometry", opacity: M2.opacity, initialColor: y, color: b, focusable: w2.focusable, initialTopColor: S, topColor: T, hoverColor: C, hovered: !!(D != null && D.hover), height: M2.height, visible: M2.visible, outline: M2.outline, showImage: M2.showImage, texture: M2.texture, topTexture: M2.topTexture, flipImageToFaceCamera: M2.flipImageToFaceCamera, parent: { id: F == null ? void 0 : F.userData.entityId, type: F == null ? void 0 : F.type }, position: this.convert3DMapPositionToCoordinate(w2.position), interactive: i.components[2] != null };
      } else if ((i == null ? void 0 : i.type) === "model") {
        let b = i.components[0], C = i.components[1], y = i.components[2];
        return { id: i.id, type: "model", position: b.mesh ? this.convert3DMapPositionToCoordinate((n = b.mesh) == null ? void 0 : n.getWorldPosition(new R())) : this.convert3DMapPositionToCoordinate(b.position), interactive: y != null, material: C.material, parent: (s2 = i.parentObject3D) != null && s2.parent ? { id: i.parentObject3D.parent.userData.entityId, type: i.parentObject3D.parent.type } : void 0, visible: C.visible, verticalOffset: C.verticalOffset, color: C.color, opacity: C.opacity, rotation: (c2 = C.rotation) != null ? c2 : Ep, scale: (l = C.scale) != null ? l : Dp };
      } else if ((i == null ? void 0 : i.type) === "path") {
        let b = i.components[0], C = i.components[2], y = i.components[1];
        return { id: i.id, type: "path", position: this.convert3DMapPositionToCoordinate(b.position), visible: y.visible, interactive: C != null, completeFraction: b.completeFraction, color: y.color, accentColor: b.accentColor, nearRadius: b.nearRadius, farRadius: b.farRadius, animateArrowsOnPath: b.animateArrowsOnPath, displayArrowsOnPath: b.displayArrowsOnPath, nearZoomLevel: b.nearZoomLevel, farZoomLevel: b.farZoomLevel };
      } else if ((i == null ? void 0 : i.type) === "image") {
        let b = i.components[0];
        return { id: i.id, type: "image", position: this.convert3DMapPositionToCoordinate(b.position), visible: i.components[1].visible, verticalOffset: (p = b.feature.properties.verticalOffset) != null ? p : 0, flipImageToFaceCamera: i.components[1].flipImageToFaceCamera };
      } else if ((i == null ? void 0 : i.type) === "text3d" && i.components[0] instanceof Bi && "textArea" in i.components[0].feature.properties) {
        my(i);
        let b = i.components[0], C = i.components[1], { textMesh: y } = b, S = (d = b.mesh) == null ? void 0 : d.parent;
        S instanceof mt && ((f = S.children.find((M2) => M2.type === "batchedtext")) == null || f.getWorldPosition(u(this, op2))), u(this, ks).set(0, 0, 0);
        let T = y ? y.getWorldPosition(u(this, ks)) : u(this, ks);
        return Object.assign({}, du, C.getState(), { id: i.id, type: "text3d", position: this.convert3DMapPositionToCoordinate(T.add(u(this, op2))), visible: (g = b.visible) != null ? g : false, content: (v2 = b.feature.properties.content) != null ? v2 : "" });
      } else return;
    }
  }
  setState(e2, i) {
    var n, s2;
    if (typeof e2 == "object" && i == null) {
      "hoverColor" in e2 && (u(this, L).hoverColor = (n = e2.hoverColor) != null ? n : u(this, L).hoverColor), "text3dHoverColor" in e2 && (u(this, L).text3dHoverColor = (s2 = e2.text3dHoverColor) != null ? s2 : u(this, L).text3dHoverColor);
      return;
    }
    let o = lu(u(this, L), e2);
    if (o != null) {
      if (o.type === "custom-geometry") {
        let c2 = u(this, L).geometry3DMap.get(o.id);
        if (c2 instanceof Pt && c2.components[0] instanceof Es) {
          let l = i;
          tu(o, u(this, L), l.visible), cy(o, l.altitude), Qv(o, l.position, this.convertTo3DMapPosition), $v(o, this.getParentContainer(l.parent, false));
        }
      } else if (o.type === "path") {
        let c2 = i;
        jn(o, c2.interactive, u(this, L)) && u(this, Se).call(this), cy(o, c2.altitude), py(o, u(this, L), c2);
      } else if (o.type === "model") {
        let c2 = i;
        jn(o, c2.interactive, u(this, L)) && u(this, Se).call(this), tu(o, u(this, L), c2.visible), vy(o, c2);
      } else if (o.type === "group-container") {
        let c2 = i;
        tu(o, u(this, L), c2.visible) && (u(this, O).outlineInterpolationSystem.dirty = true, u(this, O).pathSystem.altitudeDirty = true), cy(o, c2.altitude) && (u(this, O).pathSystem.altitudeDirty = true), jn(o, c2.interactive, u(this, L)) && u(this, Se).call(this), ay(o, u(this, L), c2.opacity) && (u(this, O).outlineInterpolationSystem.geometries3DDirty = true);
      } else if (o.type === "geometry-group") {
        let c2 = i;
        tu(o, u(this, L), c2.visible) && (u(this, O).outlineInterpolationSystem.dirty = true), Xv(o, u(this, L), c2) && (u(this, O).outlineInterpolationSystem.dirty = true), fy(o, c2.outline) && (u(this, O).outlineInterpolationSystem.geometries3DDirty = true), c2.height != null && (qv(o, u(this, L), c2.height), u(this, O).outlineInterpolationSystem.geometries3DDirty = true), c2.altitude != null && (o.setAltitude(c2.altitude), o.userData.outlineDirty = true), sy(o, c2), Kv(o, c2.shading), ay(o, u(this, L), c2.opacity) && (u(this, O).outlineInterpolationSystem.geometries3DDirty = true), jn(o, c2.interactive, u(this, L)) && (u(this, Se).call(this), u(this, We).call(this));
      } else if (o.type === "geometry") {
        if (o.components[0] instanceof It) {
          let c2 = i;
          tu(o, u(this, L), c2.visible) && (u(this, O).outlineInterpolationSystem.geometries3DDirty = true), fy(o, c2.outline) && (u(this, O).outlineInterpolationSystem.geometries3DDirty = true), Jv(o, c2), dy(o, c2.focusable) && (u(this, O).geometryInFocusSystem.focusablesDirty = true), hy(o, c2.renderOrder) && (u(this, O).meshDetachmentSystem.dirty = true), uy(o, c2.opacity) && (u(this, O).meshDetachmentSystem.dirty = true, u(this, O).outlineInterpolationSystem.geometries3DDirty = true), oy(o, c2.flipImageToFaceCamera), c2.height != null && (qv(o, u(this, L), c2.height), u(this, O).outlineInterpolationSystem.geometries3DDirty = true), ly(o, c2) && (u(this, O).meshDetachmentSystem.dirty = true), rp(o, c2), ny(o, c2.hoverColor), jn(o, c2.interactive, u(this, L)), iy(o, c2.hovered);
        }
        u(this, Se).call(this);
      } else if (o.type === "label" || o.type === "marker") {
        let c2 = i;
        ry(o, i, u(this, L)), ty(o, i, u(this, L)) && (u(this, We).call(this), u(this, O).domMutationSystem.dirty = true), Qv(o, c2.position, this.convertTo3DMapPosition), $v(o, this.getParentContainer(c2.parent, false)) && (u(this, We).call(this), u(this, O).panBoundsSystem.dirty = true), ey(o, c2.enabled), tu(o, u(this, L), c2.visible);
      } else if (o.type === "image") {
        let c2 = i;
        tu(o, u(this, L), c2.visible), oy(o, c2.flipImageToFaceCamera);
      } else if (o.type === "text3d") {
        let c2 = i;
        gy(o, u(this, L), c2);
      }
      this.render();
    }
  }
  convertTo3DMapPosition(e2, i, o = 0, n) {
    var l, p, d, f, g;
    if (Array.isArray(e2)) return this.convertTo3DMapPosition(e2[1], e2[0], (l = e2[2]) != null ? l : o, typeof i == "function" ? i : void 0);
    if (typeof i != "number") throw new Error("convertTo3DMapPosition failed: longitude must be a number");
    let { x: s2, y: c2 } = l0((d = (p = u(this, L).center) == null ? void 0 : p[1]) != null ? d : 0, (g = (f = u(this, L).center) == null ? void 0 : f[0]) != null ? g : 0, e2, i);
    return n ? (n.set(s2, c2, o), n) : new R(s2, c2, o);
  }
  get backgroundColor() {
    return typeof u(this, it).backgroundColor == "string" ? u(this, it).backgroundColor : "#".concat(u(this, it).backgroundColor.getHexString());
  }
  get backgroundAlpha() {
    return u(this, it).backgroundAlpha;
  }
  getThreeRenderer() {
    return u(this, it);
  }
  getCenter(e2) {
    let i = Array.isArray(e2) ? e2 : this.getBoundingArea(e2);
    return i ? p0(i) : void 0;
  }
  isInView(e2) {
    let i = lu(u(this, L), e2);
    if (u(this, ip).identity().multiply(u(this, ke2).projectionMatrix).multiply(u(this, ke2).matrixWorldInverse), u(this, na).setFromProjectionMatrix(u(this, ip)), i instanceof Wt) return u(this, na).containsPoint(i.position);
    if (i instanceof Pt) {
      let o = i == null ? void 0 : i.components[0];
      if (o instanceof Es || o instanceof Vo) return u(this, na).containsPoint(this.convertTo3DMapPosition(o.feature.geometry.coordinates));
      if (o instanceof It) {
        let n = new Ie(this.convertTo3DMapPosition(o.featureBbox[1], o.featureBbox[0], 0), this.convertTo3DMapPosition(o.featureBbox[3], o.featureBbox[2], 0));
        return u(this, na).intersectsBox(n);
      }
    }
    return false;
  }
  getSystems() {
    return u(this, O);
  }
  getInternalState() {
    return u(this, L);
  }
  getTweenGroup() {
    return u(this, L).tweenGroup;
  }
};
Re = /* @__PURE__ */ new WeakMap(), ke2 = /* @__PURE__ */ new WeakMap(), ia = /* @__PURE__ */ new WeakMap(), zc = /* @__PURE__ */ new WeakMap(), Ls = /* @__PURE__ */ new WeakMap(), Yo2 = /* @__PURE__ */ new WeakMap(), oa = /* @__PURE__ */ new WeakMap(), As = /* @__PURE__ */ new WeakMap(), pt2 = /* @__PURE__ */ new WeakSet(), Hy = function(e2) {
  var i;
  u(this, Zo) !== "outdoors-overlay" && ((i = this.map) == null || i.setPixelRatio(e2)), u(this, L).pixelRatio = this.resolutionScale;
}, L = /* @__PURE__ */ new WeakMap(), be = /* @__PURE__ */ new WeakMap(), Dr = /* @__PURE__ */ new WeakMap(), Be = /* @__PURE__ */ new WeakMap(), ci = /* @__PURE__ */ new WeakMap(), it = /* @__PURE__ */ new WeakMap(), O = /* @__PURE__ */ new WeakMap(), qc = /* @__PURE__ */ new WeakMap(), We = /* @__PURE__ */ new WeakMap(), Se = /* @__PURE__ */ new WeakMap(), LS = function() {
  w(this, be, document.createElement("div")), u(this, be).classList.add("mappedin__smart-collision-engine__container"), w(this, Dr, document.createElement("canvas")), u(this, Dr).classList.add("mappedin__smart-collision-engine-debug__container"), this.container.appendChild(u(this, be)), w(this, Be, document.createElement("canvas")), u(this, Be).classList.add("mappedin__smart-collision-engine__container"), u(this, Be).width = u(this, be).clientWidth * this.resolutionScale, u(this, Be).height = u(this, be).clientHeight * this.resolutionScale, u(this, Be).style.width = u(this, be).clientWidth + "px", u(this, Be).style.height = u(this, be).clientHeight + "px", u(this, be).appendChild(u(this, Dr)), u(this, be).appendChild(u(this, Be)), u(this, Dr).width = u(this, be).clientWidth, u(this, Dr).height = u(this, be).clientHeight, u(this, Be).width = u(this, be).clientWidth * this.resolutionScale, u(this, Be).height = u(this, be).clientHeight * this.resolutionScale, u(this, Be).style.width = u(this, be).clientWidth + "px", u(this, Be).style.height = u(this, be).clientHeight + "px";
}, AS = function() {
  w(this, ci, document.createElement("div")), u(this, ci).classList.add("mappedin-2d-entities"), Object.assign(u(this, ci).style, { position: "absolute", top: "0", left: "0", bottom: "0", right: "0", pointerEvents: "none", "transform-style": "preserve-3d" }), this.container.appendChild(u(this, ci));
}, FS = function() {
  u(this, Be).width = u(this, be).clientWidth * this.resolutionScale, u(this, Be).height = u(this, be).clientHeight * this.resolutionScale, u(this, Be).style.width = u(this, be).clientWidth + "px", u(this, Be).style.height = u(this, be).clientHeight + "px", u(this, Dr).width = u(this, be).clientWidth, u(this, Dr).height = u(this, be).clientHeight, u(this, Be).width = u(this, be).clientWidth * this.resolutionScale, u(this, Be).height = u(this, be).clientHeight * this.resolutionScale, u(this, Be).style.width = u(this, be).clientWidth + "px", u(this, Be).style.height = u(this, be).clientHeight + "px", u(this, O).collisionSystem.collidersDirty = true;
}, Zo = /* @__PURE__ */ new WeakMap(), $c = /* @__PURE__ */ new WeakMap(), Jc = /* @__PURE__ */ new WeakMap(), Qc = /* @__PURE__ */ new WeakMap(), Kc = /* @__PURE__ */ new WeakMap(), $h = /* @__PURE__ */ new WeakMap(), ep = /* @__PURE__ */ new WeakMap(), tp = /* @__PURE__ */ new WeakMap(), rp2 = /* @__PURE__ */ new WeakMap(), Fs = /* @__PURE__ */ new WeakMap(), Wy = function(e2, i, o, n) {
  let s2 = new Wt(i, this.convertTo3DMapPosition(e2[1], e2[0], e2[2] || 0), n);
  return s2.occluderId = o != null ? o : u(this, O).occlusion2DSystem.backgroundId, u(this, L).geometry2DMap.set(s2.id, s2), s2;
}, na = /* @__PURE__ */ new WeakMap(), ip = /* @__PURE__ */ new WeakMap(), Lt2 = /* @__PURE__ */ new WeakMap(), At = /* @__PURE__ */ new WeakMap(), Xy = async function() {
  return jo.load(S5).then((e2) => {
    var i;
    return u(this, Re) && ((i = u(this, Re).environment) == null || i.dispose(), e2.mapping = pa, u(this, Re).environment = e2, this.render()), e2;
  });
}, ks = /* @__PURE__ */ new WeakMap(), op2 = /* @__PURE__ */ new WeakMap();
var np2 = Uy;
c();
function Zw(r3, t3) {
  zw(r3, t3)(r3.getScene(), t3), qw(r3, t3), t3.addFolder("Export").add({ export: async () => {
    let s2 = await r3.getCurrentSceneGLTF({ binary: true }), c2 = new Blob([s2], { type: "application/octet-stream" });
    var l = document.createElement("a");
    document.body.appendChild(l), l.style.display = "none";
    let p = window.URL.createObjectURL(c2);
    l.href = p, l.download = "scene.glb", l.click(), window.URL.revokeObjectURL(p);
  } }, "export");
  let o = t3.addFolder("Camera"), n = { get bearing() {
    return r3.camera.bearing;
  }, set bearing(s2) {
    r3.camera.setBearing(s2);
  }, get pitch() {
    return r3.camera.pitch;
  }, set pitch(s2) {
    r3.camera.setPitch(s2);
  }, get zoomLevel() {
    return r3.camera.zoomLevel;
  }, set zoomLevel(s2) {
    r3.camera.setZoomLevel(s2);
  } };
  o.add(n, "bearing", -359, 359, 1), o.add(n, "pitch", r3.camera.minPitch, r3.camera.maxPitch, 1), o.add(n, "zoomLevel", r3.camera.minZoomLevel, r3.camera.maxZoomLevel, 0.1);
}
function zw(r3, t3) {
  let e2 = t3;
  return function i(o, n) {
    let s2 = n.addFolder("".concat([o.type], " ").concat(o.id.slice(0, 16)));
    if (n.close(), o.type === "geometry" || o.type === "model" || o.type === "path" || o.type === "image") {
      let c2 = { get height() {
        let l = r3.getState(o.id);
        return (l == null ? void 0 : l.type) === "geometry" ? l.height : 0;
      }, set height(l) {
        let p = r3.getState(o.id);
        (p == null ? void 0 : p.type) === "geometry" && r3.setState(o, { height: l });
      }, set flipImageToFaceCamera(l) {
        let p = r3.getState(o.id);
        (p == null ? void 0 : p.type) === "image" && r3.setState(o, { flipImageToFaceCamera: l });
      }, get flipImageToFaceCamera() {
        let l = r3.getState(o.id);
        return (l == null ? void 0 : l.type) === "image" ? l.flipImageToFaceCamera : false;
      }, set visible(l) {
        let p = r3.getState(o.id);
        ((p == null ? void 0 : p.type) === "geometry" || (p == null ? void 0 : p.type) === "path" || (p == null ? void 0 : p.type) === "image") && r3.setState(o, { visible: l });
      }, get visible() {
        let l = r3.getState(o.id);
        return (l == null ? void 0 : l.type) === "geometry" || (l == null ? void 0 : l.type) === "path" || (l == null ? void 0 : l.type) === "image" ? l.visible : false;
      }, set outline(l) {
        let p = r3.getState(o.id);
        (p == null ? void 0 : p.type) === "geometry" && r3.setState(o, { outline: l });
      }, get outline() {
        let l = r3.getState(o.id);
        return (l == null ? void 0 : l.type) === "geometry" ? l.outline : false;
      }, get opacity() {
        let l = r3.getState(o.id);
        return (l == null ? void 0 : l.type) === "geometry" ? l.opacity : 1;
      }, set opacity(l) {
        let p = r3.getState(o.id);
        (p == null ? void 0 : p.type) === "geometry" && r3.setState(p, { opacity: l });
      }, get color() {
        let l = r3.getState(o.id);
        return (l == null ? void 0 : l.type) === "geometry" && l.color ? ae(l.color).toHexString() : "#ffffff";
      }, set color(l) {
        let p = r3.getState(o.id);
        (p == null ? void 0 : p.type) === "geometry" && r3.setState(p, { color: l });
      }, set interactive(l) {
        let p = r3.getState(o.id);
        ((p == null ? void 0 : p.type) === "geometry" || (p == null ? void 0 : p.type) === "model" || (p == null ? void 0 : p.type) === "path") && (r3.setState(o, { interactive: l }), e2.controllersRecursive().forEach((d) => d.updateDisplay()));
      }, get interactive() {
        let l = r3.getState(o.id);
        return (l == null ? void 0 : l.type) === "geometry" || (l == null ? void 0 : l.type) === "model" || (l == null ? void 0 : l.type) === "path" ? l.interactive : false;
      }, get completeFraction() {
        let l = r3.getState(o.id);
        return (l == null ? void 0 : l.type) === "path" ? l.completeFraction : 1;
      }, set completeFraction(l) {
        let p = r3.getState(o.id);
        (p == null ? void 0 : p.type) === "path" && r3.setState(p, { completeFraction: l });
      }, focus: () => {
      } };
      s2.add(c2, "focus").onChange(() => {
        let l = r3.getState(o.id);
        (l == null ? void 0 : l.type) === "model" || (l == null ? void 0 : l.type) === "path" || (l == null ? void 0 : l.type) === "image" ? r3.camera.focusOn([l.position]) : (l == null ? void 0 : l.type) === "geometry" && r3.camera.focusOn(r3.getBoundingArea(l));
      }), s2.add(c2, "visible"), o.type === "image" ? s2.add(c2, "flipImageToFaceCamera") : (s2.add(c2, "interactive"), o.type === "path" && s2.add(c2, "completeFraction", 0, 1, 0.1), o.type !== "model" && (s2.addColor(c2, "color"), s2.add(c2, "outline"))), o.type === "geometry" && (s2.add(c2, "height"), s2.add(c2, "opacity", 0, 1, 0.1));
    } else if (o.type === "marker") {
      let c2 = { get interactive() {
        var p;
        let l = r3.getState(o.id);
        return (l == null ? void 0 : l.type) === "marker" ? (p = l.options) == null ? void 0 : p.interactive : false;
      }, set interactive(l) {
        let p = r3.getState(o.id);
        (p == null ? void 0 : p.type) === "marker" && (r3.setState(p, { options: { interactive: l } }), e2.controllersRecursive().forEach((d) => d.updateDisplay()));
      }, focus: () => {
      } };
      s2.add(c2, "focus").onChange(() => {
        let l = r3.getState(o.id);
        (l == null ? void 0 : l.type) === "marker" && r3.camera.focusOn([l.position]);
      }), s2.add(c2, "interactive");
    } else if (o.type === "label") {
      let c2 = { get interactive() {
        var p;
        let l = r3.getState(o.id);
        return (l == null ? void 0 : l.type) === "label" ? (p = l.options) == null ? void 0 : p.interactive : false;
      }, set interactive(l) {
        let p = r3.getState(o.id);
        (p == null ? void 0 : p.type) === "label" && (r3.setState(p, { options: { interactive: l } }), e2.controllersRecursive().forEach((d) => d.updateDisplay()));
      }, get text() {
        let l = r3.getState(o.id);
        return (l == null ? void 0 : l.type) === "label" ? l.text : "";
      }, set text(l) {
        let p = r3.getState(o.id);
        (p == null ? void 0 : p.type) === "label" && r3.setState(p, { text: l });
      }, get "Text Color"() {
        var p, d;
        let l = r3.getState(o.id);
        return (l == null ? void 0 : l.type) === "label" ? (d = (p = l.options.appearance) == null ? void 0 : p.text) == null ? void 0 : d.foregroundColor : "#000000";
      }, set "Text Color"(l) {
        let p = r3.getState(o.id);
        (p == null ? void 0 : p.type) === "label" && r3.setState(o.id, { text: c2.text, options: { appearance: { text: { foregroundColor: l } } } });
      }, get "Text Size"() {
        var p, d;
        let l = r3.getState(o.id);
        return (l == null ? void 0 : l.type) === "label" ? (d = (p = l.options.appearance) == null ? void 0 : p.text) == null ? void 0 : d.size : 10;
      }, set "Text Size"(l) {
        let p = r3.getState(o.id);
        (p == null ? void 0 : p.type) === "label" && r3.setState(p, { text: c2.text, options: { appearance: { text: { size: l } } } });
      }, get "Icon Size"() {
        var p, d;
        let l = r3.getState(o.id);
        return (l == null ? void 0 : l.type) === "label" ? (d = (p = l.options.appearance) == null ? void 0 : p.marker) == null ? void 0 : d.iconSize : 10;
      }, set "Icon Size"(l) {
        let p = r3.getState(o.id);
        (p == null ? void 0 : p.type) === "label" && r3.setState(p, { text: c2.text, options: { appearance: { marker: { iconSize: l } } } });
      }, get "Active Foreground Color"() {
        var p, d, f;
        let l = r3.getState(o.id);
        return (l == null ? void 0 : l.type) === "label" ? (f = (d = (p = l.options.appearance) == null ? void 0 : p.marker) == null ? void 0 : d.foregroundColor) == null ? void 0 : f.active : "#000000";
      }, set "Active Foreground Color"(l) {
        var d, f;
        let p = r3.getState(o.id);
        (p == null ? void 0 : p.type) === "label" && r3.setState(p, { text: c2.text, options: { appearance: { marker: { foregroundColor: { ...(f = (d = p.options.appearance) == null ? void 0 : d.marker) == null ? void 0 : f.foregroundColor, active: l } } } } });
      }, get "Inactive Foreground Color"() {
        var p, d, f;
        let l = r3.getState(o.id);
        return (l == null ? void 0 : l.type) === "label" ? (f = (d = (p = l.options.appearance) == null ? void 0 : p.marker) == null ? void 0 : d.foregroundColor) == null ? void 0 : f.inactive : "#000000";
      }, set "Inactive Foreground Color"(l) {
        var d, f;
        let p = r3.getState(o.id);
        (p == null ? void 0 : p.type) === "label" && r3.setState(p, { text: c2.text, options: { appearance: { marker: { foregroundColor: { ...(f = (d = p.options.appearance) == null ? void 0 : d.marker) == null ? void 0 : f.foregroundColor, inactive: l } } } } });
      }, get "Active Background Color"() {
        var p, d, f;
        let l = r3.getState(o.id);
        return (l == null ? void 0 : l.type) === "label" ? (f = (d = (p = l.options.appearance) == null ? void 0 : p.marker) == null ? void 0 : d.backgroundColor) == null ? void 0 : f.active : "#000000";
      }, set "Active Background Color"(l) {
        var d, f;
        let p = r3.getState(o.id);
        (p == null ? void 0 : p.type) === "label" && r3.setState(p, { text: c2.text, options: { appearance: { marker: { backgroundColor: { ...(f = (d = p.options.appearance) == null ? void 0 : d.marker) == null ? void 0 : f.backgroundColor, active: l } } } } });
      }, get "Inactive Background Color"() {
        var p, d, f;
        let l = r3.getState(o.id);
        return (l == null ? void 0 : l.type) === "label" ? (f = (d = (p = l.options.appearance) == null ? void 0 : p.marker) == null ? void 0 : d.backgroundColor) == null ? void 0 : f.inactive : "#000000";
      }, set "Inactive Background Color"(l) {
        var d, f;
        let p = r3.getState(o.id);
        (p == null ? void 0 : p.type) === "label" && r3.setState(p, { text: c2.text, options: { appearance: { marker: { backgroundColor: { ...(f = (d = p.options.appearance) == null ? void 0 : d.marker) == null ? void 0 : f.backgroundColor, inactive: l } } } } });
      }, focus: () => {
      } };
      s2.add(c2, "focus").onChange(() => {
        let l = r3.getState(o.id);
        (l == null ? void 0 : l.type) === "label" && r3.camera.focusOn([l.position]);
      }), s2.add(c2, "interactive"), s2.add(c2, "text"), s2.add(c2, "Text Size", 10, 50), s2.add(c2, "Icon Size", 10, 50), s2.addColor(c2, "Text Color"), s2.addColor(c2, "Active Background Color"), s2.addColor(c2, "Inactive Background Color"), s2.addColor(c2, "Active Foreground Color"), s2.addColor(c2, "Inactive Foreground Color");
    } else if (o.type === "geometry-group") {
      let c2 = { get opacity() {
        let l = r3.getState(o.id);
        return (l == null ? void 0 : l.type) === "geometry-group" ? l.opacity : 1;
      }, set opacity(l) {
        let p = r3.getState(o.id);
        (p == null ? void 0 : p.type) === "geometry-group" && r3.setState(o, { opacity: l });
      }, set visible(l) {
        let p = r3.getState(o.id);
        (p == null ? void 0 : p.type) === "geometry-group" && r3.setState(o, { visible: l });
      }, get visible() {
        let l = r3.getState(o.id);
        return (l == null ? void 0 : l.type) === "geometry-group" ? l.visible : false;
      }, set outline(l) {
        let p = r3.getState(o.id);
        (p == null ? void 0 : p.type) === "geometry-group" && r3.setState(o, { outline: l });
      }, get outline() {
        let l = r3.getState(o.id);
        return (l == null ? void 0 : l.type) === "geometry-group" ? l.outline : false;
      }, set interactive(l) {
        let p = r3.getState(o.id);
        (p == null ? void 0 : p.type) === "geometry-group" && (r3.setState(o, { interactive: l }), e2.controllersRecursive().forEach((d) => d.updateDisplay()));
      }, get interactive() {
        let l = r3.getState(o.id);
        return (l == null ? void 0 : l.type) === "geometry-group" ? l.interactive : false;
      }, get shadingStart() {
        var p, d;
        let l = r3.getState(o.id);
        return (l == null ? void 0 : l.type) === "geometry-group" && (d = (p = l.shading) == null ? void 0 : p.start) != null ? d : 0;
      }, set shadingStart(l) {
        let p = r3.getState(o.id);
        (p == null ? void 0 : p.type) === "geometry-group" && r3.setState(p, { shading: { start: l } });
      }, get shadingEnd() {
        var p, d;
        let l = r3.getState(o.id);
        return (l == null ? void 0 : l.type) === "geometry-group" && (d = (p = l.shading) == null ? void 0 : p.end) != null ? d : 0;
      }, set shadingEnd(l) {
        let p = r3.getState(o.id);
        (p == null ? void 0 : p.type) === "geometry-group" && r3.setState(p, { shading: { end: l } });
      }, get shadingIntensity() {
        var p, d;
        let l = r3.getState(o.id);
        return (l == null ? void 0 : l.type) === "geometry-group" && (d = (p = l.shading) == null ? void 0 : p.intensity) != null ? d : 0;
      }, set shadingIntensity(l) {
        let p = r3.getState(o.id);
        (p == null ? void 0 : p.type) === "geometry-group" && r3.setState(p, { shading: { intensity: l } });
      } };
      s2.add(c2, "visible"), s2.add(c2, "opacity", 0, 1, 0.1), s2.add(c2, "interactive"), s2.add(c2, "outline"), s2.add(c2, "shadingStart", 0, 1, 0.1), s2.add(c2, "shadingEnd", 0, 1, 0.1), s2.add(c2, "shadingIntensity", 0, 1, 0.1);
    } else if (o.type === "group-container") {
      let c2 = { set visible(l) {
        let p = r3.getState(o.id);
        (p == null ? void 0 : p.type) === "group-container" && r3.setState(o, { visible: l });
      }, get visible() {
        let l = r3.getState(o.id);
        return (l == null ? void 0 : l.type) === "group-container" ? l.visible : false;
      }, set interactive(l) {
        let p = r3.getState(o.id);
        (p == null ? void 0 : p.type) === "group-container" && (r3.setState(p, { interactive: l }), e2.controllersRecursive().forEach((d) => d.updateDisplay()));
      }, get interactive() {
        let l = r3.getState(o.id);
        return (l == null ? void 0 : l.type) === "group-container" ? l.interactive : false;
      } };
      s2.add(c2, "visible"), s2.add(c2, "interactive");
    }
    if (s2.close(), o.children) for (let c2 of o.children.values()) i(c2, s2);
  };
}
function qw(r3, t3) {
  let e2 = t3.addFolder("Watermark"), i = { padding: 16, iconOnly: false, position: "bottom-left", color: "dark", scale: 1 };
  e2.add(i, "padding", 0, 100, 1), e2.add(i, "scale", 0.5, 1.5, 0.1), e2.add(i, "color", ["dark", "light"]), e2.add(i, "position", ["top-left", "top-right", "bottom-left", "bottom-right", "center", "top", "bottom", "left", "right"]), e2.add(i, "iconOnly"), e2.onChange(() => {
    r3.updateWatermark(i);
  });
}
var kS = "https://tiles-cdn.mappedin.com/styles/mappedin/style.json";
var Jw = "https://auth.mappedin.com/oauth2/token";
async function BS(r3, t3) {
  var e2, i, o, n, s2;
  if ((e2 = t3 == null ? void 0 : t3.outdoorView) != null && e2.enabled) {
    let { Map: c2, MercatorCoordinate: l } = await import("./outdoor-context-v4-7JNIM35B-PQLUNWIH.js"), p = t3.outdoorView.headers;
    p == null && (p = await c0(Jw));
    let d = t3.center || [0, 0], f = new c2({ container: r3, style: t3.outdoorView.style || kS, center: d, attributionControl: false, zoom: (i = t3.zoomLevel) != null ? i : zy2, pitch: (o = t3.pitch) != null ? o : Yy, bearing: (n = t3.bearing) != null ? n : Zy, transformRequest: Sp(p), trackResize: false, pixelRatio: t3.outdoorView.lowDpi ? 1 : yp(), antialias: typeof t3.antialias == "boolean" ? t3.antialias : true, boxZoom: false, doubleClickZoom: false, scrollZoom: false, dragPan: false, dragRotate: false, keyboard: false, touchZoomRotate: false }), g = f.painter.context.gl, v2 = new np2(r3, { center: d, zoomLevel: f.getZoom(), pitch: f.getPitch(), bearing: f.getBearing(), gl: g, map: f, mode: "outdoors-interleaved", watermark: t3.watermark, attribution: t3.attribution, antialias: t3.antialias, occlusionEnabled: t3.occlusionEnabled, transformImageRequest: t3.transformImageRequest, naturalBearing: (s2 = t3.naturalBearing) != null ? s2 : 0, imagePlacementOptions: t3.imagePlacementOptions, onWebGLContextCreationError: t3.onWebGLContextCreationError, onWebGLContextLost: t3.onWebGLContextLost, onWebGLContextRestored: t3.onWebGLContextRestored, onWebGLRendererError: t3.onWebGLRendererError }), b = { center: f.getCenter().toArray(), zoom: f.getZoom(), bearing: f.getBearing(), pitch: f.getPitch() };
    f.setMinZoom(v2.camera.minZoomLevel), f.setMaxZoom(v2.camera.maxZoomLevel), v2.on("camera-change", (M2) => {
      b.center = M2.center, b.zoom = M2.zoomLevel, b.bearing = M2.bearing, b.pitch = M2.pitch, f.jumpTo(b);
    });
    let C = l.fromLngLat(d, 0), y = u0(C, v2.viewCamera, v2.camera, () => {
      v2.renderSync();
    });
    f.on("style.load", async () => {
      f && (f.addLayer(y), v2.renderSync());
    });
    let S = false, T = false;
    f.on("idle", () => {
      f && (S || (v2.publish("outdoor-view-loaded"), S = true), T || (T = true, v2.publish("outdoor-style-loaded")));
    });
    let w2 = (M2) => {
      M2 && (M2.sourceDataType === "metadata" || M2.sourceDataType === "visibility" || M2.dataType === "style" || M2.type === "terrain") && v2.getSystems().htmlControlsSystem.updateData(f);
    };
    return f.on("styledata", (M2) => {
      f && M2 && M2.dataType === "style" && M2.type === "styledata" && (T = false), w2(M2);
    }), f.on("sourcedata", w2), f.on("terrain", w2), f.on("error", (M2) => {
      var D;
      if (((D = M2.error) == null ? void 0 : D.url) === kS) {
        Lt.error('Failed to load outdoor view style, possibly due to invalid token "'.concat(p["x-mappedin-tiles-key"], '"'));
        return;
      }
      Lt.warn(M2);
    }), v2;
  } else return new np2(r3, t3);
}
c();
var Yd = ((e2) => (e2.Exterior = "exterior-walls", e2.Interior = "interior-walls", e2))(Yd || {});
var Zd = ((e2) => (e2.Interior = "interior-doors", e2.Exterior = "exterior-doors", e2))(Zd || {});
c();
c();
var ap = class ap2 {
  constructor(t3, e2, i) {
    t(this, "id");
    t(this, "text");
    t(this, "target");
    t(this, "__type", ap2.__type);
    this.id = t3, this.text = e2, this.target = i;
  }
  static is(t3) {
    return t3.__type === ap2.__type;
  }
  get focusTarget() {
    return this.target.anchorTarget;
  }
};
t(ap, "__type", "Label");
var zo = ap;
c();
var aa;
var sp = class sp2 {
  constructor(t3, e2, i) {
    t(this, "id");
    v(this, aa);
    t(this, "__type", sp2.__type);
    t(this, "contentEl");
    this.id = t3, this.contentEl = e2, w(this, aa, i);
  }
  get target() {
    return u(this, aa);
  }
  get coordinate() {
    return u(this, aa).anchorTarget;
  }
  static is(t3) {
    return t3.__type === sp2.__type;
  }
  get focusTarget() {
    return this.target.anchorTarget;
  }
  updateTarget(t3) {
    w(this, aa, t3);
  }
};
aa = /* @__PURE__ */ new WeakMap(), t(sp, "__type", "Marker");
var Vi = sp;
c();
var pp2;
var up;
var lp = class lp2 {
  constructor(t3, e2, i) {
    v(this, pp2);
    v(this, up);
    t(this, "target");
    t(this, "__type", lp2.__type);
    w(this, pp2, t3), w(this, up, e2), this.target = i;
  }
  static is(t3) {
    return t3.__type === lp2.__type;
  }
  get id() {
    return u(this, pp2);
  }
  get url() {
    return u(this, up);
  }
};
pp2 = /* @__PURE__ */ new WeakMap(), up = /* @__PURE__ */ new WeakMap(), t(lp, "__type", "Image");
var cp = lp;
c();
var Bs;
var dp = class dp2 {
  constructor(t3, e2, i) {
    t(this, "id");
    t(this, "groupId");
    t(this, "__type", dp2.__type);
    v(this, Bs);
    this.id = t3, this.groupId = e2, w(this, Bs, i);
  }
  get target() {
    return u(this, Bs);
  }
  static is(t3) {
    return t3.__type === dp2.__type;
  }
  updateTarget(t3) {
    w(this, Bs, t3);
  }
};
Bs = /* @__PURE__ */ new WeakMap(), t(dp, "__type", "Model");
var sa = dp;
c();
var hp = class hp2 {
  constructor(t3, e2) {
    t(this, "id");
    t(this, "coordinates");
    t(this, "__type", hp2.__type);
    this.id = t3, this.coordinates = e2;
  }
  static is(t3) {
    return t3.__type === hp2.__type;
  }
  get focusTarget() {
    return this.coordinates;
  }
};
t(hp, "__type", "PathSegment");
var _s = hp;
var fp = class fp2 {
  constructor(t3, e2, i, o) {
    t(this, "id");
    t(this, "animation");
    t(this, "coordinates");
    t(this, "segments");
    t(this, "__type", fp2.__type);
    this.id = t3, this.animation = e2, this.coordinates = i, this.segments = o.map(({ id: n, coordinates: s2 }) => new _s(n.toString(), s2));
  }
  static is(t3) {
    return t3.__type === fp2.__type;
  }
  get focusTarget() {
    return this.coordinates;
  }
};
t(fp, "__type", "Path");
var Er2 = fp;
c();
var qo;
var mp = class {
  constructor(t3) {
    v(this, qo);
    w(this, qo, t3);
  }
  get center() {
    return u(this, qo).center;
  }
  get bearing() {
    return u(this, qo).bearing;
  }
  get pitch() {
    return u(this, qo).pitch;
  }
  get zoomLevel() {
    return u(this, qo).zoomLevel;
  }
};
qo = /* @__PURE__ */ new WeakMap();
c();
var gp = class gp2 {
  constructor(t3) {
    t(this, "id");
    t(this, "__type", gp2.__type);
    this.id = t3;
  }
  static is(t3) {
    return t3.__type === gp2.__type;
  }
  get focusTarget() {
    return this;
  }
};
t(gp, "__type", "Shape");
var $o = gp;
c();
var Jh = class Jh2 {
  constructor(t3, e2) {
    t(this, "id");
    t(this, "target");
    t(this, "__type", "Text3D");
    this.id = t3, this.target = e2;
  }
  static is(t3) {
    return t3.__type === Jh2.__type;
  }
};
t(Jh, "__type", "Text3D");
var Jo2 = Jh;
c();
c();
c();
var Qw = /* @__PURE__ */ new Map([["search-16x16", '<svg viewBox="0 0 16 16">\n			<path\n				fillRule="evenodd"\n				clipRule="evenodd"\n				d="M1 7C1 3.68629 3.68629 1 7 1C10.3137 1 13 3.68629 13 7C13 8.29583 12.5892 9.49572 11.8907 10.4765L15.4614 14.0472C15.6567 14.2425 15.6567 14.559 15.4614 14.7543L14.7543 15.4614C14.559 15.6567 14.2424 15.6567 14.0472 15.4614L10.4765 11.8907C9.49571 12.5892 8.29583 13 7 13C3.68629 13 1 10.3137 1 7ZM7 11C4.79086 11 3 9.20914 3 7C3 4.79086 4.79086 3 7 3C9.20914 3 11 4.79086 11 7C11 9.20914 9.20914 11 7 11Z"\n				stroke="none"\n			/>\n		</svg>'], ["close-16x16", '<svg viewBox="0 0 16 16">\n			<path\n				d="M12.5963 1.98959C12.7916 1.79433 13.1082 1.79433 13.3034 1.98959L14.0105 2.6967C14.2058 2.89196 14.2058 3.20855 14.0105 3.40381L3.40392 14.0104C3.20866 14.2057 2.89208 14.2057 2.69682 14.0104L1.98971 13.3033C1.79445 13.108 1.79445 12.7915 1.98971 12.5962L12.5963 1.98959Z"\n				stroke="none"\n			/>\n			<path\n				d="M1.98971 3.40381C1.79445 3.20855 1.79445 2.89196 1.98971 2.6967L2.69682 1.98959C2.89208 1.79433 3.20866 1.79433 3.40392 1.98959L14.0105 12.5962C14.2058 12.7915 14.2058 13.108 14.0105 13.3033L13.3034 14.0104C13.1082 14.2057 12.7916 14.2057 12.5963 14.0104L1.98971 3.40381Z"\n				stroke="none"\n			/>\n		</svg>'], ["empty-64x40", '<svg viewBox="0 0 64 40">\n			<g>\n				<g clipPath="url(#clip0_499_175492)">\n					<path\n						d="M32 39.7032C49.6731 39.7032 64 36.5925 64 32.7552C64 28.9179 49.6731 25.8071 32 25.8071C14.3269 25.8071 0 28.9179 0 32.7552C0 36.5925 14.3269 39.7032 32 39.7032Z"\n						stroke="none"\n						fill="#F5F5F5"\n					/>\n					<path\n						d="M55 13.6653L44.854 2.24866C44.367 1.47048 43.656 1 42.907 1H21.093C20.344 1 19.633 1.47048 19.146 2.24767L9 13.6663V22.8367H55V13.6653Z"\n						fill="none"\n					/>\n					<path\n						d="M41.613 16.8128C41.613 15.2197 42.607 13.9046 43.84 13.9036H55V31.9059C55 34.0132 53.68 35.7402 52.05 35.7402H11.95C10.32 35.7402 9 34.0122 9 31.9059V13.9036H20.16C21.393 13.9036 22.387 15.2167 22.387 16.8098V16.8317C22.387 18.4248 23.392 19.7111 24.624 19.7111H39.376C40.608 19.7111 41.613 18.4128 41.613 16.8198V16.8128Z"\n						fill="#FAFAFA"\n					/>\n				</g>\n				<defs>\n					<clipPath id="clip0_499_175492">\n						<rect width="64" height="40" fill="white" />\n					</clipPath>\n				</defs>\n			</g>\n		</svg>'], ["caret-12x12", '<svg viewBox="0 0 12 12">\n			<path\n				stroke="none"\n				d="M8.38828 5.78337L3.92578 1.93493C3.75938 1.79196 3.51562 1.92087 3.51562 2.15173V9.84861C3.51562 10.0795 3.75938 10.2084 3.92578 10.0654L8.38828 6.21696C8.51602 6.10681 8.51602 5.89353 8.38828 5.78337Z"\n			/>\n		</svg>'], ["plus-16x16", '<svg viewBox="0 0 16 16">\n			<path\n				d="M7.5 1C7.22386 1 7 1.22386 7 1.5V7H1.5C1.22386 7 1 7.22386 1 7.5L1 8.5C1 8.77614 1.22386 9 1.5 9H7V14.5C7 14.7761 7.22386 15 7.5 15H8.5C8.77614 15 9 14.7761 9 14.5V9H14.5C14.7761 9 15 8.77614 15 8.5V7.5C15 7.22386 14.7761 7 14.5 7H9V1.5C9 1.22386 8.77614 1 8.5 1H7.5Z"\n				stroke="none"\n			/>\n		</svg>'], ["recenter-16x16", '<svg viewBox="0 0 16 16">\n			<g stroke="none">\n				<path d="M0 2.5C0 2.22386 0.223858 2 0.5 2H1.5C1.77614 2 2 2.22386 2 2.5V13.5C2 13.7761 1.77614 14 1.5 14H0.5C0.223858 14 0 13.7761 0 13.5V2.5Z" />\n				<path\n					fillRule="evenodd"\n					clipRule="evenodd"\n					d="M4.5 4C4.22386 4 4 4.22386 4 4.5V11.5C4 11.7761 4.22386 12 4.5 12H11.5C11.7761 12 12 11.7761 12 11.5V4.5C12 4.22386 11.7761 4 11.5 4H4.5ZM6 6V10H10V6H6Z"\n				/>\n				<path d="M14.5 2C14.2239 2 14 2.22386 14 2.5V13.5C14 13.7761 14.2239 14 14.5 14H15.5C15.7761 14 16 13.7761 16 13.5V2.5C16 2.22386 15.7761 2 15.5 2H14.5Z" />\n			</g>\n		</svg>'], ["minus-16x16", '<svg viewBox="0 0 16 16">\n			<path\n				d="M1.5 9C1.22386 9 1 8.77614 1 8.5L1 7.5C1 7.22386 1.22386 7 1.5 7L14.5 7C14.7761 7 15 7.22386 15 7.5V8.5C15 8.77614 14.7761 9 14.5 9L1.5 9Z"\n				stroke="none"\n			/>\n		</svg>'], ["logo-horizontal-206x48", '<svg viewBox="0 0 206 48">\n			<path d="M27.2678 14.2261H22.3187C21.0695 14.2261 20.4695 14.7801 20.4695 15.9852V31.142L10.3966 15.5591C9.69665 14.4784 9.2475 14.2773 7.8475 14.2261H2.97462C1.67462 14.2261 1.07631 14.7801 1.07631 15.9852V44.7665C1.07631 45.9716 1.67462 46.5256 2.97462 46.5256H7.92377C9.22207 46.5256 9.82207 45.9716 9.82207 44.7665V29.6847L19.9441 45.1926C20.695 46.3244 21.095 46.5256 22.4933 46.5256H27.2933C28.5916 46.5256 29.1916 45.9716 29.1916 44.7665V15.9852C29.1407 14.7801 28.5424 14.2261 27.2678 14.2261Z" />\n			<path d="M5.44915 10.9602C8.45863 10.9602 10.8983 8.50669 10.8983 5.48011C10.8983 2.45353 8.45863 0 5.44915 0C2.43967 0 0 2.45353 0 5.48011C0 8.50669 2.43967 10.9602 5.44915 10.9602Z" />\n			<path d="M61.7899 25.0449C63.2306 23.1903 65.078 22.2051 67.556 22.2051C72.0526 22.2051 74.7611 25.3347 74.7611 29.4511V39.2489C74.8187 39.7125 74.5306 39.9443 74.0695 39.9443H72.5136C72.0526 39.9443 71.7645 39.7125 71.8221 39.2489V29.5091C71.8221 27.1909 69.9187 25.2187 67.4984 25.2187C65.1339 25.2187 63.2323 27.1329 63.2323 29.2773V39.2489C63.2899 39.7125 63.0018 39.9443 62.5407 39.9443H60.9831C60.5221 39.9443 60.2916 39.7125 60.2916 39.2489V29.4511C60.2916 27.1329 58.3899 25.2187 56.0255 25.2187C53.7204 25.2187 51.7594 27.075 51.7594 29.2773V39.3068C51.817 39.7705 51.5289 40.0023 51.0102 40.0023H49.5119C49.0509 40.0023 48.7628 39.7705 48.7628 39.3068V23.25C48.7051 22.7864 48.9933 22.4966 49.5119 22.4966H50.9526C51.356 22.4966 51.5289 22.6704 51.5289 23.0182V24.2352C52.7407 22.9602 54.239 22.2648 56.0255 22.2648C58.4475 22.2068 60.3492 23.192 61.7899 25.0466V25.0449ZM77.1255 31.2477C77.1255 26.3216 81.1018 22.2051 86.1187 22.2051C88.539 22.2051 90.6136 23.1903 92.3441 25.1608V23.1903C92.3441 22.7267 92.5746 22.5528 93.0357 22.5528H94.4187C94.8797 22.5528 95.1102 22.7847 95.1102 23.3062V39.3648C95.1102 39.8284 94.8797 40.0602 94.4187 40.0602H93.0357C92.5746 40.0602 92.3441 39.8284 92.3441 39.4227V37.4523C90.6712 39.3648 88.5967 40.35 86.1746 40.35C81.1018 40.2341 77.1238 36.1773 77.1238 31.2477H77.1255ZM92.1136 31.2477C92.1136 27.8284 89.4611 25.2187 86.0594 25.2187C82.7746 25.2187 80.1221 27.8864 80.1221 31.2477C80.1221 34.6687 82.7746 37.2784 86.1187 37.2784C86.9062 37.2789 87.6861 37.1232 88.4138 36.8202C89.1414 36.5173 89.8026 36.0731 90.3593 35.513C90.9161 34.9528 91.3577 34.2878 91.6587 33.556C91.9597 32.8241 92.1143 32.0397 92.1136 31.2477ZM100.992 37.3943V46.3807C101.049 46.8443 100.761 47.1341 100.298 47.1341H98.7424C98.2814 47.1341 97.9933 46.9023 97.9933 46.3807V23.1903C97.9933 22.7267 98.2238 22.4369 98.7424 22.4369H100.183C100.646 22.379 100.934 22.6687 100.934 23.0744V24.9869C102.605 23.0744 104.68 22.1472 107.044 22.1472C112.002 22.1472 116.037 26.2619 116.037 31.1898C116.037 36.1176 112.059 40.2341 107.044 40.2341C104.622 40.2341 102.603 39.3068 100.992 37.3943ZM106.987 25.2187C103.7 25.2187 101.049 27.8864 101.049 31.2477C101.049 34.6687 103.7 37.2784 107.044 37.2784C110.446 37.2784 113.039 34.6108 113.039 31.2477C113.039 27.8864 110.388 25.2187 106.987 25.2187ZM121.11 37.3943V46.3807C121.168 46.8443 120.88 47.1341 120.419 47.1341H118.861C118.4 47.1341 118.112 46.9023 118.112 46.3807V23.1903C118.112 22.7267 118.342 22.4369 118.861 22.4369H120.302C120.764 22.379 121.053 22.6687 121.053 23.0744V24.9869C122.724 23.0744 124.798 22.1472 127.163 22.1472C132.12 22.1472 136.156 26.2619 136.156 31.1898C136.156 36.1176 132.178 40.2341 127.163 40.2341C124.742 40.2341 122.781 39.3068 121.11 37.3943ZM127.105 25.2187C123.819 25.2187 121.168 27.8864 121.168 31.2477C121.168 34.6687 123.819 37.2784 127.163 37.2784C130.564 37.2784 133.158 34.6108 133.158 31.2477C133.158 27.8864 130.507 25.2187 127.107 25.2187H127.105ZM153.97 32.3506H141.054C141.342 35.2483 143.995 37.4523 147.164 37.4523C148.893 37.4523 150.393 37.0466 151.719 36.0597C152.007 35.8858 152.295 35.7699 152.353 35.7699C152.583 35.7699 152.756 35.8858 152.929 36.1773L153.505 37.1625C153.622 37.3364 153.68 37.4523 153.68 37.5682C153.68 37.8 153.507 38.0318 153.103 38.3216C151.258 39.5966 149.183 40.292 146.992 40.292C141.688 40.292 137.883 36.3511 137.883 31.2477C137.883 26.204 141.803 22.2051 146.703 22.2051C151.546 22.2051 154.717 25.7983 154.717 31.0176C154.717 31.5972 154.717 32.3506 153.968 32.3506H153.97ZM141.056 30.0324H151.72C151.432 26.8432 149.473 24.929 146.648 24.929C145.241 24.8904 143.875 25.3995 142.833 26.3501C141.791 27.3007 141.154 28.6194 141.056 30.0307V30.0324ZM156.332 31.2477C156.332 26.3216 160.31 22.2051 165.326 22.2051C167.748 22.2051 169.707 23.1324 171.32 25.0449V16.2324C171.263 15.7687 171.551 15.479 172.012 15.479H173.57C174.031 15.479 174.319 15.7108 174.319 16.2324V39.3068C174.319 39.7705 174.088 40.0023 173.57 40.0023H172.129C171.666 40.0602 171.378 39.7705 171.378 39.3648V37.3943C169.649 39.3068 167.632 40.292 165.268 40.292C160.31 40.2341 156.332 36.1773 156.332 31.2477ZM171.264 31.2477C171.264 27.8284 168.612 25.2187 165.21 25.2187C161.924 25.2187 159.273 27.8864 159.273 31.2477C159.273 34.6687 161.924 37.2784 165.268 37.2784C166.057 37.2838 166.839 37.1316 167.569 36.8304C168.299 36.5292 168.962 36.0852 169.52 35.5241C170.077 34.963 170.519 34.296 170.818 33.5619C171.117 32.8277 171.268 32.0411 171.263 31.2477H171.264ZM177.72 19.0739C177.715 18.8594 177.754 18.646 177.833 18.4468C177.912 18.2476 178.031 18.0667 178.182 17.915C178.333 17.7633 178.512 17.6439 178.71 17.5642C178.909 17.4845 179.121 17.446 179.334 17.4511C179.546 17.4507 179.756 17.4923 179.952 17.5737C180.148 17.6551 180.326 17.7746 180.476 17.9254C180.626 18.0762 180.745 18.2553 180.826 18.4523C180.907 18.6494 180.948 18.8606 180.948 19.0739C180.953 19.2884 180.914 19.5017 180.835 19.7009C180.756 19.9001 180.637 20.081 180.486 20.2327C180.335 20.3845 180.156 20.5038 179.957 20.5835C179.759 20.6633 179.547 20.7017 179.334 20.6966C178.412 20.7545 177.72 20.0591 177.72 19.0739ZM177.836 39.2489V23.1903C177.836 22.7267 178.066 22.4369 178.527 22.4369H180.083C180.544 22.4369 180.832 22.6687 180.775 23.1903V39.2489C180.832 39.7125 180.544 39.9443 180.083 39.9443H178.527C178.066 39.9443 177.836 39.7125 177.836 39.2489ZM186.944 23.0165V24.1756C188.212 22.8426 189.71 22.2051 191.497 22.2051C195.937 22.2051 198.646 25.2767 198.646 29.3932V39.2489C198.703 39.7125 198.415 39.9443 197.954 39.9443H196.398C195.936 39.9443 195.705 39.7125 195.705 39.2489V29.4511C195.705 27.1329 193.803 25.2187 191.439 25.2187C189.134 25.2187 187.175 27.075 187.175 29.2773V39.3068C187.232 39.7705 186.944 40.0023 186.424 40.0023H184.868C184.407 40.0023 184.119 39.7705 184.119 39.3068V23.1903C184.061 22.7267 184.349 22.4949 184.868 22.4949H186.309C186.712 22.4949 186.944 22.6687 186.944 23.0165Z" />\n			<path d="M204 40C205.115 40 206 39.0857 206 38V37.9886C206 36.9029 205.126 36 204 36C202.885 36 202 36.9143 202 38V38.0114C202 39.0971 202.874 40 204 40ZM204 39.7829C202.989 39.7829 202.23 38.9829 202.23 38.0114V38C202.23 37.0286 203 36.2171 204 36.2171C205.011 36.2171 205.77 37.0171 205.77 37.9886V38C205.77 38.9714 205 39.7829 204 39.7829ZM203.218 38.9714H203.609V38.2743H204.034L204.517 38.9714H204.989L204.448 38.2057C204.724 38.1257 204.92 37.92 204.92 37.5886C204.92 37.1657 204.586 36.9486 204.138 36.9486H203.218V38.9714ZM203.609 37.9543V37.2914H204.103C204.368 37.2914 204.517 37.4057 204.517 37.6229C204.517 37.8171 204.368 37.9543 204.103 37.9543H203.609Z" />\n		</svg>'], ["share-16x16", '<svg viewBox="0 0 16 16">\n			<path\n				fillRule="evenodd"\n				clipRule="evenodd"\n				d="M13 6C14.6569 6 16 4.65685 16 3C16 1.34315 14.6569 0 13 0C11.3431 0 10 1.34315 10 3C10 3.13463 10.0089 3.26719 10.0261 3.39712L6.82972 5.17286C6.10576 4.44825 5.10523 4 4 4C1.79086 4 0 5.79086 0 8C0 10.2091 1.79086 12 4 12C5.10523 12 6.10576 11.5518 6.82972 10.8271L10.0261 12.6029C10.0089 12.7328 10 12.8654 10 13C10 14.6569 11.3431 16 13 16C14.6569 16 16 14.6569 16 13C16 11.3431 14.6569 10 13 10C12.2011 10 11.4752 10.3123 10.9376 10.8214L7.84579 9.1037C7.94622 8.75313 8 8.38284 8 8C8 7.61716 7.94622 7.24687 7.84579 6.8963L10.9376 5.17864C11.4752 5.68775 12.2011 6 13 6ZM13 4C13.5523 4 14 3.55228 14 3C14 2.44772 13.5523 2 13 2C12.4477 2 12 2.44772 12 3C12 3.55228 12.4477 4 13 4ZM4 10C5.10457 10 6 9.10457 6 8C6 6.89543 5.10457 6 4 6C2.89543 6 2 6.89543 2 8C2 9.10457 2.89543 10 4 10ZM14 13C14 13.5523 13.5523 14 13 14C12.4477 14 12 13.5523 12 13C12 12.4477 12.4477 12 13 12C13.5523 12 14 12.4477 14 13Z"\n				stroke="none"\n			/>\n		</svg>'], ["checkmark-16x16", '<svg viewBox="0 0 16 16">\n			<path\n				fillRule="evenodd"\n				clipRule="evenodd"\n				d="M15.387 3.31662C15.6008 3.49148 15.6323 3.80649 15.4574 4.02021L6.77402 14.6332C6.58509 14.8642 6.30292 14.9986 6.00457 15C5.70622 15.0013 5.42285 14.8694 5.23184 14.6402L0.551937 9.02429C0.375155 8.81215 0.403817 8.49687 0.615956 8.32009L1.38418 7.67991C1.59632 7.50312 1.9116 7.53179 2.08838 7.74392L5.99299 12.4295L13.9095 2.75374C14.0844 2.54002 14.3994 2.50852 14.6131 2.68338L15.387 3.31662Z"\n				stroke="none"\n			/>\n		</svg>'], ["arrow-right-16x16", '<svg viewBox="0 0 16 16">\n			<path\n				fillRule="evenodd"\n				clipRule="evenodd"\n				d="M8.35355 1.64645C8.54881 1.45118 8.8654 1.45118 9.06066 1.64645L14.7071 7.29289C15.0976 7.68342 15.0976 8.31658 14.7071 8.70711L9.06066 14.3536C8.8654 14.5488 8.54882 14.5488 8.35355 14.3536L7.64645 13.6464C7.45118 13.4512 7.45118 13.1346 7.64645 12.9393L11.5858 9H0.5C0.223858 9 0 8.77614 0 8.5V7.5C0 7.22386 0.223858 7 0.5 7H11.5858L7.64645 3.06066C7.45118 2.8654 7.45118 2.54882 7.64645 2.35355L8.35355 1.64645Z"\n				stroke="none"\n			/>\n		</svg>'], ["arrow-up-16x16", '<svg viewBox="0 0 16 16">\n			<path\n				fillRule="evenodd"\n				clipRule="evenodd"\n				d="M8.00015 0.5C8.34685 0.5 8.67835 0.642318 8.91714 0.893677L15.6517 7.98267C15.8441 8.18525 15.8359 8.50548 15.6333 8.69793L14.533 9.7433C14.3304 9.93575 14.0101 9.92754 13.8177 9.72496L9.26497 4.93262V15.4249C9.26497 15.7043 9.03846 15.9308 8.75904 15.9308H7.24125C6.96184 15.9308 6.73532 15.7043 6.73532 15.4249V4.93262L2.1826 9.72496C1.99015 9.92754 1.66992 9.93575 1.46734 9.7433L0.366945 8.69793C0.164367 8.50548 0.156156 8.18525 0.348604 7.98267L7.08315 0.893677C7.32194 0.642318 7.65344 0.5 8.00015 0.5Z"\n				stroke="none"\n			/>\n		</svg>'], ["connection-stairs-16x16", '<svg viewBox="0 0 16 16">\n			<g stroke="none">\n				<path d="M1 11.5C1 11.2239 1.22386 11 1.5 11H6V13.5C6 13.7761 5.77614 14 5.5 14H1.5C1.22386 14 1 13.7761 1 13.5V11.5Z" />\n				<path d="M4 8.5C4 8.22386 4.22386 8 4.5 8H9V10.5C9 10.7761 8.77614 11 8.5 11H4V8.5Z" />\n				<path d="M7 5.5C7 5.22386 7.22386 5 7.5 5H12V7.5C12 7.77614 11.7761 8 11.5 8H7V5.5Z" />\n				<path d="M10 2.5C10 2.22386 10.2239 2 10.5 2H14.5C14.7761 2 15 2.22386 15 2.5V4.5C15 4.77614 14.7761 5 14.5 5H10V2.5Z" />\n			</g>\n		</svg>'], ["connection-stairs-14x14", '<svg viewBox="0 0 14 14">\n			<path\n				d="M5.25 12H2.5C2.225 12 2 11.7429 2 11.4286C2 11.1143 2.225 10.8571 2.5 10.8571H4.25V7.91429H6.5V4.94286H8.75V2H11.5C11.775 2 12 2.25714 12 2.57143C12 2.88571 11.775 3.14286 11.5 3.14286H9.75V6.08571H7.5V9.02857H5.25V12Z"\n				stroke="none"\n			/>\n		</svg>'], ["connection-stairs-12x12", '<svg viewBox="0 0 12 12" stroke="none">\n			<path d="M1.625 8.1875C1.625 8.01491 1.76491 7.875 1.9375 7.875H4.75V9.4375C4.75 9.61009 4.61009 9.75 4.4375 9.75H1.9375C1.76491 9.75 1.625 9.61009 1.625 9.4375V8.1875Z" />\n			<path d="M3.5 6.3125C3.5 6.13991 3.63991 6 3.8125 6H6.625V7.5625C6.625 7.73509 6.48509 7.875 6.3125 7.875H3.5V6.3125Z" />\n			<path d="M5.375 4.4375C5.375 4.26491 5.51491 4.125 5.6875 4.125H8.5V5.6875C8.5 5.86009 8.36009 6 8.1875 6H5.375V4.4375Z" />\n			<path d="M7.25 2.5625C7.25 2.38991 7.38991 2.25 7.5625 2.25H10.0625C10.2351 2.25 10.375 2.38991 10.375 2.5625V3.8125C10.375 3.98509 10.2351 4.125 10.0625 4.125H7.25V2.5625Z" />\n		</svg>'], ["connection-escalator-16x16", '<svg viewBox="0 0 16 16">\n			<g stroke="none">\n				<path d="M3.63008 12H2C0.895431 12 0 12.8954 0 14C0 15.1046 0.89543 16 2 16H4.63008C4.86879 16 5.09962 15.9146 5.28087 15.7593L11.7191 10.2407C11.9004 10.0854 12.1312 10 12.3699 10H14C15.1046 10 16 9.10457 16 8C16 6.89543 15.1046 6 14 6H11.3699C11.1312 6 10.9004 6.08539 10.7191 6.24074L4.28087 11.7593C4.09962 11.9146 3.86879 12 3.63008 12Z" />\n				<path d="M5 6C5 4.89543 5.89543 4 7 4C8.10457 4 9 4.89543 9 6L5 9.5V6Z" />\n				<path d="M9 2C9 3.10457 8.10457 4 7 4C5.89543 4 5 3.10457 5 2C5 0.89543 5.89543 0 7 0C8.10457 0 9 0.89543 9 2Z" />\n			</g>\n		</svg>'], ["connection-escalator-14x14", '<svg viewBox="0 0 14 14">\n			<path\n				d="M5.26686 2.98522C5.26686 2.44335 5.71573 2 6.26436 2C6.81299 2 7.26187 2.44335 7.26187 2.98522C7.26187 3.5271 6.81299 3.97045 6.26436 3.97045C5.71573 3.97045 5.26686 3.50246 5.26686 2.98522Z"\n				stroke="none"\n			/>\n			<path\n				d="M7.26188 5.48588V5.25125C7.26188 4.85716 6.91275 4.53696 6.48881 4.53696H6.03993C5.61599 4.53696 5.26687 4.88179 5.26687 5.25125V7.66458L4.3192 8.6995H3.67082C2.74813 8.6995 2 9.43842 2 10.3498C2 11.2611 2.74813 12 3.67082 12H4.61845C5.36658 12 6.11471 11.6798 6.61347 11.1133L9.6808 7.76354H10.3292C11.2519 7.76354 12 7.02463 12 6.11329C12 5.20196 11.2519 4.46305 10.3292 4.46305H9.38155C8.60848 4.46305 7.88529 4.78324 7.38653 5.34975L7.26188 5.48588ZM4.61846 11.0148H3.67083C3.29677 11.0148 2.99751 10.7192 2.99751 10.3498C2.99751 9.9803 3.29677 9.68473 3.67083 9.68473H4.61846C4.71821 9.68473 4.81796 9.63547 4.86784 9.56158L8.13467 5.99015C8.45886 5.64532 8.90774 5.44828 9.38155 5.44828H10.3292C10.7032 5.44828 11.0025 5.74384 11.0025 6.1133C11.0025 6.48276 10.7032 6.77833 10.3292 6.77833H9.38155C9.2818 6.77833 9.18205 6.82759 9.13218 6.87685L5.86534 10.4729C5.54115 10.8177 5.09228 11.0148 4.61846 11.0148Z"\n				stroke="none"\n			/>\n		</svg>'], ["connection-elevator-16x16", '<svg viewBox="0 0 16 16">\n			<g stroke="none">\n				<path d="M3 5.5C3 6.32843 2.32843 7 1.5 7C0.671573 7 0 6.32843 0 5.5C0 4.67157 0.671573 4 1.5 4C2.32843 4 3 4.67157 3 5.5Z" />\n				<path d="M3 10.5C3 11.3284 2.32843 12 1.5 12C0.671573 12 0 11.3284 0 10.5C0 9.67157 0.671573 9 1.5 9C2.32843 9 3 9.67157 3 10.5Z" />\n				<path d="M11 1H14C14.5523 1 15 1.44772 15 2V14C15 14.5523 14.5523 15 14 15H11V1Z" />\n				<path d="M9 1H6C5.44772 1 5 1.44772 5 2V14C5 14.5523 5.44772 15 6 15H9V1Z" />\n			</g>\n		</svg>'], ["connection-elevator-14x14", '<svg viewBox="0 0 14 14">\n			<path\n				d="M7.476 2H2.72693C1.77095 2 1 2.72464 1 3.62319V10.3768C1 11.2754 1.77095 12 2.72693 12H7.476C8.43198 12 9.20293 11.2754 9.20293 10.3768V3.62319C9.17209 2.72464 8.40114 2 7.476 2ZM7.476 3.15942C7.75354 3.15942 7.96941 3.36232 7.96941 3.62319V10.3768C7.96941 10.6377 7.75354 10.8406 7.476 10.8406H5.71824V3.15942H7.476ZM4.48472 3.15942V10.8406H2.72693C2.44939 10.8406 2.23352 10.6377 2.23352 10.3768V3.62319C2.23352 3.36232 2.44939 3.15942 2.72693 3.15942H4.48472Z"\n				stroke="none"\n			/>\n			<path\n				d="M12.4643 6.19064H10.6638C10.4456 6.19064 10.2546 6.06243 10.1728 5.88294C10.0909 5.70346 10.1455 5.47269 10.2819 5.31884L11.1821 4.47269C11.4004 4.26756 11.755 4.26756 11.946 4.47269L12.8462 5.31884C13.0099 5.47269 13.0371 5.67781 12.9553 5.88294C12.8735 6.08807 12.6825 6.19064 12.4643 6.19064Z"\n				stroke="none"\n			/>\n			<path\n				d="M11.564 9.65216C11.4276 9.65216 11.2912 9.60088 11.1821 9.49831L10.2819 8.65216C10.1182 8.49831 10.0909 8.29319 10.1728 8.08806C10.2546 7.90857 10.4456 7.78036 10.6638 7.78036H12.4643C12.6825 7.78036 12.8735 7.90857 12.9553 8.08806C13.0371 8.26754 12.9826 8.49831 12.8462 8.65216L11.9459 9.49831C11.8641 9.60088 11.7004 9.65216 11.564 9.65216Z"\n				stroke="none"\n			/>\n		</svg>'], ["connection-elevator-12x12", '<svg viewBox="0 0 12 12" stroke="none">\n			<circle cx="1.9375" cy="4.4375" r="0.9375" />\n			<circle cx="1.9375" cy="7.5625" r="0.9375" />\n			<path\n				fillRule="evenodd"\n				clipRule="evenodd"\n				d="M7.6 2H9.4C9.73137 2 10 2.26863 10 2.6V9.41328C10 9.74465 9.73137 10.0133 9.4 10.0133H7.6V2ZM6.4 2H4.6C4.26863 2 4 2.26863 4 2.6V9.41328C4 9.74465 4.26863 10.0133 4.6 10.0133H6.4V2Z"\n			/>\n		</svg>'], ["new-tab-14x14", '<svg viewBox="0 0 14 14">\n			<g stroke="none">\n				<path d="M2.625 2.625H5.6875C5.92913 2.625 6.125 2.42912 6.125 2.1875V1.3125C6.125 1.07088 5.92913 0.875 5.6875 0.875H1.3125C1.07088 0.875 0.875 1.07088 0.875 1.3125V12.6875C0.875 12.9291 1.07088 13.125 1.3125 13.125H12.6875C12.9291 13.125 13.125 12.9291 13.125 12.6875V8.3125C13.125 8.07088 12.9291 7.875 12.6875 7.875H11.8125C11.5709 7.875 11.375 8.07088 11.375 8.3125V11.375H2.625V2.625Z" />\n				<path d="M12.9063 0.875H8.40311C8.20822 0.875 8.11063 1.11062 8.24843 1.24843L9.88124 2.88124L5.8156 6.94688C5.64475 7.11774 5.64475 7.39475 5.8156 7.5656L6.43432 8.18432C6.60517 8.35517 6.88218 8.35517 7.05304 8.18432L11.1187 4.11868L12.7516 5.75157C12.8894 5.88938 13.125 5.79178 13.125 5.59689V1.09375C13.125 0.972938 13.0271 0.875 12.9063 0.875Z" />\n			</g>\n		</svg>'], ["compress-16x16", '<svg viewBox="0 0 16 16">\n			<g stroke="none">\n				<path\n					id="Vector"\n					d="M4.67773 10.7154H0.713449C0.556306 10.7154 0.427734 10.844 0.427734 11.0011V11.8583C0.427734 12.0154 0.556306 12.144 0.713449 12.144H3.82059V15.2868C3.82059 15.444 3.94916 15.5725 4.10631 15.5725H4.96345C5.12059 15.5725 5.24916 15.444 5.24916 15.2868V11.2868C5.24916 10.9708 4.99381 10.7154 4.67773 10.7154ZM4.96345 0.429688H4.10631C3.94916 0.429688 3.82059 0.558259 3.82059 0.715402V3.85826H0.713449C0.556306 3.85826 0.427734 3.98683 0.427734 4.14397V5.00112C0.427734 5.15826 0.556306 5.28683 0.713449 5.28683H4.67773C4.99381 5.28683 5.24916 5.03147 5.24916 4.7154V0.715402C5.24916 0.558259 5.12059 0.429688 4.96345 0.429688ZM15.2849 10.7154H11.3206C11.0045 10.7154 10.7492 10.9708 10.7492 11.2868V15.2868C10.7492 15.444 10.8777 15.5725 11.0349 15.5725H11.892C12.0492 15.5725 12.1777 15.444 12.1777 15.2868V12.144H15.2849C15.442 12.144 15.5706 12.0154 15.5706 11.8583V11.0011C15.5706 10.844 15.442 10.7154 15.2849 10.7154ZM15.2849 3.85826H12.1777V0.715402C12.1777 0.558259 12.0492 0.429688 11.892 0.429688H11.0349C10.8777 0.429688 10.7492 0.558259 10.7492 0.715402V4.7154C10.7492 5.03147 11.0045 5.28683 11.3206 5.28683H15.2849C15.442 5.28683 15.5706 5.15826 15.5706 5.00112V4.14397C15.5706 3.98683 15.442 3.85826 15.2849 3.85826Z"\n				/>\n			</g>\n		</svg>'], ["washroom-14x14", '<svg viewBox="0 0 14 14" stroke="none">\n			<path d="M4.55125 3.09062C4.55125 3.69326 4.07639 4.18176 3.49058 4.18176C2.90525 4.18176 2.43039 3.69326 2.43039 3.09062C2.43039 2.4885 2.90525 2 3.49058 2C4.07639 2 4.55125 2.4885 4.55125 3.09062Z" />\n			<path d="M5.1193 5.48047C4.81653 4.83116 4.17252 4.41571 3.47822 4.41571C2.78392 4.41571 2.13986 4.83116 1.83714 5.48047L1.04175 7.22034C0.940664 7.441 1.02893 7.70073 1.24393 7.81791C1.47077 7.90871 1.72324 7.81791 1.82433 7.59725L2.49349 6.15554L2.21587 11.4407C2.20305 11.7263 2.41805 11.9734 2.69567 11.9993C2.97329 12.0124 3.21344 11.7913 3.23859 11.5057L3.4028 8.285H3.567L3.73121 11.5057C3.74403 11.7913 3.97086 11.9993 4.23616 11.9993H4.26131C4.53893 11.9861 4.75343 11.7395 4.74111 11.4407L4.46349 6.15554L5.13265 7.59725C5.20858 7.75298 5.35997 7.85697 5.52418 7.85697C5.5873 7.85697 5.65042 7.84379 5.71354 7.81792C5.92804 7.71393 6.0163 7.44153 5.91572 7.22035L5.1193 5.48047Z" />\n			<path d="M12.9582 7.22034L12.1505 5.48047C11.8477 4.83116 11.2037 4.41571 10.5094 4.41571C9.81513 4.41571 9.17107 4.83116 8.86836 5.48047L8.06064 7.22034C7.95955 7.441 8.04782 7.70073 8.26282 7.81791C8.47732 7.9219 8.7298 7.8311 8.84371 7.60993L9.52519 6.12977L9.46207 7.2204L8.57842 8.92184C8.47733 9.11663 8.61638 9.36316 8.83089 9.36316H9.33584L9.22242 11.4668C9.2096 11.7397 9.41177 11.9862 9.68939 11.9994C9.95469 12.0126 10.1943 11.8046 10.2072 11.519L10.3581 9.33723H10.6737L10.7871 11.5058C10.7999 11.7787 11.0144 11.9862 11.2792 11.9862H11.3043C11.5696 11.973 11.7841 11.7396 11.7713 11.4535L11.6579 9.33718H12.1628C12.3773 9.33718 12.5287 9.09066 12.4153 8.89586L11.5317 7.19442L11.4685 6.1038L12.1757 7.5972C12.2516 7.75293 12.403 7.85692 12.5672 7.85692C12.6303 7.85692 12.6934 7.84373 12.7566 7.81786C12.9711 7.70068 13.0593 7.44102 12.9582 7.22034Z" />\n			<path d="M11.5696 3.09062C11.5696 3.69326 11.0948 4.18176 10.5094 4.18176C9.92363 4.18176 9.44876 3.69326 9.44876 3.09062C9.44876 2.4885 9.92363 2 10.5094 2C11.0948 2 11.5696 2.4885 11.5696 3.09062Z" />\n			<path d="M6.99996 2.00006C6.76031 2.00006 6.57095 2.19485 6.57095 2.44138V11.5575C6.57095 11.804 6.76031 11.9988 6.99996 11.9988C7.2396 11.9988 7.42896 11.804 7.42896 11.5575V2.44138C7.42896 2.19485 7.2396 2.00006 6.99996 2.00006Z" />\n		</svg>'], ["point-of-interest-12x12", '<svg viewBox="0 0 12 12" stroke="none">\n			<path\n				stroke="none"\n				id="Subtract"\n				// Do not change these to fillRule or clipRule, since they need to be rendered as actual SVGs in labels, not React SVGs\n				fill-rule="evenodd"\n				clip-rule="evenodd"\n				d="M6.24724 10.7516C7.94597 9.0358 9.85962 6.89195 9.85962 4.85965C9.85962 2.72802 8.13159 1 5.99997 1C3.86834 1 2.14032 2.72802 2.14032 4.85965C2.14032 6.89195 4.05397 9.0358 5.7527 10.7516C5.88904 10.8893 6.1109 10.8893 6.24724 10.7516ZM5.99994 6.26317C6.77508 6.26317 7.40345 5.6348 7.40345 4.85967C7.40345 4.08453 6.77508 3.45616 5.99994 3.45616C5.22481 3.45616 4.59644 4.08453 4.59644 4.85967C4.59644 5.6348 5.22481 6.26317 5.99994 6.26317Z"\n			/>\n		</svg>'], ["flag-20x20", '<svg viewBox="0 0 20 20" stroke="none">\n			<path\n				d="M16.9987 4.27111C16.936 5.06715 16.3836 5.93162 15.5238 6.57845C14.7549 7.15682 13.0885 8.04927 10.5434 7.55174C8.32167 7.1164 6.82156 8.02129 6.08085 10.2416L8.24615 17.3998C8.31833 17.6471 8.17711 17.9059 7.9292 17.9813C7.88527 17.9938 7.83976 18 7.79426 18C7.58634 18 7.40277 17.8647 7.34236 17.6673L5.1644 10.4686C5.13773 10.4173 5.12125 10.3613 5.11419 10.3038L3.41956 4.70042C3.38112 4.63512 3.35994 4.56127 3.3568 4.48587L3.02101 3.37886C2.98413 3.25992 2.9959 3.13165 3.05553 3.02203C3.11437 2.91242 3.21479 2.83079 3.33482 2.79504C3.45564 2.75928 3.5851 2.7725 3.69494 2.83235C3.80477 2.89144 3.88637 2.99172 3.92167 3.11143L3.9813 3.31355C4.38847 2.85956 4.90472 2.51439 5.48136 2.30915C6.97201 1.75566 8.95216 1.95467 10.6469 2.83156C11.6888 3.36951 14.3374 4.54493 16.3647 3.79553C16.5154 3.74111 16.684 3.76599 16.8127 3.86239C16.9406 3.95879 17.0105 4.11251 16.9987 4.27111Z"\n				stroke="none"\n			/>\n		</svg>'], ["link-16x16", '<svg viewBox="0 0 16 16" stroke="none">\n			<path\n				d="M9.10678 11.2433C9.07993 11.2167 9.04367 11.2018 9.00589 11.2018C8.9681 11.2018 8.93184 11.2167 8.90499 11.2433L6.82999 13.3183C5.86928 14.279 4.24785 14.3808 3.18714 13.3183C2.12464 12.2558 2.22642 10.6362 3.18714 9.67546L5.26214 7.60046C5.31749 7.5451 5.31749 7.45403 5.26214 7.39868L4.55142 6.68796C4.52457 6.66138 4.48832 6.64646 4.45053 6.64646C4.41274 6.64646 4.37649 6.66138 4.34964 6.68796L2.27464 8.76296C0.763923 10.2737 0.763923 12.7183 2.27464 14.2272C3.78535 15.7362 6.22999 15.738 7.73892 14.2272L9.81392 12.1522C9.86928 12.0969 9.86928 12.0058 9.81392 11.9505L9.10678 11.2433ZM13.7246 2.77903C12.2139 1.26832 9.76928 1.26832 8.26035 2.77903L6.18357 4.85403C6.15698 4.88088 6.14207 4.91714 6.14207 4.95493C6.14207 4.99271 6.15698 5.02897 6.18357 5.05582L6.89249 5.76475C6.94785 5.8201 7.03892 5.8201 7.09428 5.76475L9.16928 3.68975C10.13 2.72903 11.7514 2.62725 12.8121 3.68975C13.8746 4.75225 13.7729 6.37189 12.8121 7.3326L10.7371 9.4076C10.7106 9.43445 10.6956 9.47071 10.6956 9.5085C10.6956 9.54628 10.7106 9.58254 10.7371 9.60939L11.4479 10.3201C11.5032 10.3755 11.5943 10.3755 11.6496 10.3201L13.7246 8.2451C15.2336 6.73439 15.2336 4.28975 13.7246 2.77903ZM9.75142 6.00939C9.72457 5.9828 9.68832 5.96789 9.65053 5.96789C9.61275 5.96789 9.57649 5.9828 9.54964 6.00939L5.50499 10.0522C5.47841 10.0791 5.46349 10.1154 5.46349 10.1531C5.46349 10.1909 5.47841 10.2272 5.50499 10.254L6.21214 10.9612C6.26749 11.0165 6.35857 11.0165 6.41392 10.9612L10.4568 6.91832C10.5121 6.86296 10.5121 6.77189 10.4568 6.71653L9.75142 6.00939Z"\n				stroke="none"\n			/>\n		</svg>']]);
var Kw = /<svg([^>]*)>/g;
function _S(r3, t3, e2) {
  let i = Qw.get(r3);
  return i ? i.replace(Kw, '<svg$1 style="fill:'.concat(t3, "; width:").concat(e2, "px; height:").concat(e2, 'px">')) : "";
}
var eD = (r3) => '\n		<div class="pin-shadow" style="background: '.concat(r3, '"></div>\n		<svg width="').concat(20 * 0.9, 'px" height="').concat(48 * 0.9, 'px" viewBox="0 0 20 48">\n			<path\n				d="M1.37965 29.3246C1.5778 31.2167 2.27661 33.0694 3.83078 33.775C4.0998 37.1861 4.7451 40.2227 5.65918 42.4784C6.14556 43.6787 6.72883 44.71 7.41453 45.4578C8.10027 46.2056 8.97065 46.7527 9.99989 46.7527C11.0292 46.7527 11.8995 46.2055 12.585 45.4576C13.2706 44.7098 13.8536 43.6785 14.3398 42.4783C15.2536 40.2226 15.8988 37.186 16.1688 33.7752C17.7232 33.0697 18.422 31.2169 18.6201 29.3247C18.8386 27.2385 18.5165 24.6502 17.6475 22.0285L17.6473 22.0278C16.9657 19.9761 16.0319 18.1622 14.9848 16.7474C17.0884 15.1587 18.4471 12.5964 18.4471 9.7152C18.4471 4.93539 14.6967 1 9.99966 1C5.30272 1 1.54993 4.93527 1.54993 9.7152C1.54993 12.5961 2.90839 15.1583 5.01167 16.747C3.9635 18.1625 3.03185 19.977 2.3522 22.0286C1.48319 24.6503 1.16118 27.2385 1.37965 29.3246Z"\n				fill="').concat(r3, '"\n				stroke="white"\n				strokeWidth="2"\n			/>\n		</svg>\n	');
var tD = (r3) => '\n		<div class="pin-shadow" style="background: '.concat(r3, '"></div>\n		<svg width="36" height="42" viewBox="-2 -2 40 46">\n			<path\n				d="M35.8372 5.86776C35.6765 7.92448 34.2625 10.158 32.0612 11.8292C30.0929 13.3235 25.8269 15.6292 19.3114 14.3438C13.6237 13.219 9.78333 15.5569 7.88708 21.2934L13.4303 39.7879C13.6151 40.4267 13.2536 41.0955 12.6189 41.2903C12.5064 41.3225 12.39 41.3385 12.2735 41.3385C11.7412 41.3385 11.2712 40.989 11.1166 40.4789L5.54093 21.88C5.47265 21.7474 5.43047 21.6028 5.41239 21.4542L1.07409 6.97696C0.975678 6.80825 0.921449 6.61744 0.913417 6.42263L0.053779 3.56251C-0.0406172 3.2552 -0.0104927 2.92379 0.142154 2.64058C0.29279 2.35738 0.549874 2.14649 0.857157 2.05411C1.16646 1.96172 1.49786 1.99587 1.77906 2.15052C2.06025 2.30317 2.26912 2.56226 2.35951 2.87155L2.51215 3.39375C3.55453 2.22081 4.87615 1.32902 6.35237 0.798742C10.1685 -0.631292 15.2377 -0.117113 19.5763 2.14846C22.2435 3.53834 29.0241 6.57524 34.2141 4.63904C34.5998 4.49845 35.0316 4.56272 35.361 4.81178C35.6884 5.06083 35.8673 5.45801 35.8372 5.86776Z"\n				fill="none"\n				stroke="white"\n				strokeWidth="4"\n			/>\n			<path\n				d="M35.8372 5.86776C35.6765 7.92448 34.2625 10.158 32.0612 11.8292C30.0929 13.3235 25.8269 15.6292 19.3114 14.3438C13.6237 13.219 9.78333 15.5569 7.88708 21.2934L13.4303 39.7879C13.6151 40.4267 13.2536 41.0955 12.6189 41.2903C12.5064 41.3225 12.39 41.3385 12.2735 41.3385C11.7412 41.3385 11.2712 40.989 11.1166 40.4789L5.54093 21.88C5.47265 21.7474 5.43047 21.6028 5.41239 21.4542L1.07409 6.97696C0.975678 6.80825 0.921449 6.61744 0.913417 6.42263L0.053779 3.56251C-0.0406172 3.2552 -0.0104927 2.92379 0.142154 2.64058C0.29279 2.35738 0.549874 2.14649 0.857157 2.05411C1.16646 1.96172 1.49786 1.99587 1.77906 2.15052C2.06025 2.30317 2.26912 2.56226 2.35951 2.87155L2.51215 3.39375C3.55453 2.22081 4.87615 1.32902 6.35237 0.798742C10.1685 -0.631292 15.2377 -0.117113 19.5763 2.14846C22.2435 3.53834 29.0241 6.57524 34.2141 4.63904C34.5998 4.49845 35.0316 4.56272 35.361 4.81178C35.6884 5.06083 35.8673 5.45801 35.8372 5.86776Z"\n				fill="').concat(r3, '"\n			/>\n		</svg>\n    ');
var qy = "#722ED1";
var $y2 = "#1890FF";
var RS = ({ type: r3 = "departure", color: t3 = $y2 }) => '<div class="dropped-pin-wrapper">\n			'.concat(r3 === "departure" ? eD(t3) : tD(t3), "\n		</div>");
var rD = (r3) => {
  switch (r3) {
    case "default":
      return 28;
    case "selection":
      return 28;
    case "navigation":
      return 32;
  }
};
var NS = ({ type: r3 = "stairs", color: t3 = qy, direction: e2 = "up" }) => {
  let i = rD("default"), o = i / 2 + 2, n = e2 && e2 !== "none";
  return '<div class="mappedin-connection-marker">\n			<div class="connection-circle"\n				role="button"\n                style="background:'.concat(t3, "; width:").concat(i, "px; height:").concat(i, 'px;"\n			>\n                ').concat(_S("connection-" + r3 + "-16x16", "white", o) || "", "\n			</div>\n			").concat(n ? '<div style="margin-left: -'.concat(i * 0.2, 'px;">\n					<div class="bouncey">\n						<div class="connection-circle"\n							role="button"\n							style="width: ').concat(i, "px; height: ").concat(i, 'px;">\n							<div class="').concat(e2 === "up" ? "" : "arrow--down", '">\n                                <svg viewBox="0 0 16 16" style="fill: white; width: ').concat(o, "px; height: ").concat(o, 'px">\n                                    <path\n                                        fillRule="evenodd"\n                                        clipRule="evenodd"\n                                        d="M8.00015 0.5C8.34685 0.5 8.67835 0.642318 8.91714 0.893677L15.6517 7.98267C15.8441 8.18525 15.8359 8.50548 15.6333 8.69793L14.533 9.7433C14.3304 9.93575 14.0101 9.92754 13.8177 9.72496L9.26497 4.93262V15.4249C9.26497 15.7043 9.03846 15.9308 8.75904 15.9308H7.24125C6.96184 15.9308 6.73532 15.7043 6.73532 15.4249V4.93262L2.1826 9.72496C1.99015 9.92754 1.66992 9.93575 1.46734 9.7433L0.366945 8.69793C0.164367 8.50548 0.156156 8.18525 0.348604 7.98267L7.08315 0.893677C7.32194 0.642318 7.65344 0.5 8.00015 0.5Z"\n                                        stroke="none"\n                                    />\n                                </svg>\n							</div>\n						</div>\n					</div>\n				</div>') : "", "\n		</div>");
};
c();
var GS = async (r3) => new Promise((t3) => setTimeout(t3, r3));
var iD = { drawDuration: 1e3, color: "#40A9FF", interactive: false, accentColor: "blue", nearRadius: 0.25, farRadius: 0.25 * 4, displayArrowsOnPath: false, animateArrowsOnPath: false };
var oD = { drawDuration: 1e3, color: "#B3DDFF", interactive: false, accentColor: "#40A9FF", nearRadius: 0.25, farRadius: 0.25 * 4, displayArrowsOnPath: false, animateArrowsOnPath: false };
var la = { setMapOnConnectionClick: true, setMapToDeparture: true, createMarkers: { departure: true, destination: true, connection: true }, pathOptions: iD, inactivePathOptions: oD, markerOptions: { departureColor: $y2, destinationColor: qy } };
var ji2;
var Or;
var Ui;
var he;
var bp2;
var Hi;
var ca2;
var Xe;
var Lr;
var Vt;
var Ar;
var Qo;
var Ne;
var VS;
var jS;
var Jy;
var Qh;
var Rs;
var Qy;
var Ns;
var yp2 = class {
  constructor(t3, e2, i) {
    v(this, Ne);
    v(this, ji2, /* @__PURE__ */ new Map());
    v(this, Or);
    v(this, Ui);
    v(this, he, la);
    v(this, bp2);
    v(this, Hi);
    v(this, ca2);
    v(this, Xe, []);
    v(this, Lr);
    v(this, Vt, /* @__PURE__ */ new Map());
    v(this, Ar, /* @__PURE__ */ new Map());
    v(this, Qo, /* @__PURE__ */ new Map());
    v(this, Ns, (t4) => {
      var e3;
      if ((e3 = u(this, he).createMarkers) != null && e3.connection && t4.markers.length > 0) {
        let { instruction: i2 } = u(this, ji2).get(t4.markers[0]);
        i2 != null && i2.action.toFloor && (u(this, he).setMapOnConnectionClick && this.currentMap.setFloor(i2.action.toFloor.id, "navigation-connection-click"), this.currentMap.publish("navigation-connection-click", { instruction: i2, fromFloor: i2.action.fromFloor, toFloor: i2.action.toFloor }));
      }
    });
    w(this, Or, t3), w(this, bp2, i), w(this, Ui, e2);
  }
  get currentMap() {
    return u(this, bp2).call(this);
  }
  get isMultiFloor() {
    if (!u(this, Xe).length) return false;
    let t3 = /* @__PURE__ */ new Set();
    for (let e2 of u(this, Xe)) for (let i of e2.coordinates) if (i.floorId && (t3.add(i.floorId), t3.size > 1)) return true;
    return false;
  }
  getPathById(t3) {
    return u(this, Vt).get(t3);
  }
  getMarkerById(t3) {
    return u(this, ji2).get(t3);
  }
  get paths() {
    let t3 = /* @__PURE__ */ new Set();
    return u(this, Vt).forEach(({ path: e2 }) => t3.add(e2)), Array.from(t3);
  }
  get activeDirections() {
    return u(this, Qo).get(u(this, Lr));
  }
  get activePath() {
    var t3;
    if (u(this, Lr)) return (t3 = u(this, Vt).get(u(this, Lr).id)) == null ? void 0 : t3.path;
  }
  get floorStacks() {
    let t3 = u(this, Ui).getMapData();
    if (!u(this, Xe).length || !t3) return [];
    let e2 = /* @__PURE__ */ new Set();
    for (let i of u(this, Xe)) for (let o of i.coordinates) if (o.floorId) {
      let n = t3.getById("floor", o.floorId);
      n && e2.add(n.floorStack);
    }
    return Array.from(e2);
  }
  get floors() {
    let t3 = u(this, Ui).getMapData();
    if (!u(this, Xe).length || !t3) return [];
    let e2 = /* @__PURE__ */ new Set();
    for (let i of u(this, Xe)) for (let o of i.coordinates) if (o.floorId) {
      let n = t3.getById("floor", o.floorId);
      n && e2.add(n);
    }
    return Array.from(e2);
  }
  setActivePathByIndex(t3) {
    let e2 = u(this, Xe)[t3];
    if (!u(this, Xe).length) {
      Lt.warn("Cannot set an active path before drawing. Call Navigation.draw() first.");
      return;
    }
    if (!u(this, Xe)[t3]) {
      Lt.warn("Direction #".concat(t3, " does not exist"));
      return;
    }
    let i = u(this, Ar).get(e2);
    if (!i) {
      Lt.warn("The direction is not a part of muli-direcional path");
      return;
    }
    x(this, Ne, Qh).call(this, i);
  }
  setActivePath(t3) {
    if (!u(this, Xe).length) {
      Lt.warn("Cannot set an active path before drawing. Call Navigation.draw() first.");
      return;
    }
    if (!u(this, Qo).get(t3)) {
      Lt.warn('Path "'.concat(t3.id, '" is not a part of muli-direcional path'));
      return;
    }
    x(this, Ne, Qh).call(this, t3);
  }
  setActivePathByDirections(t3) {
    if (!u(this, Xe).length) {
      Lt.warn("Cannot set an active path before drawing. Call Navigation.draw() first.");
      return;
    }
    let e2 = u(this, Ar).get(t3);
    if (!e2) {
      Lt.warn("The direction is not a part of muli-direcional path");
      return;
    }
    x(this, Ne, Qh).call(this, e2);
  }
  drawSync(t3, e2 = {}) {
    var c2, l, p;
    u(this, ca2) && this.clear(), w(this, ca2, true), x(this, Ne, Jy).call(this, e2);
    let i = Array.isArray(t3) ? t3 : [t3], o = i[0], n = i[i.length - 1], s2 = o.coordinates[0];
    w(this, Xe, i), s2.floorId && u(this, he).setMapToDeparture && this.currentMap.setFloor(s2.floorId), (c2 = u(this, he).createMarkers) != null && c2.departure && x(this, Ne, Rs).call(this, o.coordinates[0], "departure", o.instructions[0]);
    for (let d = 0; d < i.length; d++) {
      let f = i[d], g = d ? { ...u(this, he).inactivePathOptions } : { ...u(this, he).pathOptions };
      if (f.coordinates.length < 2) {
        Lt.warn("Directions must have at least 2 coordinates");
        return;
      }
      let v2 = this.currentMap.Paths.add(f.coordinates, g), b = v2.paths.map((y) => y.id.toString()), C = new Er2(tt(), v2.animation, f.coordinates, v2.paths);
      for (let y of b) {
        u(this, Vt).set(y, { path: C, entityIds: b });
        let S = d ? { ...u(this, he).inactivePathOptions, altitude: 0 } : { ...u(this, he).pathOptions, altitude: 0.05 };
        u(this, Or).setState(y, S);
      }
      u(this, Vt).set(C.id, { path: C, entityIds: b }), u(this, Ar).set(f, C), u(this, Qo).set(C, f), (l = u(this, he).createMarkers) != null && l.connection && x(this, Ne, Qy).call(this, f.instructions, "connection"), d === 0 && (w(this, Lr, u(this, Ar).get(u(this, Xe)[0])), u(this, Or).on("click", u(this, Ns)));
    }
    (p = u(this, he).createMarkers) != null && p.destination && x(this, Ne, Rs).call(this, n.coordinates[n.coordinates.length - 1], "destination", n.instructions[n.instructions.length - 1]), u(this, Ui).mapObjects.forEach((d) => {
      d.processFloorChange(d.currentFloorId);
    });
  }
  async draw(t3, e2 = {}) {
    u(this, Hi) && this.clear(), x(this, Ne, Jy).call(this, e2);
    let i = Array.isArray(t3) ? t3 : [t3], n = i[0].coordinates[0];
    return w(this, Xe, i), n.floorId && u(this, he).setMapToDeparture && this.currentMap.setFloor(n.floorId), x(this, Ne, jS).call(this, i);
  }
  clear() {
    u(this, ji2).forEach((t3, e2) => {
      this.currentMap.Markers.remove(e2.toString());
    }), u(this, ji2).clear(), u(this, Vt).forEach(({ path: t3, entityIds: e2 }) => {
      u(this, Vt).delete(t3.id), e2.forEach((i) => u(this, Vt).delete(i)), this.currentMap.Paths.remove(e2);
    }), u(this, Hi) && (u(this, Hi).cancel(), w(this, Hi, void 0)), u(this, ca2) && w(this, ca2, false), w(this, Xe, []), u(this, Ar).clear(), u(this, Qo).clear(), w(this, Lr, void 0), u(this, Or).off("click", u(this, Ns)), u(this, Ui).mapObjects.forEach((t3) => {
      t3.processFloorChange(t3.currentFloorId);
    });
  }
};
ji2 = /* @__PURE__ */ new WeakMap(), Or = /* @__PURE__ */ new WeakMap(), Ui = /* @__PURE__ */ new WeakMap(), he = /* @__PURE__ */ new WeakMap(), bp2 = /* @__PURE__ */ new WeakMap(), Hi = /* @__PURE__ */ new WeakMap(), ca2 = /* @__PURE__ */ new WeakMap(), Xe = /* @__PURE__ */ new WeakMap(), Lr = /* @__PURE__ */ new WeakMap(), Vt = /* @__PURE__ */ new WeakMap(), Ar = /* @__PURE__ */ new WeakMap(), Qo = /* @__PURE__ */ new WeakMap(), Ne = /* @__PURE__ */ new WeakSet(), VS = function(t3) {
  return t3 != null && ["TakeConnection", "ExitConnection", "TakeVortex", "ExitVortex"].includes(t3.type);
}, jS = function(t3) {
  let e2 = t3[0], i = t3[t3.length - 1], o = false;
  return w(this, Hi, { promise: new Promise(async (n) => {
    var s2, c2, l;
    if (e.env.NODE_ENV !== "test" && await GS(500), o || !t3.length) {
      n();
      return;
    }
    (s2 = u(this, he).createMarkers) != null && s2.departure && x(this, Ne, Rs).call(this, e2.coordinates[0], "departure", e2.instructions[0]);
    for (let p = 0; p < t3.length; p++) {
      let d = t3[p], f = p ? { ...u(this, he).inactivePathOptions } : { ...u(this, he).pathOptions };
      if (d.coordinates.length < 2) {
        Lt.warn("Directions must have at least 2 coordinates"), n();
        return;
      }
      let g = this.currentMap.Paths.add(d.coordinates, f), v2 = g.paths.map((C) => C.id.toString()), b = new Er2(tt(), g.animation, d.coordinates, g.paths);
      for (let C of v2) {
        u(this, Vt).set(C, { path: b, entityIds: v2 });
        let y = p ? { ...u(this, he).inactivePathOptions, altitude: 0 } : { ...u(this, he).pathOptions, altitude: 0.05 };
        u(this, Or).setState(C, y);
      }
      if (u(this, Vt).set(b.id, { path: b, entityIds: v2 }), u(this, Ar).set(d, b), u(this, Qo).set(b, d), e.env.NODE_ENV !== "test" && await g.animation, o) {
        n();
        return;
      }
      (c2 = u(this, he).createMarkers) != null && c2.connection && x(this, Ne, Qy).call(this, d.instructions, "connection"), p === 0 && (w(this, Lr, u(this, Ar).get(u(this, Xe)[0])), u(this, Or).on("click", u(this, Ns)));
    }
    if ((l = u(this, he).createMarkers) != null && l.destination && x(this, Ne, Rs).call(this, i.coordinates[i.coordinates.length - 1], "destination", i.instructions[i.instructions.length - 1]), o) {
      n();
      return;
    }
    u(this, Ui).mapObjects.forEach((p) => {
      p.processFloorChange(p.currentFloorId);
    }), n();
  }), cancel: () => {
    o = true;
  } }), u(this, Hi).promise;
}, Jy = function(t3) {
  var e2, i;
  w(this, he, { setMapOnConnectionClick: (e2 = t3.setMapOnConnectionClick) != null ? e2 : la.setMapOnConnectionClick, setMapToDeparture: (i = t3.setMapToDeparture) != null ? i : la.setMapToDeparture, pathOptions: { ...la.pathOptions, ...t3.pathOptions }, inactivePathOptions: { ...la.inactivePathOptions, ...t3.inactivePathOptions }, createMarkers: { ...la.createMarkers, ...t3.createMarkers }, markerOptions: { ...la.markerOptions, ...t3.markerOptions } });
}, Qh = function(t3) {
  w(this, Lr, t3), u(this, Xe).forEach((e2) => {
    let i = u(this, Ar).get(e2);
    if (i) {
      let o = u(this, Vt).get(i.id), n = o.path.id === u(this, Lr).id ? { ...u(this, he).pathOptions, altitude: 0.05 } : { ...u(this, he).inactivePathOptions, altitude: 0 };
      o.entityIds.forEach((s2) => {
        u(this, Or).setState(s2, n);
      });
    }
  }), this.currentMap.publish("navigation-active-path-change", { directions: this.activeDirections, path: this.activePath });
}, Rs = function(t3, e2, i) {
  var o, n, s2, c2, l;
  if (e2 === "connection" && i) {
    let p = i.action.type === "ExitConnection" ? u(this, he).markerOptions.departureColor : u(this, he).markerOptions.destinationColor, d;
    if (typeof ((o = u(this, he).createMarkers) == null ? void 0 : o.connection) == "function") {
      let g = u(this, he).createMarkers.connection(i);
      u(this, Or).setState(g.id.toString(), { options: { interactive: true } }), d = { id: g.id, type: "marker" };
    } else d = this.currentMap.Markers.add(i.coordinate, NS({ type: (s2 = (n = i.action.connection) == null ? void 0 : n.type) != null ? s2 : i.action.connectionType, color: p, direction: i.action.direction }), { interactive: true, anchor: "top", rank: "always-visible" });
    let f = this.currentMap.Markers.getContentEl(d.id.toString());
    if (!f) throw new Error("marker component should exist");
    u(this, ji2).set(d.id, { instruction: i, marker: new Vi(d.id.toString(), f, i.coordinate) });
  } else {
    let p = e2 === "departure" ? u(this, he).markerOptions.departureColor : u(this, he).markerOptions.destinationColor, d;
    typeof ((c2 = u(this, he).createMarkers) == null ? void 0 : c2.departure) == "function" && e2 === "departure" ? d = { id: u(this, he).createMarkers.departure(i).id, type: "marker" } : typeof ((l = u(this, he).createMarkers) == null ? void 0 : l.destination) == "function" && e2 === "destination" ? d = { id: u(this, he).createMarkers.destination(i).id, type: "marker" } : d = this.currentMap.Markers.add(t3, RS({ type: e2, color: p }), { anchor: "top", rank: "always-visible" }), u(this, ji2).set(d.id, void 0);
  }
}, Qy = function(t3, e2) {
  t3.filter((o) => x(this, Ne, VS).call(this, o.action)).forEach((o) => {
    x(this, Ne, Rs).call(this, o.coordinate, e2, o);
  });
}, Ns = /* @__PURE__ */ new WeakMap();
c();
c();
c();
var nD = /* @__PURE__ */ new Map([["search-16x16", '<svg viewBox="0 0 16 16">\n			<path\n				fillRule="evenodd"\n				clipRule="evenodd"\n				d="M1 7C1 3.68629 3.68629 1 7 1C10.3137 1 13 3.68629 13 7C13 8.29583 12.5892 9.49572 11.8907 10.4765L15.4614 14.0472C15.6567 14.2425 15.6567 14.559 15.4614 14.7543L14.7543 15.4614C14.559 15.6567 14.2424 15.6567 14.0472 15.4614L10.4765 11.8907C9.49571 12.5892 8.29583 13 7 13C3.68629 13 1 10.3137 1 7ZM7 11C4.79086 11 3 9.20914 3 7C3 4.79086 4.79086 3 7 3C9.20914 3 11 4.79086 11 7C11 9.20914 9.20914 11 7 11Z"\n				stroke="none"\n			/>\n		</svg>'], ["close-16x16", '<svg viewBox="0 0 16 16">\n			<path\n				d="M12.5963 1.98959C12.7916 1.79433 13.1082 1.79433 13.3034 1.98959L14.0105 2.6967C14.2058 2.89196 14.2058 3.20855 14.0105 3.40381L3.40392 14.0104C3.20866 14.2057 2.89208 14.2057 2.69682 14.0104L1.98971 13.3033C1.79445 13.108 1.79445 12.7915 1.98971 12.5962L12.5963 1.98959Z"\n				stroke="none"\n			/>\n			<path\n				d="M1.98971 3.40381C1.79445 3.20855 1.79445 2.89196 1.98971 2.6967L2.69682 1.98959C2.89208 1.79433 3.20866 1.79433 3.40392 1.98959L14.0105 12.5962C14.2058 12.7915 14.2058 13.108 14.0105 13.3033L13.3034 14.0104C13.1082 14.2057 12.7916 14.2057 12.5963 14.0104L1.98971 3.40381Z"\n				stroke="none"\n			/>\n		</svg>'], ["empty-64x40", '<svg viewBox="0 0 64 40">\n			<g>\n				<g clipPath="url(#clip0_499_175492)">\n					<path\n						d="M32 39.7032C49.6731 39.7032 64 36.5925 64 32.7552C64 28.9179 49.6731 25.8071 32 25.8071C14.3269 25.8071 0 28.9179 0 32.7552C0 36.5925 14.3269 39.7032 32 39.7032Z"\n						stroke="none"\n						fill="#F5F5F5"\n					/>\n					<path\n						d="M55 13.6653L44.854 2.24866C44.367 1.47048 43.656 1 42.907 1H21.093C20.344 1 19.633 1.47048 19.146 2.24767L9 13.6663V22.8367H55V13.6653Z"\n						fill="none"\n					/>\n					<path\n						d="M41.613 16.8128C41.613 15.2197 42.607 13.9046 43.84 13.9036H55V31.9059C55 34.0132 53.68 35.7402 52.05 35.7402H11.95C10.32 35.7402 9 34.0122 9 31.9059V13.9036H20.16C21.393 13.9036 22.387 15.2167 22.387 16.8098V16.8317C22.387 18.4248 23.392 19.7111 24.624 19.7111H39.376C40.608 19.7111 41.613 18.4128 41.613 16.8198V16.8128Z"\n						fill="#FAFAFA"\n					/>\n				</g>\n				<defs>\n					<clipPath id="clip0_499_175492">\n						<rect width="64" height="40" fill="white" />\n					</clipPath>\n				</defs>\n			</g>\n		</svg>'], ["caret-12x12", '<svg viewBox="0 0 12 12">\n			<path\n				stroke="none"\n				d="M8.38828 5.78337L3.92578 1.93493C3.75938 1.79196 3.51562 1.92087 3.51562 2.15173V9.84861C3.51562 10.0795 3.75938 10.2084 3.92578 10.0654L8.38828 6.21696C8.51602 6.10681 8.51602 5.89353 8.38828 5.78337Z"\n			/>\n		</svg>'], ["plus-16x16", '<svg viewBox="0 0 16 16">\n			<path\n				d="M7.5 1C7.22386 1 7 1.22386 7 1.5V7H1.5C1.22386 7 1 7.22386 1 7.5L1 8.5C1 8.77614 1.22386 9 1.5 9H7V14.5C7 14.7761 7.22386 15 7.5 15H8.5C8.77614 15 9 14.7761 9 14.5V9H14.5C14.7761 9 15 8.77614 15 8.5V7.5C15 7.22386 14.7761 7 14.5 7H9V1.5C9 1.22386 8.77614 1 8.5 1H7.5Z"\n				stroke="none"\n			/>\n		</svg>'], ["recenter-16x16", '<svg viewBox="0 0 16 16">\n			<g stroke="none">\n				<path d="M0 2.5C0 2.22386 0.223858 2 0.5 2H1.5C1.77614 2 2 2.22386 2 2.5V13.5C2 13.7761 1.77614 14 1.5 14H0.5C0.223858 14 0 13.7761 0 13.5V2.5Z" />\n				<path\n					fillRule="evenodd"\n					clipRule="evenodd"\n					d="M4.5 4C4.22386 4 4 4.22386 4 4.5V11.5C4 11.7761 4.22386 12 4.5 12H11.5C11.7761 12 12 11.7761 12 11.5V4.5C12 4.22386 11.7761 4 11.5 4H4.5ZM6 6V10H10V6H6Z"\n				/>\n				<path d="M14.5 2C14.2239 2 14 2.22386 14 2.5V13.5C14 13.7761 14.2239 14 14.5 14H15.5C15.7761 14 16 13.7761 16 13.5V2.5C16 2.22386 15.7761 2 15.5 2H14.5Z" />\n			</g>\n		</svg>'], ["minus-16x16", '<svg viewBox="0 0 16 16">\n			<path\n				d="M1.5 9C1.22386 9 1 8.77614 1 8.5L1 7.5C1 7.22386 1.22386 7 1.5 7L14.5 7C14.7761 7 15 7.22386 15 7.5V8.5C15 8.77614 14.7761 9 14.5 9L1.5 9Z"\n				stroke="none"\n			/>\n		</svg>'], ["logo-horizontal-206x48", '<svg viewBox="0 0 206 48">\n			<path d="M27.2678 14.2261H22.3187C21.0695 14.2261 20.4695 14.7801 20.4695 15.9852V31.142L10.3966 15.5591C9.69665 14.4784 9.2475 14.2773 7.8475 14.2261H2.97462C1.67462 14.2261 1.07631 14.7801 1.07631 15.9852V44.7665C1.07631 45.9716 1.67462 46.5256 2.97462 46.5256H7.92377C9.22207 46.5256 9.82207 45.9716 9.82207 44.7665V29.6847L19.9441 45.1926C20.695 46.3244 21.095 46.5256 22.4933 46.5256H27.2933C28.5916 46.5256 29.1916 45.9716 29.1916 44.7665V15.9852C29.1407 14.7801 28.5424 14.2261 27.2678 14.2261Z" />\n			<path d="M5.44915 10.9602C8.45863 10.9602 10.8983 8.50669 10.8983 5.48011C10.8983 2.45353 8.45863 0 5.44915 0C2.43967 0 0 2.45353 0 5.48011C0 8.50669 2.43967 10.9602 5.44915 10.9602Z" />\n			<path d="M61.7899 25.0449C63.2306 23.1903 65.078 22.2051 67.556 22.2051C72.0526 22.2051 74.7611 25.3347 74.7611 29.4511V39.2489C74.8187 39.7125 74.5306 39.9443 74.0695 39.9443H72.5136C72.0526 39.9443 71.7645 39.7125 71.8221 39.2489V29.5091C71.8221 27.1909 69.9187 25.2187 67.4984 25.2187C65.1339 25.2187 63.2323 27.1329 63.2323 29.2773V39.2489C63.2899 39.7125 63.0018 39.9443 62.5407 39.9443H60.9831C60.5221 39.9443 60.2916 39.7125 60.2916 39.2489V29.4511C60.2916 27.1329 58.3899 25.2187 56.0255 25.2187C53.7204 25.2187 51.7594 27.075 51.7594 29.2773V39.3068C51.817 39.7705 51.5289 40.0023 51.0102 40.0023H49.5119C49.0509 40.0023 48.7628 39.7705 48.7628 39.3068V23.25C48.7051 22.7864 48.9933 22.4966 49.5119 22.4966H50.9526C51.356 22.4966 51.5289 22.6704 51.5289 23.0182V24.2352C52.7407 22.9602 54.239 22.2648 56.0255 22.2648C58.4475 22.2068 60.3492 23.192 61.7899 25.0466V25.0449ZM77.1255 31.2477C77.1255 26.3216 81.1018 22.2051 86.1187 22.2051C88.539 22.2051 90.6136 23.1903 92.3441 25.1608V23.1903C92.3441 22.7267 92.5746 22.5528 93.0357 22.5528H94.4187C94.8797 22.5528 95.1102 22.7847 95.1102 23.3062V39.3648C95.1102 39.8284 94.8797 40.0602 94.4187 40.0602H93.0357C92.5746 40.0602 92.3441 39.8284 92.3441 39.4227V37.4523C90.6712 39.3648 88.5967 40.35 86.1746 40.35C81.1018 40.2341 77.1238 36.1773 77.1238 31.2477H77.1255ZM92.1136 31.2477C92.1136 27.8284 89.4611 25.2187 86.0594 25.2187C82.7746 25.2187 80.1221 27.8864 80.1221 31.2477C80.1221 34.6687 82.7746 37.2784 86.1187 37.2784C86.9062 37.2789 87.6861 37.1232 88.4138 36.8202C89.1414 36.5173 89.8026 36.0731 90.3593 35.513C90.9161 34.9528 91.3577 34.2878 91.6587 33.556C91.9597 32.8241 92.1143 32.0397 92.1136 31.2477ZM100.992 37.3943V46.3807C101.049 46.8443 100.761 47.1341 100.298 47.1341H98.7424C98.2814 47.1341 97.9933 46.9023 97.9933 46.3807V23.1903C97.9933 22.7267 98.2238 22.4369 98.7424 22.4369H100.183C100.646 22.379 100.934 22.6687 100.934 23.0744V24.9869C102.605 23.0744 104.68 22.1472 107.044 22.1472C112.002 22.1472 116.037 26.2619 116.037 31.1898C116.037 36.1176 112.059 40.2341 107.044 40.2341C104.622 40.2341 102.603 39.3068 100.992 37.3943ZM106.987 25.2187C103.7 25.2187 101.049 27.8864 101.049 31.2477C101.049 34.6687 103.7 37.2784 107.044 37.2784C110.446 37.2784 113.039 34.6108 113.039 31.2477C113.039 27.8864 110.388 25.2187 106.987 25.2187ZM121.11 37.3943V46.3807C121.168 46.8443 120.88 47.1341 120.419 47.1341H118.861C118.4 47.1341 118.112 46.9023 118.112 46.3807V23.1903C118.112 22.7267 118.342 22.4369 118.861 22.4369H120.302C120.764 22.379 121.053 22.6687 121.053 23.0744V24.9869C122.724 23.0744 124.798 22.1472 127.163 22.1472C132.12 22.1472 136.156 26.2619 136.156 31.1898C136.156 36.1176 132.178 40.2341 127.163 40.2341C124.742 40.2341 122.781 39.3068 121.11 37.3943ZM127.105 25.2187C123.819 25.2187 121.168 27.8864 121.168 31.2477C121.168 34.6687 123.819 37.2784 127.163 37.2784C130.564 37.2784 133.158 34.6108 133.158 31.2477C133.158 27.8864 130.507 25.2187 127.107 25.2187H127.105ZM153.97 32.3506H141.054C141.342 35.2483 143.995 37.4523 147.164 37.4523C148.893 37.4523 150.393 37.0466 151.719 36.0597C152.007 35.8858 152.295 35.7699 152.353 35.7699C152.583 35.7699 152.756 35.8858 152.929 36.1773L153.505 37.1625C153.622 37.3364 153.68 37.4523 153.68 37.5682C153.68 37.8 153.507 38.0318 153.103 38.3216C151.258 39.5966 149.183 40.292 146.992 40.292C141.688 40.292 137.883 36.3511 137.883 31.2477C137.883 26.204 141.803 22.2051 146.703 22.2051C151.546 22.2051 154.717 25.7983 154.717 31.0176C154.717 31.5972 154.717 32.3506 153.968 32.3506H153.97ZM141.056 30.0324H151.72C151.432 26.8432 149.473 24.929 146.648 24.929C145.241 24.8904 143.875 25.3995 142.833 26.3501C141.791 27.3007 141.154 28.6194 141.056 30.0307V30.0324ZM156.332 31.2477C156.332 26.3216 160.31 22.2051 165.326 22.2051C167.748 22.2051 169.707 23.1324 171.32 25.0449V16.2324C171.263 15.7687 171.551 15.479 172.012 15.479H173.57C174.031 15.479 174.319 15.7108 174.319 16.2324V39.3068C174.319 39.7705 174.088 40.0023 173.57 40.0023H172.129C171.666 40.0602 171.378 39.7705 171.378 39.3648V37.3943C169.649 39.3068 167.632 40.292 165.268 40.292C160.31 40.2341 156.332 36.1773 156.332 31.2477ZM171.264 31.2477C171.264 27.8284 168.612 25.2187 165.21 25.2187C161.924 25.2187 159.273 27.8864 159.273 31.2477C159.273 34.6687 161.924 37.2784 165.268 37.2784C166.057 37.2838 166.839 37.1316 167.569 36.8304C168.299 36.5292 168.962 36.0852 169.52 35.5241C170.077 34.963 170.519 34.296 170.818 33.5619C171.117 32.8277 171.268 32.0411 171.263 31.2477H171.264ZM177.72 19.0739C177.715 18.8594 177.754 18.646 177.833 18.4468C177.912 18.2476 178.031 18.0667 178.182 17.915C178.333 17.7633 178.512 17.6439 178.71 17.5642C178.909 17.4845 179.121 17.446 179.334 17.4511C179.546 17.4507 179.756 17.4923 179.952 17.5737C180.148 17.6551 180.326 17.7746 180.476 17.9254C180.626 18.0762 180.745 18.2553 180.826 18.4523C180.907 18.6494 180.948 18.8606 180.948 19.0739C180.953 19.2884 180.914 19.5017 180.835 19.7009C180.756 19.9001 180.637 20.081 180.486 20.2327C180.335 20.3845 180.156 20.5038 179.957 20.5835C179.759 20.6633 179.547 20.7017 179.334 20.6966C178.412 20.7545 177.72 20.0591 177.72 19.0739ZM177.836 39.2489V23.1903C177.836 22.7267 178.066 22.4369 178.527 22.4369H180.083C180.544 22.4369 180.832 22.6687 180.775 23.1903V39.2489C180.832 39.7125 180.544 39.9443 180.083 39.9443H178.527C178.066 39.9443 177.836 39.7125 177.836 39.2489ZM186.944 23.0165V24.1756C188.212 22.8426 189.71 22.2051 191.497 22.2051C195.937 22.2051 198.646 25.2767 198.646 29.3932V39.2489C198.703 39.7125 198.415 39.9443 197.954 39.9443H196.398C195.936 39.9443 195.705 39.7125 195.705 39.2489V29.4511C195.705 27.1329 193.803 25.2187 191.439 25.2187C189.134 25.2187 187.175 27.075 187.175 29.2773V39.3068C187.232 39.7705 186.944 40.0023 186.424 40.0023H184.868C184.407 40.0023 184.119 39.7705 184.119 39.3068V23.1903C184.061 22.7267 184.349 22.4949 184.868 22.4949H186.309C186.712 22.4949 186.944 22.6687 186.944 23.0165Z" />\n			<path d="M204 40C205.115 40 206 39.0857 206 38V37.9886C206 36.9029 205.126 36 204 36C202.885 36 202 36.9143 202 38V38.0114C202 39.0971 202.874 40 204 40ZM204 39.7829C202.989 39.7829 202.23 38.9829 202.23 38.0114V38C202.23 37.0286 203 36.2171 204 36.2171C205.011 36.2171 205.77 37.0171 205.77 37.9886V38C205.77 38.9714 205 39.7829 204 39.7829ZM203.218 38.9714H203.609V38.2743H204.034L204.517 38.9714H204.989L204.448 38.2057C204.724 38.1257 204.92 37.92 204.92 37.5886C204.92 37.1657 204.586 36.9486 204.138 36.9486H203.218V38.9714ZM203.609 37.9543V37.2914H204.103C204.368 37.2914 204.517 37.4057 204.517 37.6229C204.517 37.8171 204.368 37.9543 204.103 37.9543H203.609Z" />\n		</svg>'], ["share-16x16", '<svg viewBox="0 0 16 16">\n			<path\n				fillRule="evenodd"\n				clipRule="evenodd"\n				d="M13 6C14.6569 6 16 4.65685 16 3C16 1.34315 14.6569 0 13 0C11.3431 0 10 1.34315 10 3C10 3.13463 10.0089 3.26719 10.0261 3.39712L6.82972 5.17286C6.10576 4.44825 5.10523 4 4 4C1.79086 4 0 5.79086 0 8C0 10.2091 1.79086 12 4 12C5.10523 12 6.10576 11.5518 6.82972 10.8271L10.0261 12.6029C10.0089 12.7328 10 12.8654 10 13C10 14.6569 11.3431 16 13 16C14.6569 16 16 14.6569 16 13C16 11.3431 14.6569 10 13 10C12.2011 10 11.4752 10.3123 10.9376 10.8214L7.84579 9.1037C7.94622 8.75313 8 8.38284 8 8C8 7.61716 7.94622 7.24687 7.84579 6.8963L10.9376 5.17864C11.4752 5.68775 12.2011 6 13 6ZM13 4C13.5523 4 14 3.55228 14 3C14 2.44772 13.5523 2 13 2C12.4477 2 12 2.44772 12 3C12 3.55228 12.4477 4 13 4ZM4 10C5.10457 10 6 9.10457 6 8C6 6.89543 5.10457 6 4 6C2.89543 6 2 6.89543 2 8C2 9.10457 2.89543 10 4 10ZM14 13C14 13.5523 13.5523 14 13 14C12.4477 14 12 13.5523 12 13C12 12.4477 12.4477 12 13 12C13.5523 12 14 12.4477 14 13Z"\n				stroke="none"\n			/>\n		</svg>'], ["checkmark-16x16", '<svg viewBox="0 0 16 16">\n			<path\n				fillRule="evenodd"\n				clipRule="evenodd"\n				d="M15.387 3.31662C15.6008 3.49148 15.6323 3.80649 15.4574 4.02021L6.77402 14.6332C6.58509 14.8642 6.30292 14.9986 6.00457 15C5.70622 15.0013 5.42285 14.8694 5.23184 14.6402L0.551937 9.02429C0.375155 8.81215 0.403817 8.49687 0.615956 8.32009L1.38418 7.67991C1.59632 7.50312 1.9116 7.53179 2.08838 7.74392L5.99299 12.4295L13.9095 2.75374C14.0844 2.54002 14.3994 2.50852 14.6131 2.68338L15.387 3.31662Z"\n				stroke="none"\n			/>\n		</svg>'], ["arrow-right-16x16", '<svg viewBox="0 0 16 16">\n			<path\n				fillRule="evenodd"\n				clipRule="evenodd"\n				d="M8.35355 1.64645C8.54881 1.45118 8.8654 1.45118 9.06066 1.64645L14.7071 7.29289C15.0976 7.68342 15.0976 8.31658 14.7071 8.70711L9.06066 14.3536C8.8654 14.5488 8.54882 14.5488 8.35355 14.3536L7.64645 13.6464C7.45118 13.4512 7.45118 13.1346 7.64645 12.9393L11.5858 9H0.5C0.223858 9 0 8.77614 0 8.5V7.5C0 7.22386 0.223858 7 0.5 7H11.5858L7.64645 3.06066C7.45118 2.8654 7.45118 2.54882 7.64645 2.35355L8.35355 1.64645Z"\n				stroke="none"\n			/>\n		</svg>'], ["arrow-up-16x16", '<svg viewBox="0 0 16 16">\n			<path\n				fillRule="evenodd"\n				clipRule="evenodd"\n				d="M8.00015 0.5C8.34685 0.5 8.67835 0.642318 8.91714 0.893677L15.6517 7.98267C15.8441 8.18525 15.8359 8.50548 15.6333 8.69793L14.533 9.7433C14.3304 9.93575 14.0101 9.92754 13.8177 9.72496L9.26497 4.93262V15.4249C9.26497 15.7043 9.03846 15.9308 8.75904 15.9308H7.24125C6.96184 15.9308 6.73532 15.7043 6.73532 15.4249V4.93262L2.1826 9.72496C1.99015 9.92754 1.66992 9.93575 1.46734 9.7433L0.366945 8.69793C0.164367 8.50548 0.156156 8.18525 0.348604 7.98267L7.08315 0.893677C7.32194 0.642318 7.65344 0.5 8.00015 0.5Z"\n				stroke="none"\n			/>\n		</svg>'], ["connection-stairs-16x16", '<svg viewBox="0 0 16 16">\n			<g stroke="none">\n				<path d="M1 11.5C1 11.2239 1.22386 11 1.5 11H6V13.5C6 13.7761 5.77614 14 5.5 14H1.5C1.22386 14 1 13.7761 1 13.5V11.5Z" />\n				<path d="M4 8.5C4 8.22386 4.22386 8 4.5 8H9V10.5C9 10.7761 8.77614 11 8.5 11H4V8.5Z" />\n				<path d="M7 5.5C7 5.22386 7.22386 5 7.5 5H12V7.5C12 7.77614 11.7761 8 11.5 8H7V5.5Z" />\n				<path d="M10 2.5C10 2.22386 10.2239 2 10.5 2H14.5C14.7761 2 15 2.22386 15 2.5V4.5C15 4.77614 14.7761 5 14.5 5H10V2.5Z" />\n			</g>\n		</svg>'], ["connection-stairs-14x14", '<svg viewBox="0 0 14 14">\n			<path\n				d="M5.25 12H2.5C2.225 12 2 11.7429 2 11.4286C2 11.1143 2.225 10.8571 2.5 10.8571H4.25V7.91429H6.5V4.94286H8.75V2H11.5C11.775 2 12 2.25714 12 2.57143C12 2.88571 11.775 3.14286 11.5 3.14286H9.75V6.08571H7.5V9.02857H5.25V12Z"\n				stroke="none"\n			/>\n		</svg>'], ["connection-stairs-12x12", '<svg viewBox="0 0 12 12" stroke="none">\n			<path d="M1.625 8.1875C1.625 8.01491 1.76491 7.875 1.9375 7.875H4.75V9.4375C4.75 9.61009 4.61009 9.75 4.4375 9.75H1.9375C1.76491 9.75 1.625 9.61009 1.625 9.4375V8.1875Z" />\n			<path d="M3.5 6.3125C3.5 6.13991 3.63991 6 3.8125 6H6.625V7.5625C6.625 7.73509 6.48509 7.875 6.3125 7.875H3.5V6.3125Z" />\n			<path d="M5.375 4.4375C5.375 4.26491 5.51491 4.125 5.6875 4.125H8.5V5.6875C8.5 5.86009 8.36009 6 8.1875 6H5.375V4.4375Z" />\n			<path d="M7.25 2.5625C7.25 2.38991 7.38991 2.25 7.5625 2.25H10.0625C10.2351 2.25 10.375 2.38991 10.375 2.5625V3.8125C10.375 3.98509 10.2351 4.125 10.0625 4.125H7.25V2.5625Z" />\n		</svg>'], ["connection-escalator-16x16", '<svg viewBox="0 0 16 16">\n			<g stroke="none">\n				<path d="M3.63008 12H2C0.895431 12 0 12.8954 0 14C0 15.1046 0.89543 16 2 16H4.63008C4.86879 16 5.09962 15.9146 5.28087 15.7593L11.7191 10.2407C11.9004 10.0854 12.1312 10 12.3699 10H14C15.1046 10 16 9.10457 16 8C16 6.89543 15.1046 6 14 6H11.3699C11.1312 6 10.9004 6.08539 10.7191 6.24074L4.28087 11.7593C4.09962 11.9146 3.86879 12 3.63008 12Z" />\n				<path d="M5 6C5 4.89543 5.89543 4 7 4C8.10457 4 9 4.89543 9 6L5 9.5V6Z" />\n				<path d="M9 2C9 3.10457 8.10457 4 7 4C5.89543 4 5 3.10457 5 2C5 0.89543 5.89543 0 7 0C8.10457 0 9 0.89543 9 2Z" />\n			</g>\n		</svg>'], ["connection-escalator-14x14", '<svg viewBox="0 0 14 14">\n			<path\n				d="M5.26686 2.98522C5.26686 2.44335 5.71573 2 6.26436 2C6.81299 2 7.26187 2.44335 7.26187 2.98522C7.26187 3.5271 6.81299 3.97045 6.26436 3.97045C5.71573 3.97045 5.26686 3.50246 5.26686 2.98522Z"\n				stroke="none"\n			/>\n			<path\n				d="M7.26188 5.48588V5.25125C7.26188 4.85716 6.91275 4.53696 6.48881 4.53696H6.03993C5.61599 4.53696 5.26687 4.88179 5.26687 5.25125V7.66458L4.3192 8.6995H3.67082C2.74813 8.6995 2 9.43842 2 10.3498C2 11.2611 2.74813 12 3.67082 12H4.61845C5.36658 12 6.11471 11.6798 6.61347 11.1133L9.6808 7.76354H10.3292C11.2519 7.76354 12 7.02463 12 6.11329C12 5.20196 11.2519 4.46305 10.3292 4.46305H9.38155C8.60848 4.46305 7.88529 4.78324 7.38653 5.34975L7.26188 5.48588ZM4.61846 11.0148H3.67083C3.29677 11.0148 2.99751 10.7192 2.99751 10.3498C2.99751 9.9803 3.29677 9.68473 3.67083 9.68473H4.61846C4.71821 9.68473 4.81796 9.63547 4.86784 9.56158L8.13467 5.99015C8.45886 5.64532 8.90774 5.44828 9.38155 5.44828H10.3292C10.7032 5.44828 11.0025 5.74384 11.0025 6.1133C11.0025 6.48276 10.7032 6.77833 10.3292 6.77833H9.38155C9.2818 6.77833 9.18205 6.82759 9.13218 6.87685L5.86534 10.4729C5.54115 10.8177 5.09228 11.0148 4.61846 11.0148Z"\n				stroke="none"\n			/>\n		</svg>'], ["connection-elevator-16x16", '<svg viewBox="0 0 16 16">\n			<g stroke="none">\n				<path d="M3 5.5C3 6.32843 2.32843 7 1.5 7C0.671573 7 0 6.32843 0 5.5C0 4.67157 0.671573 4 1.5 4C2.32843 4 3 4.67157 3 5.5Z" />\n				<path d="M3 10.5C3 11.3284 2.32843 12 1.5 12C0.671573 12 0 11.3284 0 10.5C0 9.67157 0.671573 9 1.5 9C2.32843 9 3 9.67157 3 10.5Z" />\n				<path d="M11 1H14C14.5523 1 15 1.44772 15 2V14C15 14.5523 14.5523 15 14 15H11V1Z" />\n				<path d="M9 1H6C5.44772 1 5 1.44772 5 2V14C5 14.5523 5.44772 15 6 15H9V1Z" />\n			</g>\n		</svg>'], ["connection-elevator-14x14", '<svg viewBox="0 0 14 14">\n			<path\n				d="M7.476 2H2.72693C1.77095 2 1 2.72464 1 3.62319V10.3768C1 11.2754 1.77095 12 2.72693 12H7.476C8.43198 12 9.20293 11.2754 9.20293 10.3768V3.62319C9.17209 2.72464 8.40114 2 7.476 2ZM7.476 3.15942C7.75354 3.15942 7.96941 3.36232 7.96941 3.62319V10.3768C7.96941 10.6377 7.75354 10.8406 7.476 10.8406H5.71824V3.15942H7.476ZM4.48472 3.15942V10.8406H2.72693C2.44939 10.8406 2.23352 10.6377 2.23352 10.3768V3.62319C2.23352 3.36232 2.44939 3.15942 2.72693 3.15942H4.48472Z"\n				stroke="none"\n			/>\n			<path\n				d="M12.4643 6.19064H10.6638C10.4456 6.19064 10.2546 6.06243 10.1728 5.88294C10.0909 5.70346 10.1455 5.47269 10.2819 5.31884L11.1821 4.47269C11.4004 4.26756 11.755 4.26756 11.946 4.47269L12.8462 5.31884C13.0099 5.47269 13.0371 5.67781 12.9553 5.88294C12.8735 6.08807 12.6825 6.19064 12.4643 6.19064Z"\n				stroke="none"\n			/>\n			<path\n				d="M11.564 9.65216C11.4276 9.65216 11.2912 9.60088 11.1821 9.49831L10.2819 8.65216C10.1182 8.49831 10.0909 8.29319 10.1728 8.08806C10.2546 7.90857 10.4456 7.78036 10.6638 7.78036H12.4643C12.6825 7.78036 12.8735 7.90857 12.9553 8.08806C13.0371 8.26754 12.9826 8.49831 12.8462 8.65216L11.9459 9.49831C11.8641 9.60088 11.7004 9.65216 11.564 9.65216Z"\n				stroke="none"\n			/>\n		</svg>'], ["connection-elevator-12x12", '<svg viewBox="0 0 12 12" stroke="none">\n			<circle cx="1.9375" cy="4.4375" r="0.9375" />\n			<circle cx="1.9375" cy="7.5625" r="0.9375" />\n			<path\n				fillRule="evenodd"\n				clipRule="evenodd"\n				d="M7.6 2H9.4C9.73137 2 10 2.26863 10 2.6V9.41328C10 9.74465 9.73137 10.0133 9.4 10.0133H7.6V2ZM6.4 2H4.6C4.26863 2 4 2.26863 4 2.6V9.41328C4 9.74465 4.26863 10.0133 4.6 10.0133H6.4V2Z"\n			/>\n		</svg>'], ["new-tab-14x14", '<svg viewBox="0 0 14 14">\n			<g stroke="none">\n				<path d="M2.625 2.625H5.6875C5.92913 2.625 6.125 2.42912 6.125 2.1875V1.3125C6.125 1.07088 5.92913 0.875 5.6875 0.875H1.3125C1.07088 0.875 0.875 1.07088 0.875 1.3125V12.6875C0.875 12.9291 1.07088 13.125 1.3125 13.125H12.6875C12.9291 13.125 13.125 12.9291 13.125 12.6875V8.3125C13.125 8.07088 12.9291 7.875 12.6875 7.875H11.8125C11.5709 7.875 11.375 8.07088 11.375 8.3125V11.375H2.625V2.625Z" />\n				<path d="M12.9063 0.875H8.40311C8.20822 0.875 8.11063 1.11062 8.24843 1.24843L9.88124 2.88124L5.8156 6.94688C5.64475 7.11774 5.64475 7.39475 5.8156 7.5656L6.43432 8.18432C6.60517 8.35517 6.88218 8.35517 7.05304 8.18432L11.1187 4.11868L12.7516 5.75157C12.8894 5.88938 13.125 5.79178 13.125 5.59689V1.09375C13.125 0.972938 13.0271 0.875 12.9063 0.875Z" />\n			</g>\n		</svg>'], ["compress-16x16", '<svg viewBox="0 0 16 16">\n			<g stroke="none">\n				<path\n					id="Vector"\n					d="M4.67773 10.7154H0.713449C0.556306 10.7154 0.427734 10.844 0.427734 11.0011V11.8583C0.427734 12.0154 0.556306 12.144 0.713449 12.144H3.82059V15.2868C3.82059 15.444 3.94916 15.5725 4.10631 15.5725H4.96345C5.12059 15.5725 5.24916 15.444 5.24916 15.2868V11.2868C5.24916 10.9708 4.99381 10.7154 4.67773 10.7154ZM4.96345 0.429688H4.10631C3.94916 0.429688 3.82059 0.558259 3.82059 0.715402V3.85826H0.713449C0.556306 3.85826 0.427734 3.98683 0.427734 4.14397V5.00112C0.427734 5.15826 0.556306 5.28683 0.713449 5.28683H4.67773C4.99381 5.28683 5.24916 5.03147 5.24916 4.7154V0.715402C5.24916 0.558259 5.12059 0.429688 4.96345 0.429688ZM15.2849 10.7154H11.3206C11.0045 10.7154 10.7492 10.9708 10.7492 11.2868V15.2868C10.7492 15.444 10.8777 15.5725 11.0349 15.5725H11.892C12.0492 15.5725 12.1777 15.444 12.1777 15.2868V12.144H15.2849C15.442 12.144 15.5706 12.0154 15.5706 11.8583V11.0011C15.5706 10.844 15.442 10.7154 15.2849 10.7154ZM15.2849 3.85826H12.1777V0.715402C12.1777 0.558259 12.0492 0.429688 11.892 0.429688H11.0349C10.8777 0.429688 10.7492 0.558259 10.7492 0.715402V4.7154C10.7492 5.03147 11.0045 5.28683 11.3206 5.28683H15.2849C15.442 5.28683 15.5706 5.15826 15.5706 5.00112V4.14397C15.5706 3.98683 15.442 3.85826 15.2849 3.85826Z"\n				/>\n			</g>\n		</svg>'], ["washroom-14x14", '<svg viewBox="0 0 14 14" stroke="none">\n			<path d="M4.55125 3.09062C4.55125 3.69326 4.07639 4.18176 3.49058 4.18176C2.90525 4.18176 2.43039 3.69326 2.43039 3.09062C2.43039 2.4885 2.90525 2 3.49058 2C4.07639 2 4.55125 2.4885 4.55125 3.09062Z" />\n			<path d="M5.1193 5.48047C4.81653 4.83116 4.17252 4.41571 3.47822 4.41571C2.78392 4.41571 2.13986 4.83116 1.83714 5.48047L1.04175 7.22034C0.940664 7.441 1.02893 7.70073 1.24393 7.81791C1.47077 7.90871 1.72324 7.81791 1.82433 7.59725L2.49349 6.15554L2.21587 11.4407C2.20305 11.7263 2.41805 11.9734 2.69567 11.9993C2.97329 12.0124 3.21344 11.7913 3.23859 11.5057L3.4028 8.285H3.567L3.73121 11.5057C3.74403 11.7913 3.97086 11.9993 4.23616 11.9993H4.26131C4.53893 11.9861 4.75343 11.7395 4.74111 11.4407L4.46349 6.15554L5.13265 7.59725C5.20858 7.75298 5.35997 7.85697 5.52418 7.85697C5.5873 7.85697 5.65042 7.84379 5.71354 7.81792C5.92804 7.71393 6.0163 7.44153 5.91572 7.22035L5.1193 5.48047Z" />\n			<path d="M12.9582 7.22034L12.1505 5.48047C11.8477 4.83116 11.2037 4.41571 10.5094 4.41571C9.81513 4.41571 9.17107 4.83116 8.86836 5.48047L8.06064 7.22034C7.95955 7.441 8.04782 7.70073 8.26282 7.81791C8.47732 7.9219 8.7298 7.8311 8.84371 7.60993L9.52519 6.12977L9.46207 7.2204L8.57842 8.92184C8.47733 9.11663 8.61638 9.36316 8.83089 9.36316H9.33584L9.22242 11.4668C9.2096 11.7397 9.41177 11.9862 9.68939 11.9994C9.95469 12.0126 10.1943 11.8046 10.2072 11.519L10.3581 9.33723H10.6737L10.7871 11.5058C10.7999 11.7787 11.0144 11.9862 11.2792 11.9862H11.3043C11.5696 11.973 11.7841 11.7396 11.7713 11.4535L11.6579 9.33718H12.1628C12.3773 9.33718 12.5287 9.09066 12.4153 8.89586L11.5317 7.19442L11.4685 6.1038L12.1757 7.5972C12.2516 7.75293 12.403 7.85692 12.5672 7.85692C12.6303 7.85692 12.6934 7.84373 12.7566 7.81786C12.9711 7.70068 13.0593 7.44102 12.9582 7.22034Z" />\n			<path d="M11.5696 3.09062C11.5696 3.69326 11.0948 4.18176 10.5094 4.18176C9.92363 4.18176 9.44876 3.69326 9.44876 3.09062C9.44876 2.4885 9.92363 2 10.5094 2C11.0948 2 11.5696 2.4885 11.5696 3.09062Z" />\n			<path d="M6.99996 2.00006C6.76031 2.00006 6.57095 2.19485 6.57095 2.44138V11.5575C6.57095 11.804 6.76031 11.9988 6.99996 11.9988C7.2396 11.9988 7.42896 11.804 7.42896 11.5575V2.44138C7.42896 2.19485 7.2396 2.00006 6.99996 2.00006Z" />\n		</svg>'], ["point-of-interest-12x12", '<svg viewBox="0 0 12 12" stroke="none">\n			<path\n				stroke="none"\n				id="Subtract"\n				fill-rule="evenodd"\n				clip-rule="evenodd"\n				d="M6.24724 10.7516C7.94597 9.0358 9.85962 6.89195 9.85962 4.85965C9.85962 2.72802 8.13159 1 5.99997 1C3.86834 1 2.14032 2.72802 2.14032 4.85965C2.14032 6.89195 4.05397 9.0358 5.7527 10.7516C5.88904 10.8893 6.1109 10.8893 6.24724 10.7516ZM5.99994 6.26317C6.77508 6.26317 7.40345 5.6348 7.40345 4.85967C7.40345 4.08453 6.77508 3.45616 5.99994 3.45616C5.22481 3.45616 4.59644 4.08453 4.59644 4.85967C4.59644 5.6348 5.22481 6.26317 5.99994 6.26317Z"\n			/>\n		</svg>'], ["flag-20x20", '<svg viewBox="0 0 20 20" stroke="none">\n			<path\n				d="M16.9987 4.27111C16.936 5.06715 16.3836 5.93162 15.5238 6.57845C14.7549 7.15682 13.0885 8.04927 10.5434 7.55174C8.32167 7.1164 6.82156 8.02129 6.08085 10.2416L8.24615 17.3998C8.31833 17.6471 8.17711 17.9059 7.9292 17.9813C7.88527 17.9938 7.83976 18 7.79426 18C7.58634 18 7.40277 17.8647 7.34236 17.6673L5.1644 10.4686C5.13773 10.4173 5.12125 10.3613 5.11419 10.3038L3.41956 4.70042C3.38112 4.63512 3.35994 4.56127 3.3568 4.48587L3.02101 3.37886C2.98413 3.25992 2.9959 3.13165 3.05553 3.02203C3.11437 2.91242 3.21479 2.83079 3.33482 2.79504C3.45564 2.75928 3.5851 2.7725 3.69494 2.83235C3.80477 2.89144 3.88637 2.99172 3.92167 3.11143L3.9813 3.31355C4.38847 2.85956 4.90472 2.51439 5.48136 2.30915C6.97201 1.75566 8.95216 1.95467 10.6469 2.83156C11.6888 3.36951 14.3374 4.54493 16.3647 3.79553C16.5154 3.74111 16.684 3.76599 16.8127 3.86239C16.9406 3.95879 17.0105 4.11251 16.9987 4.27111Z"\n				stroke="none"\n			/>\n		</svg>'], ["link-16x16", '<svg viewBox="0 0 16 16" stroke="none">\n			<path\n				d="M9.10678 11.2433C9.07993 11.2167 9.04367 11.2018 9.00589 11.2018C8.9681 11.2018 8.93184 11.2167 8.90499 11.2433L6.82999 13.3183C5.86928 14.279 4.24785 14.3808 3.18714 13.3183C2.12464 12.2558 2.22642 10.6362 3.18714 9.67546L5.26214 7.60046C5.31749 7.5451 5.31749 7.45403 5.26214 7.39868L4.55142 6.68796C4.52457 6.66138 4.48832 6.64646 4.45053 6.64646C4.41274 6.64646 4.37649 6.66138 4.34964 6.68796L2.27464 8.76296C0.763923 10.2737 0.763923 12.7183 2.27464 14.2272C3.78535 15.7362 6.22999 15.738 7.73892 14.2272L9.81392 12.1522C9.86928 12.0969 9.86928 12.0058 9.81392 11.9505L9.10678 11.2433ZM13.7246 2.77903C12.2139 1.26832 9.76928 1.26832 8.26035 2.77903L6.18357 4.85403C6.15698 4.88088 6.14207 4.91714 6.14207 4.95493C6.14207 4.99271 6.15698 5.02897 6.18357 5.05582L6.89249 5.76475C6.94785 5.8201 7.03892 5.8201 7.09428 5.76475L9.16928 3.68975C10.13 2.72903 11.7514 2.62725 12.8121 3.68975C13.8746 4.75225 13.7729 6.37189 12.8121 7.3326L10.7371 9.4076C10.7106 9.43445 10.6956 9.47071 10.6956 9.5085C10.6956 9.54628 10.7106 9.58254 10.7371 9.60939L11.4479 10.3201C11.5032 10.3755 11.5943 10.3755 11.6496 10.3201L13.7246 8.2451C15.2336 6.73439 15.2336 4.28975 13.7246 2.77903ZM9.75142 6.00939C9.72457 5.9828 9.68832 5.96789 9.65053 5.96789C9.61275 5.96789 9.57649 5.9828 9.54964 6.00939L5.50499 10.0522C5.47841 10.0791 5.46349 10.1154 5.46349 10.1531C5.46349 10.1909 5.47841 10.2272 5.50499 10.254L6.21214 10.9612C6.26749 11.0165 6.35857 11.0165 6.41392 10.9612L10.4568 6.91832C10.5121 6.86296 10.5121 6.77189 10.4568 6.71653L9.75142 6.00939Z"\n				stroke="none"\n			/>\n		</svg>']]);
var aD = /<svg([^>]*)>/g;
function US(r3, t3, e2) {
  let i = nD.get(r3);
  return i ? i.replace(aD, '<svg$1 xmlns="http://www.w3.org/2000/svg" style="fill:'.concat(t3, "; width:").concat(e2, "px; height:").concat(e2, 'px">')) : "";
}
var pa2;
var Gs;
var jt;
var Ky;
var HS;
var WS;
var e1;
var XS;
var Kh = class {
  constructor(t3, e2) {
    v(this, jt);
    v(this, pa2);
    v(this, Gs);
    t(this, "colors", { default: "#3D5676", connection: "#128387", washroom: "#3161B4", point: "#AD468F" });
    w(this, pa2, t3), w(this, Gs, e2);
  }
  auto() {
    let t3 = [], e2 = u(this, Gs)[Object.keys(u(this, Gs))[0]];
    return [...e2.getByType("connection"), ...e2.getByType("point-of-interest"), ...e2.getByType("space")].forEach((i) => {
      if (i.__type === "connection") i.coordinates.forEach((o) => {
        let n = i.name || i.externalId;
        if (n) {
          let s2 = u(this, pa2).Labels.add(o, n, x(this, jt, Ky).call(this, i));
          t3.push(s2);
        }
      });
      else {
        i.__type === "space" && i.name !== "" && u(this, pa2).updateState(i, { interactive: true, hoverColor: "#F0F0F0" });
        let o = i.name || i.externalId;
        if (o) {
          let n = u(this, pa2).Labels.add(i, o, x(this, jt, Ky).call(this, i));
          t3.push(n);
        }
      }
    }), { labels: t3 };
  }
};
pa2 = /* @__PURE__ */ new WeakMap(), Gs = /* @__PURE__ */ new WeakMap(), jt = /* @__PURE__ */ new WeakSet(), Ky = function(t3) {
  let e2 = US(x(this, jt, HS).call(this, t3), "white", 12);
  return { appearance: { text: { foregroundColor: x(this, jt, e1).call(this, t3) }, marker: { foregroundColor: { active: x(this, jt, e1).call(this, t3) }, icon: e2, iconSize: 12 } }, interactive: true, rank: x(this, jt, XS).call(this, t3) };
}, HS = function(t3) {
  return t3.__type === "connection" ? x(this, jt, WS).call(this, t3.type) : t3.name.includes("Washroom") ? "washroom-14x14" : t3.__type === "point-of-interest" ? "point-of-interest-12x12" : "";
}, WS = function(t3) {
  let e2 = "";
  switch (t3) {
    case "elevator":
      e2 = "connection-elevator-12x12";
      break;
    case "escalator":
      e2 = "connection-escalator-12x12";
      break;
    case "stairs":
      e2 = "connection-stairs-12x12";
      break;
  }
  return e2;
}, e1 = function(t3) {
  return t3.__type === "connection" ? this.colors.connection : t3.__type === "point-of-interest" ? this.colors.point : "name" in t3 && t3.name.includes("Washroom") ? this.colors.washroom : this.colors.default;
}, XS = function(t3) {
  return t3.__type === "connection" ? "high" : (t3.__type === "point-of-interest", "medium");
};
var ef = class {
  constructor(t3, e2) {
    t(this, "Labels");
    t(this, "auto", () => this.Labels.auto());
    this.Labels = new Kh(t3, e2);
  }
};
c();
var re;
var Cp2;
var Wi;
var tf;
var t1;
var vp2 = class {
  constructor(t3) {
    v(this, Wi);
    v(this, re);
    v(this, Cp2);
    t(this, "interactions", { set: (t4) => {
      (t4 == null ? void 0 : t4.pan) != null && (u(this, re).getSystems().cameraSystem.enablePan = t4.pan), (t4 == null ? void 0 : t4.zoom) != null && (u(this, re).getSystems().cameraSystem.enableZoom = t4.zoom), (t4 == null ? void 0 : t4.bearingAndPitch) != null && (u(this, re).getSystems().cameraSystem.enableRotate = t4.bearingAndPitch);
    }, enable: () => {
      u(this, re).getSystems().cameraSystem.enablePan = true, u(this, re).getSystems().cameraSystem.enableZoom = true, u(this, re).getSystems().cameraSystem.enableRotate = true;
    }, disable: () => {
      u(this, re).getSystems().cameraSystem.enablePan = false, u(this, re).getSystems().cameraSystem.enableZoom = false, u(this, re).getSystems().cameraSystem.enableRotate = false;
    } });
    t(this, "setMinPitch", (t4) => {
      u(this, re).camera.setMinPitch(t4);
    });
    t(this, "setMaxPitch", (t4) => {
      u(this, re).camera.setMaxPitch(t4);
    });
    t(this, "setMinZoomLevel", (t4) => {
      u(this, re).camera.setMinZoomLevel(t4, true);
    });
    t(this, "setMaxZoomLevel", (t4) => {
      u(this, re).camera.setMaxZoomLevel(t4);
    });
    w(this, Cp2, t3), w(this, re, t3.core);
  }
  setScreenOffsets(t3) {
    u(this, re).camera.setInsetPadding(t3);
  }
  get screenOffsets() {
    return u(this, re).camera.insetsPadding;
  }
  get panMode() {
    return u(this, re).camera.panMode;
  }
  setPanMode(t3) {
    if (t3 !== "default" && t3 !== "elevation") throw new Error("Invalid pan mode");
    t3 !== this.panMode && u(this, re).camera.setPanMode(t3);
  }
  getFocusOnTransform(t3, e2) {
    var o;
    let i = u(this, re).camera.getCameraFrameForCoordinates(x(this, Wi, t1).call(this, t3), { pitch: e2 == null ? void 0 : e2.pitch, bearing: e2 == null ? void 0 : e2.bearing, padding: (e2 == null ? void 0 : e2.screenOffsets) || this.screenOffsets, maxZoomLevel: e2 == null ? void 0 : e2.maxZoomLevel, verticalPadding: (o = e2 == null ? void 0 : e2.axisAlignedPadding) == null ? void 0 : o.vertical, minZoomLevel: e2 == null ? void 0 : e2.minZoomLevel, duration: e2 == null ? void 0 : e2.duration, easing: e2 == null ? void 0 : e2.easing });
    return { center: new K2(i.center[1], i.center[0]), zoomLevel: i.zoomLevel };
  }
  focusOn(t3, e2) {
    var i;
    return u(this, re).camera.focusOn(x(this, Wi, t1).call(this, t3), { pitch: e2 == null ? void 0 : e2.pitch, bearing: e2 == null ? void 0 : e2.bearing, padding: (e2 == null ? void 0 : e2.screenOffsets) || this.screenOffsets, maxZoomLevel: e2 == null ? void 0 : e2.maxZoomLevel, minZoomLevel: e2 == null ? void 0 : e2.minZoomLevel, duration: e2 == null ? void 0 : e2.duration, verticalPadding: (i = e2 == null ? void 0 : e2.axisAlignedPadding) == null ? void 0 : i.vertical, easing: e2 == null ? void 0 : e2.easing });
  }
  animateTo(t3, e2) {
    var l;
    let { center: i, zoomLevel: o, bearing: n, pitch: s2 } = t3, c2 = i != null ? i : this.center;
    return u(this, re).camera.animateTo({ center: i != null ? [c2.longitude, c2.latitude, u(this, re).camera.elevation] : void 0, zoomLevel: o, bearing: n, pitch: s2, duration: (l = e2 == null ? void 0 : e2.duration) != null ? l : 600, easing: e2 == null ? void 0 : e2.easing });
  }
  set(t3) {
    let { center: e2 = this.center, zoomLevel: i = this.zoomLevel, bearing: o = this.bearing, pitch: n = this.pitch } = t3, s2 = [e2.longitude, e2.latitude];
    u(this, re).camera.setCenter(s2), u(this, re).camera.setZoomLevel(i), u(this, re).camera.setBearing(o), u(this, re).camera.setPitch(n);
  }
  get center() {
    let t3 = u(this, re).camera.center;
    return new K2(t3[1], t3[0], void 0);
  }
  setAutoMinZoomLevel(t3) {
    u(this, re).camera.setAutoMinZoomLevel(t3);
  }
  get autoMinZoomLevel() {
    return u(this, re).camera.autoMinZoomLevel;
  }
  get zoomLevel() {
    return u(this, re).camera.zoomLevel;
  }
  get pitch() {
    return u(this, re).camera.pitch;
  }
  get minPitch() {
    return u(this, re).camera.minPitch;
  }
  get maxPitch() {
    return u(this, re).camera.maxPitch;
  }
  get bearing() {
    let t3 = u(this, re).camera.bearing;
    return (t3 < 0 ? t3 + 360 : t3) % 360;
  }
  get minZoomLevel() {
    return u(this, re).camera.minZoomLevel;
  }
  get maxZoomLevel() {
    return u(this, re).camera.maxZoomLevel;
  }
  setElevation(t3) {
    u(this, re).camera.setElevation(t3);
  }
  get elevation() {
    return u(this, re).camera.elevation;
  }
  animateElevation(t3, e2) {
    return u(this, re).camera.animateElevation(t3, e2);
  }
};
re = /* @__PURE__ */ new WeakMap(), Cp2 = /* @__PURE__ */ new WeakMap(), Wi = /* @__PURE__ */ new WeakSet(), tf = function(t3) {
  var i, o, n, s2, c2, l;
  let e2 = u(this, re).camera.elevation;
  return K2.is(t3) && t3.floorId != null ? (o = (i = u(this, re).getState(t3.floorId)) == null ? void 0 : i.altitude) != null ? o : e2 : Zt.is(t3) ? (s2 = (n = u(this, re).getState(t3.id)) == null ? void 0 : n.altitude) != null ? s2 : e2 : "floor" in t3 && Zt.is(t3.floor) && (l = (c2 = u(this, re).getState(t3.floor.id)) == null ? void 0 : c2.altitude) != null ? l : e2;
}, t1 = function(t3) {
  var n;
  let e2 = [], o = (Array.isArray(t3) ? t3 : [t3]).flatMap((s2) => {
    var c2;
    return (c2 = s2 == null ? void 0 : s2.focusTarget) != null ? c2 : [s2];
  });
  for (let s2 of o) if (s2 != null) if (K2.is(s2)) {
    let c2 = x(this, Wi, tf).call(this, s2);
    e2.push([s2.longitude, s2.latitude, c2]);
  } else if ((s2 == null ? void 0 : s2.id) != null) {
    let c2 = x(this, Wi, tf).call(this, s2);
    if (Zt.is(s2) && ((n = u(this, Cp2).getMapDataInternal()) != null && n.enterpriseMode)) {
      e2.push(s2.id);
      continue;
    } else if ("geoJSON" in s2 && s2.geoJSON.geometry.coordinates.length > 0) {
      Mi(s2.geoJSON, (p) => {
        e2.push([p[0], p[1], c2]);
      });
      continue;
    }
    let l = u(this, re).getBoundingArea(s2.id);
    if (l) e2.push(...l.map((p) => [p[0], p[1], c2]));
    else if ("geoJSONBoundingBox" in s2) {
      let p = x(this, Wi, tf).call(this, s2);
      if (s2.geoJSONBoundingBox != null) {
        let d = [[s2.geoJSONBoundingBox[0], s2.geoJSONBoundingBox[1], p], [s2.geoJSONBoundingBox[2], s2.geoJSONBoundingBox[3], p]];
        e2.push(...d);
      }
    }
  } else Rg(s2) && e2.push(s2);
  return e2;
};
c();
var Vs;
var Sp2 = class {
  constructor({ currentMapGetter: t3 }) {
    v(this, Vs);
    w(this, Vs, t3);
  }
  get currentMap() {
    return u(this, Vs).call(this);
  }
  async getCurrentSceneGLTF(t3) {
    let e2 = u(this, Vs).call(this);
    return e2 ? e2 == null ? void 0 : e2.Exporter.getCurrentSceneGLTF(t3) : (Lt.error("There is no map to export. Please load a map first."), new Blob());
  }
};
Vs = /* @__PURE__ */ new WeakMap();
c();
var pi;
var Ip;
var xp = class {
  constructor({ currentMapGetter: t3 }) {
    v(this, pi, /* @__PURE__ */ new Map());
    v(this, Ip);
    w(this, Ip, t3);
  }
  get currentMap() {
    return u(this, Ip).call(this);
  }
  getById(t3) {
    return u(this, pi).get(t3);
  }
  add(t3, e2, i) {
    let o = t3.anchorTarget, n = this.currentMap;
    if (!n) throw new Error("currentMap should exist");
    let s2 = n.Labels.add(o, e2, { ...i, parentId: He.is(t3) || zt.is(t3) ? t3.id : void 0, floorId: o.floorId, rank: (i == null ? void 0 : i.rank) == null || (i == null ? void 0 : i.rank) === "initial" ? "medium" : i.rank }), c2 = new zo(s2.id.toString(), e2, t3);
    return u(this, pi).set(c2.id, { label: c2, entityId: c2.id }), c2;
  }
  all(t3) {
    var i;
    let e2 = [];
    return (i = this.currentMap) == null || i.Labels.all({ onCreate: (o, n, s2) => {
      let c2 = new zo(o.toString(), n, s2);
      u(this, pi).set(c2.id, { label: c2, entityId: c2.id }), e2.push(c2);
    }, labelOptions: t3 }), e2;
  }
  remove(t3) {
    var i;
    let e2 = u(this, pi).get(t3.id);
    e2 && ((i = this.currentMap) == null || i.Labels.remove(e2), u(this, pi).delete(t3.id.toString()));
  }
  removeAll() {
    let t3 = [];
    return u(this, pi).forEach(({ label: e2 }) => {
      this.remove(e2), t3.push(e2), u(this, pi).delete(e2.id.toString());
    }), t3;
  }
};
pi = /* @__PURE__ */ new WeakMap(), Ip = /* @__PURE__ */ new WeakMap();
c();
c();
var r1 = { altitude: 0, height: 1, color: "#ffffff", opacity: 1, width: 0.15 };
var YS = { opacity: 0.25, color: "#a7d1ec", height: 0.8, width: 0.05, altitude: 0.1, cap: "square", visible: false };
var ZS = 0.5;
var Xi = class {
  constructor(t3, e2, i = /* @__PURE__ */ new Map()) {
    t(this, "containerId");
    t(this, "labelIds", /* @__PURE__ */ new Set());
    t(this, "layers");
    t(this, "renderer");
    this.containerId = e2, this.layers = i, this.renderer = t3;
  }
  show() {
    this.renderer.setState(this.containerId, { visible: true });
    for (let t3 of this.labelIds) this.renderer.setState(t3, { visible: true });
  }
  hide() {
    this.renderer.setState(this.containerId, { visible: false });
    for (let t3 of this.labelIds) this.renderer.setState(t3, { visible: false });
  }
};
var ua2;
var Pp = class {
  constructor(t3, e2, i, o, n, s2, c2, l) {
    t(this, "id");
    t(this, "name");
    t(this, "elevation");
    t(this, "containerId");
    t(this, "externalId");
    t(this, "metadata");
    t(this, "shortName");
    t(this, "subtitle");
    t(this, "occluderId");
    t(this, "loaded", false);
    t(this, "styleMap", {});
    t(this, "obstructions");
    t(this, "entrances");
    t(this, "spaces");
    t(this, "floorImages");
    t(this, "floorText");
    t(this, "renderer");
    t(this, "options");
    t(this, "layers", /* @__PURE__ */ new Map());
    t(this, "footprint");
    t(this, "floorStackId");
    t(this, "multiFloorView");
    t(this, "mapDataInternal");
    t(this, "facadesByStyleId", /* @__PURE__ */ new Map());
    v(this, ua2);
    t(this, "load", () => {
      var o2, n2, s4, c3, l2, p3, d2, f3, g2, v3, b2;
      if (this.loaded || this.obstructions == null && this.spaces == null) return this;
      this.loaded = true;
      let t4 = this.renderer.addGroupContainer("".concat(Ai, "-").concat(this.id), {}, this.id);
      this.layers.set(Ai, new Xi(this.renderer, t4.id.toString()));
      let e3 = this.renderer.addGroupContainer("".concat(ti, "-").concat(this.id), {}, this.id);
      this.layers.set(ti, new Xi(this.renderer, e3.id.toString()));
      let i2 = this.renderer.addGroupContainer("".concat(we, "-").concat(this.id), {}, this.id);
      if (this.layers.set(we, new Xi(this.renderer, i2.id.toString())), ((o2 = this.footprint) == null ? void 0 : o2.geometry) != null && ((n2 = this.footprint) == null ? void 0 : n2.geometry.coordinates.length) !== 0) {
        let C2 = this.renderer.addGroupContainer("".concat(ps, "-").concat(this.id), {}, this.id);
        this.layers.set(ps, new Xi(this.renderer, C2.id.toString())), this.occluderId = this.renderer.addOccluder(this.footprint, C2.id);
      }
      if (this.spaces != null && this.spaces.features.length > 0) {
        let C2 = [], y = /* @__PURE__ */ new Map();
        this.spaces.features.filter((M2) => {
          var D;
          return M2.geometry.type === "Polygon" && ((D = M2.properties.kind) == null ? void 0 : D.toLowerCase()) !== "void";
        }).forEach((M2) => {
          var F;
          let D = (F = this.mapDataInternal) == null ? void 0 : F.facadesBySpaceId[M2.properties.id];
          if (D) {
            let A = y.get(D.id) || [];
            y.set(D.id, [...A, M2]);
          } else C2.push(M2);
        });
        let S = Wd(C2, this.styleMap), T = this.renderer.addGroupContainer("spaces-".concat(this.id), {}, i2), w2 = 0;
        for (let [M2, D] of S) {
          let F = this.renderer.addGeometryGroup("Spaces-".concat(this.id, "-").concat(w2), { features: D }, gs2(M2, this.options), T);
          w2++;
          let A = T.id.toString();
          this.layers.get(we).layers.set(M2.id || A, F.id.toString());
        }
        if (y.size > 0) {
          let M2 = this.renderer.addGroupContainer("".concat(An, "-").concat(this.id), {}, this.id);
          this.layers.set(An, new Xi(this.renderer, M2.id.toString()));
          for (let [D, F] of y) {
            let A = this.renderer.addGroupContainer(D, {}, M2), k = Wd(F, this.styleMap), B = 0;
            for (let [G, V] of k) {
              let W = this.renderer.addGeometryGroup("Facades-".concat(this.id, "-").concat(D, "-").concat(B), { features: V }, gs2(G, this.options), A);
              B++;
              let $ = G.id || W.id.toString();
              this.layers.get(An).layers.set("".concat(D, "-").concat($), W.id.toString()), this.facadesByStyleId.has($) ? (s4 = this.facadesByStyleId.get($)) == null || s4.push(D) : this.facadesByStyleId.set($, [D]);
            }
          }
        }
      }
      if (this.obstructions != null && this.obstructions.features.length > 0) {
        let C2 = this.obstructions.features.filter((k) => k.geometry.type === "Polygon" && k.properties.kind === "object"), y = Wd(C2, this.styleMap), S = this.renderer.addGroupContainer("objects-".concat(this.id), {}, i2), T = 0;
        for (let [k, B] of y) {
          let G = this.renderer.addGeometryGroup("Objects-".concat(this.id, "-").concat(T), { features: B }, gs2(k, this.options), S);
          T++;
          let V = S.id.toString();
          this.layers.get(we).layers.set(k.id || V, G.id.toString());
        }
        let w2 = this.obstructions.features.filter((k) => k.geometry.type === "LineString" && k.properties.kind === "Wall" && k.properties.footprintComponent === false), M2 = this.obstructions.features.filter((k) => k.geometry.type === "LineString" && k.properties.kind === "Wall" && k.properties.footprintComponent === true), D = this.entrances, F = r1, A = r1;
        if (w2 != null && w2.length > 0) {
          let k = this.styleMap[(c3 = w2[0].properties) == null ? void 0 : c3.id];
          k != null && (F = { ...k }), A = F;
          let { walls: B, entrances: G } = ly2(w2, (D == null ? void 0 : D.features) || []), V = Math.max(F.height - 0.11, ZS), W = { ...YS, height: V }, $ = this.renderer.addGeometryGroup("InteriorDoors-".concat(this.id), G, W, i2);
          this.layers.get(we).layers.set(ss, $.id.toString());
          let U = this.renderer.addGeometryGroup("Walls-".concat(this.id), { features: [B] }, gs2(F, this.options), i2);
          this.layers.get(we).layers.set(Do, U.id.toString());
        }
        if (M2 != null && M2.length > 0) {
          let k = this.styleMap[(l2 = M2[0].properties) == null ? void 0 : l2.id];
          k != null && (A = { ...k, id: ei });
          let { walls: B, entrances: G } = ly2(M2, (D == null ? void 0 : D.features) || []), V = Math.max(A.height - 0.11, ZS), W = { ...YS, height: V }, $ = this.renderer.addGeometryGroup("ExteriorDoors-".concat(this.id), G, W, i2);
          this.layers.get(we).layers.set(ls, $.id.toString());
          let U = this.renderer.addGeometryGroup("ExteriorWalls-".concat(this.id), { features: [B] }, gs2(A, this.options), i2);
          this.layers.get(we).layers.set(ei, U.id.toString());
        }
      }
      if (this.floorImages != null) {
        let C2 = this.renderer.addGroupContainer("images-".concat(this.id), {}, this.id);
        for (let y of this.floorImages.features || []) "anchorId" in y.properties || "anchorId" in y.properties && ((p3 = y.properties) == null ? void 0 : p3.anchorId) == null || this.renderer.addImage(tt(), y, { url: y.properties.path, flipImageToFaceCamera: (d2 = this.options.flipImagesToFaceCamera) != null ? d2 : true }, C2);
        this.layers.set(w4, new Xi(this.renderer, C2.id.toString()));
      }
      if (this.floorText != null) for (let C2 of this.floorText.features || []) {
        let y = 0;
        "geometryId" in C2.properties ? y = (g2 = (f3 = this.renderer.getState(C2.properties.geometryId)) == null ? void 0 : f3.height) != null ? g2 : 0 : y = (v3 = C2.properties.verticalOffset) != null ? v3 : 0, this.renderer.addText3D(tt(), { ...C2, properties: { ...C2.properties, verticalOffset: y } }, {}, this.id);
      }
      return (b2 = this.multiFloorView) != null && b2.enabled && this.renderer.setState(this.id, { altitude: this.elevation * this.multiFloorView.floorHeight }), this.renderer.render(), this;
    });
    var d, f, g, v2, b, C;
    this.id = e2.id, this.options = n;
    let p = i.addGroupContainer(this.id, { visible: false, interactive: true }, t3);
    if (this.containerId = p.id.toString(), this.externalId = e2.externalId, this.metadata = e2.metadata, this.shortName = e2.shortName, this.subtitle = e2.subtitle, this.name = e2.name, this.elevation = e2.elevation, s2 != null && c2 != null && (this.styleMap = c2, this.spaces = s2.space[this.id], this.entrances = s2.entrance[this.id], this.obstructions = s2.obstruction[this.id], this.floorImages = (d = s2.floorImages) == null ? void 0 : d[this.id], this.floorText = (g = (f = s2.enterprise) == null ? void 0 : f.floorText) == null ? void 0 : g[this.id], this.footprint = (v2 = s2["floor.geojson"]) == null ? void 0 : v2.features.find((y) => y.properties.id === e2.id)), this.renderer = i, this.floorStackId = t3, this.multiFloorView = o, this.mapDataInternal = l, this.footprint && ((b = this.multiFloorView) != null && b.enabled)) {
      let y = r1;
      if (this.obstructions != null && this.obstructions.features.length > 0) {
        let T = this.obstructions.features.filter((w2) => w2.geometry.type === "LineString" && w2.properties.kind === "Wall" && w2.properties.footprintComponent === true);
        T != null && T.length > 0 && (y = this.styleMap[(C = T[0].properties) == null ? void 0 : C.id]);
      }
      let S = this.renderer.addGeometryGroup("Footprint-".concat(this.id), { features: [{ geometry: this.footprint.geometry, properties: { id: "Footprint-Floor-".concat(this.id) } }] }, { ...y, height: this.multiFloorView.floorHeight, altitude: 0, opacity: this.elevation < 0 ? 1 : 0.4, side: this.elevation < 0 ? "back" : "double", color: this.elevation < 0 ? "#F0EEE8" : y.color }, this.id);
      this.layers.set(cs, new Xi(this.renderer, S.id.toString()));
    }
  }
  get geoJSONBoundingBox() {
    if (u(this, ua2)) return u(this, ua2);
    if (!this.footprint) {
      Lt.warn("Attempting to get bounding box with no footprint for floor ".concat(this.id));
      return;
    }
    return w(this, ua2, Xd(this.footprint)), u(this, ua2);
  }
  get visible() {
    return this.renderer.getState(this.containerId).visible;
  }
  setVisible(t3) {
    this.renderer.setState(this.containerId, { visible: t3 });
  }
};
ua2 = /* @__PURE__ */ new WeakMap();
c();
var i1 = 50;
var o1 = false;
var sD = 1e3;
var Le;
var js;
var ui;
var Fr;
var ut;
var Tp2;
var en;
var Us;
var da2;
var Ut;
var a1;
var ha;
var wp2;
var Dp2;
var Ep2;
var Op;
var Yi;
var JS;
var Lp;
var tn;
var s1;
var QS;
var KS;
var fa2;
var Mp = class extends _n {
  constructor({ currentMapGetter: e2 }) {
    super();
    v(this, Ut);
    v(this, Le);
    v(this, js, 0);
    v(this, ui);
    v(this, Fr, false);
    v(this, ut, []);
    v(this, Tp2, 0);
    v(this, en, i1);
    v(this, Us, false);
    v(this, da2, "collapsed");
    t(this, "expandedFactor", 0);
    v(this, ha, "all-floors");
    v(this, wp2, () => {
      let e3 = u(this, Le).call(this);
      if (u(this, Tp2) === this.expandedFactor || e3 == null || !u(this, Fr)) return;
      w(this, Tp2, this.expandedFactor);
      let i2 = su(this.expandedFactor, 0, 1, 0, this.distanceBetweenFloors), n = su(this.expandedFactor, 0, 0.1, 0, 1) === 0;
      u(this, ut).forEach((s2, c2) => {
        e3.renderer.setState(s2.containerId, { visible: n ? s2.id === e3.currentFloorId : true, altitude: i2 * c2 });
      }), this.expandedFactor === 0 ? (w(this, Fr, false), e3.renderer.camera.setPanMode("default"), u(this, tn) && u(this, tn).call(this)) : this.expandedFactor === 1 && (w(this, Fr, false), u(this, tn) && u(this, tn).call(this));
    });
    v(this, Dp2, () => {
      var e3, i2, o;
      this.expanded && w(this, js, (i2 = (e3 = u(this, Le).call(this)) == null ? void 0 : e3.renderer.camera.elevation) != null ? i2 : 0), (o = u(this, Le).call(this)) == null || o.renderer.on("user-interaction-end", u(this, Op));
    });
    v(this, Ep2, () => {
      var i2;
      let e3 = u(this, Le).call(this);
      if (e3 != null && this.expanded && u(this, Us) && !u(this, Fr)) {
        let o = e3.currentFloorId, n = [1 / 0, e3.currentFloorId];
        for (let s2 = 0; s2 < u(this, ut).length; s2++) {
          let c2 = u(this, ut)[s2], l = Math.abs(((i2 = e3.renderer.camera.elevation) != null ? i2 : 0) - s2 * this.distanceBetweenFloors);
          l < this.distanceBetweenFloors / 3 && (n[0] = l, n[1] = c2.id);
        }
        n[1] !== e3.currentFloorId && (e3.currentFloorId = n[1], u(this, ut).forEach((s2) => {
          e3.renderer.setState(s2.containerId, { visible: u(this, ha) === "all-floors" ? true : e3.currentFloor.id === s2.id });
        }), e3.publish("floor-change", { reason: "stacked-maps-elevation-change", floorId: e3.currentFloorId, previousFloorId: o }));
      }
    });
    v(this, Op, () => {
      var i2, o;
      let e3 = u(this, Le).call(this);
      if (this.expanded && e3 && u(this, js) !== ((i2 = e3.renderer.camera.elevation) != null ? i2 : 0)) {
        let n = [1 / 0, e3.currentFloorId, 0];
        for (let s2 = 0; s2 < u(this, ut).length; s2++) {
          let c2 = u(this, ut)[s2], l = Math.abs(((o = e3.renderer.camera.elevation) != null ? o : 0) - s2 * this.distanceBetweenFloors);
          l < n[0] && (n[0] = l, n[1] = c2.id, n[2] = s2 * this.distanceBetweenFloors);
        }
        u(this, Us) && x(this, Ut, JS).call(this, n[2]), w(this, js, 0), e3.renderer.off("user-interaction-end", u(this, Op));
      }
    });
    v(this, Yi, null);
    v(this, Lp, null);
    v(this, tn);
    v(this, fa2);
    w(this, Le, e2);
    let i = u(this, Le).call(this);
    i != null && i.id !== "outdoors" && (i.renderer.on("user-interaction-start", u(this, Dp2)), i.renderer.on("camera-change", u(this, Ep2)), i.renderer.on("pre-render", u(this, wp2)));
  }
  get state() {
    return u(this, da2);
  }
  get expanded() {
    return u(this, da2) !== "collapsed";
  }
  get distanceBetweenFloors() {
    if (u(this, en) === "auto") {
      if (u(this, fa2) != null) return u(this, fa2);
      let e2 = x(this, Ut, KS).call(this);
      if (e2) return w(this, fa2, e2), e2;
    }
    return typeof u(this, en) == "number" ? u(this, en) : i1;
  }
  clearCachedFloorSeparationDistance() {
    w(this, fa2, void 0);
  }
  get includedFloors() {
    var e2;
    return (e2 = u(this, Ut, a1)) != null && e2.api.mapData ? u(this, ut).map((i) => {
      var o, n;
      return (n = (o = u(this, Ut, a1)) == null ? void 0 : o.api.mapData) == null ? void 0 : n.getById("floor", i.id);
    }).filter(Boolean) : [];
  }
  get floorVisibilityMode() {
    return u(this, ha);
  }
  setFloorVisiblityMode(e2) {
    w(this, ha, e2);
    let i = u(this, Le).call(this);
    i != null && u(this, ut).forEach((o) => {
      i.renderer.setState(o.containerId, { visible: u(this, ha) === "all-floors" ? true : i.currentFloor.id === o.id });
    });
  }
  changeFloorOnElevationChanges(e2) {
    w(this, Us, e2);
  }
  async expand(e2) {
    var o, n, s2;
    let i = u(this, Le).call(this);
    if (i != null) return (e2 == null ? void 0 : e2.distanceBetweenFloors) === "auto" ? w(this, en, "auto") : w(this, en, (o = e2 == null ? void 0 : e2.distanceBetweenFloors) != null ? o : i1), w(this, ut, (e2 == null ? void 0 : e2.includedFloors) != null && (e2 == null ? void 0 : e2.includedFloors.length) > 0 ? e2 == null ? void 0 : e2.includedFloors.map((c2) => i.floorsById.get(c2.id)).filter(Boolean) : i.currentFloorStack.floorObjects), u(this, ut).sort((c2, l) => c2.elevation - l.elevation), u(this, ut).length <= 1 || this.expanded === true ? Promise.resolve() : (w(this, Fr, true), i.api.Camera.setPanMode((n = e2 == null ? void 0 : e2.cameraPanMode) != null ? n : "elevation"), this.changeFloorOnElevationChanges((s2 = e2 == null ? void 0 : e2.changeFloorOnElevationChanges) != null ? s2 : true), x(this, Ut, s1).call(this, "expand", e2).then(() => {
      w(this, da2, "expanded"), this.publish("stacked-maps-state-change", { state: "expanded" });
    }).finally(() => {
      w(this, Fr, false);
    }));
  }
  async collapse(e2) {
    let i = u(this, Le).call(this);
    if (i != null) return this.expanded === true ? (w(this, Fr, true), i.api.Camera.setPanMode("default"), this.changeFloorOnElevationChanges(false), x(this, Ut, s1).call(this, "collapse", e2).then(() => {
      w(this, da2, "collapsed"), this.publish("stacked-maps-state-change", { state: "collapsed" });
    }).finally(() => {
      w(this, Fr, false);
    })) : Promise.resolve();
  }
  destroy() {
    let e2 = u(this, Le).call(this);
    e2 != null && (e2.renderer.off("user-interaction-start", u(this, Dp2)), e2.renderer.off("camera-change", u(this, Ep2)), e2.renderer.off("pre-render", u(this, wp2)));
  }
};
Le = /* @__PURE__ */ new WeakMap(), js = /* @__PURE__ */ new WeakMap(), ui = /* @__PURE__ */ new WeakMap(), Fr = /* @__PURE__ */ new WeakMap(), ut = /* @__PURE__ */ new WeakMap(), Tp2 = /* @__PURE__ */ new WeakMap(), en = /* @__PURE__ */ new WeakMap(), Us = /* @__PURE__ */ new WeakMap(), da2 = /* @__PURE__ */ new WeakMap(), Ut = /* @__PURE__ */ new WeakSet(), a1 = function() {
  return u(this, Le).call(this);
}, ha = /* @__PURE__ */ new WeakMap(), wp2 = /* @__PURE__ */ new WeakMap(), Dp2 = /* @__PURE__ */ new WeakMap(), Ep2 = /* @__PURE__ */ new WeakMap(), Op = /* @__PURE__ */ new WeakMap(), Yi = /* @__PURE__ */ new WeakMap(), JS = function(e2) {
  var o, n, s2;
  u(this, Yi) && u(this, Yi).stop();
  let i = u(this, Le).call(this);
  i != null && (w(this, Yi, new Gt({ elevation: (o = i.renderer.camera.elevation) != null ? o : 0 }).to({ elevation: e2 }, 150).easing(Fe.Quadratic.Out).onComplete(() => {
    var c2;
    u(this, Yi) && ((c2 = u(this, Le).call(this)) == null || c2.renderer.getTweenGroup().remove(u(this, Yi)));
  }).onUpdate(({ elevation: c2 }) => {
    i.renderer.camera.setElevation(c2);
  }).start()), (n = u(this, Le).call(this)) == null || n.renderer.getTweenGroup().add(u(this, Yi)), (s2 = u(this, Le).call(this)) == null || s2.renderer.render());
}, Lp = /* @__PURE__ */ new WeakMap(), tn = /* @__PURE__ */ new WeakMap(), s1 = function(e2, i) {
  var c2, l, p, d;
  u(this, ui) && u(this, ui).stop();
  let o = u(this, Le).call(this);
  if (o == null) return Promise.reject(new Error("No current map"));
  let n = u(this, ut).indexOf(o.currentFloor), s2 = (c2 = o.renderer.camera.elevation) != null ? c2 : 0;
  return w(this, Lp, new Promise((f) => {
    w(this, tn, f);
  })), w(this, ui, new Gt({ percentExpanded: this.expandedFactor }).to({ percentExpanded: e2 === "expand" ? 1 : 0 }, (l = i == null ? void 0 : i.duration) != null ? l : sD).easing(ws2[(i == null ? void 0 : i.easing) || "ease-in-out"]).onUpdate(({ percentExpanded: f }) => {
    this.expandedFactor = f;
    let g = n * this.distanceBetweenFloors;
    o.renderer.camera.setElevation(e2 === "expand" ? g * f : s2 * f);
  }).onComplete(() => {
    var f;
    u(this, ui) && ((f = u(this, Le).call(this)) == null || f.renderer.getTweenGroup().remove(u(this, ui)));
  }).start()), u(this, ui).cameraAnimation = true, (p = u(this, Le).call(this)) == null || p.renderer.getTweenGroup().add(u(this, ui)), (d = u(this, Le).call(this)) == null || d.renderer.render(), u(this, Lp);
}, QS = function(e2, i, o, n) {
  let s2 = n1(e2, o), c2 = i.clone(), l = n1(c2, o);
  if (!wu(s2) || !wu(l)) return -1;
  let p = 0, d;
  o1 && n.querySelectorAll(".debug-box").forEach((g) => g.remove());
  do {
    if (p > 1e4) return -1;
    if (p += 20, c2.position.z = p, c2.updateMatrixWorld(), l.makeEmpty(), n1(c2, o, l), d = s2.intersectsBox(l), o1) {
      let f = $S(s2, "blue", n), g = $S(l, d ? "red" : "green", n);
      f.classList.add("debug-box"), g.classList.add("debug-box");
    }
  } while (d);
  return p;
}, KS = function() {
  let e2 = u(this, Le).call(this);
  if (!e2) return;
  let i = e2.renderer, o = i.getThreeScene();
  if (!e2.api.mapData || !o) return;
  let s2 = u(this, ut).length > 0 ? u(this, ut) : e2.currentFloorStack.floorObjects;
  if (s2.length < 2) return;
  let c2 = i.getInternalState().geometry3DMap.get(s2[0].id), l = i.getInternalState().geometry3DMap.get(s2[1].id);
  if (!c2 || !l) return;
  if (Jp(c2, "group-container"), Jp(l, "group-container"), o1) {
    let d = new Ie();
    d.setFromObject(c2);
    let f = new Ie();
    if (f.setFromObject(l), c2.children.forEach((T) => {
      T instanceof ve && T.userData.debugBox && ji(T);
    }), l.children.forEach((T) => {
      T instanceof ve && T.userData.debugBox && ji(T);
    }), !wu(d) || !wu(f)) return;
    let g = new ki(d.max.x - d.min.x, d.max.y - d.min.y, d.max.z - d.min.z), v2 = new fs({ color: 255, transparent: true, opacity: 0.5 }), b = new ve(g, v2);
    b.position.set((d.min.x + d.max.x) / 2, (d.min.y + d.max.y) / 2, (d.min.z + d.max.z) / 2), b.userData.debugBox = true;
    let C = new ki(f.max.x - f.min.x, f.max.y - f.min.y, f.max.z - f.min.z), y = new fs({ color: "cyan", transparent: true, opacity: 0.5 }), S = new ve(C, y);
    S.position.set((f.min.x + f.max.x) / 2, (f.min.y + f.max.y) / 2, (f.min.z + f.max.z) / 2), S.userData.debugBox = true, c2.add(b), l.add(S);
  }
  let p = x(this, Ut, QS).call(this, c2, l, i.getThreeCamera(), i.container);
  if (p !== -1) return p;
}, fa2 = /* @__PURE__ */ new WeakMap();
var Ko = new R();
var zS = new at();
function n1(r3, t3, e2 = new wl()) {
  return r3.traverse((i) => {
    if (i instanceof ve) {
      let n = i.geometry.attributes.position;
      if (t3.position.distanceTo(i.position) < t3.near) return;
      for (let c2 = 0; c2 < n.count; c2++) Ko.fromBufferAttribute(n, c2), Ko.applyMatrix4(i.matrixWorld), Ko.applyMatrix4(t3.matrixWorldInverse), Ko.applyMatrix4(t3.projectionMatrix), Ko.z < 1 && Ko.z > 0 && (zS.set(Ko.x, Ko.y), e2.expandByPoint(zS));
    }
  }), e2;
}
function qS(r3, t3) {
  let e2 = t3.clientWidth, i = t3.clientHeight;
  return new at((r3.x + 1) * e2 / 2, (1 - r3.y) * i / 2);
}
function $S(r3, t3, e2) {
  let i = document.createElement("div");
  i.style.position = "absolute", i.style.border = "2px solid ".concat(t3), i.style.pointerEvents = "none";
  let o = qS(new at(r3.min.x, r3.min.y), e2), n = qS(new at(r3.max.x, r3.max.y), e2);
  i.style.left = "".concat(o.x, "px"), i.style.top = "".concat(n.y, "px");
  let s2 = Math.abs(n.x - o.x), c2 = Math.abs(n.y - o.y);
  return i.style.width = "".concat(s2, "px"), i.style.height = "".concat(c2, "px"), e2.appendChild(i), i;
}
c();
var Hs;
var Ap = class {
  constructor(t3, e2, i, o) {
    t(this, "id");
    t(this, "externalId");
    t(this, "name");
    t(this, "type");
    t(this, "floorIds");
    t(this, "defaultFloorId");
    t(this, "floorObjects", []);
    t(this, "floorObjectsByElevation", /* @__PURE__ */ new Map());
    t(this, "metadata");
    t(this, "containerId");
    t(this, "facade");
    t(this, "renderer");
    v(this, Hs);
    var s2;
    this.id = t3.id, this.externalId = t3.externalId, this.name = t3.name, this.type = t3.type, this.metadata = t3.metadata, this.floorIds = (s2 = t3.floors) != null ? s2 : t3.maps, this.defaultFloorId = t3.defaultFloor, this.renderer = i;
    let n = i.addGroupContainer(this.id, { visible: true, interactive: true }, e2);
    this.containerId = n.id.toString(), this.facade = o;
  }
  get defaultFloor() {
    if (u(this, Hs) == null) {
      this.floorObjects.length === 0 && Lt.throw("No floors in floor stack (".concat(this.id, "). Could not get default floor."));
      let t3;
      this.defaultFloorId && (t3 = this.floorObjects.find((e2) => e2.id === this.defaultFloorId)), t3 || (t3 = this.floorObjects.reduce((e2, i) => Math.abs(i.elevation) < Math.abs(e2.elevation) ? i : e2)), w(this, Hs, t3);
    }
    return u(this, Hs);
  }
  addFloor(t3) {
    if (this.floorObjectsByElevation.has(t3.elevation)) {
      Lt.error("Floor with same elevation ".concat(t3.elevation, " already exists in Stack (").concat(this.id, "). Floor (").concat(t3.id, ") will not be added."));
      return;
    }
    t3.load(), this.floorObjects.push(t3), this.floorObjectsByElevation.set(t3.elevation, t3);
  }
  setFacadeVisible(t3) {
    var e2, i;
    (i = (e2 = this.facade) == null ? void 0 : e2.spaces) == null || i.forEach((o) => {
      this.renderer.setState(o.spaceId, { visible: t3 });
    });
  }
};
Hs = /* @__PURE__ */ new WeakMap();
c();
function ex(r3, t3, e2, i) {
  let o = { outdoorOpacity: 1, floorStates: [] };
  for (let n = 0; n < r3.length; n++) {
    let s2 = r3[n];
    o.floorStates.push({ floor: s2, visible: false, visibleLayers: [], footprint: { height: 0, altitude: 0 } }), s2.id === t3.id ? (o.floorStates[n].visible = true, o.floorStates[n].visibleLayers = [ti, we, Ai, ps], s2.elevation < 0 && (o.outdoorOpacity = 0.2, o.floorStates[n].footprint.height = Math.abs(s2.elevation) * e2, o.floorStates[n].footprint.altitude = 0, o.floorStates[n].visibleLayers.push(cs))) : i.includes(s2.id) && s2.elevation < t3.elevation ? (o.floorStates[n].visible = true, o.floorStates[n].visibleLayers = [cs, ti, we, ps], s2.elevation < 0 ? (o.floorStates[n].footprint.height = Math.abs(s2.elevation) * e2, o.floorStates[n].footprint.altitude = 0, o.outdoorOpacity = 0.2) : (o.floorStates[n].footprint.height = e2, o.floorStates[n].footprint.altitude = 0)) : t3.elevation > 0 && s2.elevation < t3.elevation && s2.elevation >= 0 && (o.floorStates[n].visible = true, o.floorStates[n].visibleLayers = [cs], o.floorStates[n].footprint.height = e2, o.floorStates[n].footprint.altitude = 0);
  }
  return o;
}
c();
c();
c();
c();
var Ws;
var ma;
var Ke;
var kp2;
var ga;
var Bp;
var _p;
var Xs;
var Ft;
var Fp = class {
  constructor(t3, e2, i) {
    t(this, "id");
    v(this, Ws);
    v(this, ma);
    v(this, Ke);
    v(this, kp2);
    v(this, ga, []);
    v(this, Bp, false);
    v(this, _p, 1);
    v(this, Xs, /* @__PURE__ */ new Map());
    v(this, Ft);
    this.id = t3.id, w(this, Ws, t3), w(this, ma, e2), w(this, Ke, i), this.setDefaultFloor(this.defaultFloor);
  }
  get floorStack() {
    return u(this, ma);
  }
  get defaultFloor() {
    var t3;
    return (t3 = u(this, kp2)) != null ? t3 : u(this, ma).defaultFloor;
  }
  setDefaultFloor(t3) {
    u(this, ga).forEach((e2) => {
      u(this, Ke).setState(u(this, Ke).getState(e2), { opacity: 1 });
    }), u(this, Ft) && (this.defaultFloor.setVisible(false), t3.setVisible(true)), w(this, kp2, t3), this.updateChildGeometryIds(t3);
  }
  updateChildGeometryIds(t3) {
    w(this, ga, []);
    let e2 = u(this, Ke).getState(t3.layers.get(we).containerId);
    for (let i of e2.children) {
      let o = u(this, Ke).getState(i);
      for (let n of o.children) {
        let s2 = u(this, Ke).getState(n);
        s2 && u(this, ga).push(s2.id.toString());
      }
    }
  }
  set focusable(t3) {
    w(this, Bp, t3), u(this, Ws).spaces.forEach((e2) => {
      let i = u(this, Ke).getState(e2.id);
      i && u(this, Ke).setState(i, { focusable: t3, renderOrder: t3 ? 2 : 0 });
    });
  }
  get focusable() {
    return u(this, Bp);
  }
  set opacity(t3) {
    w(this, _p, t3), u(this, Ws).spaces.forEach((e2) => {
      let i = u(this, Ke).getState(e2.id);
      i && (u(this, Xs).has(e2.id) || u(this, Xs).set(e2.id, i.opacity), u(this, Ke).setState(i, { opacity: Math.min(u(this, Xs).get(e2.id), t3) }));
    });
  }
  get opacity() {
    return u(this, _p);
  }
  animateOpacity(t3, { duration: e2 = 300, onEnd: i } = {}) {
    u(this, Ft) && u(this, Ft).stop(), t3 < 1 && this.defaultFloor.setVisible(true), w(this, Ft, new Gt({ opacity: this.opacity }).easing(Fe.Quadratic.In).to({ opacity: t3 }, e2).onUpdate(({ opacity: o }) => {
      this.opacity = o, u(this, ga).forEach((n) => {
        u(this, Ke).setState(u(this, Ke).getState(n), { opacity: 1 - o });
      });
    }).onStop(() => {
      u(this, Ft) && (u(this, Ke).getTweenGroup().remove(u(this, Ft)), w(this, Ft, void 0)), i == null || i();
    }).onComplete(() => {
      u(this, Ft) && (u(this, Ke).getTweenGroup().remove(u(this, Ft)), w(this, Ft, void 0)), this.opacity === 1 && u(this, ma).floorObjects.forEach((o) => {
        o.setVisible(false);
      }), i == null || i();
    })), u(this, Ft).start(), u(this, Ke).getTweenGroup().add(u(this, Ft)), u(this, Ke).render();
  }
};
Ws = /* @__PURE__ */ new WeakMap(), ma = /* @__PURE__ */ new WeakMap(), Ke = /* @__PURE__ */ new WeakMap(), kp2 = /* @__PURE__ */ new WeakMap(), ga = /* @__PURE__ */ new WeakMap(), Bp = /* @__PURE__ */ new WeakMap(), _p = /* @__PURE__ */ new WeakMap(), Xs = /* @__PURE__ */ new WeakMap(), Ft = /* @__PURE__ */ new WeakMap();
var rx = false;
var kr2;
var ya;
var Ys;
var rn;
var Rp;
var ba;
var Br;
var di;
var Np2;
var me;
var ot;
var ix;
var l1;
var rf;
var Gp;
var c1;
var Vp2;
var Zs;
var zs;
var qs2 = class extends _n {
  constructor(e2, i, { currentMapGetter: o }) {
    super();
    v(this, me);
    v(this, kr2);
    v(this, ya, false);
    v(this, Ys, 17);
    v(this, rn, false);
    v(this, Rp);
    v(this, ba);
    v(this, Br, /* @__PURE__ */ new Map());
    v(this, di, /* @__PURE__ */ new Set());
    v(this, Np2, /* @__PURE__ */ new Set());
    v(this, Gp, (e3, i2) => {
      if (!u(this, ya) || e3.length === 0 || !u(this, rn)) return;
      let o2 = -1 / 0, n, s2 = false, c2 = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Map();
      e3.forEach((p, d) => {
        var b;
        let f = x(this, me, l1).call(this, p);
        if (!f) return;
        let g = 1 - d / e3.length, v2 = ((b = l.get(f.id)) != null ? b : 0) + g;
        l.set(f.id, v2), v2 > o2 && (o2 = v2, n = f), u(this, di).has(f.id) || (x(this, me, rf).call(this, f.id, 0), s2 = true), c2.add(f.id);
      }), rx && Lt.log("likelyInFocus:", [n == null ? void 0 : n.floorStack.name, o2], "Weights:", e3.flatMap((p) => {
        let d = x(this, me, l1).call(this, p);
        return d ? [d.floorStack.name, l.get(d.id)] : [];
      }));
      for (let p of u(this, di)) c2.has(p) || (x(this, me, rf).call(this, p, 1), s2 = true);
      w(this, di, c2), w(this, Np2, new Set(e3)), i2 && n && u(this, me, ot).currentFloorStackId !== n.floorStack.id && (x(this, me, ix).call(this, n.id), s2 = true), s2 && this.publish("focus-change", { facades: Array.from(u(this, di)), spaces: e3 });
    });
    v(this, Vp2, (e3) => {
      u(this, Gp).call(this, e3, true);
    });
    v(this, Zs, (e3) => {
      if (e3.zoomLevel >= u(this, Ys) && !u(this, rn)) w(this, rn, true);
      else if (e3.zoomLevel < u(this, Ys) && u(this, rn)) {
        w(this, rn, false);
        for (let i2 of u(this, Br).values()) i2.opacity < 1 && x(this, me, rf).call(this, i2.id, 1);
        u(this, di).clear(), u(this, me, ot).outdoorFloorStacks.size > 0 && !u(this, me, ot).outdoorFloorStacks.has(u(this, me, ot).currentFloorStackId) && (u(this, me, ot).setFloorStack(u(this, me, ot).outdoorFloorStacks.values().next().value, "dynamic-focus"), this.publish("focus-change", { facades: [], spaces: [] }));
      }
    });
    v(this, zs, ({ floorId: e3 }) => {
      var n;
      let i2 = u(this, me, ot).floorsById.get(e3);
      if (!i2) return;
      let o2 = (n = u(this, me, ot).floorStacksById.get(i2.floorStackId)) == null ? void 0 : n.facade;
      if (o2 && !u(this, di).has(o2.id)) {
        let s2 = o2.spaces.map((c2) => c2.spaceId);
        u(this, Gp).call(this, [...s2, ...u(this, Np2)], false);
      }
    });
    w(this, kr2, e2), w(this, Rp, o), w(this, ba, i);
  }
  get focusedFacades() {
    return Array.from(u(this, di)).map((e2) => {
      var i;
      return (i = u(this, ba).getMapDataInternal()) == null ? void 0 : i.getById("facade", e2);
    }).filter((e2) => e2 != null);
  }
  enable(e2) {
    var i;
    w(this, Ys, (i = e2 == null ? void 0 : e2.minZoomLevel) != null ? i : 17), this.enabled || (u(this, kr2).on("geometry-in-focus", u(this, Vp2)), u(this, kr2).on("camera-change", u(this, Zs)), u(this, me, ot).on("floor-change", u(this, zs)), u(this, Zs).call(this, u(this, kr2).camera), x(this, me, c1).call(this, true), u(this, zs).call(this, { floorId: u(this, me, ot).currentFloorId }), w(this, ya, true)), rx && u(this, kr2).getSystems().geometryInFocusSystem.showRaycasters();
  }
  disable() {
    w(this, ya, false), u(this, kr2).off("geometry-in-focus", u(this, Vp2)), u(this, kr2).off("camera-change", u(this, Zs)), u(this, me, ot).off("floor-change", u(this, zs)), x(this, me, c1).call(this, false);
  }
  get enabled() {
    return u(this, ya);
  }
  setDefaultFloorForStack(e2, i) {
    u(this, me, ot) == null && Lt.throw("Current map does not exist.");
    let o = u(this, me, ot).floorsById.get(i.id);
    if (o == null) {
      Lt.warn("Floor (".concat(i.id, ") does not exist. Default floor will not be set."));
      return;
    }
    if (o.floorStackId !== e2.id) {
      Lt.warn("Floor (".concat(i.id, ") does not belong to floor stack (").concat(e2.id, "). Default floor will not be set."));
      return;
    }
    let n = e2.facade && u(this, Br).get(e2.facade.id);
    n && n.setDefaultFloor(o);
  }
  resetDefaultFloorForStack(e2) {
    let i = e2.facade && u(this, Br).get(e2.facade.id);
    i && i.setDefaultFloor(i.floorStack.defaultFloor);
  }
};
kr2 = /* @__PURE__ */ new WeakMap(), ya = /* @__PURE__ */ new WeakMap(), Ys = /* @__PURE__ */ new WeakMap(), rn = /* @__PURE__ */ new WeakMap(), Rp = /* @__PURE__ */ new WeakMap(), ba = /* @__PURE__ */ new WeakMap(), Br = /* @__PURE__ */ new WeakMap(), di = /* @__PURE__ */ new WeakMap(), Np2 = /* @__PURE__ */ new WeakMap(), me = /* @__PURE__ */ new WeakSet(), ot = function() {
  return u(this, Rp).call(this);
}, ix = function(e2) {
  let i = u(this, Br).get(e2);
  i && u(this, me, ot).setFloor(i.defaultFloor.id, "dynamic-focus");
}, l1 = function(e2) {
  var o;
  let i = (o = u(this, ba).getMapDataInternal()) == null ? void 0 : o.facadesBySpaceId[e2];
  return u(this, Br).get(i.id);
}, rf = function(e2, i) {
  let o = u(this, Br).get(e2);
  if (o) if (i < 1) {
    let n = o.defaultFloor, s2 = u(this, me, ot).floorsById.get(u(this, me, ot).currentFloorId);
    o.floorStack.id === (s2 == null ? void 0 : s2.floorStackId) && s2.id !== o.defaultFloor.id && o.setDefaultFloor(s2), o.animateOpacity(i, { onEnd: () => {
      o.defaultFloor !== n && o.setDefaultFloor(n);
    } });
  } else o.animateOpacity(i);
}, Gp = /* @__PURE__ */ new WeakMap(), c1 = function(e2) {
  var i;
  (i = u(this, ba).getMapDataInternal()) == null || i.facades.forEach((o) => {
    let n = u(this, Br).get(o.id);
    n == null && (n = new Fp(o, u(this, me, ot).floorStacksById.get(o.floorStack.id), u(this, kr2)), u(this, Br).set(o.id, n)), n.focusable = e2;
  });
}, Vp2 = /* @__PURE__ */ new WeakMap(), Zs = /* @__PURE__ */ new WeakMap(), zs = /* @__PURE__ */ new WeakMap();
var pD = { linear: Fe.Linear.None, easeIn: Fe.Quadratic.In, easeOut: Fe.Quadratic.Out, easeInOut: Fe.Quadratic.InOut };
var hi;
var jp2 = class extends _n {
  constructor(e2, i, o, n) {
    var p, d, f, g;
    super();
    t(this, "floorStacksById", /* @__PURE__ */ new Map());
    t(this, "floorsById", /* @__PURE__ */ new Map());
    t(this, "currentFloorId", "");
    t(this, "currentFloorStackId", "");
    t(this, "outdoorFloorStacks", /* @__PURE__ */ new Set());
    t(this, "id");
    t(this, "renderer");
    t(this, "api");
    t(this, "mvf");
    t(this, "options", {});
    t(this, "styleMap");
    t(this, "StackedMaps");
    t(this, "DynamicFocus");
    t(this, "animations", /* @__PURE__ */ new Map());
    t(this, "Models", { add: (e3, i2, o2) => {
      let { floorId: n2, scale: s4, ...c3 } = o2, l2 = n2 ? this.floorsById.get(n2) : this.currentFloor, p3 = { ...c3 };
      s4 != null && (p3.scale = Array.isArray(o2.scale) ? o2.scale : [o2.scale, o2.scale, o2.scale]);
      let d2 = this.renderer.addModelGroup(e3, { type: "FeatureCollection", features: i2.map((f3) => {
        var g2;
        return { type: "Feature", properties: { id: tt(), rotation: o2.rotation, scale: p3.scale, interactive: o2.interactive, verticalOffset: f3.verticalOffset + ((g2 = o2.verticalOffset) != null ? g2 : 0) }, geometry: { type: "Point", coordinates: sr(f3) } };
      }) }, p3, { parent: l2.id });
      if (d2 == null) throw new Error("error creating model");
      return this.renderer.getState(d2).children;
    }, remove: (e3, i2) => {
      this.renderer.remove(e3), this.renderer.getState(i2).children.length === 0 && this.renderer.remove(i2);
    } });
    t(this, "Images", { add: (e3, i2, o2) => {
      let { floorId: n2, flipImageToFaceCamera: s4, ...c3 } = o2, l2 = n2 ? this.floorsById.get(n2) : this.currentFloor, p3 = { type: "Feature", properties: c3, geometry: { type: "Point", coordinates: e3 } };
      return this.renderer.addImage(tt(), p3, { url: i2, flipImageToFaceCamera: s4 != null ? s4 : false }, l2.id);
    }, remove: (e3) => {
      this.renderer.remove(e3);
    }, removeAll: () => {
    } });
    t(this, "Markers", { add: (e3, i2, o2) => {
      var c3;
      let n2 = uy2(e3, this.floorsById, this.api.mapObjects[0].floorsById.get("default-floor")), s4 = o2;
      return o2.rank === "initial" && (s4.rank = "medium"), this.renderer.addMarker2D(sr(e3), i2, { ...s4, occluderId: n2 == null ? void 0 : n2.occluderId }, (c3 = n2 == null ? void 0 : n2.layers.get(ti)) == null ? void 0 : c3.containerId);
    }, remove: (e3) => {
      this.renderer.remove(e3);
    }, getContentEl: (e3) => {
      let i2 = this.renderer.getState(e3);
      if ((i2 == null ? void 0 : i2.type) === "marker") return i2.element;
    }, removeAll: () => {
    }, setPosition: (e3, i2, o2) => {
      var c3;
      let n2 = this.renderer.getState(e3), s4 = o2 ? this.floorsById.get(o2) : this.currentFloor;
      if (!n2) {
        Lt.error('Failed to retrieve state for Marker with id "'.concat(e3, '".'));
        return;
      }
      if (n2.type !== "marker") {
        Lt.error('Geometry with id "'.concat(e3, '" is not of type "marker".'));
        return;
      }
      this.renderer.setState(n2, { position: i2, parent: (c3 = s4 == null ? void 0 : s4.layers.get(ti)) == null ? void 0 : c3.containerId });
    }, animateTo: (e3, i2, o2, n2) => {
      let s4 = this.renderer.getState(e3), c3 = o2 ? this.floorsById.get(o2) : this.currentFloor;
      if (!s4) return Lt.error('Failed to retrieve state for Marker with id "'.concat(e3, '".')), Promise.resolve();
      if (s4.type !== "marker") return Lt.error('Geometry with id "'.concat(e3, '" is not of type "marker".')), Promise.resolve();
      let l2 = { duration: 1e3, easing: "ease-in-out", ...n2 };
      this.cancelAnimation(e3);
      let p3 = new Gt({ lon: s4.position[0], lat: s4.position[1] }).to({ lon: i2[0], lat: i2[1] }, l2.duration).easing(pD[l2.easing]).onUpdate(({ lon: d2, lat: f3 }) => {
        var v2;
        if (!this.renderer.getState(e3)) this.cancelAnimation(e3);
        else {
          let b = (v2 = c3 == null ? void 0 : c3.layers.get(ti)) == null ? void 0 : v2.containerId;
          b && this.Markers.setPosition(e3, [d2, f3], b);
        }
      }).start();
      return this.renderer.getTweenGroup().add(p3), this.renderer.render(), this.animations.set(e3, p3), py2(p3).then(() => {
        this.animations.delete(e3);
      });
    } });
    t(this, "Exporter", { getCurrentSceneGLTF: async (e3) => this.renderer.getCurrentSceneGLTF(e3) });
    t(this, "Shapes", { add: (e3, i2, o2) => {
      let n2 = o2 != null && o2.floorId ? this.floorsById.get(o2 == null ? void 0 : o2.floorId) : this.currentFloor, s4 = tt();
      return this.renderer.addGeometryGroup(s4, e3, i2, n2.id), s4;
    }, remove: (e3) => (this.renderer.remove(e3.id), e3.id) });
    t(this, "Text3D", { label: (e3, i2, o2) => {
      var s4;
      if (!((s4 = this.api.getMapDataInternal()) != null && s4.enterpriseMode)) {
        Lt.warn("Enterprise mode is not enabled, skipping label creation");
        return;
      }
      let n2 = ox(this.renderer, e3, i2, o2);
      if (n2) return { textInfo: n2, target: e3 };
    }, labelAll: (e3 = {}) => {
      var n2;
      if (!((n2 = this.api.getMapDataInternal()) != null && n2.enterpriseMode)) return Lt.warn("Enterprise mode is not enabled, skipping label creation"), [];
      let i2 = this.api.getMapData();
      if (!i2) return [];
      let o2 = [];
      return i2.getByType("space").forEach((s4) => {
        var c3, l2;
        if (s4.locations[0]) {
          let p3 = ox(this.renderer, s4, (l2 = (c3 = s4.locations[0]) == null ? void 0 : c3.name) != null ? l2 : s4.name, e3);
          p3 && o2.push({ textInfo: p3, target: s4 });
        }
      }), o2;
    }, remove: (e3) => {
      var i2;
      if (!((i2 = this.api.getMapDataInternal()) != null && i2.enterpriseMode)) {
        Lt.warn("Remove text label only works in enterprise mode");
        return;
      }
      return this.renderer.remove(e3), e3;
    } });
    t(this, "Labels", { all: ({ onCreate: e3, labelOptions: i2 = {} }) => {
      for (let o2 of Object.entries(this.mvf.space)) {
        let [n2, s4] = o2;
        s4 && s4.features.forEach((c3) => {
          var C, y, S, T, w2;
          let l2 = (C = this.api.getMapData()) == null ? void 0 : C.getById("space", c3.properties.id);
          if (!l2) return;
          let p3 = (y = this.styleMap[c3.properties.id]) == null ? void 0 : y.showImage, d2 = (S = c3.properties.details) == null ? void 0 : S.images, g2 = { marker: { ...p3 && ((T = d2 == null ? void 0 : d2[0]) != null && T.url) ? { icon: d2[0].url } : {}, ...(w2 = i2.appearance) == null ? void 0 : w2.marker }, ...i2.appearance }, b = (n2 ? this.floorsById.get(n2) : this.currentFloor).layers.get(Ai);
          if (c3.properties.center && l2.name !== "") {
            let M2 = this.renderer.addLabel2D(c3.properties.center, l2.name, { id: c3.properties.id + "-label", ...i2, appearance: g2, rank: i2.rank }, He.is(l2) ? l2.id : b == null ? void 0 : b.containerId);
            M2 && (He.is(l2) && b && b.labelIds.add(M2.id.toString()), e3(M2.id, l2.name, l2));
          }
        });
      }
    }, add: (e3, i2, o2 = {}) => {
      var d2;
      let { floorId: n2, ...s4 } = o2, c3 = uy2(e3, this.floorsById, this.api.mapObjects[0].floorsById.get("default-floor")), l2 = c3.layers.get(Ai), p3 = this.renderer.addLabel2D(sr(e3), i2, { ...s4, occluderId: c3.occluderId, verticalOffset: o2.verticalOffset }, (d2 = o2 == null ? void 0 : o2.parentId) != null ? d2 : l2 == null ? void 0 : l2.containerId);
      if (!p3) throw new Error("label creating failed");
      return l2 && l2.labelIds.add(p3.id.toString()), p3;
    }, remove: ({ label: e3, entityId: i2 }) => {
      var o2;
      if (He.is(e3.target)) {
        let n2 = this.floorsById.get(e3.target.floor.id);
        n2 && ((o2 = n2.layers.get(Ai)) == null || o2.labelIds.delete(e3.id.toString()));
      }
      this.renderer.remove(i2);
    }, removeAll: () => {
    } });
    t(this, "Paths", { add: (e3, i2) => {
      var p3;
      let o2 = [], n2 = e3[0].floorId || "root", s4 = 0;
      for (let d2 of e3) {
        let { floorId: f3 = "root", latitude: g2, longitude: v2 } = d2;
        f3 !== n2 && (s4++, n2 = f3), o2[s4] == null && o2.push({ floorId: f3, coordinates: [] });
        let b = f3 === d2.floorId ? d2 : new K2({ longitude: v2, latitude: g2, floorId: f3 });
        o2[s4].coordinates.push(b);
      }
      let c3 = o2.reduce((d2, { floorId: f3, coordinates: g2 }, v2) => {
        if (v2 !== 0) {
          let C = o2[v2 - 1], y = C.coordinates[C.coordinates.length - 1], S = g2[0], T = sr(y), w2 = sr(S), M2 = this.renderer.addPath({ type: "FeatureCollection", features: [{ type: "Feature", properties: { parentId: C.floorId }, geometry: { type: "Point", coordinates: T } }, { type: "Feature", properties: { parentId: f3 }, geometry: { type: "Point", coordinates: w2 } }] }, i2, this.id);
          M2 && d2.push({ ...M2, coordinates: [y, S] });
        }
        let b = this.renderer.addPath({ type: "FeatureCollection", features: g2.map((C) => ({ type: "Feature", properties: {}, geometry: { type: "Point", coordinates: sr(C) } })) }, i2, f3);
        return b && d2.push({ ...b, coordinates: g2 }), d2;
      }, []), l2 = new Gt({ fraction: 0 }).to({ fraction: 1 }, (p3 = i2 == null ? void 0 : i2.drawDuration) != null ? p3 : 1e3).onUpdate(({ fraction: d2 }) => {
        c3.forEach((f3) => {
          this.renderer.setState(f3.id, { completeFraction: d2 });
        });
      }).start();
      return this.renderer.getTweenGroup().add(l2), this.renderer.render(), this.animations.set(c3[0].id.toString(), l2), { paths: c3, animation: py2(l2).then(() => {
        this.animations.delete(c3[0].id.toString());
      }) };
    }, remove: (e3) => {
      e3.forEach((i2) => {
        this.cancelAnimation(i2), this.renderer.remove(i2);
      });
    } });
    v(this, hi, { enabled: false, floorHeight: 10, updateCameraElevationOnFloorChange: true });
    this.renderer = n.core, this.api = n, this.id = e2, this.renderer.addGroupContainer(e2, {}, "root"), this.options = o != null ? o : {}, this.StackedMaps = new Mp({ currentMapGetter: () => this }), this.DynamicFocus = new qs2(this.renderer, this.api, { currentMapGetter: () => this }), this.mvf = (p = i == null ? void 0 : i.mvf) != null ? p : {};
    let s2 = q4(this.mvf["styles.json"] || {});
    if (this.styleMap = s2, w(this, hi, { enabled: false, floorHeight: 10, updateCameraElevationOnFloorChange: true, ...o == null ? void 0 : o.multiFloorView }), !i) {
      this.id !== "outdoors-container" && Lt.warn("Map (".concat(this.id, ") created with no data."));
      let v2 = new Ap({ id: "default-stack", externalId: "default-stack", name: "Default Stack", maps: ["default-floor"] }, this.id, this.renderer);
      this.floorStacksById.set(v2.id, v2), this.currentFloorStackId = v2.id;
      let b = new Pp(v2.id, { id: "default-floor", externalId: "default-floor", name: "Default Floor", elevation: 0 }, this.renderer, u(this, hi), o != null ? o : {});
      v2.addFloor(b), this.floorsById.set(b.id, b), this.setFloor(b.id);
      return;
    }
    let c2 = i.getMVFFeatureByType("floor-stack");
    (c2 == null || c2.length === 0) && Lt.throw("MVF does not contain any Floor Stacks.");
    for (let v2 of c2) {
      let b = new Ap(v2, this.id, this.renderer, (d = this.mvf.facade) == null ? void 0 : d[v2.id]);
      if (b.floorIds.length !== 0) {
        for (let C of b.floorIds) {
          let y = i.getMVFFeatureById("floor", C);
          if (y != null) {
            let S = this.mvf.space[y.id], T = this.mvf.obstruction[y.id];
            if ((S == null || S.features.length === 0) && (T == null || T.features.length === 0)) continue;
            let w2 = new Pp(b.id, y, this.renderer, u(this, hi), o != null ? o : {}, this.mvf, s2, i);
            b.addFloor(w2), this.floorsById.set(w2.id, w2);
          }
        }
        this.floorStacksById.set(v2.id, b), this.currentFloorStackId || (this.currentFloorStackId = v2.id);
      }
    }
    for (let [v2] of Object.entries(i.facadesBySpaceId)) {
      let b = i.getById("space", v2);
      b && (this.outdoorFloorStacks.add(b.floor.floorStack.id), (f = this.floorsById.get(b.floor.id)) == null || f.setVisible(true));
    }
    let l = (g = this.mvf.enterprise) == null ? void 0 : g.venue.defaultMap;
    if (o != null && o.initialFloor) {
      let v2 = Ul(o.initialFloor);
      v2 && this.floorsById.has(v2) ? l = v2 : Lt.error("Invalid initial floor specified (".concat(o.initialFloor, "), using default behavior instead"));
    }
    l || (l = this.currentFloorStack.defaultFloor.id), this.setFloor(l);
  }
  get currentFloorStack() {
    let e2 = this.floorStacksById.get(this.currentFloorStackId);
    return e2 || Lt.throw('Current floor stack with id "'.concat(this.currentFloorStackId, '" not found')), e2;
  }
  setFloorStack(e2, i) {
    if (this.currentFloorStackId === e2) return;
    let o = this.floorStacksById.get(e2);
    if (o == null) {
      Lt.error("Invalid floor stack passed to setFloorStack (".concat(e2, "), the floor stack was not changed. Current floor stack is still ").concat(this.currentFloorStack.id, "."));
      return;
    }
    if (o.floorObjects.length === 0) {
      Lt.error("Floor stack (".concat(e2, ") has no floors. The floor stack was not changed. Current floor stack is still ").concat(this.currentFloorStack.id, "."));
      return;
    }
    this.setFloor(o.defaultFloor.id, i);
  }
  get currentFloor() {
    let e2 = this.floorsById.get(this.currentFloorId);
    return e2 || Lt.throw('Floor with id "'.concat(this.currentFloorId, '" not found')), e2;
  }
  get floors() {
    return Array.from(this.floorsById.values());
  }
  processFloorChange(e2) {
    var n, s2, c2, l, p;
    if (this.StackedMaps.expandedFactor !== 0) return;
    let i = this.floorsById.get(e2), o = this.floorStacksById.get(this.currentFloorStackId);
    if (i && o) if (!((n = u(this, hi)) != null && n.enabled) || i.floorStackId !== (o == null ? void 0 : o.id)) for (let d of this.floorStacksById.values()) this.options.keepOutdoorGeometryVisible && this.outdoorFloorStacks.has(d.id) || d.floorObjects.forEach((f) => {
      f.id !== e2 && (this.DynamicFocus.enabled && this.DynamicFocus.focusedFacades.some((g) => g.floorStack.id !== o.id && g.floorStack.defaultFloor.id === f.id) || f.setVisible(false));
    });
    else {
      let d = ex(this.currentFloorStack.floorObjects, i, u(this, hi).floorHeight, ((c2 = (s2 = this.api.Navigation) == null ? void 0 : s2.floors) == null ? void 0 : c2.map((f) => f.id)) || []);
      (p = (l = this.api) == null ? void 0 : l.Outdoor) == null || p.setOpacity(d.outdoorOpacity), d.floorStates.forEach((f) => {
        f.floor.setVisible(f.visible);
        for (let [g, v2] of f.floor.layers) f.visibleLayers.includes(g) ? v2.show() : v2.hide();
        this.renderer.setState("Footprint-".concat(f.floor.id), { height: f.footprint.height, altitude: f.footprint.altitude });
      }), u(this, hi).updateCameraElevationOnFloorChange && this.api.Camera.setElevation(i.elevation * u(this, hi).floorHeight);
    }
  }
  setFloor(e2, i) {
    if (this.currentFloorId === e2) return;
    let o = this.floorsById.get(e2);
    if (!o) {
      Lt.error("Invalid floor passed to setFloor (".concat(e2, "), the floor was not changed. Current floor is still ").concat(this.currentFloor.id));
      return;
    }
    let n = this.currentFloorId;
    if (this.publish("floor-change-start", { previousFloorId: n, floorId: e2, reason: i }), this.DynamicFocus.enabled) {
      let s2 = this.floorStacksById.get(o.floorStackId);
      if (s2) for (let c2 of s2.floorObjects) c2.id !== e2 && c2.setVisible(false);
    } else !this.StackedMaps.expanded && this.currentFloorStack && (this.DynamicFocus.enabled || this.currentFloorStack.setFacadeVisible(true), this.processFloorChange(e2));
    this.currentFloorId = e2, this.currentFloorStackId = this.currentFloor.floorStackId, this.currentFloor.setVisible(true), this.DynamicFocus.enabled || this.currentFloorStack.setFacadeVisible(false), this.publish("floor-change", { reason: i, floorId: this.currentFloor.id, previousFloorId: n });
  }
  cancelAnimation(e2) {
    let i = this.animations.get(e2);
    i && (i.stop(), this.animations.delete(e2), this.renderer.getTweenGroup().remove(i));
  }
};
hi = /* @__PURE__ */ new WeakMap();
function ox(r3, t3, e2, i) {
  return r3.labelText3D(t3.id, e2 != null ? e2 : t3.name, { ...i, parentId: t3.floor.id });
}
c();
var _r;
var Hp;
var Up = class {
  constructor({ currentMapGetter: t3 }) {
    v(this, _r, /* @__PURE__ */ new Map());
    v(this, Hp);
    w(this, Hp, t3);
  }
  get currentMap() {
    return u(this, Hp).call(this);
  }
  getById(t3) {
    return u(this, _r).get(t3);
  }
  add(t3, e2, i) {
    let o = t3.anchorTarget;
    if (!o) throw new Error("get coordinate failed");
    let n = this.currentMap;
    if (!n) throw new Error("currentMap should exist");
    let s2 = n.Markers.add(o, e2, { ...i, rank: (i == null ? void 0 : i.rank) || "medium", dynamicResize: (i == null ? void 0 : i.dynamicResize) || false });
    if (s2 == null) throw new Error("error creating marker");
    let c2 = n.Markers.getContentEl(s2.id.toString());
    if (!c2) throw new Error("marker component should exist");
    let l = new Vi(s2.id.toString(), c2, t3);
    return u(this, _r).set(l.id, { marker: l, entityId: s2.id.toString() }), l;
  }
  remove(t3) {
    var i;
    let e2 = u(this, _r).get(t3.id);
    e2 && ((i = this.currentMap) == null || i.Markers.remove(e2.entityId), u(this, _r).delete(t3.id.toString()));
  }
  removeAll() {
    let t3 = [];
    return u(this, _r).forEach(({ marker: e2 }) => {
      this.remove(e2), t3.push(e2), u(this, _r).delete(e2.id.toString());
    }), t3;
  }
  setPosition(t3, e2) {
    var s2;
    let i = e2.anchorTarget;
    if (!i) {
      Lt.error("Cannot determine coordinate from target.");
      return;
    }
    let o = this.currentMap;
    if (!o) {
      Lt.error("Cannot determine the current map.");
      return;
    }
    let n = u(this, _r).get(t3.id);
    if (!n) {
      Lt.error('Cannot find the Marker with id "'.concat(t3.id, '".'));
      return;
    }
    o.Markers.setPosition(n.entityId, sr(i), (s2 = i.floorId) != null ? s2 : o.currentFloorId), n.marker.updateTarget(e2);
  }
  animateTo(t3, e2, i) {
    var c2;
    let o = e2.anchorTarget;
    if (!o) return Lt.error("Cannot determine coordinate from target."), Promise.resolve();
    let n = this.currentMap;
    if (!n) return Lt.error("Cannot determine the current map."), Promise.resolve();
    let s2 = u(this, _r).get(t3.id);
    return s2 ? (s2.marker.updateTarget(e2), n.Markers.animateTo(s2.entityId, sr(o), (c2 = o.floorId) != null ? c2 : n.currentFloorId, i)) : (Lt.error('Cannot find the Marker with id "'.concat(t3.id, '".')), Promise.resolve());
  }
};
_r = /* @__PURE__ */ new WeakMap(), Hp = /* @__PURE__ */ new WeakMap();
c();
var Zi;
var Xp;
var Wp2 = class {
  constructor({ currentMapGetter: t3 }) {
    v(this, Zi, /* @__PURE__ */ new Map());
    v(this, Xp);
    w(this, Xp, t3);
  }
  get currentMap() {
    return u(this, Xp).call(this);
  }
  getById(t3) {
    return u(this, Zi).get(t3);
  }
  add(t3, e2, i) {
    var l;
    let o = t3.anchorTarget;
    if (!o) throw new Error("Target does not implement IAnchorable.");
    let n = this.currentMap;
    if (!n) throw new Error("currentMap should exist");
    let s2 = n.Images.add(sr(o), e2, { ...i, floorId: o.floorId, verticalOffset: o.verticalOffset + ((l = i.verticalOffset) != null ? l : 0) });
    if (!s2) throw new Error("image component should exist");
    let c2 = new cp(s2.id.toString(), e2, t3);
    return u(this, Zi).set(c2.id, { image: c2, entityId: s2.id.toString() }), c2;
  }
  remove(t3) {
    var i;
    let e2 = u(this, Zi).get(t3.id);
    e2 && ((i = this.currentMap) == null || i.Images.remove(e2.entityId), u(this, Zi).delete(t3.id.toString()));
  }
  removeAll() {
    let t3 = [];
    return u(this, Zi).forEach(({ image: e2 }) => {
      this.remove(e2), t3.push(e2), u(this, Zi).delete(e2.id.toString());
    }), t3;
  }
};
Zi = /* @__PURE__ */ new WeakMap(), Xp = /* @__PURE__ */ new WeakMap();
c();
var fi;
var Zp;
var Yp2 = class {
  constructor({ currentMapGetter: t3 }) {
    v(this, fi, /* @__PURE__ */ new Map());
    v(this, Zp);
    w(this, Zp, t3);
  }
  get currentMap() {
    return u(this, Zp).call(this);
  }
  getById(t3) {
    return u(this, fi).get(t3);
  }
  add(t3, e2, i) {
    let o = [t3], n = o.reduce((l, p) => {
      var d;
      return p ? (l.has(p.floorId) || l.set(p.floorId, []), (d = l.get(p.floorId)) == null || d.push(p), l) : (Lt.error("Cannot determine coordinate from options."), l);
    }, /* @__PURE__ */ new Map());
    if (!o.length) throw new Error("targets should not be empty when adding a model");
    let s2 = this.currentMap;
    if (!s2) throw new Error("currentMap should exist");
    let c2 = [];
    return n.forEach((l, p) => {
      let d = tt();
      s2.Models.add(d, l, { ...i, url: e2, floorId: p }).forEach(({ id: g }) => {
        let v2 = new sa(g.toString(), d, l[0]);
        u(this, fi).set(v2.id, { model: v2, entityId: g.toString(), groupId: d }), c2.push(v2);
      });
    }), c2[0];
  }
  remove(t3) {
    var i;
    let e2 = u(this, fi).get(t3.id);
    e2 && ((i = this.currentMap) == null || i.Models.remove(e2.entityId, e2.groupId), u(this, fi).delete(t3.id.toString()));
  }
  removeAll() {
    let t3 = [];
    return u(this, fi).forEach(({ model: e2 }) => {
      var o;
      let i = u(this, fi).get(e2.id);
      i && (t3.push(e2), (o = this.currentMap) == null || o.Models.remove(i.entityId, i.groupId), u(this, fi).delete(e2.id.toString()));
    }), t3;
  }
};
fi = /* @__PURE__ */ new WeakMap(), Zp = /* @__PURE__ */ new WeakMap();
c();
var mi;
var qp;
var zp2 = class {
  constructor({ currentMapGetter: t3 }) {
    v(this, mi, /* @__PURE__ */ new Map());
    v(this, qp);
    w(this, qp, t3);
  }
  get currentMap() {
    return u(this, qp).call(this);
  }
  getById(t3) {
    return u(this, mi).get(t3);
  }
  add(t3, e2) {
    let i = this.currentMap;
    if (!i) throw new Error("currentMap should exist");
    let o = i.Paths.add(t3, e2), n = o.paths.map((c2) => c2.id.toString()), s2 = new Er2(tt(), o.animation, t3, o.paths);
    for (let c2 of n) u(this, mi).set(c2, { path: s2, entityIds: n });
    return u(this, mi).set(s2.id, { path: s2, entityIds: n }), s2;
  }
  remove(t3) {
    var i;
    let e2 = u(this, mi).get(t3.id);
    e2 && ((i = this.currentMap) == null || i.Paths.remove(e2.entityIds), u(this, mi).delete(t3.id), e2.entityIds.forEach((o) => u(this, mi).delete(o)));
  }
  removeAll() {
    let t3 = [];
    return u(this, mi).forEach(({ path: e2 }) => {
      this.remove(e2), t3.push(e2);
    }), t3;
  }
};
mi = /* @__PURE__ */ new WeakMap(), qp = /* @__PURE__ */ new WeakMap();
c();
var gx = s(qs(), 1);
c();
var p1 = "#2266ff";
var uD = "#808080";
var nx = "#f5f5f5";
var ax = { radius: 10, color: p1, inactiveColor: uD, heading: { color: p1, opacity: 0.7 }, accuracyRing: { color: p1, opacity: 0.3 }, timeout: 3e4, watchDevicePosition: true, debug: false };
c();
var sx = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAAkklEQVRoge3awQ3AIAxD0VAMYf+F0yUixbL8JshXuLSwIqJCwDc9QBeZEOy9p2doAQDTM7TQ2cg5Z3qGFjpHS2YjDiGDe+/0DC0cwkYpJKdnaIFMkY1kymzEIVQcwsYhbPDem56hhc5GHELGIWwcwsYhbJS+2R1CxSFsdH5iO4SMr97Y6FxPqxytVVV+HcTEIWx+9mcIqHSOm9QAAAAASUVORK5CYII=";
c();
var lx = (r3, t3, e2 = 0) => {
  if (Math.abs(r3) >= Math.PI) throw new Error("Sector angle too wide!");
  let i = e2 / Math.tan(r3 / 2), o = e2 / Math.sin(r3 / 2), n = o + t3, s2 = 10, c2 = new Zr();
  c2.moveTo(-o * Math.sin(r3 / 2), o * Math.cos(r3 / 2) - i);
  for (let l = 0; l < s2; l++) c2.lineTo(-(n * Math.sin(r3 / 2 - r3 / s2 * l)), n * Math.cos(r3 / 2 - r3 / s2 * l) - i);
  for (let l = 0; l < s2; l++) c2.lineTo(-(e2 * Math.sin(Math.PI / -2 + Math.PI / s2 * l)), e2 * Math.cos(Math.PI / -2 + Math.PI / s2 * l));
  return new sl(c2, { depth: 0.1, bevelEnabled: false, UVGenerator: hD(t3) });
};
var u1 = (r3, t3, e2) => {
  let o = Math.sqrt(Math.pow(r3, 2) + Math.pow(t3, 2)) / e2;
  return o > 1 ? o = 1 : o < 0 && (o = 0), new at(0, o);
};
var hD = (r3) => ({ generateTopUV: (t3, e2, i, o, n) => {
  let s2 = e2[i * 3], c2 = e2[i * 3 + 1], l = e2[o * 3], p = e2[o * 3 + 1], d = e2[n * 3], f = e2[n * 3 + 1];
  return [u1(s2, c2, r3), u1(l, p, r3), u1(d, f, r3)];
}, generateSideWallUV: () => [new at(0, 1), new at(0, 1), new at(0, 1), new at(0, 1)] });
function cx(r3, t3) {
  if (t3 == null) return r3;
  let e2 = { latitude: r3 == null ? void 0 : r3.latitude, longitude: r3 == null ? void 0 : r3.longitude, accuracy: r3 == null ? void 0 : r3.accuracy, floor: r3 == null ? void 0 : r3.floor, heading: r3 == null ? void 0 : r3.heading };
  return "latitude" in t3 && (e2.latitude = (t3 == null ? void 0 : t3.latitude) == null || t3.latitude === "device" ? r3 == null ? void 0 : r3.latitude : t3.latitude), "longitude" in t3 && (e2.longitude = t3.longitude == null || t3.longitude === "device" ? r3 == null ? void 0 : r3.longitude : t3.longitude), "accuracy" in t3 && (e2.accuracy = t3.accuracy === "device" ? r3 == null ? void 0 : r3.accuracy : t3.accuracy), "floor" in t3 && (e2.floor = t3.floor === "device" ? r3 == null ? void 0 : r3.floor : t3.floor), "heading" in t3 && (e2.heading = t3.heading === "device" ? r3 == null ? void 0 : r3.heading : t3.heading), e2;
}
function fD([r3, t3], [e2, i], [o, n]) {
  let s2 = e2 - r3, c2 = i - t3, l = s2 ** 2 + c2 ** 2;
  if (l === 0) return;
  let p = ((o - r3) * s2 + (n - t3) * c2) / l, d;
  p <= 0 ? d = [r3, t3] : p >= 1 ? d = [e2, i] : d = [r3 + p * s2, t3 + p * c2];
  let f = zp([o, n], d);
  return { proportion: Math.max(0, Math.min(1, p)), intersection: d, distance: f };
}
function px(r3, t3) {
  if (r3 == null || r3.length < 2) return;
  let e2 = Number.MAX_SAFE_INTEGER, i, o = 0, n = 0;
  for (let s2 = 0; s2 < r3.length - 1; s2++) {
    let c2 = r3[s2], l = r3[s2 + 1], p = fD(c2, l, t3);
    p != null && p.distance < e2 && (e2 = p.distance, i = p.intersection, o = s2, n = p.proportion);
  }
  if (i) return { intersection: i, distance: e2, segmentIndex: o, proportion: n };
}
function ux(r3, t3) {
  let e2 = new ll({ color: r3, opacity: t3, transparent: true, depthTest: false, depthWrite: false }), i = 0.35, o = 0.35 * 4, n = lx(Math.PI / 6, o, i);
  new dl().load(sx, (c2) => {
    e2.alphaMap = c2, e2.needsUpdate = true;
  });
  let s2 = new ve(n, e2);
  return s2.position.z = -0.05, s2.renderOrder = 0, s2;
}
function dx(r3, t3) {
  let e2 = new tl(1, 1, 0.05, 32), i = new ll({ transparent: true, color: r3, opacity: t3, depthTest: false, depthWrite: false }), o = new ve(e2, i);
  return o.scale.set(0, 0, 0.05), o.renderOrder = 1, o.rotation.x = Math.PI / 2, o;
}
function hx(r3) {
  let t3 = new tl(0.35, 0.35, 0.07, 32), e2 = new ll({ transparent: true, color: nx, depthTest: false, depthWrite: false }), i = new ve(t3, e2);
  i.renderOrder = 2;
  let o = new tl(0.35 * 0.8, 0.35 * 0.8, 0.01, 32), n = new ll({ transparent: true, color: r3, depthTest: false, depthWrite: false }), s2 = new ve(o, n);
  return s2.renderOrder = 3, i.rotation.x = Math.PI / 2, i.position.z = 0.07 / 2, s2.rotation.x = Math.PI / 2, s2.position.z = 0.07, { outerMesh: i, innerMesh: s2 };
}
var yx = s(fx(), 1);
var sf = "blue-dot";
var va;
var zi;
var $t;
var Jt3;
var qi;
var Ca;
var Sa;
var xa;
var je;
var Ht;
var $p;
var $i;
var Jp2;
var Qp;
var Kp;
var eu;
var nf;
var gi;
var Ji;
var af;
var Ia;
var tu2;
var yi;
var Js = class extends _n {
  constructor(e2, i) {
    super();
    this.core = e2;
    this.geoJSONApi = i;
    v(this, va, null);
    t(this, "geometry");
    v(this, zi);
    v(this, $t);
    v(this, Jt3);
    v(this, qi);
    v(this, Ca);
    v(this, Sa);
    v(this, xa);
    v(this, je, ax);
    v(this, Ht, 1);
    v(this, $p);
    v(this, $i);
    t(this, "state", "disabled");
    t(this, "following", false);
    v(this, Jp2, (e3) => {
      var i2;
      return (i2 = this.geoJSONApi.getMapData()) == null ? void 0 : i2.getById("floor", e3);
    });
    v(this, Qp, (e3) => {
      var o;
      let i2;
      if (e3 != null) {
        let n = (o = this.geoJSONApi.currentMap) == null ? void 0 : o.currentFloorStack.floorObjectsByElevation.get(e3);
        i2 = n ? u(this, Jp2).call(this, n.id) : void 0;
      }
      return i2;
    });
    v(this, Kp, (e3) => {
      if (this.state === "hidden" || this.state === "disabled") return;
      let [i2, o, n, s2] = e3.children;
      if (u(this, nf).call(this), o.scale.set(u(this, Ht), u(this, Ht), u(this, Ht)), o.position.z = 0.07 / 2 * u(this, Ht), n.scale.set(u(this, Ht), u(this, Ht), u(this, Ht)), n.position.z = 0.07 * u(this, Ht), this.state === "active") {
        n.material.color.set(u(this, je).color);
        let c2 = this.accuracy;
        c2 != null ? (i2.visible = true, u(this, Sa) && u(this, Sa).stop(), w(this, Sa, new Gt({ scale: i2.scale.x }).to({ scale: c2 / 2 }, 150).onUpdate(({ scale: p }) => {
          i2.scale.set(p, 1, p);
        }).start()), this.core.getTweenGroup().add(u(this, Sa))) : i2.visible = false;
        let l = this.heading;
        if (l != null) {
          s2.visible = true, u(this, xa) && u(this, xa).stop();
          let { start: p, end: d } = Wp(s2.rotation.z, -md.degToRad(l));
          w(this, xa, new Gt({ rotation: p }).to({ rotation: d }, 150).onUpdate(({ rotation: f }) => {
            s2.rotation.z = f;
          }).start()), this.core.getTweenGroup().add(u(this, xa)), s2.scale.set(u(this, Ht), u(this, Ht), 1);
        } else s2.visible = false;
      } else this.state === "inactive" && (n.material.color.set(u(this, je).inactiveColor), s2.visible = false, i2.visible = false);
    });
    v(this, eu, (e3) => {
      var s2, c2;
      let i2;
      try {
        i2 = vD.parse(cx(e3, u(this, $t)));
      } catch (l) {
        u(this, gi).call(this, "error"), Lt.error("BlueDot: Position parse failed", l instanceof K.ZodError ? l.message : String(l)), this.publish("error");
        return;
      }
      u(this, je).debug && Lt.log("BlueDot: Parsed position", i2), w(this, Jt3, i2), u(this, gi).call(this, "position-update"), u(this, qi) && clearTimeout(u(this, qi)), typeof u(this, je).timeout == "number" && u(this, je).timeout < 1 / 0 && w(this, qi, setTimeout(() => {
        u(this, je).debug && Lt.log("BlueDot: Position timed out after ".concat(u(this, je).timeout, "ms")), u(this, gi).call(this, "timeout"), this.core.render();
      }, u(this, je).timeout)), (c2 = this.geoJSONApi.getMapDataInternal()) == null || c2.Analytics.updateState({ userPosition: { bluedotTimestamp: Date.now(), latitude: i2.latitude, longitude: i2.longitude, floorLevel: (s2 = i2.floor) == null ? void 0 : s2.elevation, accuracy: i2.accuracy } });
      let o = i2.floor != null ? i2.floor.id : "outdoors-container", n = [i2.longitude, i2.latitude];
      if (!this.geometry) this.geometry = this.core.addCustomGeometry(sf, { type: "Feature", properties: {}, geometry: { type: "Point", coordinates: n } }, { setup: (l) => {
        let p = dx(u(this, je).accuracyRing.color, u(this, je).accuracyRing.opacity), { outerMesh: d, innerMesh: f } = hx(u(this, je).color), g = ux(u(this, je).heading.color, u(this, je).heading.opacity);
        l.add(p), p.visible = false, l.add(d), l.add(f), l.add(g), g.visible = false, u(this, Kp).call(this, l);
      }, update: u(this, Kp) }, { visible: true, interactive: true }, o);
      else {
        let l = this.core.getState(this.geometry);
        n = [l.position[0], l.position[1]];
      }
      u(this, Ca) && u(this, Ca).stop(), w(this, Ca, new Gt(n).to([i2.longitude, i2.latitude], 1e3).easing(Fe.Cubic.Out).onUpdate((l) => {
        if (this.geometry) {
          let p = { position: [l[0], l[1]] };
          p.parent = o, this.core.setState(this.geometry, p);
        }
      }).start()), this.core.getTweenGroup().add(u(this, Ca)), this.publish("position-update", { floor: this.floor, heading: this.heading, accuracy: this.accuracy, coordinate: this.coordinate }), this.core.render();
    });
    t(this, "onPositionUpdate", (e3) => {
      var i2, o, n, s2, c2;
      if (this.state !== "disabled") {
        try {
          bD.parse(e3);
        } catch (l) {
          u(this, gi).call(this, "error"), Lt.error("BlueDot: Browser sent invalid position", l instanceof K.ZodError ? l.message : String(l)), this.publish("error");
          return;
        }
        w(this, zi, { latitude: (i2 = e3.coords) == null ? void 0 : i2.latitude, longitude: (o = e3.coords) == null ? void 0 : o.longitude, accuracy: (n = e3.coords) == null ? void 0 : n.accuracy, heading: (s2 = e3.coords) == null ? void 0 : s2.heading, floor: u(this, Qp).call(this, (c2 = e3.coords) == null ? void 0 : c2.floorLevel) }), u(this, eu).call(this, u(this, zi));
      }
    });
    t(this, "onPositionError", (e3) => {
      var i2;
      switch (u(this, gi).call(this, "error"), e3.code) {
        case e3.PERMISSION_DENIED:
          Lt.error("Geolocation permission denied by the user.", e3), (i2 = this.geoJSONApi.getMapDataInternal()) == null || i2.Analytics.sendWatchPositionDenied();
          break;
        case e3.POSITION_UNAVAILABLE:
          Lt.error("Geolocation position unavailable.", e3);
          break;
        case e3.TIMEOUT:
          Lt.error("Geolocation request timed out.", e3);
          break;
        default:
          Lt.error("An unknown geolocation error occurred.", e3);
          break;
      }
      this.publish("error", e3);
    });
    v(this, nf, () => {
      var i2;
      let e3 = Math.round(this.core.camera.zoomLevel * 1e5);
      if (e3 !== u(this, $p)) {
        w(this, $p, e3);
        let o = (i2 = this.core.getMetresPerPixel()) != null ? i2 : 1;
        w(this, Ht, Math.max(u(this, je).radius / (0.35 / o), 1));
      }
    });
    v(this, gi, (e3) => {
      let i2 = yD[this.state].actions[e3];
      if (i2) {
        switch (u(this, je).debug && Lt.log("BlueDot: Transitioning from ".concat(this.state, " to ").concat(i2, " using ").concat(e3)), i2) {
          case "hidden":
          case "disabled":
            this.geometry && this.core.setState(this.geometry, { visible: false });
            break;
          case "active":
            this.geometry && this.core.setState(this.geometry, { visible: true });
            break;
        }
        this.state !== i2 && (this.publish("state-change", { state: i2, action: e3 }), this.state = i2);
      } else Lt.warn("BlueDot: Invalid state transition from ".concat(this.state, " to ").concat(i2, " using ").concat(e3));
    });
    v(this, Ji);
    v(this, af, () => {
      if (u(this, Ji) == null && this.geoJSONApi.Navigation.activeDirections != null) {
        let i2 = (Array.isArray(this.geoJSONApi.Navigation.activeDirections) ? this.geoJSONApi.Navigation.activeDirections.flatMap((o) => o.coordinates) : this.geoJSONApi.Navigation.activeDirections.coordinates).filter((o) => o.floorId === this.geoJSONApi.currentFloor.id);
        w(this, Ji, (0, yx.default)(i2.map((o) => ({ x: o.longitude, y: o.latitude })), 1e-5).map((o) => [o.x, o.y]));
      }
      return u(this, Ji);
    });
    v(this, Ia, () => {
      this.core.camera.isAnimating && this.core.camera.cancelAnimation(), u(this, yi) && (this.off("position-update", u(this, yi)), w(this, yi, void 0)), this.following = false, w(this, Ji, void 0), this.core.off("user-interaction-start", u(this, Ia)), this.geoJSONApi.currentMap.off("navigation-active-path-change", u(this, tu2)), this.publish("follow-change", { following: false });
    });
    v(this, tu2, () => {
      w(this, Ji, void 0);
    });
    v(this, yi);
    t(this, "follow", (e3, i2) => {
      var n, s2, c2, l;
      if (e3 === false) {
        u(this, Ia).call(this);
        return;
      }
      e3 !== "position-only" && (i2 == null ? void 0 : i2.bearing) != null && Lt.warn("BlueDot: Camera bearing option will be ignored in follow mode '".concat(e3, "'. To control the bearing manually, use mode 'position-only'."));
      let o = { zoomLevel: (n = i2 == null ? void 0 : i2.zoomLevel) != null ? n : 21, bearing: e3 === "position-only" ? i2 == null ? void 0 : i2.bearing : void 0, pitch: (s2 = i2 == null ? void 0 : i2.pitch) != null ? s2 : 45, duration: (c2 = i2 == null ? void 0 : i2.duration) != null ? c2 : 1e3, easing: (l = i2 == null ? void 0 : i2.easing) != null ? l : "ease-in-out" };
      this.following ? u(this, yi) && this.off("position-update", u(this, yi)) : (this.following = true, this.core.on("user-interaction-start", u(this, Ia)), this.geoJSONApi.currentMap.on("navigation-active-path-change", u(this, tu2))), w(this, yi, (p) => {
        let { coordinate: d, heading: f, floor: g } = p;
        if (o.center = [d.longitude, d.latitude], g != null && g.id !== this.geoJSONApi.currentFloor.id && (this.geoJSONApi.currentMap.setFloor(g.id), w(this, Ji, void 0)), e3 === "position-and-heading") o.bearing = f != null ? f : void 0;
        else if (e3 === "position-and-path-direction") {
          let v2 = u(this, af).call(this);
          if (v2 != null) {
            let b = px(v2, [d.longitude, d.latitude]);
            if (b != null) {
              let C = v2[b.segmentIndex], y = v2[b.segmentIndex + 1];
              o.bearing = Vp(C, y);
            }
          }
        }
        this.core.camera.animateTo(o);
      }), this.on("position-update", u(this, yi)), this.publish("follow-change", { following: true, mode: e3 });
    });
  }
  get heading() {
    var e2;
    return (e2 = u(this, Jt3)) == null ? void 0 : e2.heading;
  }
  get accuracy() {
    var e2;
    return (e2 = u(this, Jt3)) == null ? void 0 : e2.accuracy;
  }
  get coordinate() {
    var e2, i;
    if (u(this, Jt3) != null) return (u(this, $i) == null || ((e2 = this.floor) == null ? void 0 : e2.id) !== u(this, $i).floorId || u(this, Jt3).latitude !== u(this, $i).latitude || u(this, Jt3).longitude !== u(this, $i).longitude) && w(this, $i, new K2(u(this, Jt3).latitude, u(this, Jt3).longitude, (i = this.floor) == null ? void 0 : i.id)), u(this, $i);
  }
  get floor() {
    var e2;
    return (e2 = u(this, Jt3)) == null ? void 0 : e2.floor;
  }
  enable(e2) {
    w(this, je, (0, gx.default)({}, e2, u(this, je))), u(this, gi).call(this, "enable"), this.watchDevicePosition(u(this, je).watchDevicePosition);
  }
  disable() {
    this.geometry && (this.core.remove(this.geometry.id), this.geometry = void 0), u(this, qi) && (clearTimeout(u(this, qi)), w(this, qi, void 0)), this.following && u(this, Ia).call(this), this.watchDevicePosition(false), w(this, Jt3, void 0), w(this, $t, void 0), u(this, gi).call(this, "disable");
  }
  watchDevicePosition(e2) {
    if (u(this, va) && (navigator.geolocation.clearWatch(u(this, va)), w(this, va, null)), u(this, zi) && w(this, zi, void 0), e2) {
      if (this.state === "disabled") {
        Lt.warn("BlueDot must be enabled before watching browser position.");
        return;
      }
      w(this, va, navigator.geolocation.watchPosition(this.onPositionUpdate, this.onPositionError, { enableHighAccuracy: true }));
    }
  }
  update(e2) {
    var o, n;
    e2 == null ? w(this, $t, void 0) : "coords" in e2 ? w(this, $t, Object.assign({}, u(this, $t), { latitude: e2.coords.latitude, longitude: e2.coords.longitude, accuracy: e2.coords.accuracy, heading: e2.coords.heading, floor: u(this, Qp).call(this, e2.coords.floorLevel) })) : (w(this, $t, Object.assign({}, u(this, $t), e2)), "floorOrFloorId" in e2 && (u(this, $t).floor = typeof e2.floorOrFloorId == "string" && e2.floorOrFloorId !== "device" ? u(this, Jp2).call(this, e2.floorOrFloorId) : e2.floorOrFloorId)), (((o = u(this, $t)) == null ? void 0 : o.latitude) != null && ((n = u(this, $t)) == null ? void 0 : n.longitude) != null || u(this, zi) != null) && u(this, eu).call(this, u(this, zi));
  }
};
va = /* @__PURE__ */ new WeakMap(), zi = /* @__PURE__ */ new WeakMap(), $t = /* @__PURE__ */ new WeakMap(), Jt3 = /* @__PURE__ */ new WeakMap(), qi = /* @__PURE__ */ new WeakMap(), Ca = /* @__PURE__ */ new WeakMap(), Sa = /* @__PURE__ */ new WeakMap(), xa = /* @__PURE__ */ new WeakMap(), je = /* @__PURE__ */ new WeakMap(), Ht = /* @__PURE__ */ new WeakMap(), $p = /* @__PURE__ */ new WeakMap(), $i = /* @__PURE__ */ new WeakMap(), Jp2 = /* @__PURE__ */ new WeakMap(), Qp = /* @__PURE__ */ new WeakMap(), Kp = /* @__PURE__ */ new WeakMap(), eu = /* @__PURE__ */ new WeakMap(), nf = /* @__PURE__ */ new WeakMap(), gi = /* @__PURE__ */ new WeakMap(), Ji = /* @__PURE__ */ new WeakMap(), af = /* @__PURE__ */ new WeakMap(), Ia = /* @__PURE__ */ new WeakMap(), tu2 = /* @__PURE__ */ new WeakMap(), yi = /* @__PURE__ */ new WeakMap();
var yD = { hidden: { actions: { enable: "hidden", error: "hidden", "position-update": "active", disable: "disabled", timeout: "hidden" } }, active: { actions: { enable: "active", disable: "disabled", "position-update": "active", error: "inactive", timeout: "inactive" } }, inactive: { actions: { enable: "inactive", disable: "disabled", "position-update": "active", error: "inactive", timeout: "inactive" } }, disabled: { actions: { enable: "hidden", disable: "disabled" } } };
var bD = K.object({ coords: K.object({ latitude: K.number(), longitude: K.number(), accuracy: K.number(), altitude: K.number().optional().nullable(), altitudeAccuracy: K.number().optional().nullable(), heading: K.number().optional().nullable(), speed: K.number().optional().nullable(), floorLevel: K.number().optional().nullable() }), timestamp: K.number() });
var vD = K.object({ latitude: K.number(), longitude: K.number(), floor: K.custom().optional(), accuracy: K.number().optional(), heading: K.number().optional().nullable() });
c();
var Qi;
var iu;
var ru = class {
  constructor({ currentMapGetter: t3 }) {
    v(this, Qi, /* @__PURE__ */ new Map());
    v(this, iu);
    w(this, iu, t3);
  }
  get currentMap() {
    return u(this, iu).call(this);
  }
  getById(t3) {
    return u(this, Qi).get(t3);
  }
  add(t3, e2, i) {
    let o = this.currentMap;
    if (!o) throw new Error("currentMap should exist");
    let n = o.Shapes.add(t3, e2 || {}, { floorId: i == null ? void 0 : i.id }), s2 = new $o(n);
    return u(this, Qi).set(s2.id, s2), s2;
  }
  remove(t3) {
    var i;
    u(this, Qi).get(t3.id) && ((i = this.currentMap) == null || i.Shapes.remove(t3), u(this, Qi).delete(t3.id.toString()));
  }
  removeAll() {
    let t3 = [];
    return u(this, Qi).forEach((e2) => {
      this.remove(e2), t3.push(e2.id), u(this, Qi).delete(e2.id.toString());
    }), t3;
  }
};
Qi = /* @__PURE__ */ new WeakMap(), iu = /* @__PURE__ */ new WeakMap();
c();
var nu;
var ou2 = class {
  constructor({ currentMapGetter: t3 }) {
    v(this, nu);
    w(this, nu, t3);
  }
  get currentMap() {
    return u(this, nu).call(this);
  }
  setFromStyleCollection(t3) {
    var e2, i, o, n;
    for (let s2 in t3) for (let c2 of ((e2 = this.currentMap) == null ? void 0 : e2.floors) || []) {
      if (t3[s2] == null || !c2.layers.has(we)) continue;
      let l = c2.layers.get(we);
      if (l != null && l.layers.has(s2) && "color" in t3[s2]) {
        let f = l.layers.get(s2);
        f && ((i = this.currentMap) == null || i.renderer.setState(f, { color: t3[s2].color }));
      }
      if (l && s2 === Do && !(ei in t3)) {
        let f = l.layers.get(ei);
        f && "color" in t3[s2] && ((o = this.currentMap) == null || o.renderer.setState(f, { color: t3[s2].color }));
      }
      if (!c2.layers.has(An)) continue;
      let p = c2.layers.get(An), d = c2.facadesByStyleId.get(s2);
      if (d && d.length > 0) for (let f of d) {
        let g = p.layers.get("".concat(f, "-").concat(s2));
        g && "color" in t3[s2] && ((n = this.currentMap) == null || n.renderer.setState(g, { color: t3[s2].color }));
      }
    }
  }
};
nu = /* @__PURE__ */ new WeakMap();
c();
var d1 = { opacity: 1 };
var Ct;
var au;
var su2;
var nn2;
var Ki;
var Pa;
var h1;
var bx;
var Qs = class {
  constructor(t3, e2) {
    v(this, Pa);
    v(this, Ct);
    v(this, au, []);
    v(this, su2, { opacity: "initial" });
    v(this, nn2, { opacity: /* @__PURE__ */ new Map() });
    v(this, Ki, /* @__PURE__ */ new Set());
    w(this, Ct, t3), w(this, au, e2 || []);
    let i = u(this, Ct).map;
    i && i.on("idle", () => {
      u(this, nn2).opacity.size || x(this, Pa, h1).call(this, i);
    });
  }
  setStyle(t3) {
    var e2, i;
    if (u(this, Ct).map) {
      (e2 = u(this, Ct).map) == null || e2.setStyle(t3), u(this, Ki).size && (u(this, Ki).clear(), this.hide()), x(this, Pa, bx).call(this), x(this, Pa, h1).call(this, u(this, Ct).map), this.setOpacity(u(this, su2).opacity), (i = u(this, Ct).map) == null || i.moveLayer(ou);
      for (let [o, n, s2] of u(this, au) || []) u(this, Ct).hideOutdoorLayersIntersectingPolygons(o, n, s2);
    }
  }
  get map() {
    return u(this, Ct).map;
  }
  get enabled() {
    return !!u(this, Ct).map;
  }
  get visible() {
    return u(this, Ki).size === 0;
  }
  show() {
    let t3 = u(this, Ct).map;
    if (!t3) return;
    let e2 = t3.getStyle().layers;
    e2 && (e2.forEach((i) => {
      u(this, Ki).has(i.id) && t3.setLayoutProperty(i.id, "visibility", "visible");
    }), u(this, Ki).clear());
  }
  hide(t3 = []) {
    let e2 = u(this, Ct).map;
    if (!e2) return;
    let i = e2.getStyle().layers;
    i && i.forEach((o) => {
      let n = e2.getLayoutProperty(o.id, "visibility");
      !t3.includes(o.id) && n !== "none" && (e2.setLayoutProperty(o.id, "visibility", "none"), u(this, Ki).add(o.id));
    });
  }
  setOpacity(t3, e2 = []) {
    var n, s2;
    let i = u(this, Ct).map;
    if (!i) return;
    let o = (s2 = (n = u(this, Ct).map) == null ? void 0 : n.getStyle()) == null ? void 0 : s2.layers;
    o && i.once("idle", () => {
      o.forEach((c2) => {
        let l = i.getLayoutProperty(c2.id, "visibility");
        if (!e2.includes(c2.id) && l !== "none") try {
          let p = u(this, nn2).opacity.get(c2.id);
          p !== void 0 && (c2.id === "background" || (c2.type === "symbol" ? (i.setPaintProperty(c2.id, "icon-opacity", t3 === "initial" ? p[0] : t3), i.setPaintProperty(c2.id, "text-opacity", t3 === "initial" ? p[1] : t3)) : i.setPaintProperty(c2.id, "".concat(c2.type, "-opacity"), t3 === "initial" ? p[0] : t3)), u(this, su2).opacity = t3);
        } catch (p) {
          Lt.warn("Error setting opacity:", p);
        }
      });
    });
  }
};
Ct = /* @__PURE__ */ new WeakMap(), au = /* @__PURE__ */ new WeakMap(), su2 = /* @__PURE__ */ new WeakMap(), nn2 = /* @__PURE__ */ new WeakMap(), Ki = /* @__PURE__ */ new WeakMap(), Pa = /* @__PURE__ */ new WeakSet(), h1 = function(t3) {
  let e2 = t3.getStyle().layers;
  e2 && e2.forEach((i) => {
    var n, s2, c2;
    t3.getLayoutProperty(i.id, "visibility") !== "none" && (i.id === "background" || (i.type === "symbol" ? u(this, nn2).opacity.set(i.id, [(n = t3.getPaintProperty(i.id, "icon-opacity")) != null ? n : d1.opacity, (s2 = t3.getPaintProperty(i.id, "text-opacity")) != null ? s2 : d1.opacity]) : u(this, nn2).opacity.set(i.id, [(c2 = t3.getPaintProperty(i.id, "".concat(i.type, "-opacity"))) != null ? c2 : d1.opacity, void 0])));
  });
}, bx = function() {
  Object.values(u(this, nn2)).forEach((t3) => t3.clear());
};
c();
var eo;
var to;
var an2;
var lf = class {
  constructor({ currentMapGetter: t3 }) {
    v(this, eo);
    v(this, to, /* @__PURE__ */ new Map());
    v(this, an2, /* @__PURE__ */ new Map());
    w(this, eo, t3);
  }
  labelAll(t3 = {}) {
    var o, n;
    let e2 = [], i = /* @__PURE__ */ new Set();
    return (n = (o = u(this, eo).call(this)) == null ? void 0 : o.Text3D.labelAll(t3)) == null || n.forEach(({ textInfo: s2, target: c2 }) => {
      let l = s2.id.toString(), p = u(this, an2).get(l);
      if (p) {
        i.has(l) || e2.push(p.text3DView), i.add(l);
        return;
      }
      i.add(l);
      let d = new Jo2(l, c2);
      u(this, to).set(d.id, { targetId: c2.id, text3d: l, text3DView: d }), u(this, an2).set(l, { text3DView: d }), e2.push(d);
    }), e2;
  }
  label(t3, e2, i = {}) {
    var n;
    if (u(this, eo).call(this)) if (He.is(t3)) {
      let s2 = (n = u(this, eo).call(this)) == null ? void 0 : n.Text3D.label(t3, e2, i);
      if (!s2) return;
      let c2 = s2.textInfo.id.toString(), l = u(this, an2).get(c2);
      if (l) return l.text3DView;
      let p = new Jo2(c2, s2.target);
      return u(this, to).set(p.id, { targetId: s2.target.id, text3d: c2, text3DView: p }), u(this, an2).set(c2, { text3DView: p }), p;
    } else throw new Error("Non-space target is not supported");
  }
  remove(t3) {
    var o;
    let e2 = typeof t3 == "string" ? t3 : t3.id, i = u(this, to).get(e2);
    i && ((o = u(this, eo).call(this)) == null || o.Text3D.remove(i.text3d), u(this, to).delete(e2), u(this, an2).delete(i.text3d));
  }
  removeAll() {
    u(this, to).forEach((t3) => {
      var e2;
      (e2 = u(this, eo).call(this)) == null || e2.Text3D.remove(t3.text3d);
    }), u(this, to).clear();
  }
};
eo = /* @__PURE__ */ new WeakMap(), to = /* @__PURE__ */ new WeakMap(), an2 = /* @__PURE__ */ new WeakMap();
var cf = 0.05;
var lu2 = class {
  constructor(t3, e2) {
    t(this, "core");
    t(this, "mapObjects", []);
    t(this, "id");
    t(this, "mapDataExternal", {});
    t(this, "mapsByFloorId", {});
    t(this, "mapData");
    t(this, "currentMap");
    t(this, "hiddenOutdoorGeometries", []);
    t(this, "lastFacadeIntersected");
    t(this, "mapView");
    t(this, "Camera");
    t(this, "Labels");
    t(this, "Text3D");
    t(this, "Markers");
    t(this, "Models");
    t(this, "Paths");
    t(this, "Exporter");
    t(this, "Navigation");
    t(this, "Outdoor");
    t(this, "BlueDot");
    t(this, "Shapes");
    t(this, "Style");
    t(this, "Images");
    t(this, "update", () => {
      this.core.render();
    });
    this.core = t3, this.mapView = e2, this.Camera = new vp2(this), this.id = this.core.addGroupContainer("root").id.toString();
    let i = new jp2("outdoors-container", void 0, void 0, this);
    this.mapObjects.push(i), this.currentMap = i, this.core.on("pre-render", () => {
      this.mapView.publish("pre-render");
    }), this.core.on("post-render", () => {
      this.mapView.publish("post-render");
    }), this.core.on("resize", () => {
      this.mapView.publish("resize");
    });
    let o = new mp(this.Camera);
    this.core.on("camera-change", () => {
      this.mapView.publish("camera-change", o);
    });
    let n = (l) => (p) => {
      var F, A, k;
      let d = [], f = [], g = [], v2 = [];
      p.labels.forEach((B) => {
        let G = this.Labels.getById(B.toString());
        G && d.push(G.label);
      }), p.markers.forEach((B) => {
        let G = this.Markers.getById(B.toString()) || this.Navigation.getMarkerById(B.toString());
        G && f.push(G.marker);
      }), p.models.forEach((B) => {
        let G = this.Models.getById(B.toString());
        G && g.push(G.model);
      }), p.paths.forEach((B) => {
        let G = this.Paths.getById(B.toString()) || this.Navigation.getPathById(B.toString());
        G && v2.push(G.path);
      });
      let b = p.geometry.includes(sf), C = p.geometry.filter((B) => B !== sf)[0], y;
      C && (y = (F = this.getMapDataInternal()) == null ? void 0 : F.getById("space", C)), y || (y = (A = this.getMapDataInternal()) == null ? void 0 : A.getById("object", C));
      let S = p.containers.reduce((B, G) => {
        var W;
        let V = (W = this.getMapDataInternal()) == null ? void 0 : W.getById("floor", G);
        return V && Zt.is(V) && B.push(V), B;
      }, []), T, w2 = 0;
      if (S.length > 0) {
        T = S[0].id;
        let B = this.core.getState(T);
        w2 = p.coordinate[2] ? p.coordinate[2] - B.altitude : w2;
      }
      let M2;
      this.lastFacadeIntersected && this.lastFacadeIntersected.spaces.forEach((B) => {
        this.core.setState(B.id, { hovered: false });
      }), y && He.is(y) && (M2 = (k = this.getMapDataInternal()) == null ? void 0 : k.facadesBySpaceId[C], M2 && M2.spaces.forEach((B) => {
        this.core.setState(B.id, { hovered: true });
      })), this.lastFacadeIntersected = M2;
      let D = { coordinate: new K2({ latitude: p.coordinate[1], longitude: p.coordinate[0], floorId: T, verticalOffset: w2 }), spaces: y && He.is(y) ? [y] : [], objects: y && zt.is(y) ? [y] : [], markers: f, labels: d, models: g, paths: v2, blueDot: b, floors: S, facades: M2 ? [M2] : [] };
      "pointerEvent" in p && (D.pointerEvent = p.pointerEvent), this.mapView.publish(l, D);
    };
    this.core.on("hover", n("hover")), this.core.on("click", n("click")), this.core.on("user-interaction-start", () => {
      this.mapView.publish("user-interaction-start");
    }), this.core.on("user-interaction-end", () => {
      this.mapView.publish("user-interaction-end");
    });
    let s2 = { currentMapGetter: () => this.currentMap };
    this.Markers = new Up(s2), this.Models = new Yp2(s2), this.Labels = new xp(s2), this.Text3D = new lf(s2), this.Exporter = new Sp2(s2), this.Paths = new zp2(s2), this.Navigation = new yp2(this.core, this, s2.currentMapGetter), this.BlueDot = new Js(this.core, this), this.BlueDot.on("position-update", (l) => {
      this.mapView.publish("blue-dot-position-update", l);
    }), this.BlueDot.on("state-change", (l) => {
      this.mapView.publish("blue-dot-state-change", l);
    }), this.BlueDot.on("error", (l) => {
      this.mapView.publish("blue-dot-error", l);
    }), this.BlueDot.on("follow-change", (l) => {
      this.mapView.publish("blue-dot-follow-change", l);
    }), this.Outdoor = new Qs(this.core, this.hiddenOutdoorGeometries), this.Outdoor.enabled && (this.core.on("outdoor-view-loaded", () => {
      this.mapView.publish("outdoor-view-loaded");
    }), this.core.on("outdoor-style-loaded", () => {
      this.mapView.publish("outdoor-style-loaded");
    })), this.Images = new Wp2(s2), this.Shapes = new ru(s2), this.Style = new ou2(s2);
    let c2 = new ef(e2, this.mapDataExternal);
    this.auto = c2.auto;
  }
  get DynamicFocus() {
    return this.currentMap.DynamicFocus;
  }
  get StackedMaps() {
    return this.currentMap.StackedMaps;
  }
  updateState(t3, e2) {
    if (t3 === "interior-walls") {
      this.currentMap.floors.forEach((o) => {
        let n = o.layers.get(we);
        if (n) {
          let s2 = n.layers.get(Do);
          s2 && this.core.setState(s2, cy2(e2, this.core.getState(s2)));
        }
      });
      return;
    } else if (t3 === "exterior-walls") {
      this.currentMap.floors.forEach((o) => {
        let n = o.layers.get(we);
        if (n) {
          let s2 = n.layers.get(ei);
          s2 && this.core.setState(s2, cy2(e2, this.core.getState(s2)));
        }
      });
      return;
    } else if (t3 === "interior-doors") {
      this.currentMap.floors.forEach((o) => {
        let n = o.layers.get(we);
        if (n) {
          let s2 = n.layers.get(ss);
          s2 && this.core.setState(s2, Hd(e2, this.core.getState(s2)));
        }
      });
      return;
    } else if (t3 === "exterior-doors") {
      this.currentMap.floors.forEach((o) => {
        let n = o.layers.get(we);
        if (n) {
          let s2 = n.layers.get(ls);
          s2 && this.core.setState(s2, Hd(e2, this.core.getState(s2)));
        }
      });
      return;
    }
    let i = typeof t3 == "string" ? this.getMapDataObject(t3) : t3;
    if (i) {
      if (zo.is(i)) return this.core.setState(i.id, H4({ ...e2, type: "label" }, this.core.getState(i.id)));
      if (Vi.is(i)) return this.core.setState(i.id, W4({ ...e2, type: "marker" }, this.core.getState(i.id)));
      if ((He.is(i) || zt.is(i)) && this.core.setState(i.id, X4({ ...e2, type: "geometry" }, this.core.getState(i.id))), Qr.is(i) && this.core.setState(i.id, Hd({ ...e2, type: "doors" }, this.core.getState(i.id))), $o.is(i) && this.core.setState(i.id, zn(e2, ["altitude", "color", "opacity"])), sa.is(i)) {
        let { position: o, scale: n, ...s2 } = e2, c2 = s2;
        o && (c2.position = [o.longitude, o.latitude, o.verticalOffset]), n != null && (Array.isArray(n) ? c2.scale = n : c2.scale = [n, n, n]), o && i.updateTarget(o), this.core.setState(i.id, c2);
      }
      if (Zt.is(i)) {
        let o = this.currentMap.floorsById.get(i.id);
        if (o == null) return;
        let n = o.layers.get(we);
        n != null && "geometry" in e2 && this.core.setState(n.containerId, Y4(e2.geometry));
      }
      if (xr.is(i) && this.core.setState(i.id, zn(e2, ["opacity"])), Jo2.is(i) && this.core.setState(i.id, zn(e2, op)), Er2.is(i)) for (let o of i.segments) this.core.setState(o.id, zn(e2, ["color"]));
      _s.is(i) && this.core.setState(i.id, zn(e2, ["color"]));
    }
  }
  getMapDataObject(t3) {
    var e2;
    return (e2 = this.getMapDataInternal()) == null ? void 0 : e2.getMapDataById(t3);
  }
  getMapDataInternal() {
    if (this.mapData) return vl3(this.mapData);
  }
  getMapData() {
    return this.mapData;
  }
  addMap(t3, e2) {
    return new Promise((i) => {
      var f, g, v2, b;
      let o;
      try {
        o = vl3(t3);
      } catch (C) {
        Lt.error("Error adding map", C), i(t3);
        return;
      }
      this.mapDataExternal[t3.mapName] = t3;
      let { mvf: n } = o, s2 = n["manifest.geojson"].features[0].geometry.coordinates;
      this.core.mode !== "outdoors-overlay" && this.Camera.set({ center: new K2(s2[1], s2[0]) });
      let c2 = n["manifest.geojson"].features[0].properties.name, l = new jp2("mapObject-".concat(c2), o, e2, this), p = this.core.getBoundingArea(l.currentFloor.id);
      p == null && Lt.error("Could not determine bounding box for map:", l.currentFloor.id);
      let d = (g = (f = e2 == null ? void 0 : e2.outdoorView) == null ? void 0 : f.layersHiddenByGeometry) != null ? g : [];
      if (d.length > 0) {
        let C, y = [];
        for (let S of l.floorStacksById.values()) if (S.defaultFloor.footprint && S.defaultFloor.footprint.geometry != null && ((v2 = S.defaultFloor.footprint.geometry) == null ? void 0 : v2.coordinates.length) > 0) {
          let T = S.defaultFloor.footprint, w2 = Xd(T);
          C == null ? C = w2 : J4(C, w2), y.push(T);
        }
        y.length > 0 && C != null && (this.core.hideOutdoorLayersIntersectingPolygons(C, y, d), this.hiddenOutdoorGeometries.push([C, y, d]));
      }
      if (this.mapObjects.push(l), o.getMVFFeatureByType("floor").forEach((C) => {
        this.mapsByFloorId[C.id] = l;
      }), l.on("navigation-connection-click", (C) => {
        this.mapView.publish("navigation-connection-click", C);
      }), l.on("navigation-active-path-change", (C) => {
        this.mapView.publish("navigation-active-path-change", C);
      }), l.StackedMaps.on("stacked-maps-state-change", ({ state: C }) => {
        this.mapView.publish("stacked-maps-state-change", { state: C });
      }), l.on("floor-change-start", (C) => {
        var y, S, T, w2;
        this.mapView.publish("floor-change-start", { reason: C.reason, floor: (S = (y = this.getMapDataInternal()) == null ? void 0 : y.getById("floor", C.floorId)) != null ? S : this.currentFloor, previousFloor: (w2 = (T = this.getMapDataInternal()) == null ? void 0 : T.getById("floor", C.previousFloorId)) != null ? w2 : this.currentFloor });
      }), l.on("floor-change", (C) => {
        var y, S;
        this.mapView.publish("floor-change", { reason: C.reason, floor: this.currentFloor, previousFloor: (S = (y = this.getMapDataInternal()) == null ? void 0 : y.getById("floor", C.previousFloorId)) != null ? S : this.currentFloor });
      }), l.DynamicFocus.on("focus-change", (C) => {
        this.mapView.publish("dynamic-focus-change", { facades: C.facades.map((y) => {
          var S;
          return (S = this.getMapDataInternal()) == null ? void 0 : S.getById("facade", y);
        }).filter((y) => y != null) });
      }), this.currentMap = l, this.mapData = t3, (e2 == null ? void 0 : e2.zoomLevel) != null) this.core.camera.setZoomLevel(e2.zoomLevel), i(t3);
      else if (this.core.mode !== "outdoors-overlay" && p) {
        let C = (b = e2 == null ? void 0 : e2.screenOffsets) != null ? b : { top: cf * this.core.canvasHeight, left: cf * this.core.canvasWidth, right: cf * this.core.canvasWidth, bottom: cf * this.core.canvasHeight };
        this.core.camera.focusOn(p, { duration: T4, padding: C }).then(() => {
          i(t3);
        });
      } else i(t3);
    });
  }
  setFloor(t3, e2) {
    return this.currentMap.setFloor(Ul(t3), e2);
  }
  setFloorStack(t3) {
    return this.currentMap.setFloorStack(Ul(t3));
  }
  updateWatermark(t3) {
    this.core.updateWatermark(t3);
  }
  get currentFloorStack() {
    var i;
    let t3 = this.currentMap.currentFloorStack.id;
    if (!t3) throw Lt.throw("Missing currentFloorStack.");
    let e2 = (i = this.mapData) == null ? void 0 : i.getById("floor-stack", t3);
    if (!e2) throw Lt.throw("FloorStack was not found in map data.");
    return e2;
  }
  get currentFloor() {
    var i;
    let t3 = this.currentMap.currentFloor.id;
    if (!t3) throw Lt.throw("Missing currentFloor object from GeoJsonApi");
    let e2 = (i = this.mapData) == null ? void 0 : i.getById("floor", t3);
    if (!e2) throw Lt.throw("Missing currentFloor");
    return e2;
  }
  getState(t3) {
    var o, n, s2, c2;
    typeof t3 == "object" && Er2.is(t3) && Lt.warn("Cannot get state of a Path directly. Use getState() on individual segments within Path.segments[] instead.");
    let e2 = $4(t3, this), i = this.core.getState(e2);
    if (i) if (["interior-walls", "exterior-walls"].includes(t3)) {
      let { color: l, topColor: p, texture: d, topTexture: f, visible: g, height: v2, opacity: b } = i;
      return { type: "walls", visible: g, color: l, topColor: p, texture: d ? { url: d } : void 0, topTexture: f ? { url: f } : void 0, height: v2, opacity: b };
    } else if (["interior-doors", "exterior-doors"].includes(t3)) {
      let { color: l, topColor: p, texture: d, topTexture: f, visible: g, opacity: v2 } = i;
      return { type: "doors", visible: g, color: l, topColor: p, opacity: v2, texture: d ? { url: d } : void 0, topTexture: f ? { url: f } : void 0 };
    } else {
      if (i.type === "geometry") return { type: "geometry", interactive: i.interactive, hoverColor: i.hoverColor, color: i.color, visible: i.visible, opacity: i.opacity, height: i.height, texture: i.texture ? { url: i.texture } : void 0, topTexture: i.topTexture ? { url: i.topTexture } : void 0, flipImageToFaceCamera: i.flipImageToFaceCamera, topColor: i.topColor };
      if (i.type === "label" && i.options.appearance && i.options.rank !== void 0 && i.options.interactive !== void 0) return { type: "label", text: i.text, appearance: i.options.appearance, rank: i.options.rank, enabled: i.enabled, interactive: i.options.interactive };
      if (i.type === "marker" && ((o = i.options) == null ? void 0 : o.rank) !== void 0 && i.options.interactive !== void 0) {
        let l = typeof i.parent == "object" ? i.parent.id : i.parent, p = this.Markers.getById(i.id.toString()), d = p != null && p.marker.target ? p == null ? void 0 : p.marker.target.anchorTarget : void 0;
        return d == null && (d = new K2(i.position[1], i.position[0], l.toString())), { type: "marker", rank: i.options.rank, interactive: i.options.interactive, enabled: i.enabled, element: i.element, anchor: i.anchor, zIndex: i.options.zIndex, dynamicResize: i.dynamicResize };
      } else if (i.type === "model") {
        let l = i != null && typeof i.parent == "object" ? i.parent.id.toString() : (n = i.parent) == null ? void 0 : n.toString();
        return delete i.parent, { ...i, position: new K2({ latitude: i.position[1], longitude: i.position[0], verticalOffset: i.position[2], floorId: l }), type: "model" };
      } else {
        if (i.type === "image") return { type: "image" };
        if (i.type === "text3d") return i;
        if (i.type === "geometry-group" && t3 && typeof t3 != "string" && $o.is(t3)) {
          let [l] = i.children;
          if (l.type !== "geometry") throw new Error("expect shape first child to be geometry");
          return { type: "Shape", altitude: (s2 = i.altitude) != null ? s2 : 0, visible: i.visible, color: i.color, height: l.height, opacity: i.opacity };
        } else {
          if (i.type === "path") return { type: "path", color: i.color };
          if (i.type === "group-container" && typeof t3 != "string" && Zt.is(t3)) {
            let l = (c2 = this.currentMap.floorsById.get(t3.id)) == null ? void 0 : c2.layers.get(we);
            if (l) return { type: "floor", geometry: { opacity: this.core.getState(l.containerId).opacity } };
          } else if (i.type === "group-container" && typeof t3 != "string" && xr.is(t3)) return { type: "facade", opacity: i.opacity };
        }
      }
    }
  }
  setHoverColor(t3) {
    this.core.setState({ hoverColor: t3 });
  }
  getHoverColor() {
    let t3 = this.core.getState();
    return (t3 == null ? void 0 : t3.type) === "map-view" ? t3.hoverColor : void 0;
  }
  createCoordinateFromScreenCoordinate(t3, e2, i) {
    var l;
    if (i != null) {
      let p = this.core.projectScreenXYToCoordinate(t3, e2, true);
      return p ? new K2(p.coordinate[1], p.coordinate[0], i.id) : void 0;
    }
    let o = this.core.projectScreenXYToCoordinate(t3, e2);
    if (o == null || o.coordinate == null) return;
    let { coordinate: n, groupContainers: s2 } = o, c2 = (l = s2 == null ? void 0 : s2.find((p) => {
      let d = p.userData.entityId.toString();
      return d.includes("f_") || d.includes("m_");
    })) == null ? void 0 : l.userData.entityId.toString();
    return new K2(n[1], n[0], c2);
  }
  getScreenCoordinateFromCoordinate(t3) {
    return this.core.projectCoordinateToScreenXY([t3.longitude, t3.latitude]);
  }
  isInView(t3) {
    return this.core.isInView(typeof t3 == "string" ? t3 : t3.id);
  }
  auto() {
    return { labels: this.Labels.all() };
  }
  get __core() {
    return this.core;
  }
  clear() {
    this.Navigation.clear(), this.BlueDot.disable(), this.Shapes.removeAll(), this.Paths.removeAll(), this.Models.removeAll(), this.Markers.removeAll(), this.Images.removeAll(), this.Labels.removeAll();
  }
  destroy() {
    this.clear(), this.core.destroy();
  }
};
c();
c();
var pf = class {
  constructor(t3) {
    t(this, "state");
    t(this, "update");
    this.update = t3.Debug.update.bind(t3.Debug), this.state = t3.Debug.state;
  }
};
c();
var vx = K.object({ environment: K.union([K.literal("basic"), K.literal(false)]).optional(), text3d: K.object({ hoverColor: K.string().optional() }).optional(), geometry: K.object({ hoverColor: K.string().optional() }).optional(), backgroundColor: K.string().optional(), backgroundAlpha: K.number().optional() }).strict();
var cu;
var Y;
var ro;
var Ks = class extends _n {
  constructor(e2) {
    super();
    v(this, cu, {});
    v(this, Y);
    v(this, ro);
    t(this, "Camera");
    t(this, "Labels");
    t(this, "Text3D");
    t(this, "Markers");
    t(this, "Images");
    t(this, "Models");
    t(this, "Paths");
    t(this, "Exporter");
    t(this, "Navigation");
    t(this, "BlueDot");
    t(this, "Style");
    t(this, "Shapes");
    t(this, "Outdoor");
    t(this, "update", () => {
      u(this, Y).core.render();
    });
    t(this, "getDirections", (e3, i2, o) => {
      var n;
      return (n = u(this, Y).getMapData()) == null ? void 0 : n.getDirections(e3, i2, o);
    });
    t(this, "getDirectionsMultiDestination", (e3, i2, o) => {
      var n;
      return (n = u(this, Y).getMapData()) == null ? void 0 : n.getDirectionsMultiDestination(e3, i2, o);
    });
    t(this, "on", (e3, i2) => {
      super.on(e3, i2);
    });
    t(this, "off", (e3, i2) => {
      super.off(e3, i2);
    });
    t(this, "Debug");
    w(this, ro, e2);
    let i = new lu2(e2, this);
    w(this, Y, i), this.Camera = u(this, Y).Camera, w(this, cu, u(this, Y).mapDataExternal), this.Markers = u(this, Y).Markers, this.Models = u(this, Y).Models, this.Labels = u(this, Y).Labels, this.Text3D = u(this, Y).Text3D, this.Exporter = u(this, Y).Exporter, this.Paths = u(this, Y).Paths, this.Navigation = u(this, Y).Navigation, this.BlueDot = u(this, Y).BlueDot, this.Shapes = u(this, Y).Shapes, this.Style = u(this, Y).Style, this.auto = u(this, Y).auto, this.Outdoor = u(this, Y).Outdoor, this.Images = u(this, Y).Images, u(this, ro).container.dataset.version = e.env.npm_package_version, this.Debug = new pf(u(this, Y).core);
  }
  get StackedMaps() {
    return u(this, Y).currentMap.StackedMaps;
  }
  get DynamicFocus() {
    return u(this, Y).currentMap.DynamicFocus;
  }
  updateState(e2, i) {
    return u(this, Y).updateState(e2, i);
  }
  updateGlobalState(e2) {
    var i, o, n, s2;
    try {
      vx.parse(e2);
    } catch (c2) {
      Lt.error("updateGlobalState", c2);
      return;
    }
    if (typeof e2 == "object") {
      let c2 = {};
      if ((i = e2.text3d) != null && i.hoverColor && (c2.text3dHoverColor = e2.text3d.hoverColor), (o = e2.geometry) != null && o.hoverColor && (c2.hoverColor = e2.geometry.hoverColor), e2.backgroundColor || e2.backgroundAlpha !== void 0) {
        let l = (n = e2.backgroundColor) != null ? n : u(this, Y).core.backgroundColor, p = (s2 = e2.backgroundAlpha) != null ? s2 : u(this, Y).core.backgroundAlpha;
        u(this, Y).core.setBackgroundColor(l, p);
      }
      e2.environment != null && u(this, Y).core.setEnvironment(e2.environment), u(this, Y).core.setState(c2);
    }
  }
  getGlobalState() {
    let e2 = u(this, Y).core.getState();
    return { backgroundColor: u(this, Y).core.backgroundColor, backgroundAlpha: u(this, Y).core.backgroundAlpha, environment: u(this, Y).core.getEnvironment(), geometry: { hoverColor: e2.hoverColor }, text3d: { hoverColor: e2.text3dHoverColor } };
  }
  getMapData() {
    return u(this, cu);
  }
  getDimensions() {
    return { width: u(this, ro).canvasWidth, height: u(this, ro).canvasHeight };
  }
  expand(e2) {
    var i;
    return (i = u(this, Y).currentMap) == null ? void 0 : i.StackedMaps.expand(e2);
  }
  collapse(e2) {
    var i;
    return (i = u(this, Y).currentMap) == null ? void 0 : i.StackedMaps.collapse(e2);
  }
  addMap(e2, i) {
    return u(this, Y).addMap(e2, i);
  }
  setFloor(e2) {
    return u(this, Y).setFloor(e2);
  }
  setFloorStack(e2) {
    return u(this, Y).setFloorStack(e2);
  }
  get currentFloorStack() {
    return u(this, Y).currentFloorStack;
  }
  get currentFloor() {
    return u(this, Y).currentFloor;
  }
  updateWatermark(e2) {
    u(this, Y).updateWatermark(e2);
  }
  getState(e2) {
    return u(this, Y).getState(e2);
  }
  setHoverColor(e2) {
    u(this, Y).setHoverColor(e2);
  }
  getHoverColor() {
    return u(this, Y).getHoverColor();
  }
  convertAltitudeToMercatorZoomLevel(e2) {
    return u(this, Y).core.getSystems().cameraSystem.convertAltitudeToZoomLevel(e2);
  }
  convertMercatorZoomLevelToAltitude(e2) {
    return u(this, Y).core.getSystems().cameraSystem.convertZoomLevelToAltitude(e2);
  }
  isInView(e2) {
    return u(this, Y).isInView(e2);
  }
  getDistance(e2, i) {
    var o;
    return (o = u(this, Y).getMapData()) == null ? void 0 : o.getDistance(e2, i);
  }
  createCoordinate(e2, i, o) {
    return typeof e2 == "object" ? new K2(e2) : new K2(e2, i, o == null ? void 0 : o.id);
  }
  createCoordinateFromScreenCoordinate(e2, i, o) {
    return u(this, Y).createCoordinateFromScreenCoordinate(e2, i, o);
  }
  getScreenCoordinateFromCoordinate(e2) {
    return u(this, Y).getScreenCoordinateFromCoordinate(e2);
  }
  auto() {
    return { labels: this.Labels.all() };
  }
  get __core() {
    if (e.env.INTERNAL === "true") return u(this, Y).core;
    throw new Error("__core is not available.");
  }
  clear() {
    u(this, Y).clear();
  }
  destroy() {
    u(this, Y).destroy();
  }
  async enableDebug(e2 = {}) {
    let { Inspector: i } = await import("./inspector-WHX467BE-76RGAMKL.js");
    await new i(this, u(this, Y)).enable(e2);
  }
  async takeScreenshot() {
    return await u(this, ro).renderSync(), u(this, ro).rendererDomElement.toDataURL("image/png");
  }
};
cu = /* @__PURE__ */ new WeakMap(), Y = /* @__PURE__ */ new WeakMap(), ro = /* @__PURE__ */ new WeakMap();
c();
c();
var uf = class extends _n {
  constructor(e2) {
    super();
    t(this, "gl");
    t(this, "el", document.createElement("div"));
    t(this, "core");
    t(this, "origin");
    t(this, "map");
    t(this, "layer");
    t(this, "handleStyleChange", () => {
      !this.map || !this.layer || this.map.getLayer(this.layer.id) || (this.map.addLayer(this.layer), this.core.camera.setMinZoomLevel(this.map.getMinZoom()), this.core.camera.setMaxZoomLevel(this.map.getMaxZoom()), this.core.camera.setMinPitch(this.map.getMinPitch()), this.core.camera.setMaxPitch(this.map.getMaxPitch()));
    });
    t(this, "handleMove", () => {
      if (!this.map) return;
      let [e3, i] = this.map.getCenter().toArray();
      this.core.getSystems().cameraSystem.setCenter(e3, i), this.core.getSystems().cameraSystem.setZoomLevel(this.map.getZoom()), this.core.getSystems().cameraSystem.setRotation(md.degToRad(this.map.getBearing())), this.core.getSystems().cameraSystem.setTilt(md.degToRad(this.map.getPitch()));
    });
    t(this, "handleError", (e3) => {
      Lt.warn(e3);
    });
    this.origin = e2;
  }
  onAdd(e2) {
    this.origin = this.origin || e2.getCenter().toArray(), this.gl = e2.painter.context.gl, this.core = new np2(e2._container, { center: this.origin, zoomLevel: e2.getZoom(), pitch: e2.getPitch(), bearing: e2.getBearing(), gl: this.gl, map: e2, mode: "outdoors-overlay" }), this.map = e2, this.core.camera.setMinZoomLevel(e2.getMinZoom()), this.core.camera.setMaxZoomLevel(e2.getMaxZoom()), this.core.camera.setMinPitch(e2.getMinPitch()), this.core.camera.setMaxPitch(e2.getMaxPitch()), this.map.on("error", this.handleError);
    let i = ze.fromLngLat(this.origin, 0);
    return this.layer = u0(i, this.core.viewCamera, this.core.camera, () => {
      this.core.renderSync();
    }), this.map.on("styledata", this.handleStyleChange), this.map.on("move", this.handleMove), this.handleStyleChange(), this.el;
  }
  onRemove() {
    this.map && (this.map.off("styledata", this.handleStyleChange), this.map.off("move", this.handleMove), this.map.off("error", this.handleError), this.layer && this.map.removeLayer(this.layer.id)), this.layer = void 0, this.map = void 0, this.core && this.core.destroy(), this.core = void 0;
  }
};
var Ma;
var el2;
var sn;
var Ta;
var df = class df2 extends _n {
  constructor(e2, i, o) {
    super();
    v(this, Ma);
    v(this, el2);
    v(this, sn);
    v(this, Ta);
    t(this, "on", (e3, i2) => {
      super.on(e3, i2);
    });
    t(this, "off", (e3, i2) => {
      super.off(e3, i2);
    });
    w(this, Ta, new uf(e2)), w(this, Ma, i), w(this, el2, o);
  }
  onAdd(e2) {
    var n, s2;
    let i = u(this, Ta).onAdd(e2), o = { ...Ln, ...(n = u(this, el2)) != null ? n : {}, outdoorView: { token: u(this, Ma).outdoorViewToken, ...(s2 = u(this, el2)) == null ? void 0 : s2.outdoorView } };
    return w(this, sn, new Ks(u(this, Ta).core)), u(this, sn).addMap(u(this, Ma), o).then(() => {
      this.publish("loaded", { mapView: u(this, sn), mapData: u(this, Ma) });
    }), i;
  }
  onRemove() {
    u(this, sn) && u(this, sn).clear(), df2.instance = null, u(this, Ta).onRemove();
  }
};
Ma = /* @__PURE__ */ new WeakMap(), el2 = /* @__PURE__ */ new WeakMap(), sn = /* @__PURE__ */ new WeakMap(), Ta = /* @__PURE__ */ new WeakMap(), t(df, "instance");
var tl3 = df;
c();
var CD = 1e3 * 60 * 60 * 2;
var ln2;
var il;
var Me;
var Rr;
var Nr;
var dr;
var Gr2;
var ol;
var nl;
var uu;
var De;
var Cx;
var Sx;
var rl2;
var hf;
var f1;
var m1;
var g1;
var pu = class {
  constructor(t3, e2) {
    v(this, De);
    v(this, ln2, new _n());
    v(this, il);
    v(this, Me);
    v(this, Rr);
    v(this, Nr);
    v(this, dr);
    v(this, Gr2);
    v(this, ol);
    v(this, nl);
    v(this, uu, () => {
      "key" in u(this, Me) && "secret" in u(this, Me) && x(this, De, rl2).call(this), x(this, De, hf).call(this);
    });
    t(this, "on", (t4, e3) => u(this, ln2).on(t4, e3));
    t(this, "off", (t4, e3) => u(this, ln2).off(t4, e3));
    w(this, il, t3), w(this, Me, e2);
  }
  setMapIds(t3) {
    w(this, il, t3);
  }
  setEnterprise(t3) {
    u(this, Me).enterprise = t3;
  }
  async readySync() {
    if ((!("key" in u(this, Me)) || !("secret" in u(this, Me))) && !("accessToken" in u(this, Me))) {
      Lt.error("No API keys or access token provided! Cannot preload tokens.");
      return;
    }
    let t3 = [x(this, De, rl2).call(this), null];
    u(this, Me).enterprise || (t3[1] = this.getSasTokensAsync());
    let [e2, i] = await Promise.all(t3);
    x(this, De, g1).call(this), x(this, De, f1).call(this, e2), i != null && x(this, De, m1).call(this, i), window != null && typeof window.addEventListener == "function" && window.addEventListener("focus", u(this, uu));
  }
  async refreshing() {
    let t3 = [];
    return u(this, Rr) != null && t3.push(u(this, Rr)), u(this, Nr) != null && t3.push(u(this, Nr)), Promise.all(t3);
  }
  getAccessTokenAsync() {
    return x(this, De, rl2).call(this);
  }
  getSasTokensAsync() {
    return x(this, De, hf).call(this);
  }
  getAccessToken() {
    return u(this, dr) == null ? (Lt.error("Tokens must be loaded before reading synchronously! Try awaiting readySync() first."), { token: "" }) : u(this, dr);
  }
  getSasToken(t3) {
    return u(this, Me).enterprise ? (Lt.error("SAS tokens are not available in the enterprise mode!"), { token: "" }) : u(this, Gr2) == null ? (Lt.error("Tokens must be loaded before reading synchronously! Try awaiting readySync() first."), { token: "" }) : t3 in u(this, Gr2).tokens ? u(this, Gr2).tokens[t3] : (Lt.error("SAS token for map ".concat(t3, " not found!")), { token: "" });
  }
  destroy() {
    x(this, De, g1).call(this), u(this, ln2).destroy(), window != null && typeof window.removeEventListener == "function" && window.removeEventListener("focus", u(this, uu));
  }
};
ln2 = /* @__PURE__ */ new WeakMap(), il = /* @__PURE__ */ new WeakMap(), Me = /* @__PURE__ */ new WeakMap(), Rr = /* @__PURE__ */ new WeakMap(), Nr = /* @__PURE__ */ new WeakMap(), dr = /* @__PURE__ */ new WeakMap(), Gr2 = /* @__PURE__ */ new WeakMap(), ol = /* @__PURE__ */ new WeakMap(), nl = /* @__PURE__ */ new WeakMap(), uu = /* @__PURE__ */ new WeakMap(), De = /* @__PURE__ */ new WeakSet(), Cx = function(t3) {
  var i;
  let e2 = t3.token !== ((i = u(this, dr)) == null ? void 0 : i.token);
  w(this, dr, t3), e2 && u(this, ln2).publish("access-token-refreshed", { accessToken: t3 });
}, Sx = function(t3) {
  var i;
  let e2 = JSON.stringify(t3.tokens) !== JSON.stringify((i = u(this, Gr2)) == null ? void 0 : i.tokens);
  w(this, Gr2, t3), e2 && u(this, ln2).publish("sas-tokens-refreshed", { sasTokens: t3.tokens });
}, rl2 = async function(t3 = false) {
  var e2;
  if ("accessToken" in u(this, Me) && typeof u(this, Me).accessToken == "string") {
    let i = { token: u(this, Me).accessToken, expires: Date.now() + 72e5 };
    return w(this, dr, i), i;
  }
  if (!("key" in u(this, Me)) || !("secret" in u(this, Me)) || typeof u(this, Me).key != "string" || typeof u(this, Me).secret != "string") throw new Error("No API keys or access token provided!");
  return u(this, Rr) != null ? u(this, Rr) : u(this, dr) != null && u(this, dr).expires != null && u(this, dr).expires > Date.now() && !t3 ? u(this, dr) : (w(this, Rr, Cl2({ ...u(this, Me), key: u(this, Me).key, secret: u(this, Me).secret }, (e2 = u(this, Me).enterprise) != null ? e2 : false).then((i) => {
    let o = { token: i.accessToken, expires: i.expiresTimestamp * 1e3 };
    return x(this, De, Cx).call(this, o), o;
  })), u(this, Rr).finally(() => {
    w(this, Rr, void 0);
  }), u(this, Rr));
}, hf = async function(t3 = false) {
  return u(this, Me).enterprise ? (Lt.warn("SAS tokens are not available in the enterprise mode!"), { tokens: {}, expires: 1 / 0 }) : u(this, Nr) != null ? u(this, Nr) : u(this, Gr2) != null && u(this, Gr2).expires > Date.now() && !t3 ? u(this, Gr2) : (w(this, Nr, new Promise((e2, i) => {
    x(this, De, rl2).call(this).then((o) => {
      let n = {}, s2 = u(this, il).map((c2) => Rf({ ...u(this, Me), mapId: c2 }, o.token).then((l) => {
        n[c2] = { token: l.token, expires: l.expires };
      }).catch((l) => {
        Lt.error("Error getting SAS token for map ".concat(c2, ":"), l);
      }));
      Promise.all(s2).then(() => {
        let c2 = { tokens: n, expires: Math.min(...Object.values(n).map((l) => {
          var p;
          return (p = l.expires) != null ? p : 1 / 0;
        })) };
        x(this, De, Sx).call(this, c2), e2(c2);
      });
    }).catch((o) => {
      i(o);
    });
  })), u(this, Nr).catch((e2) => {
    throw e2;
  }).finally(() => {
    w(this, Nr, void 0);
  }), u(this, Nr));
}, f1 = function(t3) {
  if (!("key" in u(this, Me)) || !("secret" in u(this, Me))) return;
  let e2 = t3.expires != null ? t3.expires - Date.now() : CD;
  isFinite(e2) && w(this, ol, setTimeout(() => {
    x(this, De, rl2).call(this, true).then((i) => {
      x(this, De, f1).call(this, i);
    });
  }, e2 - nb));
}, m1 = function(t3) {
  let e2 = t3.expires - Date.now();
  isFinite(e2) && w(this, nl, setTimeout(() => {
    x(this, De, hf).call(this, true).then((i) => {
      x(this, De, m1).call(this, i);
    });
  }, e2 - lb));
}, g1 = function() {
  u(this, ol) != null && clearTimeout(u(this, ol)), u(this, nl) != null && clearTimeout(u(this, nl));
};
c();
var xx = (r3, { id: t3 } = {}) => {
  let e2 = Array.isArray(r3) ? r3 : [r3];
  if (!e2.every((n) => typeof n == "string")) return;
  let i = e2.join(""), o = null;
  if (t3) {
    let n = document.getElementById(t3);
    n instanceof HTMLStyleElement && (o = n);
  }
  o == null && (o = document.createElement("style")), t3 && t3 !== "" && (o.id = t3), o.textContent = i, document.head.appendChild(o);
};
var Ix = ":root {\n	--pin-shadow-hover-scale: 0.9;\n	--pin-shadow-width: 12px;\n	--pin-shadow-height: 5px;\n	--pin-shadow-opacity: 0.35;\n	--pin-drop-animation-duration-ms: 250ms;\n}\n\n@keyframes drop-pin {\n	0% {\n		transform: translateY(-200%);\n	}\n\n	100% {\n		transform: translateY(0);\n	}\n}\n\n@keyframes pin-shadow {\n	0% {\n		transform: scale(var(--pin-shadow-hover-scale));\n	}\n\n	100% {\n		transform: scale(1);\n	}\n}\n\n.mappedin-dropped-pin-wrapper {\n	position: relative;\n\n	width: fit-content;\n	height: fit-content;\n	width: 36px;\n	height: 42px;\n\n	& svg {\n		position: absolute;\n		left: calc(50% - var(--pin-shadow-width));\n		animation: drop-pin var(--pin-drop-animation-duration-ms) ease-in;\n	}\n\n	& > .pin-shadow {\n		position: absolute;\n		left: calc(50% - (var(--pin-shadow-width) / 2));\n		bottom: 0;\n\n		height: var(--pin-shadow-height);\n		width: var(--pin-shadow-width);\n		border-radius: 100%;\n\n		opacity: var(--pin-shadow-opacity);\n\n		animation: pin-shadow 250ms ease-in;\n	}\n}\n\n@keyframes bounce {\n	0% {\n		transform: translateY(-10px);\n		opacity: 0;\n	}\n	12.5% {\n		transform: translateY(0);\n		opacity: 1;\n	}\n	25% {\n		transform: translateY(0);\n	}\n	37.5% {\n		transform: translateY(-10px);\n	}\n	50% {\n		transform: translateY(0);\n	}\n	62.5% {\n		transform: translateY(-10px);\n	}\n	75% {\n		transform: translateY(0);\n	}\n	87.5% {\n		transform: translateY(-10px);\n	}\n	100% {\n		transform: translateY(0);\n	}\n}\n\n.mappedin-connection-marker {\n	position: relative;\n	display: flex;\n\n	.bouncey {\n		animation: bounce 2.5s linear;\n	}\n\n	.arrow--down {\n		transform: rotate(180deg);\n	}\n\n	.connection-circle {\n		display: flex;\n		box-sizing: border-box;\n		justify-content: center;\n		align-items: center;\n		border-radius: 50%;\n		border: 2px solid white;\n		box-shadow: 0px 2px 8px 0px rgba(0, 0, 0, 0.15);\n		background: #595959;\n	}\n}\n";
var Px = ".mappedin-marker {\n	font-family: 'InterUI-Regular', Helvetica, Arial, sans-serif;\n	font-weight: normal;\n	top: 0;\n	transition: transform 300ms linear;\n	position: absolute;\n	font-weight: bold;\n	color: black;\n	display: flex;\n	flex-direction: row;\n	will-change: transform, opacity;\n	transition: opacity 150ms ease-in-out;\n	justify-content: center;\n	opacity: 0;\n}\n";
var Mx = ".mappedin__smart-collision-engine__container {\n	position: absolute;\n	left: 0px;\n	top: 0px;\n	bottom: 0px;\n	right: 0px;\n	pointer-events: none;\n	/* Enables colliders to use translate3D */\n	transform-style: preserve-3d;\n	font-family: 'InterUI-Regular', Helvetica, Arial, sans-serif;\n}\n\n.mappedin__smart-collision-engine-debug__container {\n	position: absolute;\n	left: 0px;\n	top: 0px;\n	bottom: 0px;\n	right: 0px;\n	transition: opacity 300ms ease-in-out;\n	pointer-events: none;\n	will-change: opacity;\n	&.interacting {\n		opacity: 0.2;\n	}\n}\n";
var Tx = ".mappedin-map {\n	.mappedin-interactive {\n		cursor: grab;\n\n		&:active {\n			cursor: grabbing;\n		}\n\n		&.mappedin-interaction-hover {\n			cursor: pointer;\n		}\n	}\n}\n";
var wx = ".mappedin-map {\n	.mappedin-control-container {\n		position: absolute;\n		left: 0px;\n		top: 0px;\n		bottom: 0px;\n		right: 0px;\n		pointer-events: none;\n		font-family: 'InterUI-Regular', Helvetica, Arial, sans-serif;\n\n		.mappedin-ctrl-top-left,\n		.mappedin-ctrl-top-right,\n		.mappedin-ctrl-bottom-left,\n		.mappedin-ctrl-bottom-right {\n			position: absolute;\n			pointer-events: none;\n		}\n\n		.mappedin-ctrl-top-left {\n			top: 0;\n			left: 0;\n		}\n\n		.mappedin-ctrl-top-right {\n			top: 0;\n			right: 0;\n		}\n\n		.mappedin-ctrl-bottom-left {\n			bottom: 0;\n			left: 0;\n		}\n\n		.mappedin-ctrl-bottom-right {\n			bottom: 0;\n			right: 0;\n		}\n\n		.mappedin-ctrl-attrib {\n			display: block;\n			position: relative;\n			pointer-events: auto;\n			font: 9px/11px 'InterUI-Regular', Helvetica, Arial, sans-serif;\n			padding: 3px 5px 1px 5px;\n			background-color: rgba(255, 255, 255, 0.5);\n			margin: 0;\n			min-width: 11px;\n			min-height: 11px;\n			user-select: none;\n\n			summary.mappedin-ctrl-attrib-button {\n				appearance: none;\n				list-style: none;\n			}\n\n			summary.mappedin-ctrl-attrib-button::-webkit-details-marker {\n				display: none;\n			}\n\n			&.mappedin-compact .mappedin-ctrl-attrib-button,\n			&.mappedin-compact-show .mappedin-ctrl-attrib-inner {\n				display: inline-block;\n			}\n\n			&.mappedin-compact {\n				background-color: transparent;\n			}\n\n			&.mappedin-compact-show {\n				min-width: 15px;\n				min-height: 15px;\n				box-sizing: border-box;\n				background-color: rgba(255, 255, 255, 0.5);\n			}\n		}\n\n		.mappedin-ctrl-attrib-top-left {\n			float: left;\n			border-bottom-right-radius: 4px;\n		}\n\n		.mappedin-ctrl-attrib-top-right {\n			float: right;\n			border-bottom-left-radius: 4px;\n		}\n\n		.mappedin-ctrl-attrib-bottom-left {\n			float: left;\n			border-top-right-radius: 4px;\n		}\n\n		.mappedin-ctrl-attrib-bottom-right {\n			float: right;\n			border-top-left-radius: 4px;\n		}\n		.mappedin-ctrl-attrib-top-left,\n		.mappedin-ctrl-attrib-bottom-left {\n			padding: 3px 5px 1px 20px;\n		}\n\n		.mappedin-ctrl-attrib-inner {\n			display: inline-block;\n			margin-right: 12px;\n		}\n\n		.mappedin-ctrl-attrib-inner,\n		.mappedin-ctrl-attrib-inner a {\n			color: rgba(0, 0, 0, 0.75);\n			text-decoration: none;\n		}\n\n		.mappedin-ctrl-attrib-inner-bold,\n		.mappedin-ctrl-attrib-inner-bold a {\n			font-weight: bold;\n		}\n\n		.mappedin-ctrl-attrib-inner a:hover {\n			color: #017ef1;\n			text-decoration: underline;\n			cursor: pointer;\n		}\n\n		.mappedin-ctrl-attrib-button {\n			display: none;\n			cursor: pointer;\n			position: absolute;\n			width: 15px;\n			height: 15px;\n			box-sizing: border-box;\n			border-radius: 50%;\n			top: 0;\n			right: 2px;\n			border: 1px;\n		}\n		.mappedin-ctrl-attrib-top-left .mappedin-ctrl-attrib-button,\n		.mappedin-ctrl-attrib-bottom-left .mappedin-ctrl-attrib-button {\n			left: 2px;\n		}\n	}\n}\n";
var Dx = '.maplibregl-map {\n    font: 12px/20px "Helvetica Neue", Arial, Helvetica, sans-serif;\n    overflow: hidden;\n    position: relative;\n    -webkit-tap-highlight-color: rgb(0 0 0 / 0%);\n}\n\n.maplibregl-canvas {\n    position: absolute;\n    left: 0;\n    top: 0;\n}\n\n.maplibregl-map:fullscreen {\n    width: 100%;\n    height: 100%;\n}\n\n.maplibregl-ctrl-group button.maplibregl-ctrl-compass {\n    touch-action: none;\n}\n\n.maplibregl-canvas-container.maplibregl-interactive,\n.maplibregl-ctrl-group button.maplibregl-ctrl-compass {\n    cursor: grab;\n    -moz-user-select: none;\n    -webkit-user-select: none;\n    -ms-user-select: none;\n    user-select: none;\n}\n\n.maplibregl-canvas-container.maplibregl-interactive.maplibregl-track-pointer {\n    cursor: pointer;\n}\n\n.maplibregl-canvas-container.maplibregl-interactive:active,\n.maplibregl-ctrl-group button.maplibregl-ctrl-compass:active {\n    cursor: grabbing;\n}\n\n.maplibregl-canvas-container.maplibregl-touch-zoom-rotate,\n.maplibregl-canvas-container.maplibregl-touch-zoom-rotate .maplibregl-canvas {\n    touch-action: pan-x pan-y;\n}\n\n.maplibregl-canvas-container.maplibregl-touch-drag-pan,\n.maplibregl-canvas-container.maplibregl-touch-drag-pan .maplibregl-canvas {\n    touch-action: pinch-zoom;\n}\n\n.maplibregl-canvas-container.maplibregl-touch-zoom-rotate.maplibregl-touch-drag-pan,\n.maplibregl-canvas-container.maplibregl-touch-zoom-rotate.maplibregl-touch-drag-pan .maplibregl-canvas {\n    touch-action: none;\n}\n\n.maplibregl-canvas-container.maplibregl-touch-drag-pan.maplibregl-cooperative-gestures,\n.maplibregl-canvas-container.maplibregl-touch-drag-pan.maplibregl-cooperative-gestures .maplibregl-canvas {\n    touch-action: pan-x pan-y;\n}\n\n.maplibregl-ctrl-top-left,\n.maplibregl-ctrl-top-right,\n.maplibregl-ctrl-bottom-left,\n.maplibregl-ctrl-bottom-right { position: absolute; pointer-events: none; z-index: 2; }\n\n.maplibregl-ctrl-top-left { top: 0; left: 0; }\n\n.maplibregl-ctrl-top-right { top: 0; right: 0; }\n\n.maplibregl-ctrl-bottom-left { bottom: 0; left: 0; }\n\n.maplibregl-ctrl-bottom-right { right: 0; bottom: 0; }\n\n.maplibregl-ctrl {\n    clear: both;\n    pointer-events: auto;\n\n    /* workaround for a Safari bug https://github.com/mapbox/mapbox-gl-js/issues/8185 */\n    transform: translate(0, 0);\n}\n\n.maplibregl-ctrl-top-left .maplibregl-ctrl { margin: 10px 0 0 10px; float: left; }\n\n.maplibregl-ctrl-top-right .maplibregl-ctrl { margin: 10px 10px 0 0; float: right; }\n\n.maplibregl-ctrl-bottom-left .maplibregl-ctrl { margin: 0 0 10px 10px; float: left; }\n\n.maplibregl-ctrl-bottom-right .maplibregl-ctrl { margin: 0 10px 10px 0; float: right; }\n\n.maplibregl-ctrl-group {\n    border-radius: 4px;\n    background: #fff;\n}\n\n.maplibregl-ctrl-group:not(:empty) {\n    box-shadow: 0 0 0 2px rgb(0 0 0 / 10%);\n}\n\n@media (-ms-high-contrast: active) {\n    .maplibregl-ctrl-group:not(:empty) {\n        box-shadow: 0 0 0 2px ButtonText;\n    }\n}\n\n.maplibregl-ctrl-group button {\n    width: 29px;\n    height: 29px;\n    display: block;\n    padding: 0;\n    outline: none;\n    border: 0;\n    box-sizing: border-box;\n    background-color: transparent;\n    cursor: pointer;\n}\n\n.maplibregl-ctrl-group button + button {\n    border-top: 1px solid #ddd;\n}\n\n.maplibregl-ctrl button .maplibregl-ctrl-icon {\n    display: block;\n    width: 100%;\n    height: 100%;\n    background-repeat: no-repeat;\n    background-position: center center;\n}\n\n@media (-ms-high-contrast: active) {\n    .maplibregl-ctrl-icon {\n        background-color: transparent;\n    }\n\n    .maplibregl-ctrl-group button + button {\n        border-top: 1px solid ButtonText;\n    }\n}\n\n/* https://bugzilla.mozilla.org/show_bug.cgi?id=140562 */\n.maplibregl-ctrl button::-moz-focus-inner {\n    border: 0;\n    padding: 0;\n}\n\n.maplibregl-ctrl-attrib-button:focus,\n.maplibregl-ctrl-group button:focus {\n    box-shadow: 0 0 2px 2px rgb(0 150 255 / 100%);\n}\n\n.maplibregl-ctrl button:disabled {\n    cursor: not-allowed;\n}\n\n.maplibregl-ctrl button:disabled .maplibregl-ctrl-icon {\n    opacity: 0.25;\n}\n\n.maplibregl-ctrl button:not(:disabled):hover {\n    background-color: rgb(0 0 0 / 5%);\n}\n\n.maplibregl-ctrl-group button:focus:focus-visible {\n    box-shadow: 0 0 2px 2px rgb(0 150 255 / 100%);\n}\n\n.maplibregl-ctrl-group button:focus:not(:focus-visible) {\n    box-shadow: none;\n}\n\n.maplibregl-ctrl-group button:focus:first-child {\n    border-radius: 4px 4px 0 0;\n}\n\n.maplibregl-ctrl-group button:focus:last-child {\n    border-radius: 0 0 4px 4px;\n}\n\n.maplibregl-ctrl-group button:focus:only-child {\n    border-radius: inherit;\n}\n\n.maplibregl-ctrl button.maplibregl-ctrl-zoom-out .maplibregl-ctrl-icon {\n    background-image: svg-load("svg/maplibregl-ctrl-zoom-out.svg", fill: #333);\n}\n\n.maplibregl-ctrl button.maplibregl-ctrl-zoom-in .maplibregl-ctrl-icon {\n    background-image: svg-load("svg/maplibregl-ctrl-zoom-in.svg", fill: #333);\n}\n\n@media (-ms-high-contrast: active) {\n    .maplibregl-ctrl button.maplibregl-ctrl-zoom-out .maplibregl-ctrl-icon {\n        background-image: svg-load("svg/maplibregl-ctrl-zoom-out.svg", fill: #fff);\n    }\n\n    .maplibregl-ctrl button.maplibregl-ctrl-zoom-in .maplibregl-ctrl-icon {\n        background-image: svg-load("svg/maplibregl-ctrl-zoom-in.svg", fill: #fff);\n    }\n}\n\n@media (-ms-high-contrast: black-on-white) {\n    .maplibregl-ctrl button.maplibregl-ctrl-zoom-out .maplibregl-ctrl-icon {\n        background-image: svg-load("svg/maplibregl-ctrl-zoom-out.svg", fill: #000);\n    }\n\n    .maplibregl-ctrl button.maplibregl-ctrl-zoom-in .maplibregl-ctrl-icon {\n        background-image: svg-load("svg/maplibregl-ctrl-zoom-in.svg", fill: #000);\n    }\n}\n\n.maplibregl-ctrl button.maplibregl-ctrl-fullscreen .maplibregl-ctrl-icon {\n    background-image: svg-load("svg/maplibregl-ctrl-fullscreen.svg", fill: #333);\n}\n\n.maplibregl-ctrl button.maplibregl-ctrl-shrink .maplibregl-ctrl-icon {\n    background-image: svg-load("svg/maplibregl-ctrl-shrink.svg");\n}\n\n@media (-ms-high-contrast: active) {\n    .maplibregl-ctrl button.maplibregl-ctrl-fullscreen .maplibregl-ctrl-icon {\n        background-image: svg-load("svg/maplibregl-ctrl-fullscreen.svg", fill: #fff);\n    }\n\n    .maplibregl-ctrl button.maplibregl-ctrl-shrink .maplibregl-ctrl-icon {\n        background-image: svg-load("svg/maplibregl-ctrl-shrink.svg", fill: #fff);\n    }\n}\n\n@media (-ms-high-contrast: black-on-white) {\n    .maplibregl-ctrl button.maplibregl-ctrl-fullscreen .maplibregl-ctrl-icon {\n        background-image: svg-load("svg/maplibregl-ctrl-fullscreen.svg", fill: #000);\n    }\n\n    .maplibregl-ctrl button.maplibregl-ctrl-shrink .maplibregl-ctrl-icon {\n        background-image: svg-load("svg/maplibregl-ctrl-shrink.svg", fill: #000);\n    }\n}\n\n.maplibregl-ctrl button.maplibregl-ctrl-compass .maplibregl-ctrl-icon {\n    background-image: svg-load("svg/maplibregl-ctrl-compass.svg", fill: #333);\n}\n\n@media (-ms-high-contrast: active) {\n    .maplibregl-ctrl button.maplibregl-ctrl-compass .maplibregl-ctrl-icon {\n        @svg-load ctrl-compass-white url("svg/maplibregl-ctrl-compass.svg") {\n            fill: #fff;\n            #south { fill: #999; }\n        }\n\n        background-image: svg-inline(ctrl-compass-white);\n    }\n}\n\n@media (-ms-high-contrast: black-on-white) {\n    .maplibregl-ctrl button.maplibregl-ctrl-compass .maplibregl-ctrl-icon {\n        background-image: svg-load("svg/maplibregl-ctrl-compass.svg", fill: #000);\n    }\n}\n\n@svg-load ctrl-terrain url("svg/maplibregl-ctrl-terrain.svg") {\n    fill: #333;\n    #stroke { display: none; }\n}\n\n@svg-load ctrl-terrain-enabled url("svg/maplibregl-ctrl-terrain.svg") {\n    fill: #33b5e5;\n    #stroke { display: none; }\n}\n\n.maplibregl-ctrl button.maplibregl-ctrl-terrain .maplibregl-ctrl-icon {\n    background-image: svg-inline(ctrl-terrain);\n}\n\n.maplibregl-ctrl button.maplibregl-ctrl-terrain-enabled .maplibregl-ctrl-icon {\n    background-image: svg-inline(ctrl-terrain-enabled);\n}\n\n@svg-load ctrl-geolocate url("svg/maplibregl-ctrl-geolocate.svg") {\n    fill: #333;\n    #stroke { display: none; }\n}\n\n@svg-load ctrl-geolocate-white url("svg/maplibregl-ctrl-geolocate.svg") {\n    fill: #fff;\n    #stroke { display: none; }\n}\n\n@svg-load ctrl-geolocate-black url("svg/maplibregl-ctrl-geolocate.svg") {\n    fill: #000;\n    #stroke { display: none; }\n}\n\n@svg-load ctrl-geolocate-disabled url("svg/maplibregl-ctrl-geolocate.svg") {\n    fill: #aaa;\n    #stroke { fill: #f00; }\n}\n\n@svg-load ctrl-geolocate-disabled-white url("svg/maplibregl-ctrl-geolocate.svg") {\n    fill: #999;\n    #stroke { fill: #f00; }\n}\n\n@svg-load ctrl-geolocate-disabled-black url("svg/maplibregl-ctrl-geolocate.svg") {\n    fill: #666;\n    #stroke { fill: #f00; }\n}\n\n@svg-load ctrl-geolocate-active url("svg/maplibregl-ctrl-geolocate.svg") {\n    fill: #33b5e5;\n    #stroke { display: none; }\n}\n\n@svg-load ctrl-geolocate-active-error url("svg/maplibregl-ctrl-geolocate.svg") {\n    fill: #e58978;\n    #stroke { display: none; }\n}\n\n@svg-load ctrl-geolocate-background url("svg/maplibregl-ctrl-geolocate.svg") {\n    fill: #33b5e5;\n    #stroke { display: none; }\n    #dot { display: none; }\n}\n\n@svg-load ctrl-geolocate-background-error url("svg/maplibregl-ctrl-geolocate.svg") {\n    fill: #e54e33;\n    #stroke { display: none; }\n    #dot { display: none; }\n}\n\n.maplibregl-ctrl button.maplibregl-ctrl-geolocate .maplibregl-ctrl-icon {\n    background-image: svg-inline(ctrl-geolocate);\n}\n\n.maplibregl-ctrl button.maplibregl-ctrl-geolocate:disabled .maplibregl-ctrl-icon {\n    background-image: svg-inline(ctrl-geolocate-disabled);\n}\n\n.maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-active .maplibregl-ctrl-icon {\n    background-image: svg-inline(ctrl-geolocate-active);\n}\n\n.maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-active-error .maplibregl-ctrl-icon {\n    background-image: svg-inline(ctrl-geolocate-active-error);\n}\n\n.maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-background .maplibregl-ctrl-icon {\n    background-image: svg-inline(ctrl-geolocate-background);\n}\n\n.maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-background-error .maplibregl-ctrl-icon {\n    background-image: svg-inline(ctrl-geolocate-background-error);\n}\n\n.maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-waiting .maplibregl-ctrl-icon {\n    animation: maplibregl-spin 2s infinite linear;\n}\n\n@media (-ms-high-contrast: active) {\n    .maplibregl-ctrl button.maplibregl-ctrl-geolocate .maplibregl-ctrl-icon {\n        background-image: svg-inline(ctrl-geolocate-white);\n    }\n\n    .maplibregl-ctrl button.maplibregl-ctrl-geolocate:disabled .maplibregl-ctrl-icon {\n        background-image: svg-inline(ctrl-geolocate-disabled-white);\n    }\n\n    .maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-active .maplibregl-ctrl-icon {\n        background-image: svg-inline(ctrl-geolocate-active);\n    }\n\n    .maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-active-error .maplibregl-ctrl-icon {\n        background-image: svg-inline(ctrl-geolocate-active-error);\n    }\n\n    .maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-background .maplibregl-ctrl-icon {\n        background-image: svg-inline(ctrl-geolocate-background);\n    }\n\n    .maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-background-error .maplibregl-ctrl-icon {\n        background-image: svg-inline(ctrl-geolocate-background-error);\n    }\n}\n\n@media (-ms-high-contrast: black-on-white) {\n    .maplibregl-ctrl button.maplibregl-ctrl-geolocate .maplibregl-ctrl-icon {\n        background-image: svg-inline(ctrl-geolocate-black);\n    }\n\n    .maplibregl-ctrl button.maplibregl-ctrl-geolocate:disabled .maplibregl-ctrl-icon {\n        background-image: svg-inline(ctrl-geolocate-disabled-black);\n    }\n}\n\n@keyframes maplibregl-spin {\n    0% { transform: rotate(0deg); }\n    100% { transform: rotate(360deg); }\n}\n\na.maplibregl-ctrl-logo {\n    width: 88px;\n    height: 23px;\n    margin: 0 0 -4px -4px;\n    display: block;\n    background-repeat: no-repeat;\n    cursor: pointer;\n    overflow: hidden;\n    background-image: svg-load("svg/maplibregl-ctrl-logo.svg");\n}\n\na.maplibregl-ctrl-logo.maplibregl-compact {\n    width: 14px;\n}\n\n@media (-ms-high-contrast: active) {\n    a.maplibregl-ctrl-logo {\n        @svg-load ctrl-logo-white url("svg/maplibregl-ctrl-logo.svg") {\n            #outline { opacity: 1; }\n            #fill { opacity: 1; }\n        }\n\n        background-color: transparent;\n        background-image: svg-inline(ctrl-logo-white);\n    }\n}\n\n@media (-ms-high-contrast: black-on-white) {\n    a.maplibregl-ctrl-logo {\n        @svg-load ctrl-logo-black url("svg/maplibregl-ctrl-logo.svg") {\n            #outline { opacity: 1; fill: #fff; stroke: #fff; }\n            #fill { opacity: 1; fill: #000; }\n        }\n\n        background-image: svg-inline(ctrl-logo-black);\n    }\n}\n\n.maplibregl-ctrl.maplibregl-ctrl-attrib {\n    padding: 0 5px;\n    background-color: rgb(255 255 255 / 50%);\n    margin: 0;\n}\n\n@media screen {\n    .maplibregl-ctrl-attrib.maplibregl-compact {\n        min-height: 20px;\n        padding: 2px 24px 2px 0;\n        margin: 10px;\n        position: relative;\n        background-color: #fff;\n        color: #000;\n        border-radius: 12px;\n        box-sizing: content-box;\n    }\n\n    .maplibregl-ctrl-attrib.maplibregl-compact-show {\n        padding: 2px 28px 2px 8px;\n        visibility: visible;\n    }\n\n    .maplibregl-ctrl-top-left > .maplibregl-ctrl-attrib.maplibregl-compact-show,\n    .maplibregl-ctrl-bottom-left > .maplibregl-ctrl-attrib.maplibregl-compact-show {\n        padding: 2px 8px 2px 28px;\n        border-radius: 12px;\n    }\n\n    .maplibregl-ctrl-attrib.maplibregl-compact .maplibregl-ctrl-attrib-inner {\n        display: none;\n    }\n\n    .maplibregl-ctrl-attrib-button {\n        display: none;\n        cursor: pointer;\n        position: absolute;\n        background-image: svg-load("svg/maplibregl-ctrl-attrib.svg");\n        background-color: rgb(255 255 255 / 50%);\n        width: 24px;\n        height: 24px;\n        box-sizing: border-box;\n        border-radius: 12px;\n        outline: none;\n        top: 0;\n        right: 0;\n        border: 0;\n    }\n\n    .maplibregl-ctrl-attrib summary.maplibregl-ctrl-attrib-button {\n        appearance: none;\n        list-style: none;\n    }\n\n    .maplibregl-ctrl-attrib summary.maplibregl-ctrl-attrib-button::-webkit-details-marker {\n        display: none;\n    }\n\n    .maplibregl-ctrl-top-left .maplibregl-ctrl-attrib-button,\n    .maplibregl-ctrl-bottom-left .maplibregl-ctrl-attrib-button {\n        left: 0;\n    }\n\n    .maplibregl-ctrl-attrib.maplibregl-compact .maplibregl-ctrl-attrib-button,\n    .maplibregl-ctrl-attrib.maplibregl-compact-show .maplibregl-ctrl-attrib-inner {\n        display: block;\n    }\n\n    .maplibregl-ctrl-attrib.maplibregl-compact-show .maplibregl-ctrl-attrib-button {\n        background-color: rgb(0 0 0 / 5%);\n    }\n\n    .maplibregl-ctrl-bottom-right > .maplibregl-ctrl-attrib.maplibregl-compact::after {\n        bottom: 0;\n        right: 0;\n    }\n\n    .maplibregl-ctrl-top-right > .maplibregl-ctrl-attrib.maplibregl-compact::after {\n        top: 0;\n        right: 0;\n    }\n\n    .maplibregl-ctrl-top-left > .maplibregl-ctrl-attrib.maplibregl-compact::after {\n        top: 0;\n        left: 0;\n    }\n\n    .maplibregl-ctrl-bottom-left > .maplibregl-ctrl-attrib.maplibregl-compact::after {\n        bottom: 0;\n        left: 0;\n    }\n}\n\n@media screen and (-ms-high-contrast: active) {\n    .maplibregl-ctrl-attrib.maplibregl-compact::after {\n        background-image: svg-load("svg/maplibregl-ctrl-attrib.svg", fill=#fff);\n    }\n}\n\n@media screen and (-ms-high-contrast: black-on-white) {\n    .maplibregl-ctrl-attrib.maplibregl-compact::after {\n        background-image: svg-load("svg/maplibregl-ctrl-attrib.svg");\n    }\n}\n\n.maplibregl-ctrl-attrib a {\n    color: rgb(0 0 0 / 75%);\n    text-decoration: none;\n}\n\n.maplibregl-ctrl-attrib a:hover {\n    color: inherit;\n    text-decoration: underline;\n}\n\n.maplibregl-attrib-empty {\n    display: none;\n}\n\n.maplibregl-ctrl-scale {\n    background-color: rgb(255 255 255 / 75%);\n    font-size: 10px;\n    border-width: medium 2px 2px;\n    border-style: none solid solid;\n    border-color: #333;\n    padding: 0 5px;\n    color: #333;\n    box-sizing: border-box;\n}\n\n.maplibregl-popup {\n    position: absolute;\n    top: 0;\n    left: 0;\n    display: flex;\n    will-change: transform;\n    pointer-events: none;\n}\n\n.maplibregl-popup-anchor-top,\n.maplibregl-popup-anchor-top-left,\n.maplibregl-popup-anchor-top-right {\n    flex-direction: column;\n}\n\n.maplibregl-popup-anchor-bottom,\n.maplibregl-popup-anchor-bottom-left,\n.maplibregl-popup-anchor-bottom-right {\n    flex-direction: column-reverse;\n}\n\n.maplibregl-popup-anchor-left {\n    flex-direction: row;\n}\n\n.maplibregl-popup-anchor-right {\n    flex-direction: row-reverse;\n}\n\n.maplibregl-popup-tip {\n    width: 0;\n    height: 0;\n    border: 10px solid transparent;\n    z-index: 1;\n}\n\n.maplibregl-popup-anchor-top .maplibregl-popup-tip {\n    align-self: center;\n    border-top: none;\n    border-bottom-color: #fff;\n}\n\n.maplibregl-popup-anchor-top-left .maplibregl-popup-tip {\n    align-self: flex-start;\n    border-top: none;\n    border-left: none;\n    border-bottom-color: #fff;\n}\n\n.maplibregl-popup-anchor-top-right .maplibregl-popup-tip {\n    align-self: flex-end;\n    border-top: none;\n    border-right: none;\n    border-bottom-color: #fff;\n}\n\n.maplibregl-popup-anchor-bottom .maplibregl-popup-tip {\n    align-self: center;\n    border-bottom: none;\n    border-top-color: #fff;\n}\n\n.maplibregl-popup-anchor-bottom-left .maplibregl-popup-tip {\n    align-self: flex-start;\n    border-bottom: none;\n    border-left: none;\n    border-top-color: #fff;\n}\n\n.maplibregl-popup-anchor-bottom-right .maplibregl-popup-tip {\n    align-self: flex-end;\n    border-bottom: none;\n    border-right: none;\n    border-top-color: #fff;\n}\n\n.maplibregl-popup-anchor-left .maplibregl-popup-tip {\n    align-self: center;\n    border-left: none;\n    border-right-color: #fff;\n}\n\n.maplibregl-popup-anchor-right .maplibregl-popup-tip {\n    align-self: center;\n    border-right: none;\n    border-left-color: #fff;\n}\n\n.maplibregl-popup-close-button {\n    position: absolute;\n    right: 0;\n    top: 0;\n    border: 0;\n    border-radius: 0 3px 0 0;\n    cursor: pointer;\n    background-color: transparent;\n}\n\n.maplibregl-popup-close-button:hover {\n    background-color: rgb(0 0 0 / 5%);\n}\n\n.maplibregl-popup-content {\n    position: relative;\n    background: #fff;\n    border-radius: 3px;\n    box-shadow: 0 1px 2px rgb(0 0 0 / 10%);\n    padding: 15px 10px;\n    pointer-events: auto;\n}\n\n.maplibregl-popup-anchor-top-left .maplibregl-popup-content {\n    border-top-left-radius: 0;\n}\n\n.maplibregl-popup-anchor-top-right .maplibregl-popup-content {\n    border-top-right-radius: 0;\n}\n\n.maplibregl-popup-anchor-bottom-left .maplibregl-popup-content {\n    border-bottom-left-radius: 0;\n}\n\n.maplibregl-popup-anchor-bottom-right .maplibregl-popup-content {\n    border-bottom-right-radius: 0;\n}\n\n.maplibregl-popup-track-pointer {\n    display: none;\n}\n\n.maplibregl-popup-track-pointer * {\n    pointer-events: none;\n    user-select: none;\n}\n\n.maplibregl-map:hover .maplibregl-popup-track-pointer {\n    display: flex;\n}\n\n.maplibregl-map:active .maplibregl-popup-track-pointer {\n    display: none;\n}\n\n.maplibregl-marker {\n    position: absolute;\n    top: 0;\n    left: 0;\n    will-change: transform;\n    transition: opacity 0.2s;\n}\n\n.maplibregl-user-location-dot {\n    background-color: #1da1f2;\n    width: 15px;\n    height: 15px;\n    border-radius: 50%;\n}\n\n.maplibregl-user-location-dot::before {\n    background-color: #1da1f2;\n    content: "";\n    width: 15px;\n    height: 15px;\n    border-radius: 50%;\n    position: absolute;\n    animation: maplibregl-user-location-dot-pulse 2s infinite;\n}\n\n.maplibregl-user-location-dot::after {\n    border-radius: 50%;\n    border: 2px solid #fff;\n    content: "";\n    height: 19px;\n    left: -2px;\n    position: absolute;\n    top: -2px;\n    width: 19px;\n    box-sizing: border-box;\n    box-shadow: 0 0 3px rgb(0 0 0 / 35%);\n}\n\n@keyframes maplibregl-user-location-dot-pulse {\n    0%   { transform: scale(1); opacity: 1; }\n    70%  { transform: scale(3); opacity: 0; }\n    100% { transform: scale(1); opacity: 0; }\n}\n\n.maplibregl-user-location-dot-stale {\n    background-color: #aaa;\n}\n\n.maplibregl-user-location-dot-stale::after {\n    display: none;\n}\n\n.maplibregl-user-location-accuracy-circle {\n    background-color: #1da1f233;\n    width: 1px;\n    height: 1px;\n    border-radius: 100%;\n}\n\n.maplibregl-crosshair,\n.maplibregl-crosshair .maplibregl-interactive,\n.maplibregl-crosshair .maplibregl-interactive:active {\n    cursor: crosshair;\n}\n\n.maplibregl-boxzoom {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 0;\n    height: 0;\n    background: #fff;\n    border: 2px dotted #202020;\n    opacity: 0.5;\n}\n\n.maplibregl-cooperative-gesture-screen {\n    background: rgba(0 0 0 / 40%);\n    position: absolute;\n    inset: 0;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    color: white;\n    padding: 1rem;\n    font-size: 1.4em;\n    line-height: 1.2;\n    opacity: 0;\n    pointer-events: none;\n    transition: opacity 1s ease 1s;\n    z-index: 99999;\n}\n\n.maplibregl-cooperative-gesture-screen.maplibregl-show {\n    opacity: 1;\n    transition: opacity 0.05s;\n}\n\n.maplibregl-cooperative-gesture-screen .maplibregl-mobile-message {\n    display: none;\n}\n\n@media (hover: none), (width <= 480px) {\n    .maplibregl-cooperative-gesture-screen .maplibregl-desktop-message {\n        display: none;\n    }\n\n    .maplibregl-cooperative-gesture-screen .maplibregl-mobile-message {\n        display: block;\n    }\n}\n\n.maplibregl-pseudo-fullscreen {\n    position: fixed !important;\n    width: 100% !important;\n    height: 100% !important;\n    top: 0 !important;\n    left: 0 !important;\n    z-index: 99999;\n}\n';
var wD = [Ix, Px, Mx, Tx, wx, Dx];
var Ex;
function yee(r3) {
  Ex = r3;
}
var bee = async (r3, t3) => {
  let e2, i = bn2();
  t3 && i.updateByUserOption(t3);
  try {
    t3 && (e2 = (await Cl2({ ...t3, baseAuthUri: i.getBaseAuthUri() })).accessToken);
  } catch (s2) {
    Lt.warn("Getting access token failed. Outdoor map disabled.", s2);
  }
  let o = new Cs(r3, { outdoorViewToken: e2, languagePacks: t3 == null ? void 0 : t3.languagePacks, env: i });
  return new Lu(o);
};
var Ox = false;
function vee(r3) {
  Ox = r3;
}
var Cee = async (r3, t3) => {
  var g, v2, b, C;
  let e2 = { ...t3 || {} }, i, o = bn2();
  o.updateByUserOption(e2);
  let n = {};
  if ("type" in r3 && typeof r3.type == "string") {
    if (n.enterprise = (g = r3.options) == null ? void 0 : g.enterprise, r3.type === "binary" && r3.main instanceof Uint8Array) {
      let y = await ku(r3.main);
      i = Fu(y), n.languagePacks = [];
      for (let S of (v2 = r3.languagePacks) != null ? v2 : []) S.localePack instanceof Uint8Array && n.languagePacks.push({ language: S.language, localePack: await Ua(S.localePack) });
    } else if (r3.type === "json") i = r3.main, n.languagePacks = (b = r3.languagePacks) != null ? b : [];
    else throw new Error("Invalid backup type");
    r3.type === "binary" && r3.main instanceof Uint8Array && (n.binaryBundle = r3.main);
  } else i = r3, n.enterprise = i.enterprise != null;
  let s2 = Uf(i), c2 = s2.length > 0 ? s2 : [e2.mapId], l = new pu(c2, { ...e2, enterprise: n.enterprise }), p;
  if ("accessToken" in e2) p = e2.accessToken;
  else if ("key" in e2 && "secret" in e2) {
    e2.baseAuthUri = o.getBaseAuthUri(n.enterprise);
    let y = await l.getAccessTokenAsync();
    p = (y == null ? void 0 : y.token) || "";
  }
  n.outdoorViewToken = p, n.env = o, n.getMapDataOptions = e2;
  try {
    await l.readySync();
  } catch (y) {
    Lt.error("Failed to ready token manager!", y);
  }
  let d = new Cs(i, n);
  p && d.Analytics.init({ accessToken: p, mapId: e2.mapId, key: "key" in e2 ? e2.key : void 0, secret: "secret" in e2 ? e2.secret : void 0, ...e2.analytics, baseUri: o.getAnalyticsBaseUri(), context: (C = e2.analytics) == null ? void 0 : C.context });
  let f = new Lu(d);
  if ("language" in e2) try {
    await f.changeLanguage(e2.language);
  } catch {
  }
  return typeof (t3 == null ? void 0 : t3.onMVFParsed) == "function" && t3.onMVFParsed(i), f;
};
var DD = async (r3) => {
  var y;
  let t3 = Ox, e2, i = bn2();
  i.updateByUserOption(r3);
  let o = { ...r3 }, n = new pu([o.mapId], o);
  if ("accessToken" in o) {
    e2 = o.accessToken;
    let { aud: S, sub: T } = Np(e2);
    (D4.some((w2) => S.includes(w2)) || T && T.startsWith("client")) && (t3 = true, n.setEnterprise(t3));
  } else if ("key" in o && "secret" in o) o.key.startsWith("mik_") || (t3 = true, n.setEnterprise(t3)), o.baseAuthUri = i.getBaseAuthUri(t3), e2 = (await n.getAccessTokenAsync()).token;
  else throw new Error("Missing key or secret.");
  o.layoutId != null && (t3 ? o.layoutId !== "draft" && Lt.warn('Invalid layoutId! Use "draft" to load draft data or leave unspecified to load live data.') : Lt.warn("layoutId is currently unsupported!")), o.baseUri = i.getBaseUri(t3);
  let s2 = performance.now(), c2, l;
  if (t3) {
    let S = { ...o, venue: o.mapId, clientId: o.key, clientSecret: o.secret, version: "1.0.0", perspective: o.viewId, useDraftData: o.layoutId === "draft" }, T = await Vf(S);
    c2 = T.compressed, l = T.localePacks;
  } else c2 = await jf(o, e2);
  let p = performance.now(), d = await ku(c2), f = Fu(d), g = performance.now();
  typeof r3.onMVFParsed == "function" && r3.onMVFParsed(f);
  let v2 = Uf(f);
  v2.length > 0 ? n.setMapIds(v2) : n.setMapIds([o.mapId]);
  try {
    await n.readySync();
  } catch (S) {
    Lt.error("Failed to ready token manager!", S);
  }
  let b = new Cs(f, { env: i, outdoorViewToken: e2, tokenManager: n, enterprise: t3, localePacksUrls: l, binaryBundle: c2, getMapDataOptions: o }), C = new Lu(b, { search: r3.search });
  if (b.Analytics.init({ accessToken: e2, mapId: o.mapId, key: "key" in o ? o.key : void 0, secret: "secret" in o ? o.secret : void 0, ...o.analytics, baseUri: i.getAnalyticsBaseUri(), context: (y = o.analytics) == null ? void 0 : y.context }), b.Analytics.sendGetMapDataEvent({ parseDuration: g - p, downloadDuration: p - s2, viewId: o.viewId }), "language" in o) try {
    await C.changeLanguage(o.language);
  } catch {
  }
  return C;
};
var See = DD;
var xee = (r3, t3) => {
  tl3.instance != null && Lt.warn("Only a single map venue is supported at this time.");
  let e2 = new tl3([r3.mapCenter.longitude, r3.mapCenter.latitude], r3, t3);
  return tl3.instance = e2, e2;
};
var ED = async (r3, t3, e2) => {
  var p, d, f, g, v2, b, C, y, S, T, w2, M2, D;
  let i = performance.now(), o = Xg(e2, t3);
  o && Wg(o), ((p = o.injectStyles) == null || p) && xx(wD, { id: "mappedin__styles" });
  let n = E4((d = t3.outdoorViewToken) != null ? d : ""), s2 = vl3(t3);
  (f = o.outdoorView) != null && f.style && s2.envControl.updateTileServerBaseUrl((g = o.outdoorView) == null ? void 0 : g.style);
  let c2 = await BS(r3, { center: [t3.mapCenter.longitude, t3.mapCenter.latitude], bearing: o.bearing, pitch: o.pitch, zoomLevel: o.zoomLevel, backgroundAlpha: (v2 = o.style) == null ? void 0 : v2.backgroundAlpha, backgroundColor: (b = o.style) == null ? void 0 : b.backgroundColor, outdoorView: (C = o.outdoorView) != null && C.token ? { headers: { "x-mappedin-tiles-key": (y = o.outdoorView) == null ? void 0 : y.token }, style: t3.getEnv().tileServerUri, enabled: !!((S = o.outdoorView) != null && S.enabled), lowDpi: (T = o.outdoorView) == null ? void 0 : T.lowDpi } : void 0, watermark: { ...o.watermark, visible: ((w2 = o.watermark) == null ? void 0 : w2.visible) || !s2.enterpriseMode && !n.remove_watermark, onClick: Ex || void 0 }, attribution: o.attribution, antialias: typeof o.antialiasing == "boolean" ? o.antialiasing : !!((M2 = o.antialiasing) != null && M2.enabled), accessToken: t3.outdoorViewToken, occlusionEnabled: (D = o.occlusion) == null ? void 0 : D.enabled, transformImageRequest: s2.enterpriseMode ? void 0 : s2.transformImageRequest, naturalBearing: t3.naturalBearing, imagePlacementOptions: o.imagePlacementOptions, onWebGLContextCreationError: o.onWebGLContextCreationError, onWebGLContextLost: o.onWebGLContextLost, onWebGLContextRestored: o.onWebGLContextRestored, onWebGLRendererError: o.onWebGLRendererError }), l = new Ks(c2);
  return await l.addMap(t3, o), s2.Analytics.sendMapViewLoadedEvent({ firstRenderDuration: performance.now() - i, dimension: l.getDimensions() }), l;
};
var Iee = ED;

export {
  Fu,
  ku,
  K2 as K,
  xo,
  Pn,
  Mn,
  Po,
  Qr,
  He,
  Zt,
  zM,
  Fn,
  zt,
  To,
  wo,
  Rd,
  xr,
  Li,
  Nd,
  iy2 as iy,
  fs2 as fs,
  Gd,
  I5,
  Zw,
  Yd,
  Zd,
  yee,
  bee,
  vee,
  Cee,
  DD,
  See,
  xee,
  ED,
  Iee
};
//# sourceMappingURL=chunk-BDBIBSIQ.js.map
