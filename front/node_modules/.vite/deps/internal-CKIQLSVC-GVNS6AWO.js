import {
  Li,
  Nd,
  Rd,
  xo,
  xr
} from "./chunk-BDBIBSIQ.js";
import {
  K,
  Yp,
  qs
} from "./chunk-EU42VC65.js";
import "./chunk-4OORONJH.js";
import "./chunk-OXS4RIMJ.js";
import "./chunk-STL2KGEZ.js";
import {
  c
} from "./chunk-LZZZ25U2.js";
import {
  s,
  t,
  u,
  v,
  w,
  x
} from "./chunk-ASEP6WC2.js";

// node_modules/@mappedin/mappedin-js/lib/esm/internal-CKIQLSVC.js
c();
c();
function E(n3, e, t2, s2) {
  function i(o) {
    return o instanceof t2 ? o : new t2(function(r) {
      r(o);
    });
  }
  return new (t2 || (t2 = Promise))(function(o, r) {
    function c2(u2) {
      try {
        d(s2.next(u2));
      } catch (h) {
        r(h);
      }
    }
    function a(u2) {
      try {
        d(s2.throw(u2));
      } catch (h) {
        r(h);
      }
    }
    function d(u2) {
      u2.done ? o(u2.value) : i(u2.value).then(c2, a);
    }
    d((s2 = s2.apply(n3, e || [])).next());
  });
}
var xe = "ENTRIES";
var ae = "KEYS";
var ue = "VALUES";
var y = "";
var O = class {
  constructor(e, t2) {
    let s2 = e._tree, i = Array.from(s2.keys());
    this.set = e, this._type = t2, this._path = i.length > 0 ? [{ node: s2, keys: i }] : [];
  }
  next() {
    let e = this.dive();
    return this.backtrack(), e;
  }
  dive() {
    if (this._path.length === 0) return { done: true, value: void 0 };
    let { node: e, keys: t2 } = z(this._path);
    if (z(t2) === y) return { done: false, value: this.result() };
    let s2 = e.get(z(t2));
    return this._path.push({ node: s2, keys: Array.from(s2.keys()) }), this.dive();
  }
  backtrack() {
    if (this._path.length === 0) return;
    let e = z(this._path).keys;
    e.pop(), !(e.length > 0) && (this._path.pop(), this.backtrack());
  }
  key() {
    return this.set._prefix + this._path.map(({ keys: e }) => z(e)).filter((e) => e !== y).join("");
  }
  value() {
    return z(this._path).node.get(y);
  }
  result() {
    switch (this._type) {
      case ue:
        return this.value();
      case ae:
        return this.key();
      default:
        return [this.key(), this.value()];
    }
  }
  [Symbol.iterator]() {
    return this;
  }
};
var z = (n3) => n3[n3.length - 1];
var ze = (n3, e, t2) => {
  let s2 = /* @__PURE__ */ new Map();
  if (e === void 0) return s2;
  let i = e.length + 1, o = i + t2, r = new Uint8Array(o * i).fill(t2 + 1);
  for (let c2 = 0; c2 < i; ++c2) r[c2] = c2;
  for (let c2 = 1; c2 < o; ++c2) r[c2 * i] = c2;
  return de(n3, e, t2, s2, r, 1, i, ""), s2;
};
var de = (n3, e, t2, s2, i, o, r, c2) => {
  let a = o * r;
  e: for (let d of n3.keys()) if (d === y) {
    let u2 = i[a - 1];
    u2 <= t2 && s2.set(c2, [n3.get(d), u2]);
  } else {
    let u2 = o;
    for (let h = 0; h < d.length; ++h, ++u2) {
      let l = d[h], p = r * u2, _ = p - r, f = i[p], m = Math.max(0, u2 - t2 - 1), S = Math.min(r - 1, u2 + t2);
      for (let b = m; b < S; ++b) {
        let V = l !== e[b], R = i[_ + b] + +V, M = i[_ + b + 1] + 1, w2 = i[p + b] + 1, I = i[p + b + 1] = Math.min(R, M, w2);
        I < f && (f = I);
      }
      if (f > t2) continue e;
    }
    de(n3.get(d), e, t2, s2, i, u2, r, c2 + d);
  }
};
var v2 = class n {
  constructor(e = /* @__PURE__ */ new Map(), t2 = "") {
    this._size = void 0, this._tree = e, this._prefix = t2;
  }
  atPrefix(e) {
    if (!e.startsWith(this._prefix)) throw new Error("Mismatched prefix");
    let [t2, s2] = j(this._tree, e.slice(this._prefix.length));
    if (t2 === void 0) {
      let [i, o] = Q(s2);
      for (let r of i.keys()) if (r !== y && r.startsWith(o)) {
        let c2 = /* @__PURE__ */ new Map();
        return c2.set(r.slice(o.length), i.get(r)), new n(c2, e);
      }
    }
    return new n(t2, e);
  }
  clear() {
    this._size = void 0, this._tree.clear();
  }
  delete(e) {
    return this._size = void 0, Ie(this._tree, e);
  }
  entries() {
    return new O(this, xe);
  }
  forEach(e) {
    for (let [t2, s2] of this) e(t2, s2, this);
  }
  fuzzyGet(e, t2) {
    return ze(this._tree, e, t2);
  }
  get(e) {
    let t2 = $(this._tree, e);
    return t2 !== void 0 ? t2.get(y) : void 0;
  }
  has(e) {
    let t2 = $(this._tree, e);
    return t2 !== void 0 && t2.has(y);
  }
  keys() {
    return new O(this, ae);
  }
  set(e, t2) {
    if (typeof e != "string") throw new Error("key must be a string");
    return this._size = void 0, P(this._tree, e).set(y, t2), this;
  }
  get size() {
    if (this._size) return this._size;
    this._size = 0;
    let e = this.entries();
    for (; !e.next().done; ) this._size += 1;
    return this._size;
  }
  update(e, t2) {
    if (typeof e != "string") throw new Error("key must be a string");
    this._size = void 0;
    let s2 = P(this._tree, e);
    return s2.set(y, t2(s2.get(y))), this;
  }
  fetch(e, t2) {
    if (typeof e != "string") throw new Error("key must be a string");
    this._size = void 0;
    let s2 = P(this._tree, e), i = s2.get(y);
    return i === void 0 && s2.set(y, i = t2()), i;
  }
  values() {
    return new O(this, ue);
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  static from(e) {
    let t2 = new n();
    for (let [s2, i] of e) t2.set(s2, i);
    return t2;
  }
  static fromObject(e) {
    return n.from(Object.entries(e));
  }
};
var j = (n3, e, t2 = []) => {
  if (e.length === 0 || n3 == null) return [n3, t2];
  for (let s2 of n3.keys()) if (s2 !== y && e.startsWith(s2)) return t2.push([n3, s2]), j(n3.get(s2), e.slice(s2.length), t2);
  return t2.push([n3, e]), j(void 0, "", t2);
};
var $ = (n3, e) => {
  if (e.length === 0 || n3 == null) return n3;
  for (let t2 of n3.keys()) if (t2 !== y && e.startsWith(t2)) return $(n3.get(t2), e.slice(t2.length));
};
var P = (n3, e) => {
  let t2 = e.length;
  e: for (let s2 = 0; n3 && s2 < t2; ) {
    for (let o of n3.keys()) if (o !== y && e[s2] === o[0]) {
      let r = Math.min(t2 - s2, o.length), c2 = 1;
      for (; c2 < r && e[s2 + c2] === o[c2]; ) ++c2;
      let a = n3.get(o);
      if (c2 === o.length) n3 = a;
      else {
        let d = /* @__PURE__ */ new Map();
        d.set(o.slice(c2), a), n3.set(e.slice(s2, s2 + c2), d), n3.delete(o), n3 = d;
      }
      s2 += c2;
      continue e;
    }
    let i = /* @__PURE__ */ new Map();
    return n3.set(e.slice(s2), i), i;
  }
  return n3;
};
var Ie = (n3, e) => {
  let [t2, s2] = j(n3, e);
  if (t2 !== void 0) {
    if (t2.delete(y), t2.size === 0) le(s2);
    else if (t2.size === 1) {
      let [i, o] = t2.entries().next().value;
      he(s2, i, o);
    }
  }
};
var le = (n3) => {
  if (n3.length === 0) return;
  let [e, t2] = Q(n3);
  if (e.delete(t2), e.size === 0) le(n3.slice(0, -1));
  else if (e.size === 1) {
    let [s2, i] = e.entries().next().value;
    s2 !== y && he(n3.slice(0, -1), s2, i);
  }
};
var he = (n3, e, t2) => {
  if (n3.length === 0) return;
  let [s2, i] = Q(n3);
  s2.set(i + e, t2), s2.delete(i);
};
var Q = (n3) => n3[n3.length - 1];
var U = "or";
var fe = "and";
var Oe = "and_not";
var x2 = class n2 {
  constructor(e) {
    if ((e == null ? void 0 : e.fields) == null) throw new Error('MiniSearch: option "fields" must be provided');
    let t2 = e.autoVacuum == null || e.autoVacuum === true ? N : e.autoVacuum;
    this._options = Object.assign(Object.assign(Object.assign({}, B), e), { autoVacuum: t2, searchOptions: Object.assign(Object.assign({}, ne), e.searchOptions || {}), autoSuggestOptions: Object.assign(Object.assign({}, Le), e.autoSuggestOptions || {}) }), this._index = new v2(), this._documentCount = 0, this._documentIds = /* @__PURE__ */ new Map(), this._idToShortId = /* @__PURE__ */ new Map(), this._fieldIds = {}, this._fieldLength = /* @__PURE__ */ new Map(), this._avgFieldLength = [], this._nextId = 0, this._storedFields = /* @__PURE__ */ new Map(), this._dirtCount = 0, this._currentVacuum = null, this._enqueuedVacuum = null, this._enqueuedVacuumConditions = q, this.addFields(this._options.fields);
  }
  add(e) {
    let { extractField: t2, tokenize: s2, processTerm: i, fields: o, idField: r } = this._options, c2 = t2(e, r);
    if (c2 == null) throw new Error('MiniSearch: document does not have ID field "'.concat(r, '"'));
    if (this._idToShortId.has(c2)) throw new Error("MiniSearch: duplicate ID ".concat(c2));
    let a = this.addDocumentId(c2);
    this.saveStoredFields(a, e);
    for (let d of o) {
      let u2 = t2(e, d);
      if (u2 == null) continue;
      let h = s2(u2.toString(), d), l = this._fieldIds[d], p = new Set(h).size;
      this.addFieldLength(a, l, this._documentCount - 1, p);
      for (let _ of h) {
        let f = i(_, d);
        if (Array.isArray(f)) for (let m of f) this.addTerm(l, a, m);
        else f && this.addTerm(l, a, f);
      }
    }
  }
  addAll(e) {
    for (let t2 of e) this.add(t2);
  }
  addAllAsync(e, t2 = {}) {
    let { chunkSize: s2 = 10 } = t2, i = { chunk: [], promise: Promise.resolve() }, { chunk: o, promise: r } = e.reduce(({ chunk: c2, promise: a }, d, u2) => (c2.push(d), (u2 + 1) % s2 === 0 ? { chunk: [], promise: a.then(() => new Promise((h) => setTimeout(h, 0))).then(() => this.addAll(c2)) } : { chunk: c2, promise: a }), i);
    return r.then(() => this.addAll(o));
  }
  remove(e) {
    let { tokenize: t2, processTerm: s2, extractField: i, fields: o, idField: r } = this._options, c2 = i(e, r);
    if (c2 == null) throw new Error('MiniSearch: document does not have ID field "'.concat(r, '"'));
    let a = this._idToShortId.get(c2);
    if (a == null) throw new Error("MiniSearch: cannot remove document with ID ".concat(c2, ": it is not in the index"));
    for (let d of o) {
      let u2 = i(e, d);
      if (u2 == null) continue;
      let h = t2(u2.toString(), d), l = this._fieldIds[d], p = new Set(h).size;
      this.removeFieldLength(a, l, this._documentCount, p);
      for (let _ of h) {
        let f = s2(_, d);
        if (Array.isArray(f)) for (let m of f) this.removeTerm(l, a, m);
        else f && this.removeTerm(l, a, f);
      }
    }
    this._storedFields.delete(a), this._documentIds.delete(a), this._idToShortId.delete(c2), this._fieldLength.delete(a), this._documentCount -= 1;
  }
  removeAll(e) {
    if (e) for (let t2 of e) this.remove(t2);
    else {
      if (arguments.length > 0) throw new Error("Expected documents to be present. Omit the argument to remove all documents.");
      this._index = new v2(), this._documentCount = 0, this._documentIds = /* @__PURE__ */ new Map(), this._idToShortId = /* @__PURE__ */ new Map(), this._fieldLength = /* @__PURE__ */ new Map(), this._avgFieldLength = [], this._storedFields = /* @__PURE__ */ new Map(), this._nextId = 0;
    }
  }
  discard(e) {
    let t2 = this._idToShortId.get(e);
    if (t2 == null) throw new Error("MiniSearch: cannot discard document with ID ".concat(e, ": it is not in the index"));
    this._idToShortId.delete(e), this._documentIds.delete(t2), this._storedFields.delete(t2), (this._fieldLength.get(t2) || []).forEach((s2, i) => {
      this.removeFieldLength(t2, i, this._documentCount, s2);
    }), this._fieldLength.delete(t2), this._documentCount -= 1, this._dirtCount += 1, this.maybeAutoVacuum();
  }
  maybeAutoVacuum() {
    if (this._options.autoVacuum === false) return;
    let { minDirtFactor: e, minDirtCount: t2, batchSize: s2, batchWait: i } = this._options.autoVacuum;
    this.conditionalVacuum({ batchSize: s2, batchWait: i }, { minDirtCount: t2, minDirtFactor: e });
  }
  discardAll(e) {
    let t2 = this._options.autoVacuum;
    try {
      this._options.autoVacuum = false;
      for (let s2 of e) this.discard(s2);
    } finally {
      this._options.autoVacuum = t2;
    }
    this.maybeAutoVacuum();
  }
  replace(e) {
    let { idField: t2, extractField: s2 } = this._options, i = s2(e, t2);
    this.discard(i), this.add(e);
  }
  vacuum(e = {}) {
    return this.conditionalVacuum(e);
  }
  conditionalVacuum(e, t2) {
    return this._currentVacuum ? (this._enqueuedVacuumConditions = this._enqueuedVacuumConditions && t2, this._enqueuedVacuum != null ? this._enqueuedVacuum : (this._enqueuedVacuum = this._currentVacuum.then(() => {
      let s2 = this._enqueuedVacuumConditions;
      return this._enqueuedVacuumConditions = q, this.performVacuuming(e, s2);
    }), this._enqueuedVacuum)) : this.vacuumConditionsMet(t2) === false ? Promise.resolve() : (this._currentVacuum = this.performVacuuming(e), this._currentVacuum);
  }
  performVacuuming(e, t2) {
    return E(this, void 0, void 0, function* () {
      let s2 = this._dirtCount;
      if (this.vacuumConditionsMet(t2)) {
        let i = e.batchSize || J.batchSize, o = e.batchWait || J.batchWait, r = 1;
        for (let [c2, a] of this._index) {
          for (let [d, u2] of a) for (let [h] of u2) this._documentIds.has(h) || (u2.size <= 1 ? a.delete(d) : u2.delete(h));
          this._index.get(c2).size === 0 && this._index.delete(c2), r % i === 0 && (yield new Promise((d) => setTimeout(d, o))), r += 1;
        }
        this._dirtCount -= s2;
      }
      yield null, this._currentVacuum = this._enqueuedVacuum, this._enqueuedVacuum = null;
    });
  }
  vacuumConditionsMet(e) {
    if (e == null) return true;
    let { minDirtCount: t2, minDirtFactor: s2 } = e;
    return t2 = t2 || N.minDirtCount, s2 = s2 || N.minDirtFactor, this.dirtCount >= t2 && this.dirtFactor >= s2;
  }
  get isVacuuming() {
    return this._currentVacuum != null;
  }
  get dirtCount() {
    return this._dirtCount;
  }
  get dirtFactor() {
    return this._dirtCount / (1 + this._documentCount + this._dirtCount);
  }
  has(e) {
    return this._idToShortId.has(e);
  }
  getStoredFields(e) {
    let t2 = this._idToShortId.get(e);
    if (t2 != null) return this._storedFields.get(t2);
  }
  search(e, t2 = {}) {
    let s2 = this.executeQuery(e, t2), i = [];
    for (let [o, { score: r, terms: c2, match: a }] of s2) {
      let d = c2.length || 1, u2 = { id: this._documentIds.get(o), score: r * d, terms: Object.keys(a), queryTerms: c2, match: a };
      Object.assign(u2, this._storedFields.get(o)), (t2.filter == null || t2.filter(u2)) && i.push(u2);
    }
    return e === n2.wildcard && t2.boostDocument == null && this._options.searchOptions.boostDocument == null || i.sort(re), i;
  }
  autoSuggest(e, t2 = {}) {
    t2 = Object.assign(Object.assign({}, this._options.autoSuggestOptions), t2);
    let s2 = /* @__PURE__ */ new Map();
    for (let { score: o, terms: r } of this.search(e, t2)) {
      let c2 = r.join(" "), a = s2.get(c2);
      a != null ? (a.score += o, a.count += 1) : s2.set(c2, { score: o, terms: r, count: 1 });
    }
    let i = [];
    for (let [o, { score: r, terms: c2, count: a }] of s2) i.push({ suggestion: o, terms: c2, score: r / a });
    return i.sort(re), i;
  }
  get documentCount() {
    return this._documentCount;
  }
  get termCount() {
    return this._index.size;
  }
  static loadJSON(e, t2) {
    if (t2 == null) throw new Error("MiniSearch: loadJSON should be given the same options used when serializing the index");
    return this.loadJS(JSON.parse(e), t2);
  }
  static loadJSONAsync(e, t2) {
    return E(this, void 0, void 0, function* () {
      if (t2 == null) throw new Error("MiniSearch: loadJSON should be given the same options used when serializing the index");
      return this.loadJSAsync(JSON.parse(e), t2);
    });
  }
  static getDefault(e) {
    if (B.hasOwnProperty(e)) return W(B, e);
    throw new Error('MiniSearch: unknown option "'.concat(e, '"'));
  }
  static loadJS(e, t2) {
    let { index: s2, documentIds: i, fieldLength: o, storedFields: r, serializationVersion: c2 } = e, a = this.instantiateMiniSearch(e, t2);
    a._documentIds = k(i), a._fieldLength = k(o), a._storedFields = k(r);
    for (let [d, u2] of a._documentIds) a._idToShortId.set(u2, d);
    for (let [d, u2] of s2) {
      let h = /* @__PURE__ */ new Map();
      for (let l of Object.keys(u2)) {
        let p = u2[l];
        c2 === 1 && (p = p.ds), h.set(parseInt(l, 10), k(p));
      }
      a._index.set(d, h);
    }
    return a;
  }
  static loadJSAsync(e, t2) {
    return E(this, void 0, void 0, function* () {
      let { index: s2, documentIds: i, fieldLength: o, storedFields: r, serializationVersion: c2 } = e, a = this.instantiateMiniSearch(e, t2);
      a._documentIds = yield A(i), a._fieldLength = yield A(o), a._storedFields = yield A(r);
      for (let [u2, h] of a._documentIds) a._idToShortId.set(h, u2);
      let d = 0;
      for (let [u2, h] of s2) {
        let l = /* @__PURE__ */ new Map();
        for (let p of Object.keys(h)) {
          let _ = h[p];
          c2 === 1 && (_ = _.ds), l.set(parseInt(p, 10), yield A(_));
        }
        ++d % 1e3 === 0 && (yield pe(0)), a._index.set(u2, l);
      }
      return a;
    });
  }
  static instantiateMiniSearch(e, t2) {
    let { documentCount: s2, nextId: i, fieldIds: o, averageFieldLength: r, dirtCount: c2, serializationVersion: a } = e;
    if (a !== 1 && a !== 2) throw new Error("MiniSearch: cannot deserialize an index created with an incompatible version");
    let d = new n2(t2);
    return d._documentCount = s2, d._nextId = i, d._idToShortId = /* @__PURE__ */ new Map(), d._fieldIds = o, d._avgFieldLength = r, d._dirtCount = c2 || 0, d._index = new v2(), d;
  }
  executeQuery(e, t2 = {}) {
    if (e === n2.wildcard) return this.executeWildcardQuery(t2);
    if (typeof e != "string") {
      let l = Object.assign(Object.assign(Object.assign({}, t2), e), { queries: void 0 }), p = e.queries.map((_) => this.executeQuery(_, l));
      return this.combineResults(p, l.combineWith);
    }
    let { tokenize: s2, processTerm: i, searchOptions: o } = this._options, r = Object.assign(Object.assign({ tokenize: s2, processTerm: i }, o), t2), { tokenize: c2, processTerm: a } = r, h = c2(e).flatMap((l) => a(l)).filter((l) => !!l).map(Ce(r)).map((l) => this.executeQuerySpec(l, r));
    return this.combineResults(h, r.combineWith);
  }
  executeQuerySpec(e, t2) {
    let s2 = Object.assign(Object.assign({}, this._options.searchOptions), t2), i = (s2.fields || this._options.fields).reduce((f, m) => Object.assign(Object.assign({}, f), { [m]: W(s2.boost, m) || 1 }), {}), { boostDocument: o, weights: r, maxFuzzy: c2, bm25: a } = s2, { fuzzy: d, prefix: u2 } = Object.assign(Object.assign({}, ne.weights), r), h = this._index.get(e.term), l = this.termResults(e.term, e.term, 1, e.termBoost, h, i, o, a), p, _;
    if (e.prefix && (p = this._index.atPrefix(e.term)), e.fuzzy) {
      let f = e.fuzzy === true ? 0.2 : e.fuzzy, m = f < 1 ? Math.min(c2, Math.round(e.term.length * f)) : f;
      m && (_ = this._index.fuzzyGet(e.term, m));
    }
    if (p) for (let [f, m] of p) {
      let S = f.length - e.term.length;
      if (!S) continue;
      _ == null || _.delete(f);
      let b = u2 * f.length / (f.length + 0.3 * S);
      this.termResults(e.term, f, b, e.termBoost, m, i, o, a, l);
    }
    if (_) for (let f of _.keys()) {
      let [m, S] = _.get(f);
      if (!S) continue;
      let b = d * f.length / (f.length + S);
      this.termResults(e.term, f, b, e.termBoost, m, i, o, a, l);
    }
    return l;
  }
  executeWildcardQuery(e) {
    let t2 = /* @__PURE__ */ new Map(), s2 = Object.assign(Object.assign({}, this._options.searchOptions), e);
    for (let [i, o] of this._documentIds) {
      let r = s2.boostDocument ? s2.boostDocument(o, "", this._storedFields.get(i)) : 1;
      t2.set(i, { score: r, terms: [], match: {} });
    }
    return t2;
  }
  combineResults(e, t2 = U) {
    if (e.length === 0) return /* @__PURE__ */ new Map();
    let s2 = t2.toLowerCase(), i = ve[s2];
    if (!i) throw new Error("Invalid combination operator: ".concat(t2));
    return e.reduce(i) || /* @__PURE__ */ new Map();
  }
  toJSON() {
    let e = [];
    for (let [t2, s2] of this._index) {
      let i = {};
      for (let [o, r] of s2) i[o] = Object.fromEntries(r);
      e.push([t2, i]);
    }
    return { documentCount: this._documentCount, nextId: this._nextId, documentIds: Object.fromEntries(this._documentIds), fieldIds: this._fieldIds, fieldLength: Object.fromEntries(this._fieldLength), averageFieldLength: this._avgFieldLength, storedFields: Object.fromEntries(this._storedFields), dirtCount: this._dirtCount, index: e, serializationVersion: 2 };
  }
  termResults(e, t2, s2, i, o, r, c2, a, d = /* @__PURE__ */ new Map()) {
    if (o == null) return d;
    for (let u2 of Object.keys(r)) {
      let h = r[u2], l = this._fieldIds[u2], p = o.get(l);
      if (p == null) continue;
      let _ = p.size, f = this._avgFieldLength[l];
      for (let m of p.keys()) {
        if (!this._documentIds.has(m)) {
          this.removeTerm(l, m, t2), _ -= 1;
          continue;
        }
        let S = c2 ? c2(this._documentIds.get(m), t2, this._storedFields.get(m)) : 1;
        if (!S) continue;
        let b = p.get(m), V = this._fieldLength.get(m)[l], R = Me(b, _, this._documentCount, V, f, a), M = s2 * i * h * S * R, w2 = d.get(m);
        if (w2) {
          w2.score += M, ke(w2.terms, e);
          let I = W(w2.match, t2);
          I ? I.push(u2) : w2.match[t2] = [u2];
        } else d.set(m, { score: M, terms: [e], match: { [t2]: [u2] } });
      }
    }
    return d;
  }
  addTerm(e, t2, s2) {
    let i = this._index.fetch(s2, ce), o = i.get(e);
    if (o == null) o = /* @__PURE__ */ new Map(), o.set(t2, 1), i.set(e, o);
    else {
      let r = o.get(t2);
      o.set(t2, (r || 0) + 1);
    }
  }
  removeTerm(e, t2, s2) {
    if (!this._index.has(s2)) {
      this.warnDocumentChanged(t2, e, s2);
      return;
    }
    let i = this._index.fetch(s2, ce), o = i.get(e);
    o == null || o.get(t2) == null ? this.warnDocumentChanged(t2, e, s2) : o.get(t2) <= 1 ? o.size <= 1 ? i.delete(e) : o.delete(t2) : o.set(t2, o.get(t2) - 1), this._index.get(s2).size === 0 && this._index.delete(s2);
  }
  warnDocumentChanged(e, t2, s2) {
    for (let i of Object.keys(this._fieldIds)) if (this._fieldIds[i] === t2) {
      this._options.logger("warn", "MiniSearch: document with ID ".concat(this._documentIds.get(e), ' has changed before removal: term "').concat(s2, '" was not present in field "').concat(i, '". Removing a document after it has changed can corrupt the index!'), "version_conflict");
      return;
    }
  }
  addDocumentId(e) {
    let t2 = this._nextId;
    return this._idToShortId.set(e, t2), this._documentIds.set(t2, e), this._documentCount += 1, this._nextId += 1, t2;
  }
  addFields(e) {
    for (let t2 = 0; t2 < e.length; t2++) this._fieldIds[e[t2]] = t2;
  }
  addFieldLength(e, t2, s2, i) {
    let o = this._fieldLength.get(e);
    o == null && this._fieldLength.set(e, o = []), o[t2] = i;
    let c2 = (this._avgFieldLength[t2] || 0) * s2 + i;
    this._avgFieldLength[t2] = c2 / (s2 + 1);
  }
  removeFieldLength(e, t2, s2, i) {
    if (s2 === 1) {
      this._avgFieldLength[t2] = 0;
      return;
    }
    let o = this._avgFieldLength[t2] * s2 - i;
    this._avgFieldLength[t2] = o / (s2 - 1);
  }
  saveStoredFields(e, t2) {
    let { storeFields: s2, extractField: i } = this._options;
    if (s2 == null || s2.length === 0) return;
    let o = this._storedFields.get(e);
    o == null && this._storedFields.set(e, o = {});
    for (let r of s2) {
      let c2 = i(t2, r);
      c2 !== void 0 && (o[r] = c2);
    }
  }
};
x2.wildcard = Symbol("*");
var W = (n3, e) => Object.prototype.hasOwnProperty.call(n3, e) ? n3[e] : void 0;
var ve = { [U]: (n3, e) => {
  for (let t2 of e.keys()) {
    let s2 = n3.get(t2);
    if (s2 == null) n3.set(t2, e.get(t2));
    else {
      let { score: i, terms: o, match: r } = e.get(t2);
      s2.score = s2.score + i, s2.match = Object.assign(s2.match, r), oe(s2.terms, o);
    }
  }
  return n3;
}, [fe]: (n3, e) => {
  let t2 = /* @__PURE__ */ new Map();
  for (let s2 of e.keys()) {
    let i = n3.get(s2);
    if (i == null) continue;
    let { score: o, terms: r, match: c2 } = e.get(s2);
    oe(i.terms, r), t2.set(s2, { score: i.score + o, terms: i.terms, match: Object.assign(i.match, c2) });
  }
  return t2;
}, [Oe]: (n3, e) => {
  for (let t2 of e.keys()) n3.delete(t2);
  return n3;
} };
var Fe = { k: 1.2, b: 0.7, d: 0.5 };
var Me = (n3, e, t2, s2, i, o) => {
  let { k: r, b: c2, d: a } = o;
  return Math.log(1 + (t2 - e + 0.5) / (e + 0.5)) * (a + n3 * (r + 1) / (n3 + r * (1 - c2 + c2 * s2 / i)));
};
var Ce = (n3) => (e, t2, s2) => {
  let i = typeof n3.fuzzy == "function" ? n3.fuzzy(e, t2, s2) : n3.fuzzy || false, o = typeof n3.prefix == "function" ? n3.prefix(e, t2, s2) : n3.prefix === true, r = typeof n3.boostTerm == "function" ? n3.boostTerm(e, t2, s2) : 1;
  return { term: e, fuzzy: i, prefix: o, termBoost: r };
};
var B = { idField: "id", extractField: (n3, e) => n3[e], tokenize: (n3) => n3.split(Ae), processTerm: (n3) => n3.toLowerCase(), fields: void 0, searchOptions: void 0, storeFields: [], logger: (n3, e) => {
  typeof (console == null ? void 0 : console[n3]) == "function" && console[n3](e);
}, autoVacuum: true };
var ne = { combineWith: U, prefix: false, fuzzy: false, maxFuzzy: 6, boost: {}, weights: { fuzzy: 0.45, prefix: 0.375 }, bm25: Fe };
var Le = { combineWith: fe, prefix: (n3, e, t2) => e === t2.length - 1 };
var J = { batchSize: 1e3, batchWait: 10 };
var q = { minDirtFactor: 0.1, minDirtCount: 20 };
var N = Object.assign(Object.assign({}, J), q);
var ke = (n3, e) => {
  n3.includes(e) || n3.push(e);
};
var oe = (n3, e) => {
  for (let t2 of e) n3.includes(t2) || n3.push(t2);
};
var re = ({ score: n3 }, { score: e }) => e - n3;
var ce = () => /* @__PURE__ */ new Map();
var k = (n3) => {
  let e = /* @__PURE__ */ new Map();
  for (let t2 of Object.keys(n3)) e.set(parseInt(t2, 10), n3[t2]);
  return e;
};
var A = (n3) => E(void 0, void 0, void 0, function* () {
  let e = /* @__PURE__ */ new Map(), t2 = 0;
  for (let s2 of Object.keys(n3)) e.set(parseInt(s2, 10), n3[s2]), ++t2 % 1e3 === 0 && (yield pe(0));
  return e;
});
var pe = (n3) => new Promise((e) => setTimeout(e, n3));
var Ae = /[\n\r\p{Z}\p{P}]+/u;
var _e = s(qs(), 1);
var F;
var T;
var ye;
var me = class {
  constructor(e) {
    v(this, T);
    t(this, "mapData");
    t(this, "indexes");
    t(this, "ready");
    v(this, F);
    this.mapData = e, this.indexes = Te(e), this.ready = this.populate(), w(this, F, Yp(x(this, T, ye).bind(this), 2e3));
  }
  async populate() {
    let { places: e, enterpriseLocations: t2, enterpriseCategories: s2 } = this.indexes, i = this.mapData, o = [];
    return e.removeAll(), o = o.concat([e.addAllAsync(i.getByType("space")), e.addAllAsync(i.getByType("point-of-interest")), e.addAllAsync(i.getByType("connection")), e.addAllAsync(i.getByType("floor")), e.addAllAsync(i.getByType("door")), e.addAllAsync(i.getByType("annotation")), e.addAllAsync(i.getByType("area"))]), t2 && (t2 == null || t2.removeAll(), o.push(t2.addAllAsync(i.getByType("enterprise-location")))), s2 && (s2 == null || s2.removeAll(), o.push(s2.addAllAsync(i.getByType("enterprise-category")))), Promise.all(o);
  }
  async search(e, t2 = {}) {
    var a, d;
    await this.ready, Ve.parse(t2);
    let s2 = (0, _e.default)({}, t2, je), i = this.indexes.places.search(e, { fields: Object.keys(s2.places.fields).filter((u2) => s2.places.fields[u2]) });
    s2.places.limit && (i = i.slice(0, s2.places.limit));
    let o = (a = this.indexes.enterpriseLocations) == null ? void 0 : a.search(e, { fields: Object.keys(s2.enterpriseLocations.fields).filter((u2) => s2.enterpriseLocations.fields[u2]) });
    o && s2.enterpriseLocations.limit && (o = o.slice(0, s2.enterpriseLocations.limit));
    let r = (d = this.indexes.enterpriseCategories) == null ? void 0 : d.search(e, { fields: Object.keys(s2.enterpriseCategories.fields).filter((u2) => s2.enterpriseCategories.fields[u2]) });
    r && s2.enterpriseCategories.limit && (r = r.slice(0, s2.enterpriseCategories.limit));
    let c2 = Ee(this.mapData, { placesResult: i, locationsResult: o, categoriesResult: r });
    return u(this, F).call(this, e), c2;
  }
  async suggest(e, t2 = {}) {
    await this.ready, Re.parse(t2);
    let s2 = [], { places: { enabled: i = true } = {}, enterpriseLocations: { enabled: o = true } = {} } = t2;
    return o && this.indexes.enterpriseLocations && this.indexes.enterpriseLocations.autoSuggest(e, { fields: ["name", "tags"], combineWith: "AND", prefix: true, boost: { name: 2, tags: 1 } }).forEach((r) => s2.push(r)), i && this.indexes.places.autoSuggest(e, { fields: ["name"], combineWith: "AND", prefix: true }).forEach((r) => s2.push(r)), s2.sort((r, c2) => c2.score - r.score), this.mapData.Analytics.capture("$query-suggest", { query: e, suggestions: s2.map((r) => r.suggestion) }), s2;
  }
};
F = /* @__PURE__ */ new WeakMap(), T = /* @__PURE__ */ new WeakSet(), ye = function(e) {
  this.mapData.Analytics.capture("$query-search", { query: e });
};
function Ee(n3, { placesResult: e, locationsResult: t2, categoriesResult: s2 }) {
  let i = e.reduce((c2, { id: a, match: d, score: u2, __type: h }) => {
    let l = n3.getById(h, a);
    return l != null && !xo.is(l) && !Rd.is(l) && !xr.is(l) && !Li.is(l) && !Nd.is(l) && c2.push({ type: l.__type, match: d, score: u2, item: l }), c2;
  }, []), o;
  if (t2) {
    o = [];
    for (let { id: c2, match: a, score: d } of t2) {
      let u2 = n3.getById("enterprise-location", c2);
      u2 && o.push({ type: u2.__type, match: a, score: d, item: u2 });
    }
  }
  let r;
  if (s2) {
    r = [];
    for (let { id: c2, match: a, score: d } of s2) {
      let u2 = n3.getById("enterprise-category", c2);
      u2 && r.push({ type: u2.__type, match: a, score: d, item: u2 });
    }
  }
  return { places: i, enterpriseLocations: o, enterpriseCategories: r };
}
var je = { places: { fields: { name: true, description: true } }, enterpriseCategories: { fields: { name: true, description: false, "locations.name": true } }, enterpriseLocations: { fields: { name: true, tags: true, description: true } } };
function G(n3) {
  return n3.normalize("NFD").replace(/[\u0300-\u036f|\u2019|\u0027|\']/g, "").toLowerCase();
}
function Te(n3) {
  let e = new x2({ fields: ["name", "description"], storeFields: ["id", "__type"], searchOptions: { fuzzy: 0.2, prefix: true, boost: { name: 2 }, combineWith: "AND" }, extractField: (r, c2) => {
    let a = r[c2];
    return typeof a == "string" ? G(a) : r[c2];
  }, processTerm: (r) => De.has(r) ? "" : r.toLowerCase() }), t2 = n3.getByType("enterprise-location"), s2;
  t2 && (s2 = new x2({ fields: ["name", "tags", "description"], storeFields: ["id", "__type"], searchOptions: { combineWith: "OR", prefix: true, fuzzy: 0.2, boost: { name: 3, tags: 2, description: 1 } }, extractField: (r, c2) => Array.isArray(r[c2]) ? r[c2].join(" ") : typeof r[c2] == "string" ? G(r[c2]) : r[c2] }));
  let i = n3.getByType("enterprise-category"), o;
  return i && (o = new x2({ fields: ["name", "description", "locations.name"], storeFields: ["id", "__type"], extractField(r, c2) {
    return c2 === "locations.name" ? r.locations.reduce((d, u2) => d + " ".concat(ge, " ") + u2.name, "") + " ".concat(ge) : typeof r[c2] == "string" ? G(r[c2]) : r[c2];
  }, searchOptions: { combineWith: "OR", prefix: true, fuzzy: 0.2, boost: { name: 2, "locations.name": 2 } } })), { enterpriseCategories: o, enterpriseLocations: s2, places: e };
}
var Ve = K.object({ places: K.object({ fields: K.object({ name: K.boolean().optional(), description: K.boolean().optional() }).optional(), limit: K.number().positive().optional() }).optional(), enterpriseCategories: K.object({ fields: K.object({ name: K.boolean().optional(), description: K.boolean().optional(), "locations.name": K.boolean().optional() }).optional(), limit: K.number().positive().optional() }).optional(), enterpriseLocations: K.object({ fields: K.object({ name: K.boolean().optional(), tags: K.boolean().optional(), description: K.boolean().optional() }).optional(), limit: K.number().positive().optional() }).optional() });
var Re = K.object({ places: K.object({ enabled: K.boolean().optional() }).optional(), enterpriseLocations: K.object({ enabled: K.boolean().optional() }).optional() });
var De = /* @__PURE__ */ new Set(["the", "an", "and", "or", "of", "in", "on", "at", "to", "from", "with", "by", "for"]);
var ge = "";
export {
  me as InternalSearch,
  G as removeAccents
};
//# sourceMappingURL=internal-CKIQLSVC-GVNS6AWO.js.map
