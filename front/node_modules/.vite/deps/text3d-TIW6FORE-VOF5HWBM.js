import {
  Fl,
  du,
  hv,
  pv,
  sn,
  wi
} from "./chunk-EU42VC65.js";
import "./chunk-4OORONJH.js";
import {
  R,
  kt,
  md
} from "./chunk-OXS4RIMJ.js";
import "./chunk-STL2KGEZ.js";
import {
  c
} from "./chunk-LZZZ25U2.js";
import "./chunk-ASEP6WC2.js";

// node_modules/@mappedin/mappedin-js/lib/esm/text3d-TIW6FORE.js
c();
var g = new kt();
var n = new R();
var J = new R(0, 0, 1);
async function ot(p, s, o, M) {
  var m, k, d, t, x, h, T, y, f, l, c2, O;
  let r = s.feature.properties, e = new sn();
  s.textMesh = e, e.text = r.text, e.anchorX = "center", e.anchorY = "middle", e.textAlign = (m = r.align) != null ? m : "center", e.color = (k = r.color) != null ? k : "black", e.fontSize = r.fontSize || 20;
  let a = (d = o.font) != null ? d : du.font;
  a ? e.font = a : u ? e.font = await u : e.font = await q(), e.outlineOpacity = (t = o.outlineOpacity) != null ? t : du.outlineOpacity, e.outlineColor = (x = o.outlineColor) != null ? x : du.outlineColor, e.outlineOffsetY = (h = o.outlineOffsetY) != null ? h : du.outlineOffsetY, e.outlineOffsetX = (T = o.outlineOffsetX) != null ? T : du.outlineOffsetX, e.outlineWidth = (y = o.outlineWidth) != null ? y : du.outlineWidth, e.outlineBlur = (f = o.outlineBlur) != null ? f : du.outlineBlur, e.strokeWidth = (l = o.strokeWidth) != null ? l : du.strokeWidth, e.strokeColor = (c2 = o.strokeColor) != null ? c2 : du.strokeColor, e.strokeOpacity = (O = o.strokeOpacity) != null ? O : du.strokeOpacity;
  let W = M(s.feature.geometry.coordinates);
  return e.position.copy(W), e.position.z = r.verticalOffset, e.rotation.z = md.degToRad(-r.rotation), e.userData = { entityId: p.toString(), rotationZ: -r.rotation }, { text: e };
}
async function it(p, s, o, M) {
  var O, P, z, B, X, D, F, Y, b, E, I, R2, v, _, L;
  let r = s.feature.properties, { textArea: e } = r;
  if (!e) throw new Error("textArea is required");
  let a = (O = o.margin) != null ? O : du.margin, [W, m, k, d] = Array.isArray(a) ? a : [a, a, a, a], t = new sn();
  t.text = r.content;
  let x = e.maxHeight - W - k, h = e.maxWidth - d - m;
  t.fontSize = Math.min(x, (P = o.fontSize) != null ? P : du.fontSize), t.color = (z = o.color) != null ? z : du.color, t.maxWidth = (B = o.maxWidth) != null ? B : h, t.anchorX = "center", t.anchorY = "middle", t.textAlign = "center";
  let T = (X = o.font) != null ? X : du.font;
  T ? t.font = T : u ? t.font = await u : t.font = await q(), t.outlineOpacity = (D = o.outlineOpacity) != null ? D : du.outlineOpacity, t.outlineColor = (F = o.outlineColor) != null ? F : du.outlineColor, t.outlineOffsetY = (Y = o.outlineOffsetY) != null ? Y : du.outlineOffsetY, t.outlineOffsetX = (b = o.outlineOffsetX) != null ? b : du.outlineOffsetX, t.outlineWidth = (E = o.outlineWidth) != null ? E : du.outlineWidth, t.outlineBlur = (I = o.outlineBlur) != null ? I : du.outlineBlur, t.strokeWidth = (R2 = o.strokeWidth) != null ? R2 : du.strokeWidth, t.strokeColor = (v = o.strokeColor) != null ? v : du.strokeColor, t.strokeOpacity = (_ = o.strokeOpacity) != null ? _ : du.strokeOpacity;
  let y = M(e.position, n);
  t.position.copy(y);
  let f = wi(Math.PI / 2 - md.degToRad(e.rotation));
  t.rotation.z = f, t.userData = { entityId: p.toString(), rotationZ: f };
  let l, c2;
  try {
    c2 = (await pv(t, h, x, t.fontSize * 0.2)).size;
  } catch (j) {
    throw (L = t.dispose) == null || L.call(t), new Error("Cannot fit text to area: entityId: ".concat(s.polygonEntityId, " ").concat(j));
  }
  if (c2) return g.identity(), n.set(0, 0, 1), g.makeRotationAxis(J, f), n.set(e.align === "near" ? d + c2[0] / 2 : e.maxWidth / 2, 0, 0), n.applyMatrix4(g), t.position.x -= n.x, t.position.y -= n.y, s.textMesh = t, l && (n.set(e.maxWidth / 2, 0, 0), n.applyMatrix4(g), l.position.x -= n.x, l.position.y -= n.y), { text: t };
}
var u;
function q(p) {
  return u = hv(p), u;
}
export {
  Fl as BatchedText,
  sn as Text,
  it as createTroikaTextArea,
  ot as createTroikaTextPoint,
  u as fontPreloadLoadPromise,
  q as preloadFont
};
//# sourceMappingURL=text3d-TIW6FORE-VOF5HWBM.js.map
