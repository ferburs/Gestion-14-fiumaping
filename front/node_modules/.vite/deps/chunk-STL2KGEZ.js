import {
  c
} from "./chunk-LZZZ25U2.js";
import {
  q,
  r,
  s
} from "./chunk-ASEP6WC2.js";

// node_modules/@mappedin/mappedin-js/lib/esm/chunk-MEAXYDH5.js
var ye = q((zM, Wh) => {
  "use strict";
  c();
  Wh.exports = bi;
  function bi(r50, e) {
    this.x = r50, this.y = e;
  }
  bi.prototype = { clone: function() {
    return new bi(this.x, this.y);
  }, add: function(r50) {
    return this.clone()._add(r50);
  }, sub: function(r50) {
    return this.clone()._sub(r50);
  }, multByPoint: function(r50) {
    return this.clone()._multByPoint(r50);
  }, divByPoint: function(r50) {
    return this.clone()._divByPoint(r50);
  }, mult: function(r50) {
    return this.clone()._mult(r50);
  }, div: function(r50) {
    return this.clone()._div(r50);
  }, rotate: function(r50) {
    return this.clone()._rotate(r50);
  }, rotateAround: function(r50, e) {
    return this.clone()._rotateAround(r50, e);
  }, matMult: function(r50) {
    return this.clone()._matMult(r50);
  }, unit: function() {
    return this.clone()._unit();
  }, perp: function() {
    return this.clone()._perp();
  }, round: function() {
    return this.clone()._round();
  }, mag: function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }, equals: function(r50) {
    return this.x === r50.x && this.y === r50.y;
  }, dist: function(r50) {
    return Math.sqrt(this.distSqr(r50));
  }, distSqr: function(r50) {
    var e = r50.x - this.x, t = r50.y - this.y;
    return e * e + t * t;
  }, angle: function() {
    return Math.atan2(this.y, this.x);
  }, angleTo: function(r50) {
    return Math.atan2(this.y - r50.y, this.x - r50.x);
  }, angleWith: function(r50) {
    return this.angleWithSep(r50.x, r50.y);
  }, angleWithSep: function(r50, e) {
    return Math.atan2(this.x * e - this.y * r50, this.x * r50 + this.y * e);
  }, _matMult: function(r50) {
    var e = r50[0] * this.x + r50[1] * this.y, t = r50[2] * this.x + r50[3] * this.y;
    return this.x = e, this.y = t, this;
  }, _add: function(r50) {
    return this.x += r50.x, this.y += r50.y, this;
  }, _sub: function(r50) {
    return this.x -= r50.x, this.y -= r50.y, this;
  }, _mult: function(r50) {
    return this.x *= r50, this.y *= r50, this;
  }, _div: function(r50) {
    return this.x /= r50, this.y /= r50, this;
  }, _multByPoint: function(r50) {
    return this.x *= r50.x, this.y *= r50.y, this;
  }, _divByPoint: function(r50) {
    return this.x /= r50.x, this.y /= r50.y, this;
  }, _unit: function() {
    return this._div(this.mag()), this;
  }, _perp: function() {
    var r50 = this.y;
    return this.y = this.x, this.x = -r50, this;
  }, _rotate: function(r50) {
    var e = Math.cos(r50), t = Math.sin(r50), i = e * this.x - t * this.y, n = t * this.x + e * this.y;
    return this.x = i, this.y = n, this;
  }, _rotateAround: function(r50, e) {
    var t = Math.cos(r50), i = Math.sin(r50), n = e.x + t * (this.x - e.x) - i * (this.y - e.y), o = e.y + i * (this.x - e.x) + t * (this.y - e.y);
    return this.x = n, this.y = o, this;
  }, _round: function() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  } };
  bi.convert = function(r50) {
    return r50 instanceof bi ? r50 : Array.isArray(r50) ? new bi(r50[0], r50[1]) : r50;
  };
});
var Jh = q((RM, Kh) => {
  "use strict";
  c();
  Kh.exports = Xh;
  function Xh(r50, e, t, i) {
    this.cx = 3 * r50, this.bx = 3 * (t - r50) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e, this.by = 3 * (i - e) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = r50, this.p1y = e, this.p2x = t, this.p2y = i;
  }
  Xh.prototype = { sampleCurveX: function(r50) {
    return ((this.ax * r50 + this.bx) * r50 + this.cx) * r50;
  }, sampleCurveY: function(r50) {
    return ((this.ay * r50 + this.by) * r50 + this.cy) * r50;
  }, sampleCurveDerivativeX: function(r50) {
    return (3 * this.ax * r50 + 2 * this.bx) * r50 + this.cx;
  }, solveCurveX: function(r50, e) {
    if (e === void 0 && (e = 1e-6), r50 < 0) return 0;
    if (r50 > 1) return 1;
    for (var t = r50, i = 0; i < 8; i++) {
      var n = this.sampleCurveX(t) - r50;
      if (Math.abs(n) < e) return t;
      var o = this.sampleCurveDerivativeX(t);
      if (Math.abs(o) < 1e-6) break;
      t = t - n / o;
    }
    var a = 0, s3 = 1;
    for (t = r50, i = 0; i < 20 && (n = this.sampleCurveX(t), !(Math.abs(n - r50) < e)); i++) r50 > n ? a = t : s3 = t, t = (s3 - a) * 0.5 + a;
    return t;
  }, solve: function(r50, e) {
    return this.sampleCurveY(this.solveCurveX(r50, e));
  } };
});
var Gm = q((YC, dp) => {
  c();
  function x1(r50, e) {
    var t, i, n, o, a, s3, l, u, c3, p;
    for (t = r50.length & 3, i = r50.length - t, n = e, a = 3432918353, l = 461845907, p = 0; p < i; ) c3 = r50.charCodeAt(p) & 255 | (r50.charCodeAt(++p) & 255) << 8 | (r50.charCodeAt(++p) & 255) << 16 | (r50.charCodeAt(++p) & 255) << 24, ++p, c3 = (c3 & 65535) * a + (((c3 >>> 16) * a & 65535) << 16) & 4294967295, c3 = c3 << 15 | c3 >>> 17, c3 = (c3 & 65535) * l + (((c3 >>> 16) * l & 65535) << 16) & 4294967295, n ^= c3, n = n << 13 | n >>> 19, o = (n & 65535) * 5 + (((n >>> 16) * 5 & 65535) << 16) & 4294967295, n = (o & 65535) + 27492 + (((o >>> 16) + 58964 & 65535) << 16);
    switch (c3 = 0, t) {
      case 3:
        c3 ^= (r50.charCodeAt(p + 2) & 255) << 16;
      case 2:
        c3 ^= (r50.charCodeAt(p + 1) & 255) << 8;
      case 1:
        c3 ^= r50.charCodeAt(p) & 255, c3 = (c3 & 65535) * a + (((c3 >>> 16) * a & 65535) << 16) & 4294967295, c3 = c3 << 15 | c3 >>> 17, c3 = (c3 & 65535) * l + (((c3 >>> 16) * l & 65535) << 16) & 4294967295, n ^= c3;
    }
    return n ^= r50.length, n ^= n >>> 16, n = (n & 65535) * 2246822507 + (((n >>> 16) * 2246822507 & 65535) << 16) & 4294967295, n ^= n >>> 13, n = (n & 65535) * 3266489909 + (((n >>> 16) * 3266489909 & 65535) << 16) & 4294967295, n ^= n >>> 16, n >>> 0;
  }
  typeof dp < "u" && (dp.exports = x1);
});
var qm = q((eE, yp) => {
  c();
  function b1(r50, e) {
    for (var t = r50.length, i = e ^ t, n = 0, o; t >= 4; ) o = r50.charCodeAt(n) & 255 | (r50.charCodeAt(++n) & 255) << 8 | (r50.charCodeAt(++n) & 255) << 16 | (r50.charCodeAt(++n) & 255) << 24, o = (o & 65535) * 1540483477 + (((o >>> 16) * 1540483477 & 65535) << 16), o ^= o >>> 24, o = (o & 65535) * 1540483477 + (((o >>> 16) * 1540483477 & 65535) << 16), i = (i & 65535) * 1540483477 + (((i >>> 16) * 1540483477 & 65535) << 16) ^ o, t -= 4, ++n;
    switch (t) {
      case 3:
        i ^= (r50.charCodeAt(n + 2) & 255) << 16;
      case 2:
        i ^= (r50.charCodeAt(n + 1) & 255) << 8;
      case 1:
        i ^= r50.charCodeAt(n) & 255, i = (i & 65535) * 1540483477 + (((i >>> 16) * 1540483477 & 65535) << 16);
    }
    return i ^= i >>> 13, i = (i & 65535) * 1540483477 + (((i >>> 16) * 1540483477 & 65535) << 16), i ^= i >>> 15, i >>> 0;
  }
  typeof yp !== void 0 && (yp.exports = b1);
});
var gp = q((rE, Vs) => {
  c();
  var jm = Gm(), _1 = qm();
  Vs.exports = jm;
  Vs.exports.murmur3 = jm;
  Vs.exports.murmur2 = _1;
});
var Cp = q((_L, Ip) => {
  "use strict";
  c();
  Ip.exports = Ys;
  Ip.exports.default = Ys;
  function Ys(r50, e, t) {
    t = t || 2;
    var i = e && e.length, n = i ? e[0] * t : r50.length, o = Xd(r50, 0, n, t, true), a = [];
    if (!o || o.next === o.prev) return a;
    var s3, l, u, c3, p, h, f;
    if (i && (o = EP(r50, e, o, t)), r50.length > 80 * t) {
      s3 = u = r50[0], l = c3 = r50[1];
      for (var d = t; d < n; d += t) p = r50[d], h = r50[d + 1], p < s3 && (s3 = p), h < l && (l = h), p > u && (u = p), h > c3 && (c3 = h);
      f = Math.max(u - s3, c3 - l), f = f !== 0 ? 32767 / f : 0;
    }
    return So(o, a, t, s3, l, f, 0), a;
  }
  function Xd(r50, e, t, i, n) {
    var o, a;
    if (n === Mp(r50, e, t, i) > 0) for (o = e; o < t; o += i) a = Wd(o, r50[o], r50[o + 1], a);
    else for (o = t - i; o >= e; o -= i) a = Wd(o, r50[o], r50[o + 1], a);
    return a && Qs(a, a.next) && (To(a), a = a.next), a;
  }
  function si(r50, e) {
    if (!r50) return r50;
    e || (e = r50);
    var t = r50, i;
    do
      if (i = false, !t.steiner && (Qs(t, t.next) || Be(t.prev, t, t.next) === 0)) {
        if (To(t), t = e = t.prev, t === t.next) break;
        i = true;
      } else t = t.next;
    while (i || t !== e);
    return e;
  }
  function So(r50, e, t, i, n, o, a) {
    if (r50) {
      !a && o && FP(r50, i, n, o);
      for (var s3 = r50, l, u; r50.prev !== r50.next; ) {
        if (l = r50.prev, u = r50.next, o ? MP(r50, i, n, o) : AP(r50)) {
          e.push(l.i / t | 0), e.push(r50.i / t | 0), e.push(u.i / t | 0), To(r50), r50 = u.next, s3 = u.next;
          continue;
        }
        if (r50 = u, r50 === s3) {
          a ? a === 1 ? (r50 = IP(si(r50), e, t), So(r50, e, t, i, n, o, 2)) : a === 2 && CP(r50, e, t, i, n, o) : So(si(r50), e, t, i, n, o, 1);
          break;
        }
      }
    }
  }
  function AP(r50) {
    var e = r50.prev, t = r50, i = r50.next;
    if (Be(e, t, i) >= 0) return false;
    for (var n = e.x, o = t.x, a = i.x, s3 = e.y, l = t.y, u = i.y, c3 = n < o ? n < a ? n : a : o < a ? o : a, p = s3 < l ? s3 < u ? s3 : u : l < u ? l : u, h = n > o ? n > a ? n : a : o > a ? o : a, f = s3 > l ? s3 > u ? s3 : u : l > u ? l : u, d = i.next; d !== e; ) {
      if (d.x >= c3 && d.x <= h && d.y >= p && d.y <= f && Hi(n, s3, o, l, a, u, d.x, d.y) && Be(d.prev, d, d.next) >= 0) return false;
      d = d.next;
    }
    return true;
  }
  function MP(r50, e, t, i) {
    var n = r50.prev, o = r50, a = r50.next;
    if (Be(n, o, a) >= 0) return false;
    for (var s3 = n.x, l = o.x, u = a.x, c3 = n.y, p = o.y, h = a.y, f = s3 < l ? s3 < u ? s3 : u : l < u ? l : u, d = c3 < p ? c3 < h ? c3 : h : p < h ? p : h, y = s3 > l ? s3 > u ? s3 : u : l > u ? l : u, g = c3 > p ? c3 > h ? c3 : h : p > h ? p : h, x = Tp(f, d, e, t, i), v = Tp(y, g, e, t, i), b = r50.prevZ, w = r50.nextZ; b && b.z >= x && w && w.z <= v; ) {
      if (b.x >= f && b.x <= y && b.y >= d && b.y <= g && b !== n && b !== a && Hi(s3, c3, l, p, u, h, b.x, b.y) && Be(b.prev, b, b.next) >= 0 || (b = b.prevZ, w.x >= f && w.x <= y && w.y >= d && w.y <= g && w !== n && w !== a && Hi(s3, c3, l, p, u, h, w.x, w.y) && Be(w.prev, w, w.next) >= 0)) return false;
      w = w.nextZ;
    }
    for (; b && b.z >= x; ) {
      if (b.x >= f && b.x <= y && b.y >= d && b.y <= g && b !== n && b !== a && Hi(s3, c3, l, p, u, h, b.x, b.y) && Be(b.prev, b, b.next) >= 0) return false;
      b = b.prevZ;
    }
    for (; w && w.z <= v; ) {
      if (w.x >= f && w.x <= y && w.y >= d && w.y <= g && w !== n && w !== a && Hi(s3, c3, l, p, u, h, w.x, w.y) && Be(w.prev, w, w.next) >= 0) return false;
      w = w.nextZ;
    }
    return true;
  }
  function IP(r50, e, t) {
    var i = r50;
    do {
      var n = i.prev, o = i.next.next;
      !Qs(n, o) && Kd(n, i, i.next, o) && Po(n, o) && Po(o, n) && (e.push(n.i / t | 0), e.push(i.i / t | 0), e.push(o.i / t | 0), To(i), To(i.next), i = r50 = o), i = i.next;
    } while (i !== r50);
    return si(i);
  }
  function CP(r50, e, t, i, n, o) {
    var a = r50;
    do {
      for (var s3 = a.next.next; s3 !== a.prev; ) {
        if (a.i !== s3.i && OP(a, s3)) {
          var l = Jd(a, s3);
          a = si(a, a.next), l = si(l, l.next), So(a, e, t, i, n, o, 0), So(l, e, t, i, n, o, 0);
          return;
        }
        s3 = s3.next;
      }
      a = a.next;
    } while (a !== r50);
  }
  function EP(r50, e, t, i) {
    var n = [], o, a, s3, l, u;
    for (o = 0, a = e.length; o < a; o++) s3 = e[o] * i, l = o < a - 1 ? e[o + 1] * i : r50.length, u = Xd(r50, s3, l, i, false), u === u.next && (u.steiner = true), n.push(BP(u));
    for (n.sort(kP), o = 0; o < n.length; o++) t = LP(n[o], t);
    return t;
  }
  function kP(r50, e) {
    return r50.x - e.x;
  }
  function LP(r50, e) {
    var t = DP(r50, e);
    if (!t) return e;
    var i = Jd(t, r50);
    return si(i, i.next), si(t, t.next);
  }
  function DP(r50, e) {
    var t = e, i = r50.x, n = r50.y, o = -1 / 0, a;
    do {
      if (n <= t.y && n >= t.next.y && t.next.y !== t.y) {
        var s3 = t.x + (n - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
        if (s3 <= i && s3 > o && (o = s3, a = t.x < t.next.x ? t : t.next, s3 === i)) return a;
      }
      t = t.next;
    } while (t !== e);
    if (!a) return null;
    var l = a, u = a.x, c3 = a.y, p = 1 / 0, h;
    t = a;
    do
      i >= t.x && t.x >= u && i !== t.x && Hi(n < c3 ? i : o, n, u, c3, n < c3 ? o : i, n, t.x, t.y) && (h = Math.abs(n - t.y) / (i - t.x), Po(t, r50) && (h < p || h === p && (t.x > a.x || t.x === a.x && zP(a, t))) && (a = t, p = h)), t = t.next;
    while (t !== l);
    return a;
  }
  function zP(r50, e) {
    return Be(r50.prev, r50, e.prev) < 0 && Be(e.next, r50, r50.next) < 0;
  }
  function FP(r50, e, t, i) {
    var n = r50;
    do
      n.z === 0 && (n.z = Tp(n.x, n.y, e, t, i)), n.prevZ = n.prev, n.nextZ = n.next, n = n.next;
    while (n !== r50);
    n.prevZ.nextZ = null, n.prevZ = null, RP(n);
  }
  function RP(r50) {
    var e, t, i, n, o, a, s3, l, u = 1;
    do {
      for (t = r50, r50 = null, o = null, a = 0; t; ) {
        for (a++, i = t, s3 = 0, e = 0; e < u && (s3++, i = i.nextZ, !!i); e++) ;
        for (l = u; s3 > 0 || l > 0 && i; ) s3 !== 0 && (l === 0 || !i || t.z <= i.z) ? (n = t, t = t.nextZ, s3--) : (n = i, i = i.nextZ, l--), o ? o.nextZ = n : r50 = n, n.prevZ = o, o = n;
        t = i;
      }
      o.nextZ = null, u *= 2;
    } while (a > 1);
    return r50;
  }
  function Tp(r50, e, t, i, n) {
    return r50 = (r50 - t) * n | 0, e = (e - i) * n | 0, r50 = (r50 | r50 << 8) & 16711935, r50 = (r50 | r50 << 4) & 252645135, r50 = (r50 | r50 << 2) & 858993459, r50 = (r50 | r50 << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, r50 | e << 1;
  }
  function BP(r50) {
    var e = r50, t = r50;
    do
      (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
    while (e !== r50);
    return t;
  }
  function Hi(r50, e, t, i, n, o, a, s3) {
    return (n - a) * (e - s3) >= (r50 - a) * (o - s3) && (r50 - a) * (i - s3) >= (t - a) * (e - s3) && (t - a) * (o - s3) >= (n - a) * (i - s3);
  }
  function OP(r50, e) {
    return r50.next.i !== e.i && r50.prev.i !== e.i && !VP(r50, e) && (Po(r50, e) && Po(e, r50) && UP(r50, e) && (Be(r50.prev, r50, e.prev) || Be(r50, e.prev, e)) || Qs(r50, e) && Be(r50.prev, r50, r50.next) > 0 && Be(e.prev, e, e.next) > 0);
  }
  function Be(r50, e, t) {
    return (e.y - r50.y) * (t.x - e.x) - (e.x - r50.x) * (t.y - e.y);
  }
  function Qs(r50, e) {
    return r50.x === e.x && r50.y === e.y;
  }
  function Kd(r50, e, t, i) {
    var n = Js(Be(r50, e, t)), o = Js(Be(r50, e, i)), a = Js(Be(t, i, r50)), s3 = Js(Be(t, i, e));
    return !!(n !== o && a !== s3 || n === 0 && Ks(r50, t, e) || o === 0 && Ks(r50, i, e) || a === 0 && Ks(t, r50, i) || s3 === 0 && Ks(t, e, i));
  }
  function Ks(r50, e, t) {
    return e.x <= Math.max(r50.x, t.x) && e.x >= Math.min(r50.x, t.x) && e.y <= Math.max(r50.y, t.y) && e.y >= Math.min(r50.y, t.y);
  }
  function Js(r50) {
    return r50 > 0 ? 1 : r50 < 0 ? -1 : 0;
  }
  function VP(r50, e) {
    var t = r50;
    do {
      if (t.i !== r50.i && t.next.i !== r50.i && t.i !== e.i && t.next.i !== e.i && Kd(t, t.next, r50, e)) return true;
      t = t.next;
    } while (t !== r50);
    return false;
  }
  function Po(r50, e) {
    return Be(r50.prev, r50, r50.next) < 0 ? Be(r50, e, r50.next) >= 0 && Be(r50, r50.prev, e) >= 0 : Be(r50, e, r50.prev) < 0 || Be(r50, r50.next, e) < 0;
  }
  function UP(r50, e) {
    var t = r50, i = false, n = (r50.x + e.x) / 2, o = (r50.y + e.y) / 2;
    do
      t.y > o != t.next.y > o && t.next.y !== t.y && n < (t.next.x - t.x) * (o - t.y) / (t.next.y - t.y) + t.x && (i = !i), t = t.next;
    while (t !== r50);
    return i;
  }
  function Jd(r50, e) {
    var t = new Ap(r50.i, r50.x, r50.y), i = new Ap(e.i, e.x, e.y), n = r50.next, o = e.prev;
    return r50.next = e, e.prev = r50, t.next = n, n.prev = t, i.next = t, t.prev = i, o.next = i, i.prev = o, i;
  }
  function Wd(r50, e, t, i) {
    var n = new Ap(r50, e, t);
    return i ? (n.next = i.next, n.prev = i, i.next.prev = n, i.next = n) : (n.prev = n, n.next = n), n;
  }
  function To(r50) {
    r50.next.prev = r50.prev, r50.prev.next = r50.next, r50.prevZ && (r50.prevZ.nextZ = r50.nextZ), r50.nextZ && (r50.nextZ.prevZ = r50.prevZ);
  }
  function Ap(r50, e, t) {
    this.i = r50, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
  }
  Ys.deviation = function(r50, e, t, i) {
    var n = e && e.length, o = n ? e[0] * t : r50.length, a = Math.abs(Mp(r50, 0, o, t));
    if (n) for (var s3 = 0, l = e.length; s3 < l; s3++) {
      var u = e[s3] * t, c3 = s3 < l - 1 ? e[s3 + 1] * t : r50.length;
      a -= Math.abs(Mp(r50, u, c3, t));
    }
    var p = 0;
    for (s3 = 0; s3 < i.length; s3 += 3) {
      var h = i[s3] * t, f = i[s3 + 1] * t, d = i[s3 + 2] * t;
      p += Math.abs((r50[h] - r50[d]) * (r50[f + 1] - r50[h + 1]) - (r50[h] - r50[f]) * (r50[d + 1] - r50[h + 1]));
    }
    return a === 0 && p === 0 ? 0 : Math.abs((p - a) / a);
  };
  function Mp(r50, e, t, i) {
    for (var n = 0, o = e, a = t - i; o < t; o += i) n += (r50[a] - r50[o]) * (r50[o + 1] + r50[a + 1]), a = o;
    return n;
  }
  Ys.flatten = function(r50) {
    for (var e = r50[0][0].length, t = { vertices: [], holes: [], dimensions: e }, i = 0, n = 0; n < r50.length; n++) {
      for (var o = 0; o < r50[n].length; o++) for (var a = 0; a < e; a++) t.vertices.push(r50[n][o][a]);
      n > 0 && (i += r50[n - 1].length, t.holes.push(i));
    }
    return t;
  };
});
var kp = q((pD, oy) => {
  "use strict";
  c();
  var $P = ye();
  oy.exports = Xi;
  function Xi(r50, e, t, i, n) {
    this.properties = {}, this.extent = t, this.type = 0, this._pbf = r50, this._geometry = -1, this._keys = i, this._values = n, r50.readFields(WP, this, e);
  }
  function WP(r50, e, t) {
    r50 == 1 ? e.id = t.readVarint() : r50 == 2 ? XP(t, e) : r50 == 3 ? e.type = t.readVarint() : r50 == 4 && (e._geometry = t.pos);
  }
  function XP(r50, e) {
    for (var t = r50.readVarint() + r50.pos; r50.pos < t; ) {
      var i = e._keys[r50.readVarint()], n = e._values[r50.readVarint()];
      e.properties[i] = n;
    }
  }
  Xi.types = ["Unknown", "Point", "LineString", "Polygon"];
  Xi.prototype.loadGeometry = function() {
    var r50 = this._pbf;
    r50.pos = this._geometry;
    for (var e = r50.readVarint() + r50.pos, t = 1, i = 0, n = 0, o = 0, a = [], s3; r50.pos < e; ) {
      if (i <= 0) {
        var l = r50.readVarint();
        t = l & 7, i = l >> 3;
      }
      if (i--, t === 1 || t === 2) n += r50.readSVarint(), o += r50.readSVarint(), t === 1 && (s3 && a.push(s3), s3 = []), s3.push(new $P(n, o));
      else if (t === 7) s3 && s3.push(s3[0].clone());
      else throw new Error("unknown command " + t);
    }
    return s3 && a.push(s3), a;
  };
  Xi.prototype.bbox = function() {
    var r50 = this._pbf;
    r50.pos = this._geometry;
    for (var e = r50.readVarint() + r50.pos, t = 1, i = 0, n = 0, o = 0, a = 1 / 0, s3 = -1 / 0, l = 1 / 0, u = -1 / 0; r50.pos < e; ) {
      if (i <= 0) {
        var c3 = r50.readVarint();
        t = c3 & 7, i = c3 >> 3;
      }
      if (i--, t === 1 || t === 2) n += r50.readSVarint(), o += r50.readSVarint(), n < a && (a = n), n > s3 && (s3 = n), o < l && (l = o), o > u && (u = o);
      else if (t !== 7) throw new Error("unknown command " + t);
    }
    return [a, l, s3, u];
  };
  Xi.prototype.toGeoJSON = function(r50, e, t) {
    var i = this.extent * Math.pow(2, t), n = this.extent * r50, o = this.extent * e, a = this.loadGeometry(), s3 = Xi.types[this.type], l, u;
    function c3(f) {
      for (var d = 0; d < f.length; d++) {
        var y = f[d], g = 180 - (y.y + o) * 360 / i;
        f[d] = [(y.x + n) * 360 / i - 180, 360 / Math.PI * Math.atan(Math.exp(g * Math.PI / 180)) - 90];
      }
    }
    switch (this.type) {
      case 1:
        var p = [];
        for (l = 0; l < a.length; l++) p[l] = a[l][0];
        a = p, c3(a);
        break;
      case 2:
        for (l = 0; l < a.length; l++) c3(a[l]);
        break;
      case 3:
        for (a = KP(a), l = 0; l < a.length; l++) for (u = 0; u < a[l].length; u++) c3(a[l][u]);
        break;
    }
    a.length === 1 ? a = a[0] : s3 = "Multi" + s3;
    var h = { type: "Feature", geometry: { type: s3, coordinates: a }, properties: this.properties };
    return "id" in this && (h.id = this.id), h;
  };
  function KP(r50) {
    var e = r50.length;
    if (e <= 1) return [r50];
    for (var t = [], i, n, o = 0; o < e; o++) {
      var a = JP(r50[o]);
      a !== 0 && (n === void 0 && (n = a < 0), n === a < 0 ? (i && t.push(i), i = [r50[o]]) : i.push(r50[o]));
    }
    return i && t.push(i), t;
  }
  function JP(r50) {
    for (var e = 0, t = 0, i = r50.length, n = i - 1, o, a; t < i; n = t++) o = r50[t], a = r50[n], e += (a.x - o.x) * (o.y + a.y);
    return e;
  }
});
var Lp = q((fD, sy) => {
  "use strict";
  c();
  var YP = kp();
  sy.exports = ay;
  function ay(r50, e) {
    this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = r50, this._keys = [], this._values = [], this._features = [], r50.readFields(QP, this, e), this.length = this._features.length;
  }
  function QP(r50, e, t) {
    r50 === 15 ? e.version = t.readVarint() : r50 === 1 ? e.name = t.readString() : r50 === 5 ? e.extent = t.readVarint() : r50 === 2 ? e._features.push(t.pos) : r50 === 3 ? e._keys.push(t.readString()) : r50 === 4 && e._values.push(eT(t));
  }
  function eT(r50) {
    for (var e = null, t = r50.readVarint() + r50.pos; r50.pos < t; ) {
      var i = r50.readVarint() >> 3;
      e = i === 1 ? r50.readString() : i === 2 ? r50.readFloat() : i === 3 ? r50.readDouble() : i === 4 ? r50.readVarint64() : i === 5 ? r50.readVarint() : i === 6 ? r50.readSVarint() : i === 7 ? r50.readBoolean() : null;
    }
    return e;
  }
  ay.prototype.feature = function(r50) {
    if (r50 < 0 || r50 >= this._features.length) throw new Error("feature index out of bounds");
    this._pbf.pos = this._features[r50];
    var e = this._pbf.readVarint() + this._pbf.pos;
    return new YP(this._pbf, e, this.extent, this._keys, this._values);
  };
});
var uy = q((dD, ly) => {
  "use strict";
  c();
  var tT = Lp();
  ly.exports = rT;
  function rT(r50, e) {
    this.layers = r50.readFields(iT, {}, e);
  }
  function iT(r50, e, t) {
    if (r50 === 3) {
      var i = new tT(t, t.readVarint() + t.pos);
      i.length && (e[i.name] = i);
    }
  }
});
var Co = q((gD, tl) => {
  c();
  tl.exports.VectorTile = uy();
  tl.exports.VectorTileFeature = kp();
  tl.exports.VectorTileLayer = Lp();
});
var ky = q((Bp) => {
  c();
  Bp.read = function(r50, e, t, i, n) {
    var o, a, s3 = n * 8 - i - 1, l = (1 << s3) - 1, u = l >> 1, c3 = -7, p = t ? n - 1 : 0, h = t ? -1 : 1, f = r50[e + p];
    for (p += h, o = f & (1 << -c3) - 1, f >>= -c3, c3 += s3; c3 > 0; o = o * 256 + r50[e + p], p += h, c3 -= 8) ;
    for (a = o & (1 << -c3) - 1, o >>= -c3, c3 += i; c3 > 0; a = a * 256 + r50[e + p], p += h, c3 -= 8) ;
    if (o === 0) o = 1 - u;
    else {
      if (o === l) return a ? NaN : (f ? -1 : 1) * (1 / 0);
      a = a + Math.pow(2, i), o = o - u;
    }
    return (f ? -1 : 1) * a * Math.pow(2, o - i);
  };
  Bp.write = function(r50, e, t, i, n, o) {
    var a, s3, l, u = o * 8 - n - 1, c3 = (1 << u) - 1, p = c3 >> 1, h = n === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f = i ? 0 : o - 1, d = i ? 1 : -1, y = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
    for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (s3 = isNaN(e) ? 1 : 0, a = c3) : (a = Math.floor(Math.log(e) / Math.LN2), e * (l = Math.pow(2, -a)) < 1 && (a--, l *= 2), a + p >= 1 ? e += h / l : e += h * Math.pow(2, 1 - p), e * l >= 2 && (a++, l /= 2), a + p >= c3 ? (s3 = 0, a = c3) : a + p >= 1 ? (s3 = (e * l - 1) * Math.pow(2, n), a = a + p) : (s3 = e * Math.pow(2, p - 1) * Math.pow(2, n), a = 0)); n >= 8; r50[t + f] = s3 & 255, f += d, s3 /= 256, n -= 8) ;
    for (a = a << n | s3, u += n; u > 0; r50[t + f] = a & 255, f += d, a /= 256, u -= 8) ;
    r50[t + f - d] |= y * 128;
  };
});
var Vp = q((mF, Ry) => {
  "use strict";
  c();
  Ry.exports = Pe;
  var al = ky();
  function Pe(r50) {
    this.buf = ArrayBuffer.isView && ArrayBuffer.isView(r50) ? r50 : new Uint8Array(r50 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
  }
  Pe.Varint = 0;
  Pe.Fixed64 = 1;
  Pe.Bytes = 2;
  Pe.Fixed32 = 5;
  var Op = 65536 * 65536, Ly = 1 / Op, wT = 12, Fy = typeof TextDecoder > "u" ? null : new TextDecoder("utf8");
  Pe.prototype = { destroy: function() {
    this.buf = null;
  }, readFields: function(r50, e, t) {
    for (t = t || this.length; this.pos < t; ) {
      var i = this.readVarint(), n = i >> 3, o = this.pos;
      this.type = i & 7, r50(n, e, this), this.pos === o && this.skip(i);
    }
    return e;
  }, readMessage: function(r50, e) {
    return this.readFields(r50, e, this.readVarint() + this.pos);
  }, readFixed32: function() {
    var r50 = sl(this.buf, this.pos);
    return this.pos += 4, r50;
  }, readSFixed32: function() {
    var r50 = zy(this.buf, this.pos);
    return this.pos += 4, r50;
  }, readFixed64: function() {
    var r50 = sl(this.buf, this.pos) + sl(this.buf, this.pos + 4) * Op;
    return this.pos += 8, r50;
  }, readSFixed64: function() {
    var r50 = sl(this.buf, this.pos) + zy(this.buf, this.pos + 4) * Op;
    return this.pos += 8, r50;
  }, readFloat: function() {
    var r50 = al.read(this.buf, this.pos, true, 23, 4);
    return this.pos += 4, r50;
  }, readDouble: function() {
    var r50 = al.read(this.buf, this.pos, true, 52, 8);
    return this.pos += 8, r50;
  }, readVarint: function(r50) {
    var e = this.buf, t, i;
    return i = e[this.pos++], t = i & 127, i < 128 || (i = e[this.pos++], t |= (i & 127) << 7, i < 128) || (i = e[this.pos++], t |= (i & 127) << 14, i < 128) || (i = e[this.pos++], t |= (i & 127) << 21, i < 128) ? t : (i = e[this.pos], t |= (i & 15) << 28, ST(t, r50, this));
  }, readVarint64: function() {
    return this.readVarint(true);
  }, readSVarint: function() {
    var r50 = this.readVarint();
    return r50 % 2 === 1 ? (r50 + 1) / -2 : r50 / 2;
  }, readBoolean: function() {
    return !!this.readVarint();
  }, readString: function() {
    var r50 = this.readVarint() + this.pos, e = this.pos;
    return this.pos = r50, r50 - e >= wT && Fy ? BT(this.buf, e, r50) : RT(this.buf, e, r50);
  }, readBytes: function() {
    var r50 = this.readVarint() + this.pos, e = this.buf.subarray(this.pos, r50);
    return this.pos = r50, e;
  }, readPackedVarint: function(r50, e) {
    if (this.type !== Pe.Bytes) return r50.push(this.readVarint(e));
    var t = ar(this);
    for (r50 = r50 || []; this.pos < t; ) r50.push(this.readVarint(e));
    return r50;
  }, readPackedSVarint: function(r50) {
    if (this.type !== Pe.Bytes) return r50.push(this.readSVarint());
    var e = ar(this);
    for (r50 = r50 || []; this.pos < e; ) r50.push(this.readSVarint());
    return r50;
  }, readPackedBoolean: function(r50) {
    if (this.type !== Pe.Bytes) return r50.push(this.readBoolean());
    var e = ar(this);
    for (r50 = r50 || []; this.pos < e; ) r50.push(this.readBoolean());
    return r50;
  }, readPackedFloat: function(r50) {
    if (this.type !== Pe.Bytes) return r50.push(this.readFloat());
    var e = ar(this);
    for (r50 = r50 || []; this.pos < e; ) r50.push(this.readFloat());
    return r50;
  }, readPackedDouble: function(r50) {
    if (this.type !== Pe.Bytes) return r50.push(this.readDouble());
    var e = ar(this);
    for (r50 = r50 || []; this.pos < e; ) r50.push(this.readDouble());
    return r50;
  }, readPackedFixed32: function(r50) {
    if (this.type !== Pe.Bytes) return r50.push(this.readFixed32());
    var e = ar(this);
    for (r50 = r50 || []; this.pos < e; ) r50.push(this.readFixed32());
    return r50;
  }, readPackedSFixed32: function(r50) {
    if (this.type !== Pe.Bytes) return r50.push(this.readSFixed32());
    var e = ar(this);
    for (r50 = r50 || []; this.pos < e; ) r50.push(this.readSFixed32());
    return r50;
  }, readPackedFixed64: function(r50) {
    if (this.type !== Pe.Bytes) return r50.push(this.readFixed64());
    var e = ar(this);
    for (r50 = r50 || []; this.pos < e; ) r50.push(this.readFixed64());
    return r50;
  }, readPackedSFixed64: function(r50) {
    if (this.type !== Pe.Bytes) return r50.push(this.readSFixed64());
    var e = ar(this);
    for (r50 = r50 || []; this.pos < e; ) r50.push(this.readSFixed64());
    return r50;
  }, skip: function(r50) {
    var e = r50 & 7;
    if (e === Pe.Varint) for (; this.buf[this.pos++] > 127; ) ;
    else if (e === Pe.Bytes) this.pos = this.readVarint() + this.pos;
    else if (e === Pe.Fixed32) this.pos += 4;
    else if (e === Pe.Fixed64) this.pos += 8;
    else throw new Error("Unimplemented type: " + e);
  }, writeTag: function(r50, e) {
    this.writeVarint(r50 << 3 | e);
  }, realloc: function(r50) {
    for (var e = this.length || 16; e < this.pos + r50; ) e *= 2;
    if (e !== this.length) {
      var t = new Uint8Array(e);
      t.set(this.buf), this.buf = t, this.length = e;
    }
  }, finish: function() {
    return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
  }, writeFixed32: function(r50) {
    this.realloc(4), Ji(this.buf, r50, this.pos), this.pos += 4;
  }, writeSFixed32: function(r50) {
    this.realloc(4), Ji(this.buf, r50, this.pos), this.pos += 4;
  }, writeFixed64: function(r50) {
    this.realloc(8), Ji(this.buf, r50 & -1, this.pos), Ji(this.buf, Math.floor(r50 * Ly), this.pos + 4), this.pos += 8;
  }, writeSFixed64: function(r50) {
    this.realloc(8), Ji(this.buf, r50 & -1, this.pos), Ji(this.buf, Math.floor(r50 * Ly), this.pos + 4), this.pos += 8;
  }, writeVarint: function(r50) {
    if (r50 = +r50 || 0, r50 > 268435455 || r50 < 0) {
      PT(r50, this);
      return;
    }
    this.realloc(4), this.buf[this.pos++] = r50 & 127 | (r50 > 127 ? 128 : 0), !(r50 <= 127) && (this.buf[this.pos++] = (r50 >>>= 7) & 127 | (r50 > 127 ? 128 : 0), !(r50 <= 127) && (this.buf[this.pos++] = (r50 >>>= 7) & 127 | (r50 > 127 ? 128 : 0), !(r50 <= 127) && (this.buf[this.pos++] = r50 >>> 7 & 127)));
  }, writeSVarint: function(r50) {
    this.writeVarint(r50 < 0 ? -r50 * 2 - 1 : r50 * 2);
  }, writeBoolean: function(r50) {
    this.writeVarint(!!r50);
  }, writeString: function(r50) {
    r50 = String(r50), this.realloc(r50.length * 4), this.pos++;
    var e = this.pos;
    this.pos = OT(this.buf, r50, this.pos);
    var t = this.pos - e;
    t >= 128 && Dy(e, t, this), this.pos = e - 1, this.writeVarint(t), this.pos += t;
  }, writeFloat: function(r50) {
    this.realloc(4), al.write(this.buf, r50, this.pos, true, 23, 4), this.pos += 4;
  }, writeDouble: function(r50) {
    this.realloc(8), al.write(this.buf, r50, this.pos, true, 52, 8), this.pos += 8;
  }, writeBytes: function(r50) {
    var e = r50.length;
    this.writeVarint(e), this.realloc(e);
    for (var t = 0; t < e; t++) this.buf[this.pos++] = r50[t];
  }, writeRawMessage: function(r50, e) {
    this.pos++;
    var t = this.pos;
    r50(e, this);
    var i = this.pos - t;
    i >= 128 && Dy(t, i, this), this.pos = t - 1, this.writeVarint(i), this.pos += i;
  }, writeMessage: function(r50, e, t) {
    this.writeTag(r50, Pe.Bytes), this.writeRawMessage(e, t);
  }, writePackedVarint: function(r50, e) {
    e.length && this.writeMessage(r50, MT, e);
  }, writePackedSVarint: function(r50, e) {
    e.length && this.writeMessage(r50, IT, e);
  }, writePackedBoolean: function(r50, e) {
    e.length && this.writeMessage(r50, kT, e);
  }, writePackedFloat: function(r50, e) {
    e.length && this.writeMessage(r50, CT, e);
  }, writePackedDouble: function(r50, e) {
    e.length && this.writeMessage(r50, ET, e);
  }, writePackedFixed32: function(r50, e) {
    e.length && this.writeMessage(r50, LT, e);
  }, writePackedSFixed32: function(r50, e) {
    e.length && this.writeMessage(r50, DT, e);
  }, writePackedFixed64: function(r50, e) {
    e.length && this.writeMessage(r50, zT, e);
  }, writePackedSFixed64: function(r50, e) {
    e.length && this.writeMessage(r50, FT, e);
  }, writeBytesField: function(r50, e) {
    this.writeTag(r50, Pe.Bytes), this.writeBytes(e);
  }, writeFixed32Field: function(r50, e) {
    this.writeTag(r50, Pe.Fixed32), this.writeFixed32(e);
  }, writeSFixed32Field: function(r50, e) {
    this.writeTag(r50, Pe.Fixed32), this.writeSFixed32(e);
  }, writeFixed64Field: function(r50, e) {
    this.writeTag(r50, Pe.Fixed64), this.writeFixed64(e);
  }, writeSFixed64Field: function(r50, e) {
    this.writeTag(r50, Pe.Fixed64), this.writeSFixed64(e);
  }, writeVarintField: function(r50, e) {
    this.writeTag(r50, Pe.Varint), this.writeVarint(e);
  }, writeSVarintField: function(r50, e) {
    this.writeTag(r50, Pe.Varint), this.writeSVarint(e);
  }, writeStringField: function(r50, e) {
    this.writeTag(r50, Pe.Bytes), this.writeString(e);
  }, writeFloatField: function(r50, e) {
    this.writeTag(r50, Pe.Fixed32), this.writeFloat(e);
  }, writeDoubleField: function(r50, e) {
    this.writeTag(r50, Pe.Fixed64), this.writeDouble(e);
  }, writeBooleanField: function(r50, e) {
    this.writeVarintField(r50, !!e);
  } };
  function ST(r50, e, t) {
    var i = t.buf, n, o;
    if (o = i[t.pos++], n = (o & 112) >> 4, o < 128 || (o = i[t.pos++], n |= (o & 127) << 3, o < 128) || (o = i[t.pos++], n |= (o & 127) << 10, o < 128) || (o = i[t.pos++], n |= (o & 127) << 17, o < 128) || (o = i[t.pos++], n |= (o & 127) << 24, o < 128) || (o = i[t.pos++], n |= (o & 1) << 31, o < 128)) return Ki(r50, n, e);
    throw new Error("Expected varint not more than 10 bytes");
  }
  function ar(r50) {
    return r50.type === Pe.Bytes ? r50.readVarint() + r50.pos : r50.pos + 1;
  }
  function Ki(r50, e, t) {
    return t ? e * 4294967296 + (r50 >>> 0) : (e >>> 0) * 4294967296 + (r50 >>> 0);
  }
  function PT(r50, e) {
    var t, i;
    if (r50 >= 0 ? (t = r50 % 4294967296 | 0, i = r50 / 4294967296 | 0) : (t = ~(-r50 % 4294967296), i = ~(-r50 / 4294967296), t ^ 4294967295 ? t = t + 1 | 0 : (t = 0, i = i + 1 | 0)), r50 >= 18446744073709552e3 || r50 < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
    e.realloc(10), TT(t, i, e), AT(i, e);
  }
  function TT(r50, e, t) {
    t.buf[t.pos++] = r50 & 127 | 128, r50 >>>= 7, t.buf[t.pos++] = r50 & 127 | 128, r50 >>>= 7, t.buf[t.pos++] = r50 & 127 | 128, r50 >>>= 7, t.buf[t.pos++] = r50 & 127 | 128, r50 >>>= 7, t.buf[t.pos] = r50 & 127;
  }
  function AT(r50, e) {
    var t = (r50 & 7) << 4;
    e.buf[e.pos++] |= t | ((r50 >>>= 3) ? 128 : 0), r50 && (e.buf[e.pos++] = r50 & 127 | ((r50 >>>= 7) ? 128 : 0), r50 && (e.buf[e.pos++] = r50 & 127 | ((r50 >>>= 7) ? 128 : 0), r50 && (e.buf[e.pos++] = r50 & 127 | ((r50 >>>= 7) ? 128 : 0), r50 && (e.buf[e.pos++] = r50 & 127 | ((r50 >>>= 7) ? 128 : 0), r50 && (e.buf[e.pos++] = r50 & 127)))));
  }
  function Dy(r50, e, t) {
    var i = e <= 16383 ? 1 : e <= 2097151 ? 2 : e <= 268435455 ? 3 : Math.floor(Math.log(e) / (Math.LN2 * 7));
    t.realloc(i);
    for (var n = t.pos - 1; n >= r50; n--) t.buf[n + i] = t.buf[n];
  }
  function MT(r50, e) {
    for (var t = 0; t < r50.length; t++) e.writeVarint(r50[t]);
  }
  function IT(r50, e) {
    for (var t = 0; t < r50.length; t++) e.writeSVarint(r50[t]);
  }
  function CT(r50, e) {
    for (var t = 0; t < r50.length; t++) e.writeFloat(r50[t]);
  }
  function ET(r50, e) {
    for (var t = 0; t < r50.length; t++) e.writeDouble(r50[t]);
  }
  function kT(r50, e) {
    for (var t = 0; t < r50.length; t++) e.writeBoolean(r50[t]);
  }
  function LT(r50, e) {
    for (var t = 0; t < r50.length; t++) e.writeFixed32(r50[t]);
  }
  function DT(r50, e) {
    for (var t = 0; t < r50.length; t++) e.writeSFixed32(r50[t]);
  }
  function zT(r50, e) {
    for (var t = 0; t < r50.length; t++) e.writeFixed64(r50[t]);
  }
  function FT(r50, e) {
    for (var t = 0; t < r50.length; t++) e.writeSFixed64(r50[t]);
  }
  function sl(r50, e) {
    return (r50[e] | r50[e + 1] << 8 | r50[e + 2] << 16) + r50[e + 3] * 16777216;
  }
  function Ji(r50, e, t) {
    r50[t] = e, r50[t + 1] = e >>> 8, r50[t + 2] = e >>> 16, r50[t + 3] = e >>> 24;
  }
  function zy(r50, e) {
    return (r50[e] | r50[e + 1] << 8 | r50[e + 2] << 16) + (r50[e + 3] << 24);
  }
  function RT(r50, e, t) {
    for (var i = "", n = e; n < t; ) {
      var o = r50[n], a = null, s3 = o > 239 ? 4 : o > 223 ? 3 : o > 191 ? 2 : 1;
      if (n + s3 > t) break;
      var l, u, c3;
      s3 === 1 ? o < 128 && (a = o) : s3 === 2 ? (l = r50[n + 1], (l & 192) === 128 && (a = (o & 31) << 6 | l & 63, a <= 127 && (a = null))) : s3 === 3 ? (l = r50[n + 1], u = r50[n + 2], (l & 192) === 128 && (u & 192) === 128 && (a = (o & 15) << 12 | (l & 63) << 6 | u & 63, (a <= 2047 || a >= 55296 && a <= 57343) && (a = null))) : s3 === 4 && (l = r50[n + 1], u = r50[n + 2], c3 = r50[n + 3], (l & 192) === 128 && (u & 192) === 128 && (c3 & 192) === 128 && (a = (o & 15) << 18 | (l & 63) << 12 | (u & 63) << 6 | c3 & 63, (a <= 65535 || a >= 1114112) && (a = null))), a === null ? (a = 65533, s3 = 1) : a > 65535 && (a -= 65536, i += String.fromCharCode(a >>> 10 & 1023 | 55296), a = 56320 | a & 1023), i += String.fromCharCode(a), n += s3;
    }
    return i;
  }
  function BT(r50, e, t) {
    return Fy.decode(r50.subarray(e, t));
  }
  function OT(r50, e, t) {
    for (var i = 0, n, o; i < e.length; i++) {
      if (n = e.charCodeAt(i), n > 55295 && n < 57344) if (o) if (n < 56320) {
        r50[t++] = 239, r50[t++] = 191, r50[t++] = 189, o = n;
        continue;
      } else n = o - 55296 << 10 | n - 56320 | 65536, o = null;
      else {
        n > 56319 || i + 1 === e.length ? (r50[t++] = 239, r50[t++] = 191, r50[t++] = 189) : o = n;
        continue;
      }
      else o && (r50[t++] = 239, r50[t++] = 191, r50[t++] = 189, o = null);
      n < 128 ? r50[t++] = n : (n < 2048 ? r50[t++] = n >> 6 | 192 : (n < 65536 ? r50[t++] = n >> 12 | 224 : (r50[t++] = n >> 18 | 240, r50[t++] = n >> 12 & 63 | 128), r50[t++] = n >> 6 & 63 | 128), r50[t++] = n & 63 | 128);
    }
    return t;
  }
});
c();
var Fa = { name: "@packages/outdoor-context-v4", version: "4.1.3", private: true, main: "dist/maplibre-gl.js", style: "dist/maplibre-gl.css", license: "BSD-3-Clause", homepage: "https://maplibre.org/", funding: "https://github.com/maplibre/maplibre-gl-js?sponsor=1", bugs: { url: "https://github.com/maplibre/maplibre-gl-js/issues/" }, repository: { type: "git", url: "git://github.com/maplibre/maplibre-gl-js.git" }, types: "dist/maplibre-gl.d.ts", type: "module", dependencies: { "@mapbox/geojson-rewind": "^0.5.2", "@mapbox/jsonlint-lines-primitives": "^2.0.2", "@mapbox/point-geometry": "^0.1.0", "@mapbox/tiny-sdf": "^2.0.6", "@mapbox/unitbezier": "^0.0.1", "@mapbox/vector-tile": "^1.3.1", "@mapbox/whoots-js": "^3.1.0", "@maplibre/maplibre-gl-style-spec": "^20.1.1", "@types/geojson": "^7946.0.14", "@types/geojson-vt": "3.2.5", "@types/junit-report-builder": "^3.0.2", "@types/mapbox__point-geometry": "^0.1.4", "@types/mapbox__vector-tile": "^1.3.4", "@types/pbf": "^3.0.5", "@types/supercluster": "^7.1.3", earcut: "^2.2.4", "geojson-vt": "^3.2.1", "gl-matrix": "^3.4.3", "global-prefix": "^3.0.0", kdbush: "^4.0.2", "murmurhash-js": "^1.0.0", pbf: "^3.2.1", potpack: "^2.0.0", quickselect: "^2.0.0", supercluster: "^8.0.1", tinyqueue: "^2.0.3", "vt-pbf": "^3.1.3" }, devDependencies: { "@mapbox/mapbox-gl-rtl-text": "^0.2.3", "@mapbox/mvt-fixtures": "^3.10.0", "@rollup/plugin-commonjs": "^25.0.7", "@rollup/plugin-json": "^6.1.0", "@rollup/plugin-node-resolve": "^15.2.3", "@rollup/plugin-replace": "^5.0.5", "@rollup/plugin-strip": "^3.0.4", "@rollup/plugin-terser": "^0.4.4", "@rollup/plugin-typescript": "^11.1.6", "@types/benchmark": "^2.1.5", "@types/cssnano": "^5.0.0", "@types/d3": "^7.4.3", "@types/diff": "^5.2.0", "@types/earcut": "^2.1.4", "@types/eslint": "^8.56.7", "@types/gl": "^6.0.5", "@types/glob": "^8.1.0", "@types/jest": "^29.5.12", "@types/jsdom": "^21.1.6", "@types/minimist": "^1.2.5", "@types/murmurhash-js": "^1.0.6", "@types/nise": "^1.4.4", "@types/node": "^20.12.7", "@types/offscreencanvas": "^2019.7.3", "@types/pixelmatch": "^5.2.6", "@types/pngjs": "^6.0.4", "@types/react": "^18.2.79", "@types/react-dom": "^18.2.25", "@types/request": "^2.48.12", "@types/shuffle-seed": "^1.1.3", "@types/window-or-global": "^1.0.6", "@typescript-eslint/eslint-plugin": "^7.7.1", "@typescript-eslint/parser": "^7.7.1", address: "^2.0.2", benchmark: "^2.1.4", canvas: "^2.11.2", cssnano: "^6.1.2", d3: "^7.9.0", "d3-queue": "^3.0.7", "devtools-protocol": "^0.0.1291694", diff: "^5.2.0", "dts-bundle-generator": "^9.5.1", eslint: "^8.57.0", "eslint-config-mourner": "^3.0.0", "eslint-plugin-html": "^8.1.1", "eslint-plugin-import": "^2.29.1", "eslint-plugin-jest": "^28.2.0", "eslint-plugin-react": "^7.34.1", "eslint-plugin-tsdoc": "0.2.17", expect: "^29.7.0", glob: "^10.3.12", "is-builtin-module": "^3.2.1", jest: "^29.7.0", "jest-environment-jsdom": "^29.7.0", "jest-junit": "^16.0.0", "jest-monocart-coverage": "^1.1.0", "jest-webgl-canvas-mock": "^2.5.3", jsdom: "^24.0.0", "json-stringify-pretty-compact": "^4.0.0", "junit-report-builder": "^3.2.1", minimist: "^1.2.8", "mock-geolocation": "^1.0.11", "monocart-coverage-reports": "^2.7.9", nise: "^5.1.9", "npm-font-open-sans": "^1.1.0", "npm-run-all": "^4.1.5", "pdf-merger-js": "^5.1.1", pixelmatch: "^5.3.0", pngjs: "^7.0.0", postcss: "^8.4.38", "postcss-cli": "^11.0.0", "postcss-inline-svg": "^6.0.0", "pretty-bytes": "^6.1.1", puppeteer: "^22.7.0", react: "^18.2.0", "react-dom": "^18.2.0", rollup: "^4.16.4", "rollup-plugin-sourcemaps": "^0.6.3", rw: "^1.3.3", semver: "^7.6.0", "shuffle-seed": "^1.1.6", "source-map-explorer": "^2.5.3", st: "^3.0.0", stylelint: "^16.4.0", "stylelint-config-standard": "^36.0.0", "ts-jest": "^29.1.2", "ts-node": "^10.9.2", tslib: "^2.6.2", typedoc: "^0.25.13", "typedoc-plugin-markdown": "^3.17.1", "typedoc-plugin-missing-exports": "^2.2.0", typescript: "^5.4.5" }, overrides: { "postcss-inline-svg": { "css-select": "^5.1.0", "dom-serializer": "^2.0.0", htmlparser2: "^8.0.1", "postcss-value-parser": "^4.2.0" } }, scripts: { "generate-dist-package": "node --no-warnings --loader ts-node/esm build/generate-dist-package.js", "generate-shaders": "node --no-warnings --loader ts-node/esm build/generate-shaders.ts", "generate-struct-arrays": "node --no-warnings --loader ts-node/esm build/generate-struct-arrays.ts", "generate-style-code": "node --no-warnings --loader ts-node/esm build/generate-style-code.ts", "generate-typings": "dts-bundle-generator --export-referenced-types --umd-module-name=maplibregl -o ./dist/maplibre-gl.d.ts ./src/index.ts", "generate-docs": "typedoc && node --no-warnings --loader ts-node/esm build/generate-docs.ts", "generate-images": "node --no-warnings --loader ts-node/esm build/generate-doc-images.ts", "build-dist": "npm run build-css && npm run generate-typings && npm run build-dev && npm run build-csp-dev && npm run build-prod && npm run build-csp", "build-dev": "rollup --configPlugin @rollup/plugin-typescript -c --environment BUILD:dev", "watch-dev": "rollup --configPlugin @rollup/plugin-typescript -c --environment BUILD:dev --watch", "build-prod": "rollup --configPlugin @rollup/plugin-typescript -c --environment BUILD:production", "build-csp": "rollup --configPlugin @rollup/plugin-typescript -c rollup.config.csp.ts", "build-csp-dev": "rollup --configPlugin @rollup/plugin-typescript -c rollup.config.csp.ts --environment BUILD:dev", "build-css": "postcss -o dist/maplibre-gl.css src/css/maplibre-gl.css", "watch-css": "postcss --watch -o dist/maplibre-gl.css src/css/maplibre-gl.css", "build-benchmarks": "npm run build-dev && rollup --configPlugin @rollup/plugin-typescript -c test/bench/rollup_config_benchmarks.ts", "watch-benchmarks": "rollup --configPlugin @rollup/plugin-typescript -c test/bench/rollup_config_benchmarks.ts --watch", "start-server": "st --no-cache -H 0.0.0.0 --port 9966 .", "start-docs": "docker run --rm -it -p 8000:8000 -v ${PWD}:/docs squidfunk/mkdocs-material", start: "run-p watch-css watch-dev start-server", "start-bench": "run-p watch-css watch-benchmarks start-server", lint: "eslint --cache --ext .ts,.tsx,.js,.html --ignore-path .gitignore .", "lint-css": "stylelint src/css/maplibre-gl.css", test: "run-p lint lint-css test-render jest", jest: "jest", "test-build": "jest --selectProjects=build --reporters=default", "test-build-ci": "jest --selectProjects=build", "test-integration": "jest --selectProjects=integration --reporters=default", "test-integration-ci": "jest --selectProjects=integration", "test-render": "node --no-warnings --loader ts-node/esm test/integration/render/run_render_tests.ts", "test-unit": "jest --selectProjects=unit --reporters=default", "test-unit-ci": "jest --coverage --selectProjects unit", "test-watch-roots": "jest --watch", codegen: "run-p --print-label generate-dist-package generate-style-code generate-struct-arrays generate-shaders && npm run generate-typings", benchmark: "node --no-warnings --loader ts-node/esm test/bench/run-benchmarks.ts", "gl-stats": "node --no-warnings --loader ts-node/esm test/bench/gl-stats.ts", prepare: "npm run codegen", typecheck: "tsc --noEmit && tsc --project tsconfig.dist.json", tsnode: "node --experimental-loader=ts-node/esm --no-warnings" }, files: ["build/", "dist/*", "src/"], engines: { npm: ">=8.1.0", node: ">=16.14.0" } };
c();
c();
var ef = s(ye(), 1);
var tf = s(Jh(), 1);
c();
c();
var wc;
function Ra() {
  return wc == null && (wc = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), wc;
}
var Ba;
function Sc() {
  if (Ba == null && (Ba = false, Ra())) {
    let t = new OffscreenCanvas(5, 5).getContext("2d", { willReadFrequently: true });
    if (t) {
      for (let n = 0; n < 5 * 5; n++) {
        let o = n * 4;
        t.fillStyle = "rgb(".concat(o, ",").concat(o + 1, ",").concat(o + 2, ")"), t.fillRect(n % 5, Math.floor(n / 5), 1, 1);
      }
      let i = t.getImageData(0, 0, 5, 5).data;
      for (let n = 0; n < 5 * 5 * 4; n++) if (n % 4 !== 3 && i[n] !== n) {
        Ba = true;
        break;
      }
    }
  }
  return Ba || false;
}
function rf(r50) {
  if (r50 <= 0) return 0;
  if (r50 >= 1) return 1;
  let e = r50 * r50, t = e * r50;
  return 4 * (r50 < 0.5 ? t : 3 * (r50 - e) + t - 0.75);
}
function gn(r50, e, t, i) {
  let n = new tf.default(r50, e, t, i);
  return function(o) {
    return n.solve(o);
  };
}
var xn = gn(0.25, 0.1, 0.25, 1);
function Ae(r50, e, t) {
  return Math.min(t, Math.max(e, r50));
}
function Jt(r50, e, t) {
  let i = t - e, n = ((r50 - e) % i + i) % i + e;
  return n === e ? t : n;
}
function nf(r50, e) {
  let t = [];
  for (let i in r50) i in e || t.push(i);
  return t;
}
function O(r50, ...e) {
  for (let t of e) for (let i in t) r50[i] = t[i];
  return r50;
}
function fr(r50, e) {
  let t = {};
  for (let i = 0; i < e.length; i++) {
    let n = e[i];
    n in r50 && (t[n] = r50[n]);
  }
  return t;
}
var C_ = 1;
function Oa() {
  return C_++;
}
function of(r50) {
  return Math.log(r50) / Math.LN2 % 1 === 0;
}
function af(r50) {
  return r50 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(r50) / Math.LN2));
}
function bn(r50, e, t) {
  let i = {};
  for (let n in r50) i[n] = e.call(t || this, r50[n], n, r50);
  return i;
}
function Va(r50, e, t) {
  let i = {};
  for (let n in r50) e.call(t || this, r50[n], n, r50) && (i[n] = r50[n]);
  return i;
}
function Kt(r50, e) {
  if (Array.isArray(r50)) {
    if (!Array.isArray(e) || r50.length !== e.length) return false;
    for (let t = 0; t < r50.length; t++) if (!Kt(r50[t], e[t])) return false;
    return true;
  }
  if (typeof r50 == "object" && r50 !== null && e !== null) {
    if (typeof e != "object" || Object.keys(r50).length !== Object.keys(e).length) return false;
    for (let i in r50) if (!Kt(r50[i], e[i])) return false;
    return true;
  }
  return r50 === e;
}
function ct(r50) {
  return Array.isArray(r50) ? r50.map(ct) : typeof r50 == "object" && r50 ? bn(r50, ct) : r50;
}
function sf(r50, e) {
  for (let t = 0; t < r50.length; t++) if (e.indexOf(r50[t]) >= 0) return true;
  return false;
}
var Yh = {};
function Ee(r50) {
  Yh[r50] || (typeof console < "u" && console.warn(r50), Yh[r50] = true);
}
function Yt(r50, e, t) {
  return (t.y - r50.y) * (e.x - r50.x) > (e.y - r50.y) * (t.x - r50.x);
}
function lf(r50, e, t, i) {
  let n = e.y - r50.y, o = e.x - r50.x, a = i.y - t.y, s3 = i.x - t.x, l = a * o - s3 * n;
  if (l === 0) return null;
  let u = r50.y - t.y, c3 = r50.x - t.x, p = (s3 * u - a * c3) / l;
  return new ef.default(r50.x + p * o, r50.y + p * n);
}
function uf(r50) {
  let e = 0;
  for (let t = 0, i = r50.length, n = i - 1, o, a; t < i; n = t++) o = r50[t], a = r50[n], e += (a.x - o.x) * (o.y + a.y);
  return e;
}
function cf([r50, e, t]) {
  return e += 90, e *= Math.PI / 180, t *= Math.PI / 180, { x: r50 * Math.cos(e) * Math.sin(t), y: r50 * Math.sin(e) * Math.sin(t), z: r50 * Math.cos(t) };
}
function Qt(r50) {
  return typeof WorkerGlobalScope < "u" && typeof r50 < "u" && r50 instanceof WorkerGlobalScope;
}
function pf(r50) {
  let e = /(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, t = {};
  if (r50.replace(e, (i, n, o, a) => {
    let s3 = o || a;
    return t[n] = s3 ? s3.toLowerCase() : true, "";
  }), t["max-age"]) {
    let i = parseInt(t["max-age"], 10);
    isNaN(i) ? delete t["max-age"] : t["max-age"] = i;
  }
  return t;
}
var Pc = null;
function hf(r50) {
  if (Pc == null) {
    let e = r50.navigator ? r50.navigator.userAgent : null;
    Pc = !!r50.safari || !!(e && (/\b(iPad|iPhone|iPod)\b/.test(e) || e.match("Safari") && !e.match("Chrome")));
  }
  return Pc;
}
function pt(r50) {
  return typeof ImageBitmap < "u" && r50 instanceof ImageBitmap;
}
var ff = async (r50) => {
  if (r50.byteLength === 0) return createImageBitmap(new ImageData(1, 1));
  let e = new Blob([new Uint8Array(r50)], { type: "image/png" });
  try {
    return createImageBitmap(e);
  } catch (t) {
    throw new Error("Could not load image because of ".concat(t.message, ". Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
  }
};
var Qh = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
var mf = (r50) => new Promise((e, t) => {
  let i = new Image();
  i.onload = () => {
    e(i), URL.revokeObjectURL(i.src), i.onload = null, window.requestAnimationFrame(() => {
      i.src = Qh;
    });
  }, i.onerror = () => t(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
  let n = new Blob([new Uint8Array(r50)], { type: "image/png" });
  i.src = r50.byteLength ? URL.createObjectURL(n) : Qh;
});
function E_(r50, e, t, i, n) {
  let o = Math.max(-e, 0) * 4, l = (Math.max(0, t) - t) * i * 4 + o, u = i * 4, c3 = Math.max(0, e), p = Math.max(0, t), h = Math.min(r50.width, e + i), f = Math.min(r50.height, t + n);
  return { rect: { x: c3, y: p, width: h - c3, height: f - p }, layout: [{ offset: l, stride: u }] };
}
async function df(r50, e, t, i, n) {
  if (typeof VideoFrame > "u") throw new Error("VideoFrame not supported");
  let o = new VideoFrame(r50, { timestamp: 0 });
  try {
    let a = o == null ? void 0 : o.format;
    if (!a || !(a.startsWith("BGR") || a.startsWith("RGB"))) throw new Error("Unrecognized format ".concat(a));
    let s3 = a.startsWith("BGR"), l = new Uint8ClampedArray(i * n * 4);
    if (await o.copyTo(l, E_(r50, e, t, i, n)), s3) for (let u = 0; u < l.length; u += 4) {
      let c3 = l[u];
      l[u] = l[u + 2], l[u + 2] = c3;
    }
    return l;
  } finally {
    o.close();
  }
}
function yf(r50, e, t, i) {
  return r50.addEventListener(e, t, i), { unsubscribe: () => {
    r50.removeEventListener(e, t, i);
  } };
}
function Tc(r50) {
  return r50 * Math.PI / 180;
}
c();
c();
var k_ = "AbortError";
function Nr() {
  return new Error(k_);
}
var L_ = typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date);
var Ua;
var Ac;
var J = { now: L_, frameAsync(r50) {
  return new Promise((e, t) => {
    let i = requestAnimationFrame(e);
    r50.signal.addEventListener("abort", () => {
      cancelAnimationFrame(i), t(Nr());
    });
  });
}, getImageData(r50, e = 0) {
  return this.getImageCanvasContext(r50).getImageData(-e, -e, r50.width + 2 * e, r50.height + 2 * e);
}, getImageCanvasContext(r50) {
  let e = window.document.createElement("canvas"), t = e.getContext("2d", { willReadFrequently: true });
  if (!t) throw new Error("failed to create canvas 2d context");
  return e.width = r50.width, e.height = r50.height, t.drawImage(r50, 0, 0, r50.width, r50.height), t;
}, resolveURL(r50) {
  return Ua || (Ua = document.createElement("a")), Ua.href = r50, Ua.href;
}, hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
  return matchMedia ? (Ac == null && (Ac = matchMedia("(prefers-reduced-motion: reduce)")), Ac.matches) : false;
} };
c();
var gf = s(ye(), 1);
var Me = class Me2 {
  static testProp(e) {
    if (!Me2.docStyle) return e[0];
    for (let t = 0; t < e.length; t++) if (e[t] in Me2.docStyle) return e[t];
    return e[0];
  }
  static create(e, t, i) {
    let n = window.document.createElement(e);
    return t !== void 0 && (n.className = t), i && i.appendChild(n), n;
  }
  static createNS(e, t) {
    return window.document.createElementNS(e, t);
  }
  static disableDrag() {
    Me2.docStyle && Me2.selectProp && (Me2.userSelect = Me2.docStyle[Me2.selectProp], Me2.docStyle[Me2.selectProp] = "none");
  }
  static enableDrag() {
    Me2.docStyle && Me2.selectProp && (Me2.docStyle[Me2.selectProp] = Me2.userSelect);
  }
  static setTransform(e, t) {
    e.style[Me2.transformProp] = t;
  }
  static addEventListener(e, t, i, n = {}) {
    "passive" in n ? e.addEventListener(t, i, n) : e.addEventListener(t, i, n.capture);
  }
  static removeEventListener(e, t, i, n = {}) {
    "passive" in n ? e.removeEventListener(t, i, n) : e.removeEventListener(t, i, n.capture);
  }
  static suppressClickInternal(e) {
    e.preventDefault(), e.stopPropagation(), window.removeEventListener("click", Me2.suppressClickInternal, true);
  }
  static suppressClick() {
    window.addEventListener("click", Me2.suppressClickInternal, true), window.setTimeout(() => {
      window.removeEventListener("click", Me2.suppressClickInternal, true);
    }, 0);
  }
  static getScale(e) {
    let t = e.getBoundingClientRect();
    return { x: t.width / e.offsetWidth || 1, y: t.height / e.offsetHeight || 1, boundingClientRect: t };
  }
  static getPoint(e, t, i) {
    let n = t.boundingClientRect;
    return new gf.default((i.clientX - n.left) / t.x - e.clientLeft, (i.clientY - n.top) / t.y - e.clientTop);
  }
  static mousePos(e, t) {
    let i = Me2.getScale(e);
    return Me2.getPoint(e, i, t);
  }
  static touchPos(e, t) {
    let i = [], n = Me2.getScale(e);
    for (let o = 0; o < t.length; o++) i.push(Me2.getPoint(e, n, t[o]));
    return i;
  }
  static mouseButton(e) {
    return e.button;
  }
  static remove(e) {
    e.parentNode && e.parentNode.removeChild(e);
  }
};
Me.docStyle = typeof window < "u" && window.document && window.document.documentElement.style, Me.selectProp = Me.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), Me.transformProp = Me.testProp(["transform", "WebkitTransform"]);
var L = Me;
c();
c();
c();
var nt = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: "" };
function Na(r50) {
  return nt.REGISTERED_PROTOCOLS[r50.substring(0, r50.indexOf("://"))];
}
function D_(r50, e) {
  nt.REGISTERED_PROTOCOLS[r50] = e;
}
function z_(r50) {
  delete nt.REGISTERED_PROTOCOLS[r50];
}
c();
var Ga = "global-dispatcher";
var Gr = class extends Error {
  constructor(e, t, i, n) {
    super("AJAXError: ".concat(t, " (").concat(e, "): ").concat(i)), this.status = e, this.statusText = t, this.url = i, this.body = n;
  }
};
var qa = () => Qt(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href;
var F_ = (r50) => /^file:/.test(r50) || /^file:/.test(qa()) && !/^\w+:/.test(r50);
async function R_(r50, e) {
  let t = new Request(r50.url, { method: r50.method || "GET", body: r50.body, credentials: r50.credentials, headers: r50.headers, cache: r50.cache, referrer: qa(), signal: e.signal });
  r50.type === "json" && t.headers.set("Accept", "application/json");
  let i = await fetch(t);
  if (!i.ok) {
    let a = await i.blob();
    throw new Gr(i.status, i.statusText, r50.url, a);
  }
  let n;
  r50.type === "arrayBuffer" || r50.type === "image" ? n = i.arrayBuffer() : r50.type === "json" ? n = i.json() : n = i.text();
  let o = await n;
  if (e.signal.aborted) throw Nr();
  return { data: o, cacheControl: i.headers.get("Cache-Control"), expires: i.headers.get("Expires") };
}
function B_(r50, e) {
  return new Promise((t, i) => {
    let n = new XMLHttpRequest();
    n.open(r50.method || "GET", r50.url, true), (r50.type === "arrayBuffer" || r50.type === "image") && (n.responseType = "arraybuffer");
    for (let o in r50.headers) n.setRequestHeader(o, r50.headers[o]);
    r50.type === "json" && (n.responseType = "text", n.setRequestHeader("Accept", "application/json")), n.withCredentials = r50.credentials === "include", n.onerror = () => {
      i(new Error(n.statusText));
    }, n.onload = () => {
      if (!e.signal.aborted) if ((n.status >= 200 && n.status < 300 || n.status === 0) && n.response !== null) {
        let o = n.response;
        if (r50.type === "json") try {
          o = JSON.parse(n.response);
        } catch (a) {
          i(a);
          return;
        }
        t({ data: o, cacheControl: n.getResponseHeader("Cache-Control"), expires: n.getResponseHeader("Expires") });
      } else {
        let o = new Blob([n.response], { type: n.getResponseHeader("Content-Type") });
        i(new Gr(n.status, n.statusText, r50.url, o));
      }
    }, e.signal.addEventListener("abort", () => {
      n.abort(), i(Nr());
    }), n.send(r50.body);
  });
}
var _i = function(r50, e) {
  if (/:\/\//.test(r50.url) && !/^https?:|^file:/.test(r50.url)) {
    let t = Na(r50.url);
    if (t) return t(r50, e);
    if (Qt(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: r50, targetMapId: Ga }, e);
  }
  if (!F_(r50.url)) {
    if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return R_(r50, e);
    if (Qt(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: r50, mustQueue: true, targetMapId: Ga }, e);
  }
  return B_(r50, e);
};
var mr = (r50, e) => _i(O(r50, { type: "json" }), e);
var xf = (r50, e) => _i(O(r50, { type: "arrayBuffer" }), e);
function Mc(r50) {
  if (!r50 || r50.indexOf("://") <= 0 || r50.indexOf("data:image/") === 0 || r50.indexOf("blob:") === 0) return true;
  let e = new URL(r50), t = window.location;
  return e.protocol === t.protocol && e.host === t.host;
}
var bf = (r50) => {
  let e = window.document.createElement("video");
  return e.muted = true, new Promise((t) => {
    e.onloadstart = () => {
      t(e);
    };
    for (let i of r50) {
      let n = window.document.createElement("source");
      Mc(i) || (e.crossOrigin = "Anonymous"), n.src = i, e.appendChild(n);
    }
  });
};
c();
c();
var vn = { supported: false, testSupport: O_ };
var _n;
var Ic = false;
var vi;
var _f = false;
typeof document < "u" && (vi = document.createElement("img"), vi.onload = function() {
  _n && vf(_n), _n = null, _f = true;
}, vi.onerror = function() {
  Ic = true, _n = null;
}, vi.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
function O_(r50) {
  Ic || !vi || (_f ? vf(r50) : _n = r50);
}
function vf(r50) {
  let e = r50.createTexture();
  r50.bindTexture(r50.TEXTURE_2D, e);
  try {
    if (r50.texImage2D(r50.TEXTURE_2D, 0, r50.RGBA, r50.RGBA, r50.UNSIGNED_BYTE, vi), r50.isContextLost()) return;
    vn.supported = true;
  } catch {
  }
  r50.deleteTexture(e), Ic = true;
}
var at;
((f) => {
  let r50, e, t, i;
  f.resetRequestQueue = () => {
    r50 = [], e = 0, t = 0, i = {};
  }, f.addThrottleControl = (d) => {
    let y = t++;
    return i[y] = d, y;
  }, f.removeThrottleControl = (d) => {
    delete i[d], p();
  };
  let s3 = () => {
    for (let d of Object.keys(i)) if (i[d]()) return true;
    return false;
  };
  f.getImage = (d, y, g = true) => new Promise((x, v) => {
    vn.supported && (d.headers || (d.headers = {}), d.headers.accept = "image/webp,*/*"), O(d, { type: "image" });
    let b = { abortController: y, requestParameters: d, supportImageRefresh: g, state: "queued", onError: (w) => {
      v(w);
    }, onSuccess: (w) => {
      x(w);
    } };
    r50.push(b), p();
  });
  let u = (d) => typeof createImageBitmap == "function" ? ff(d) : mf(d), c3 = async (d) => {
    d.state = "running";
    let { requestParameters: y, supportImageRefresh: g, onError: x, onSuccess: v, abortController: b } = d, w = g === false && !Qt(self) && !Na(y.url) && (!y.headers || Object.keys(y.headers).reduce((P, k) => P && k === "accept", true));
    e++;
    let S = w ? h(y, b) : _i(y, b);
    try {
      let P = await S;
      if (delete d.abortController, d.state = "completed", P.data instanceof HTMLImageElement || pt(P.data)) v(P);
      else if (P.data) {
        let k = await u(P.data);
        v({ data: k, cacheControl: P.cacheControl, expires: P.expires });
      }
    } catch (P) {
      delete d.abortController, x(P);
    } finally {
      e--, p();
    }
  }, p = () => {
    let d = s3() ? nt.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : nt.MAX_PARALLEL_IMAGE_REQUESTS;
    for (let y = e; y < d && r50.length > 0; y++) {
      let g = r50.shift();
      if (g.abortController.signal.aborted) {
        y--;
        continue;
      }
      c3(g);
    }
  }, h = (d, y) => new Promise((g, x) => {
    let v = new Image(), b = d.url, w = d.credentials;
    w && w === "include" ? v.crossOrigin = "use-credentials" : (w && w === "same-origin" || !Mc(b)) && (v.crossOrigin = "anonymous"), y.signal.addEventListener("abort", () => {
      v.src = "", x(Nr());
    }), v.fetchPriority = "high", v.onload = () => {
      v.onerror = v.onload = null, g({ data: v });
    }, v.onerror = () => {
      v.onerror = v.onload = null, !y.signal.aborted && x(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
    }, v.src = b;
  });
})(at || (at = {}));
at.resetRequestQueue();
c();
var ja = class {
  constructor(e) {
    this._transformRequestFn = e;
  }
  transformRequest(e, t) {
    return this._transformRequestFn ? this._transformRequestFn(e, t) || { url: e } : { url: e };
  }
  normalizeSpriteURL(e, t, i) {
    let n = U_(e);
    return n.path += "".concat(t).concat(i), N_(n);
  }
  setTransformRequest(e) {
    this._transformRequestFn = e;
  }
};
var V_ = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
function U_(r50) {
  let e = r50.match(V_);
  if (!e) throw new Error('Unable to parse URL "'.concat(r50, '"'));
  return { protocol: e[1], authority: e[2], path: e[3] || "/", params: e[4] ? e[4].split("&") : [] };
}
function N_(r50) {
  let e = r50.params.length ? "?".concat(r50.params.join("&")) : "";
  return "".concat(r50.protocol, "://").concat(r50.authority).concat(r50.path).concat(e);
}
c();
c();
function wf(r50, e, t) {
  t[r50] && t[r50].indexOf(e) !== -1 || (t[r50] = t[r50] || [], t[r50].push(e));
}
function Cc(r50, e, t) {
  if (t && t[r50]) {
    let i = t[r50].indexOf(e);
    i !== -1 && t[r50].splice(i, 1);
  }
}
var z = class {
  constructor(e, t = {}) {
    O(this, t), this.type = e;
  }
};
var Z = class extends z {
  constructor(e, t = {}) {
    super("error", O({ error: e }, t));
  }
};
var me = class {
  on(e, t) {
    return this._listeners = this._listeners || {}, wf(e, t, this._listeners), this;
  }
  off(e, t) {
    return Cc(e, t, this._listeners), Cc(e, t, this._oneTimeListeners), this;
  }
  once(e, t) {
    return t ? (this._oneTimeListeners = this._oneTimeListeners || {}, wf(e, t, this._oneTimeListeners), this) : new Promise((i) => this.once(e, i));
  }
  fire(e, t) {
    typeof e == "string" && (e = new z(e, t || {}));
    let i = e.type;
    if (this.listens(i)) {
      e.target = this;
      let n = this._listeners && this._listeners[i] ? this._listeners[i].slice() : [];
      for (let s3 of n) s3.call(this, e);
      let o = this._oneTimeListeners && this._oneTimeListeners[i] ? this._oneTimeListeners[i].slice() : [];
      for (let s3 of o) Cc(i, s3, this._oneTimeListeners), s3.call(this, e);
      let a = this._eventedParent;
      a && (O(e, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), a.fire(e));
    } else e instanceof Z && console.error(e.error);
    return this;
  }
  listens(e) {
    return this._listeners && this._listeners[e] && this._listeners[e].length > 0 || this._oneTimeListeners && this._oneTimeListeners[e] && this._oneTimeListeners[e].length > 0 || this._eventedParent && this._eventedParent.listens(e);
  }
  setEventedParent(e, t) {
    return this._eventedParent = e, this._eventedParentData = t, this;
  }
};
c();
c();
c();
c();
var G_ = 8;
var q_ = { version: { required: true, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, light: { type: "light" }, sky: { type: "sky" }, projection: { type: "projection" }, terrain: { type: "terrain" }, sources: { required: true, type: "sources" }, sprite: { type: "sprite" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: true, type: "array", value: "layer" } };
var j_ = { "*": { type: "source" } };
var Z_ = ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"];
var H_ = { type: { required: true, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } };
var $_ = { type: { required: true, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } };
var W_ = { type: { required: true, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {}, custom: {} }, default: "mapbox" }, redFactor: { type: "number", default: 1 }, blueFactor: { type: "number", default: 1 }, greenFactor: { type: "number", default: 1 }, baseShift: { type: "number", default: 0 }, volatile: { type: "boolean", default: false }, "*": { type: "*" } };
var X_ = { type: { required: true, type: "enum", values: { geojson: {} } }, data: { required: true, type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: false }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: false }, generateId: { type: "boolean", default: false }, promoteId: { type: "promoteId" } };
var K_ = { type: { required: true, type: "enum", values: { video: {} } }, urls: { required: true, type: "array", value: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } };
var J_ = { type: { required: true, type: "enum", values: { image: {} } }, url: { required: true, type: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } };
var Y_ = { id: { type: "string", required: true }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {} }, required: true }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } };
var Q_ = ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"];
var ev = { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } };
var tv = { "fill-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } };
var rv = { "circle-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } };
var iv = { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } };
var nv = { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } };
var ov = { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: false, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: false, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: false, requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: false, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: true, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-variable-anchor-offset": { type: "variableAnchorOffsetCollection", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: true, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: false, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: false, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: false, requires: ["text-field", "icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } };
var av = { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } };
var sv = { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } };
var lv = { type: "array", value: "*" };
var uv = { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {} } };
var cv = { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } };
var pv = { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 };
var hv = { type: "array", value: "*", minimum: 1 };
var fv = { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: false, expression: { interpolated: false, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: true, expression: { interpolated: true, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } };
var mv = { "sky-color": { type: "color", "property-type": "data-constant", default: "#88C6FC", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "horizon-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "fog-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "fog-ground-blend": { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "horizon-fog-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "sky-horizon-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "atmosphere-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } };
var dv = { source: { type: "string", required: true }, exaggeration: { type: "number", minimum: 0, default: 1 } };
var yv = { type: { type: "enum", default: "mercator", values: { mercator: {}, globe: {} } } };
var gv = ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"];
var xv = { "fill-antialias": { type: "boolean", default: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: true, requires: [{ "!": "fill-pattern" }, { "fill-antialias": true }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } };
var bv = { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "line-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: true, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: false, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: true } }], expression: { interpolated: true, parameters: ["line-progress"] }, "property-type": "color-ramp" } };
var _v = { "circle-radius": { type: "number", default: 5, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } };
var vv = { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: false, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: false, expression: { interpolated: true, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } };
var wv = { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: true, overridable: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } };
var Sv = { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: true, units: "degrees", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: false, units: "milliseconds", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } };
var Pv = { "hillshade-illumination-direction": { type: "number", default: 335, minimum: 0, maximum: 359, transition: false, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "color", default: "#FFFFFF", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } };
var Tv = { "background-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "background-pattern" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } };
var Av = { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } };
var Mv = { "*": { type: "string" } };
var A = { $version: G_, $root: q_, sources: j_, source: Z_, source_vector: H_, source_raster: $_, source_raster_dem: W_, source_geojson: X_, source_video: K_, source_image: J_, layer: Y_, layout: Q_, layout_background: ev, layout_fill: tv, layout_circle: rv, layout_heatmap: iv, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: nv, layout_symbol: ov, layout_raster: av, layout_hillshade: sv, filter: lv, filter_operator: uv, geometry_type: cv, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: false } }, function_stop: pv, expression: hv, light: fv, sky: mv, terrain: dv, projection: yv, paint: gv, paint_fill: xv, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, requires: ["fill-extrusion-height"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: true, transition: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: bv, paint_circle: _v, paint_heatmap: vv, paint_symbol: wv, paint_raster: Sv, paint_hillshade: Pv, paint_background: Tv, transition: Av, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: Mv };
var Iv = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
function Cv(r50, e) {
  let t = {};
  for (let i in r50) i !== "ref" && (t[i] = r50[i]);
  return Iv.forEach((i) => {
    i in e && (t[i] = e[i]);
  }), t;
}
function ep(r50) {
  r50 = r50.slice();
  let e = /* @__PURE__ */ Object.create(null);
  for (let t = 0; t < r50.length; t++) e[r50[t].id] = r50[t];
  for (let t = 0; t < r50.length; t++) "ref" in r50[t] && (r50[t] = Cv(r50[t], e[r50[t].ref]));
  return r50;
}
function ke(r50, e) {
  if (Array.isArray(r50)) {
    if (!Array.isArray(e) || r50.length !== e.length) return false;
    for (let t = 0; t < r50.length; t++) if (!ke(r50[t], e[t])) return false;
    return true;
  }
  if (typeof r50 == "object" && r50 !== null && e !== null) {
    if (typeof e != "object" || Object.keys(r50).length !== Object.keys(e).length) return false;
    for (let i in r50) if (!ke(r50[i], e[i])) return false;
    return true;
  }
  return r50 === e;
}
function Pt(r50, e) {
  r50.push(e);
}
function Zf(r50, e, t) {
  Pt(t, { command: "addSource", args: [r50, e[r50]] });
}
function Hf(r50, e, t) {
  Pt(e, { command: "removeSource", args: [r50] }), t[r50] = true;
}
function Ev(r50, e, t, i) {
  Hf(r50, t, i), Zf(r50, e, t);
}
function kv(r50, e, t) {
  let i;
  for (i in r50[t]) if (Object.prototype.hasOwnProperty.call(r50[t], i) && i !== "data" && !ke(r50[t][i], e[t][i])) return false;
  for (i in e[t]) if (Object.prototype.hasOwnProperty.call(e[t], i) && i !== "data" && !ke(r50[t][i], e[t][i])) return false;
  return true;
}
function Lv(r50, e, t, i) {
  r50 = r50 || {}, e = e || {};
  let n;
  for (n in r50) Object.prototype.hasOwnProperty.call(r50, n) && (Object.prototype.hasOwnProperty.call(e, n) || Hf(n, t, i));
  for (n in e) Object.prototype.hasOwnProperty.call(e, n) && (Object.prototype.hasOwnProperty.call(r50, n) ? ke(r50[n], e[n]) || (r50[n].type === "geojson" && e[n].type === "geojson" && kv(r50, e, n) ? Pt(t, { command: "setGeoJSONSourceData", args: [n, e[n].data] }) : Ev(n, e, t, i)) : Zf(n, e, t));
}
function Za(r50, e, t, i, n, o) {
  r50 = r50 || {}, e = e || {};
  for (let a in r50) Object.prototype.hasOwnProperty.call(r50, a) && (ke(r50[a], e[a]) || t.push({ command: o, args: [i, a, e[a], n] }));
  for (let a in e) !Object.prototype.hasOwnProperty.call(e, a) || Object.prototype.hasOwnProperty.call(r50, a) || ke(r50[a], e[a]) || t.push({ command: o, args: [i, a, e[a], n] });
}
function Sf(r50) {
  return r50.id;
}
function Pf(r50, e) {
  return r50[e.id] = e, r50;
}
function Dv(r50, e, t) {
  r50 = r50 || [], e = e || [];
  let i = r50.map(Sf), n = e.map(Sf), o = r50.reduce(Pf, {}), a = e.reduce(Pf, {}), s3 = i.slice(), l = /* @__PURE__ */ Object.create(null), u, c3, p, h, f;
  for (let d = 0, y = 0; d < i.length; d++) u = i[d], Object.prototype.hasOwnProperty.call(a, u) ? y++ : (Pt(t, { command: "removeLayer", args: [u] }), s3.splice(s3.indexOf(u, y), 1));
  for (let d = 0, y = 0; d < n.length; d++) u = n[n.length - 1 - d], s3[s3.length - 1 - d] !== u && (Object.prototype.hasOwnProperty.call(o, u) ? (Pt(t, { command: "removeLayer", args: [u] }), s3.splice(s3.lastIndexOf(u, s3.length - y), 1)) : y++, h = s3[s3.length - d], Pt(t, { command: "addLayer", args: [a[u], h] }), s3.splice(s3.length - d, 0, u), l[u] = true);
  for (let d = 0; d < n.length; d++) if (u = n[d], c3 = o[u], p = a[u], !(l[u] || ke(c3, p))) {
    if (!ke(c3.source, p.source) || !ke(c3["source-layer"], p["source-layer"]) || !ke(c3.type, p.type)) {
      Pt(t, { command: "removeLayer", args: [u] }), h = s3[s3.lastIndexOf(u) + 1], Pt(t, { command: "addLayer", args: [p, h] });
      continue;
    }
    Za(c3.layout, p.layout, t, u, null, "setLayoutProperty"), Za(c3.paint, p.paint, t, u, null, "setPaintProperty"), ke(c3.filter, p.filter) || Pt(t, { command: "setFilter", args: [u, p.filter] }), (!ke(c3.minzoom, p.minzoom) || !ke(c3.maxzoom, p.maxzoom)) && Pt(t, { command: "setLayerZoomRange", args: [u, p.minzoom, p.maxzoom] });
    for (f in c3) Object.prototype.hasOwnProperty.call(c3, f) && (f === "layout" || f === "paint" || f === "filter" || f === "metadata" || f === "minzoom" || f === "maxzoom" || (f.indexOf("paint.") === 0 ? Za(c3[f], p[f], t, u, f.slice(6), "setPaintProperty") : ke(c3[f], p[f]) || Pt(t, { command: "setLayerProperty", args: [u, f, p[f]] })));
    for (f in p) !Object.prototype.hasOwnProperty.call(p, f) || Object.prototype.hasOwnProperty.call(c3, f) || f === "layout" || f === "paint" || f === "filter" || f === "metadata" || f === "minzoom" || f === "maxzoom" || (f.indexOf("paint.") === 0 ? Za(c3[f], p[f], t, u, f.slice(6), "setPaintProperty") : ke(c3[f], p[f]) || Pt(t, { command: "setLayerProperty", args: [u, f, p[f]] }));
  }
}
function $f(r50, e) {
  if (!r50) return [{ command: "setStyle", args: [e] }];
  let t = [];
  try {
    if (!ke(r50.version, e.version)) return [{ command: "setStyle", args: [e] }];
    ke(r50.center, e.center) || t.push({ command: "setCenter", args: [e.center] }), ke(r50.zoom, e.zoom) || t.push({ command: "setZoom", args: [e.zoom] }), ke(r50.bearing, e.bearing) || t.push({ command: "setBearing", args: [e.bearing] }), ke(r50.pitch, e.pitch) || t.push({ command: "setPitch", args: [e.pitch] }), ke(r50.sprite, e.sprite) || t.push({ command: "setSprite", args: [e.sprite] }), ke(r50.glyphs, e.glyphs) || t.push({ command: "setGlyphs", args: [e.glyphs] }), ke(r50.transition, e.transition) || t.push({ command: "setTransition", args: [e.transition] }), ke(r50.light, e.light) || t.push({ command: "setLight", args: [e.light] }), ke(r50.terrain, e.terrain) || t.push({ command: "setTerrain", args: [e.terrain] }), ke(r50.sky, e.sky) || t.push({ command: "setSky", args: [e.sky] }), ke(r50.projection, e.projection) || t.push({ command: "setProjection", args: [e.projection] });
    let i = {}, n = [];
    Lv(r50.sources, e.sources, n, i);
    let o = [];
    r50.layers && r50.layers.forEach((a) => {
      "source" in a && i[a.source] ? t.push({ command: "removeLayer", args: [a.id] }) : o.push(a);
    }), t = t.concat(n), Dv(o, e.layers, t);
  } catch (i) {
    console.warn("Unable to compute style diff:", i), t = [{ command: "setStyle", args: [e] }];
  }
  return t;
}
var R = class {
  constructor(e, t, i, n) {
    this.message = (e ? "".concat(e, ": ") : "") + i, n && (this.identifier = n), t != null && t.__line__ && (this.line = t.__line__);
  }
};
function Ai(r50, ...e) {
  for (let t of e) for (let i in t) r50[i] = t[i];
  return r50;
}
var Tt = class extends Error {
  constructor(e, t) {
    super(t), this.message = t, this.key = e;
  }
};
var Oc = class r2 {
  constructor(e, t = []) {
    this.parent = e, this.bindings = {};
    for (let [i, n] of t) this.bindings[i] = n;
  }
  concat(e) {
    return new r2(this, e);
  }
  get(e) {
    if (this.bindings[e]) return this.bindings[e];
    if (this.parent) return this.parent.get(e);
    throw new Error("".concat(e, " not found in scope."));
  }
  has(e) {
    return this.bindings[e] ? true : this.parent ? this.parent.has(e) : false;
  }
};
var Ci = { kind: "null" };
var q2 = { kind: "number" };
var ce = { kind: "string" };
var ae = { kind: "boolean" };
var Mt = { kind: "color" };
var Pi = { kind: "object" };
var se = { kind: "value" };
var zv = { kind: "error" };
var cs = { kind: "collator" };
var Ei = { kind: "formatted" };
var ps = { kind: "padding" };
var Vn = { kind: "resolvedImage" };
var hs = { kind: "variableAnchorOffsetCollection" };
function bt(r50, e) {
  return { kind: "array", itemType: r50, N: e };
}
function Fe(r50) {
  if (r50.kind === "array") {
    let e = Fe(r50.itemType);
    return typeof r50.N == "number" ? "array<".concat(e, ", ").concat(r50.N, ">") : r50.itemType.kind === "value" ? "array" : "array<".concat(e, ">");
  } else return r50.kind;
}
var Fv = [Ci, q2, ce, ae, Mt, Ei, Pi, bt(se), ps, Vn, hs];
function An(r50, e) {
  if (e.kind === "error") return null;
  if (r50.kind === "array") {
    if (e.kind === "array" && (e.N === 0 && e.itemType.kind === "value" || !An(r50.itemType, e.itemType)) && (typeof r50.N != "number" || r50.N === e.N)) return null;
  } else {
    if (r50.kind === e.kind) return null;
    if (r50.kind === "value") {
      for (let t of Fv) if (!An(t, e)) return null;
    }
  }
  return "Expected ".concat(Fe(r50), " but found ").concat(Fe(e), " instead.");
}
function tp(r50, e) {
  return e.some((t) => t.kind === r50.kind);
}
function Mn(r50, e) {
  return e.some((t) => t === "null" ? r50 === null : t === "array" ? Array.isArray(r50) : t === "object" ? r50 && !Array.isArray(r50) && typeof r50 == "object" : t === typeof r50);
}
function wn(r50, e) {
  return r50.kind === "array" && e.kind === "array" ? r50.itemType.kind === e.itemType.kind && typeof r50.N == "number" : r50.kind === e.kind;
}
var Wf = 0.96422;
var Xf = 1;
var Kf = 0.82521;
var Jf = 4 / 29;
var Ti = 6 / 29;
var Yf = 3 * Ti * Ti;
var Rv = Ti * Ti * Ti;
var Bv = Math.PI / 180;
var Ov = 180 / Math.PI;
function Qf(r50) {
  return r50 = r50 % 360, r50 < 0 && (r50 += 360), r50;
}
function em([r50, e, t, i]) {
  r50 = Ec(r50), e = Ec(e), t = Ec(t);
  let n, o, a = kc((0.2225045 * r50 + 0.7168786 * e + 0.0606169 * t) / Xf);
  r50 === e && e === t ? n = o = a : (n = kc((0.4360747 * r50 + 0.3850649 * e + 0.1430804 * t) / Wf), o = kc((0.0139322 * r50 + 0.0971045 * e + 0.7141733 * t) / Kf));
  let s3 = 116 * a - 16;
  return [s3 < 0 ? 0 : s3, 500 * (n - a), 200 * (a - o), i];
}
function Ec(r50) {
  return r50 <= 0.04045 ? r50 / 12.92 : Math.pow((r50 + 0.055) / 1.055, 2.4);
}
function kc(r50) {
  return r50 > Rv ? Math.pow(r50, 1 / 3) : r50 / Yf + Jf;
}
function tm([r50, e, t, i]) {
  let n = (r50 + 16) / 116, o = isNaN(e) ? n : n + e / 500, a = isNaN(t) ? n : n - t / 200;
  return n = Xf * Dc(n), o = Wf * Dc(o), a = Kf * Dc(a), [Lc(3.1338561 * o - 1.6168667 * n - 0.4906146 * a), Lc(-0.9787684 * o + 1.9161415 * n + 0.033454 * a), Lc(0.0719453 * o - 0.2289914 * n + 1.4052427 * a), i];
}
function Lc(r50) {
  return r50 = r50 <= 304e-5 ? 12.92 * r50 : 1.055 * Math.pow(r50, 1 / 2.4) - 0.055, r50 < 0 ? 0 : r50 > 1 ? 1 : r50;
}
function Dc(r50) {
  return r50 > Ti ? r50 * r50 * r50 : Yf * (r50 - Jf);
}
function Vv(r50) {
  let [e, t, i, n] = em(r50), o = Math.sqrt(t * t + i * i);
  return [Math.round(o * 1e4) ? Qf(Math.atan2(i, t) * Ov) : NaN, o, e, n];
}
function Uv([r50, e, t, i]) {
  return r50 = isNaN(r50) ? 0 : r50 * Bv, tm([t, Math.cos(r50) * e, Math.sin(r50) * e, i]);
}
function Nv([r50, e, t, i]) {
  r50 = Qf(r50), e /= 100, t /= 100;
  function n(o) {
    let a = (o + r50 / 30) % 12, s3 = e * Math.min(t, 1 - t);
    return t - s3 * Math.max(-1, Math.min(a - 3, 9 - a, 1));
  }
  return [n(0), n(8), n(4), i];
}
function Gv(r50) {
  if (r50 = r50.toLowerCase().trim(), r50 === "transparent") return [0, 0, 0, 0];
  let e = qv[r50];
  if (e) {
    let [n, o, a] = e;
    return [n / 255, o / 255, a / 255, 1];
  }
  if (r50.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(r50)) {
    let o = r50.length < 6 ? 1 : 2, a = 1;
    return [Ha(r50.slice(a, a += o)), Ha(r50.slice(a, a += o)), Ha(r50.slice(a, a += o)), Ha(r50.slice(a, a + o) || "ff")];
  }
  if (r50.startsWith("rgb")) {
    let n = /^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/, o = r50.match(n);
    if (o) {
      let [a, s3, l, u, c3, p, h, f, d, y, g, x] = o, v = [u || " ", h || " ", y].join("");
      if (v === "  " || v === "  /" || v === ",," || v === ",,,") {
        let b = [l, p, d].join(""), w = b === "%%%" ? 100 : b === "" ? 255 : 0;
        if (w) {
          let S = [wi(+s3 / w, 0, 1), wi(+c3 / w, 0, 1), wi(+f / w, 0, 1), g ? Tf(+g, x) : 1];
          if (Af(S)) return S;
        }
      }
      return;
    }
  }
  let t = /^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/, i = r50.match(t);
  if (i) {
    let [n, o, a, s3, l, u, c3, p, h] = i, f = [a || " ", l || " ", c3].join("");
    if (f === "  " || f === "  /" || f === ",," || f === ",,,") {
      let d = [+o, wi(+s3, 0, 100), wi(+u, 0, 100), p ? Tf(+p, h) : 1];
      if (Af(d)) return Nv(d);
    }
  }
}
function Ha(r50) {
  return parseInt(r50.padEnd(2, r50), 16) / 255;
}
function Tf(r50, e) {
  return wi(e ? r50 / 100 : r50, 0, 1);
}
function wi(r50, e, t) {
  return Math.min(Math.max(e, r50), t);
}
function Af(r50) {
  return !r50.some(Number.isNaN);
}
var qv = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
var W = class r3 {
  constructor(e, t, i, n = 1, o = true) {
    this.r = e, this.g = t, this.b = i, this.a = n, o || (this.r *= n, this.g *= n, this.b *= n, n || this.overwriteGetter("rgb", [e, t, i, n]));
  }
  static parse(e) {
    if (e instanceof r3) return e;
    if (typeof e != "string") return;
    let t = Gv(e);
    if (t) return new r3(...t, false);
  }
  get rgb() {
    let { r: e, g: t, b: i, a: n } = this, o = n || 1 / 0;
    return this.overwriteGetter("rgb", [e / o, t / o, i / o, n]);
  }
  get hcl() {
    return this.overwriteGetter("hcl", Vv(this.rgb));
  }
  get lab() {
    return this.overwriteGetter("lab", em(this.rgb));
  }
  overwriteGetter(e, t) {
    return Object.defineProperty(this, e, { value: t }), t;
  }
  toString() {
    let [e, t, i, n] = this.rgb;
    return "rgba(".concat([e, t, i].map((o) => Math.round(o * 255)).join(","), ",").concat(n, ")");
  }
};
W.black = new W(0, 0, 0, 1);
W.white = new W(1, 1, 1, 1);
W.transparent = new W(0, 0, 0, 0);
W.red = new W(1, 0, 0, 1);
var In = class {
  constructor(e, t, i) {
    e ? this.sensitivity = t ? "variant" : "case" : this.sensitivity = t ? "accent" : "base", this.locale = i, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
  }
  compare(e, t) {
    return this.collator.compare(e, t);
  }
  resolvedLocale() {
    return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
  }
};
var Cn = class {
  constructor(e, t, i, n, o) {
    this.text = e, this.image = t, this.scale = i, this.fontStack = n, this.textColor = o;
  }
};
var vt = class r4 {
  constructor(e) {
    this.sections = e;
  }
  static fromString(e) {
    return new r4([new Cn(e, null, null, null, null)]);
  }
  isEmpty() {
    return this.sections.length === 0 ? true : !this.sections.some((e) => e.text.length !== 0 || e.image && e.image.name.length !== 0);
  }
  static factory(e) {
    return e instanceof r4 ? e : r4.fromString(e);
  }
  toString() {
    return this.sections.length === 0 ? "" : this.sections.map((e) => e.text).join("");
  }
};
var zt = class r5 {
  constructor(e) {
    this.values = e.slice();
  }
  static parse(e) {
    if (e instanceof r5) return e;
    if (typeof e == "number") return new r5([e, e, e, e]);
    if (Array.isArray(e) && !(e.length < 1 || e.length > 4)) {
      for (let t of e) if (typeof t != "number") return;
      switch (e.length) {
        case 1:
          e = [e[0], e[0], e[0], e[0]];
          break;
        case 2:
          e = [e[0], e[1], e[0], e[1]];
          break;
        case 3:
          e = [e[0], e[1], e[2], e[1]];
          break;
      }
      return new r5(e);
    }
  }
  toString() {
    return JSON.stringify(this.values);
  }
};
var jv = /* @__PURE__ */ new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
var er = class r6 {
  constructor(e) {
    this.values = e.slice();
  }
  static parse(e) {
    if (e instanceof r6) return e;
    if (!(!Array.isArray(e) || e.length < 1 || e.length % 2 !== 0)) {
      for (let t = 0; t < e.length; t += 2) {
        let i = e[t], n = e[t + 1];
        if (typeof i != "string" || !jv.has(i) || !Array.isArray(n) || n.length !== 2 || typeof n[0] != "number" || typeof n[1] != "number") return;
      }
      return new r6(e);
    }
  }
  toString() {
    return JSON.stringify(this.values);
  }
};
var ht = class r7 {
  constructor(e) {
    this.name = e.name, this.available = e.available;
  }
  toString() {
    return this.name;
  }
  static fromString(e) {
    return e ? new r7({ name: e, available: false }) : null;
  }
};
function rm(r50, e, t, i) {
  if (!(typeof r50 == "number" && r50 >= 0 && r50 <= 255 && typeof e == "number" && e >= 0 && e <= 255 && typeof t == "number" && t >= 0 && t <= 255)) {
    let n = typeof i == "number" ? [r50, e, t, i] : [r50, e, t];
    return "Invalid rgba value [".concat(n.join(", "), "]: 'r', 'g', and 'b' must be between 0 and 255.");
  }
  return typeof i > "u" || typeof i == "number" && i >= 0 && i <= 1 ? null : "Invalid rgba value [".concat([r50, e, t, i].join(", "), "]: 'a' must be between 0 and 1.");
}
function En(r50) {
  if (r50 === null || typeof r50 == "string" || typeof r50 == "boolean" || typeof r50 == "number" || r50 instanceof W || r50 instanceof In || r50 instanceof vt || r50 instanceof zt || r50 instanceof er || r50 instanceof ht) return true;
  if (Array.isArray(r50)) {
    for (let e of r50) if (!En(e)) return false;
    return true;
  } else if (typeof r50 == "object") {
    for (let e in r50) if (!En(r50[e])) return false;
    return true;
  } else return false;
}
function Ze(r50) {
  if (r50 === null) return Ci;
  if (typeof r50 == "string") return ce;
  if (typeof r50 == "boolean") return ae;
  if (typeof r50 == "number") return q2;
  if (r50 instanceof W) return Mt;
  if (r50 instanceof In) return cs;
  if (r50 instanceof vt) return Ei;
  if (r50 instanceof zt) return ps;
  if (r50 instanceof er) return hs;
  if (r50 instanceof ht) return Vn;
  if (Array.isArray(r50)) {
    let e = r50.length, t;
    for (let i of r50) {
      let n = Ze(i);
      if (!t) t = n;
      else {
        if (t === n) continue;
        t = se;
        break;
      }
    }
    return bt(t || se, e);
  } else return Pi;
}
function Pn(r50) {
  let e = typeof r50;
  return r50 === null ? "" : e === "string" || e === "number" || e === "boolean" ? String(r50) : r50 instanceof W || r50 instanceof vt || r50 instanceof zt || r50 instanceof er || r50 instanceof ht ? r50.toString() : JSON.stringify(r50);
}
var yr = class r8 {
  constructor(e, t) {
    this.type = e, this.value = t;
  }
  static parse(e, t) {
    if (e.length !== 2) return t.error("'literal' expression requires exactly one argument, but found ".concat(e.length - 1, " instead."));
    if (!En(e[1])) return t.error("invalid value");
    let i = e[1], n = Ze(i), o = t.expectedType;
    return n.kind === "array" && n.N === 0 && o && o.kind === "array" && (typeof o.N != "number" || o.N === 0) && (n = o), new r8(n, i);
  }
  evaluate() {
    return this.value;
  }
  eachChild() {
  }
  outputDefined() {
    return true;
  }
};
var Re = class {
  constructor(e) {
    this.name = "ExpressionEvaluationError", this.message = e;
  }
  toJSON() {
    return this.message;
  }
};
var $a = { string: ce, number: q2, boolean: ae, object: Pi };
var Dt = class r9 {
  constructor(e, t) {
    this.type = e, this.args = t;
  }
  static parse(e, t) {
    if (e.length < 2) return t.error("Expected at least one argument.");
    let i = 1, n, o = e[0];
    if (o === "array") {
      let s3;
      if (e.length > 2) {
        let u = e[1];
        if (typeof u != "string" || !(u in $a) || u === "object") return t.error('The item type argument of "array" must be one of string, number, boolean', 1);
        s3 = $a[u], i++;
      } else s3 = se;
      let l;
      if (e.length > 3) {
        if (e[2] !== null && (typeof e[2] != "number" || e[2] < 0 || e[2] !== Math.floor(e[2]))) return t.error('The length argument to "array" must be a positive integer literal', 2);
        l = e[2], i++;
      }
      n = bt(s3, l);
    } else {
      if (!$a[o]) throw new Error("Types doesn't contain name = ".concat(o));
      n = $a[o];
    }
    let a = [];
    for (; i < e.length; i++) {
      let s3 = t.parse(e[i], i, se);
      if (!s3) return null;
      a.push(s3);
    }
    return new r9(n, a);
  }
  evaluate(e) {
    for (let t = 0; t < this.args.length; t++) {
      let i = this.args[t].evaluate(e);
      if (An(this.type, Ze(i))) {
        if (t === this.args.length - 1) throw new Re("Expected value to be of type ".concat(Fe(this.type), ", but found ").concat(Fe(Ze(i)), " instead."));
      } else return i;
    }
    throw new Error();
  }
  eachChild(e) {
    this.args.forEach(e);
  }
  outputDefined() {
    return this.args.every((e) => e.outputDefined());
  }
};
var Mf = { "to-boolean": ae, "to-color": Mt, "to-number": q2, "to-string": ce };
var dr = class r10 {
  constructor(e, t) {
    this.type = e, this.args = t;
  }
  static parse(e, t) {
    if (e.length < 2) return t.error("Expected at least one argument.");
    let i = e[0];
    if (!Mf[i]) throw new Error("Can't parse ".concat(i, " as it is not part of the known types"));
    if ((i === "to-boolean" || i === "to-string") && e.length !== 2) return t.error("Expected one argument.");
    let n = Mf[i], o = [];
    for (let a = 1; a < e.length; a++) {
      let s3 = t.parse(e[a], a, se);
      if (!s3) return null;
      o.push(s3);
    }
    return new r10(n, o);
  }
  evaluate(e) {
    switch (this.type.kind) {
      case "boolean":
        return !!this.args[0].evaluate(e);
      case "color": {
        let t, i;
        for (let n of this.args) {
          if (t = n.evaluate(e), i = null, t instanceof W) return t;
          if (typeof t == "string") {
            let o = e.parseColor(t);
            if (o) return o;
          } else if (Array.isArray(t) && (t.length < 3 || t.length > 4 ? i = "Invalid rbga value ".concat(JSON.stringify(t), ": expected an array containing either three or four numeric values.") : i = rm(t[0], t[1], t[2], t[3]), !i)) return new W(t[0] / 255, t[1] / 255, t[2] / 255, t[3]);
        }
        throw new Re(i || "Could not parse color from value '".concat(typeof t == "string" ? t : JSON.stringify(t), "'"));
      }
      case "padding": {
        let t;
        for (let i of this.args) {
          t = i.evaluate(e);
          let n = zt.parse(t);
          if (n) return n;
        }
        throw new Re("Could not parse padding from value '".concat(typeof t == "string" ? t : JSON.stringify(t), "'"));
      }
      case "variableAnchorOffsetCollection": {
        let t;
        for (let i of this.args) {
          t = i.evaluate(e);
          let n = er.parse(t);
          if (n) return n;
        }
        throw new Re("Could not parse variableAnchorOffsetCollection from value '".concat(typeof t == "string" ? t : JSON.stringify(t), "'"));
      }
      case "number": {
        let t = null;
        for (let i of this.args) {
          if (t = i.evaluate(e), t === null) return 0;
          let n = Number(t);
          if (!isNaN(n)) return n;
        }
        throw new Re("Could not convert ".concat(JSON.stringify(t), " to number."));
      }
      case "formatted":
        return vt.fromString(Pn(this.args[0].evaluate(e)));
      case "resolvedImage":
        return ht.fromString(Pn(this.args[0].evaluate(e)));
      default:
        return Pn(this.args[0].evaluate(e));
    }
  }
  eachChild(e) {
    this.args.forEach(e);
  }
  outputDefined() {
    return this.args.every((e) => e.outputDefined());
  }
};
var Zv = ["Unknown", "Point", "LineString", "Polygon"];
var Ja = class {
  constructor() {
    this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;
  }
  id() {
    return this.feature && "id" in this.feature ? this.feature.id : null;
  }
  geometryType() {
    return this.feature ? typeof this.feature.type == "number" ? Zv[this.feature.type] : this.feature.type : null;
  }
  geometry() {
    return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
  }
  canonicalID() {
    return this.canonical;
  }
  properties() {
    return this.feature && this.feature.properties || {};
  }
  parseColor(e) {
    let t = this._parseColorCache[e];
    return t || (t = this._parseColorCache[e] = W.parse(e)), t;
  }
};
var Ya = class r11 {
  constructor(e, t, i = [], n, o = new Oc(), a = []) {
    this.registry = e, this.path = i, this.key = i.map((s3) => "[".concat(s3, "]")).join(""), this.scope = o, this.errors = a, this.expectedType = n, this._isConstant = t;
  }
  parse(e, t, i, n, o = {}) {
    return t ? this.concat(t, i, n)._parse(e, o) : this._parse(e, o);
  }
  _parse(e, t) {
    (e === null || typeof e == "string" || typeof e == "boolean" || typeof e == "number") && (e = ["literal", e]);
    function i(n, o, a) {
      return a === "assert" ? new Dt(o, [n]) : a === "coerce" ? new dr(o, [n]) : n;
    }
    if (Array.isArray(e)) {
      if (e.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
      let n = e[0];
      if (typeof n != "string") return this.error("Expression name must be a string, but found ".concat(typeof n, ' instead. If you wanted a literal array, use ["literal", [...]].'), 0), null;
      let o = this.registry[n];
      if (o) {
        let a = o.parse(e, this);
        if (!a) return null;
        if (this.expectedType) {
          let s3 = this.expectedType, l = a.type;
          if ((s3.kind === "string" || s3.kind === "number" || s3.kind === "boolean" || s3.kind === "object" || s3.kind === "array") && l.kind === "value") a = i(a, s3, t.typeAnnotation || "assert");
          else if ((s3.kind === "color" || s3.kind === "formatted" || s3.kind === "resolvedImage") && (l.kind === "value" || l.kind === "string")) a = i(a, s3, t.typeAnnotation || "coerce");
          else if (s3.kind === "padding" && (l.kind === "value" || l.kind === "number" || l.kind === "array")) a = i(a, s3, t.typeAnnotation || "coerce");
          else if (s3.kind === "variableAnchorOffsetCollection" && (l.kind === "value" || l.kind === "array")) a = i(a, s3, t.typeAnnotation || "coerce");
          else if (this.checkSubtype(s3, l)) return null;
        }
        if (!(a instanceof yr) && a.type.kind !== "resolvedImage" && this._isConstant(a)) {
          let s3 = new Ja();
          try {
            a = new yr(a.type, a.evaluate(s3));
          } catch (l) {
            return this.error(l.message), null;
          }
        }
        return a;
      }
      return this.error('Unknown expression "'.concat(n, '". If you wanted a literal array, use ["literal", [...]].'), 0);
    } else return typeof e > "u" ? this.error("'undefined' value invalid. Use null instead.") : typeof e == "object" ? this.error('Bare objects invalid. Use ["literal", {...}] instead.') : this.error("Expected an array, but found ".concat(typeof e, " instead."));
  }
  concat(e, t, i) {
    let n = typeof e == "number" ? this.path.concat(e) : this.path, o = i ? this.scope.concat(i) : this.scope;
    return new r11(this.registry, this._isConstant, n, t || null, o, this.errors);
  }
  error(e, ...t) {
    let i = "".concat(this.key).concat(t.map((n) => "[".concat(n, "]")).join(""));
    this.errors.push(new Tt(i, e));
  }
  checkSubtype(e, t) {
    let i = An(e, t);
    return i && this.error(i), i;
  }
};
var Qa = class r12 {
  constructor(e, t) {
    this.type = t.type, this.bindings = [].concat(e), this.result = t;
  }
  evaluate(e) {
    return this.result.evaluate(e);
  }
  eachChild(e) {
    for (let t of this.bindings) e(t[1]);
    e(this.result);
  }
  static parse(e, t) {
    if (e.length < 4) return t.error("Expected at least 3 arguments, but found ".concat(e.length - 1, " instead."));
    let i = [];
    for (let o = 1; o < e.length - 1; o += 2) {
      let a = e[o];
      if (typeof a != "string") return t.error("Expected string, but found ".concat(typeof a, " instead."), o);
      if (/[^a-zA-Z0-9_]/.test(a)) return t.error("Variable names must contain only alphanumeric characters or '_'.", o);
      let s3 = t.parse(e[o + 1], o + 1);
      if (!s3) return null;
      i.push([a, s3]);
    }
    let n = t.parse(e[e.length - 1], e.length - 1, t.expectedType, i);
    return n ? new r12(i, n) : null;
  }
  outputDefined() {
    return this.result.outputDefined();
  }
};
var es = class r13 {
  constructor(e, t) {
    this.type = t.type, this.name = e, this.boundExpression = t;
  }
  static parse(e, t) {
    if (e.length !== 2 || typeof e[1] != "string") return t.error("'var' expression requires exactly one string literal argument.");
    let i = e[1];
    return t.scope.has(i) ? new r13(i, t.scope.get(i)) : t.error('Unknown variable "'.concat(i, '". Make sure "').concat(i, '" has been bound in an enclosing "let" expression before using it.'), 1);
  }
  evaluate(e) {
    return this.boundExpression.evaluate(e);
  }
  eachChild() {
  }
  outputDefined() {
    return false;
  }
};
var Vc = class r14 {
  constructor(e, t, i) {
    this.type = e, this.index = t, this.input = i;
  }
  static parse(e, t) {
    if (e.length !== 3) return t.error("Expected 2 arguments, but found ".concat(e.length - 1, " instead."));
    let i = t.parse(e[1], 1, q2), n = t.parse(e[2], 2, bt(t.expectedType || se));
    if (!i || !n) return null;
    let o = n.type;
    return new r14(o.itemType, i, n);
  }
  evaluate(e) {
    let t = this.index.evaluate(e), i = this.input.evaluate(e);
    if (t < 0) throw new Re("Array index out of bounds: ".concat(t, " < 0."));
    if (t >= i.length) throw new Re("Array index out of bounds: ".concat(t, " > ").concat(i.length - 1, "."));
    if (t !== Math.floor(t)) throw new Re("Array index must be an integer, but found ".concat(t, " instead."));
    return i[t];
  }
  eachChild(e) {
    e(this.index), e(this.input);
  }
  outputDefined() {
    return false;
  }
};
var Uc = class r15 {
  constructor(e, t) {
    this.type = ae, this.needle = e, this.haystack = t;
  }
  static parse(e, t) {
    if (e.length !== 3) return t.error("Expected 2 arguments, but found ".concat(e.length - 1, " instead."));
    let i = t.parse(e[1], 1, se), n = t.parse(e[2], 2, se);
    return !i || !n ? null : tp(i.type, [ae, ce, q2, Ci, se]) ? new r15(i, n) : t.error("Expected first argument to be of type boolean, string, number or null, but found ".concat(Fe(i.type), " instead"));
  }
  evaluate(e) {
    let t = this.needle.evaluate(e), i = this.haystack.evaluate(e);
    if (!i) return false;
    if (!Mn(t, ["boolean", "string", "number", "null"])) throw new Re("Expected first argument to be of type boolean, string, number or null, but found ".concat(Fe(Ze(t)), " instead."));
    if (!Mn(i, ["string", "array"])) throw new Re("Expected second argument to be of type array or string, but found ".concat(Fe(Ze(i)), " instead."));
    return i.indexOf(t) >= 0;
  }
  eachChild(e) {
    e(this.needle), e(this.haystack);
  }
  outputDefined() {
    return true;
  }
};
var Nc = class r16 {
  constructor(e, t, i) {
    this.type = q2, this.needle = e, this.haystack = t, this.fromIndex = i;
  }
  static parse(e, t) {
    if (e.length <= 2 || e.length >= 5) return t.error("Expected 3 or 4 arguments, but found ".concat(e.length - 1, " instead."));
    let i = t.parse(e[1], 1, se), n = t.parse(e[2], 2, se);
    if (!i || !n) return null;
    if (!tp(i.type, [ae, ce, q2, Ci, se])) return t.error("Expected first argument to be of type boolean, string, number or null, but found ".concat(Fe(i.type), " instead"));
    if (e.length === 4) {
      let o = t.parse(e[3], 3, q2);
      return o ? new r16(i, n, o) : null;
    } else return new r16(i, n);
  }
  evaluate(e) {
    let t = this.needle.evaluate(e), i = this.haystack.evaluate(e);
    if (!Mn(t, ["boolean", "string", "number", "null"])) throw new Re("Expected first argument to be of type boolean, string, number or null, but found ".concat(Fe(Ze(t)), " instead."));
    if (!Mn(i, ["string", "array"])) throw new Re("Expected second argument to be of type array or string, but found ".concat(Fe(Ze(i)), " instead."));
    if (this.fromIndex) {
      let n = this.fromIndex.evaluate(e);
      return i.indexOf(t, n);
    }
    return i.indexOf(t);
  }
  eachChild(e) {
    e(this.needle), e(this.haystack), this.fromIndex && e(this.fromIndex);
  }
  outputDefined() {
    return false;
  }
};
var Gc = class r17 {
  constructor(e, t, i, n, o, a) {
    this.inputType = e, this.type = t, this.input = i, this.cases = n, this.outputs = o, this.otherwise = a;
  }
  static parse(e, t) {
    if (e.length < 5) return t.error("Expected at least 4 arguments, but found only ".concat(e.length - 1, "."));
    if (e.length % 2 !== 1) return t.error("Expected an even number of arguments.");
    let i, n;
    t.expectedType && t.expectedType.kind !== "value" && (n = t.expectedType);
    let o = {}, a = [];
    for (let u = 2; u < e.length - 1; u += 2) {
      let c3 = e[u], p = e[u + 1];
      Array.isArray(c3) || (c3 = [c3]);
      let h = t.concat(u);
      if (c3.length === 0) return h.error("Expected at least one branch label.");
      for (let d of c3) {
        if (typeof d != "number" && typeof d != "string") return h.error("Branch labels must be numbers or strings.");
        if (typeof d == "number" && Math.abs(d) > Number.MAX_SAFE_INTEGER) return h.error("Branch labels must be integers no larger than ".concat(Number.MAX_SAFE_INTEGER, "."));
        if (typeof d == "number" && Math.floor(d) !== d) return h.error("Numeric branch labels must be integer values.");
        if (!i) i = Ze(d);
        else if (h.checkSubtype(i, Ze(d))) return null;
        if (typeof o[String(d)] < "u") return h.error("Branch labels must be unique.");
        o[String(d)] = a.length;
      }
      let f = t.parse(p, u, n);
      if (!f) return null;
      n = n || f.type, a.push(f);
    }
    let s3 = t.parse(e[1], 1, se);
    if (!s3) return null;
    let l = t.parse(e[e.length - 1], e.length - 1, n);
    return !l || s3.type.kind !== "value" && t.concat(1).checkSubtype(i, s3.type) ? null : new r17(i, n, s3, o, a, l);
  }
  evaluate(e) {
    let t = this.input.evaluate(e);
    return (Ze(t) === this.inputType && this.outputs[this.cases[t]] || this.otherwise).evaluate(e);
  }
  eachChild(e) {
    e(this.input), this.outputs.forEach(e), e(this.otherwise);
  }
  outputDefined() {
    return this.outputs.every((e) => e.outputDefined()) && this.otherwise.outputDefined();
  }
};
var qc = class r18 {
  constructor(e, t, i) {
    this.type = e, this.branches = t, this.otherwise = i;
  }
  static parse(e, t) {
    if (e.length < 4) return t.error("Expected at least 3 arguments, but found only ".concat(e.length - 1, "."));
    if (e.length % 2 !== 0) return t.error("Expected an odd number of arguments.");
    let i;
    t.expectedType && t.expectedType.kind !== "value" && (i = t.expectedType);
    let n = [];
    for (let a = 1; a < e.length - 1; a += 2) {
      let s3 = t.parse(e[a], a, ae);
      if (!s3) return null;
      let l = t.parse(e[a + 1], a + 1, i);
      if (!l) return null;
      n.push([s3, l]), i = i || l.type;
    }
    let o = t.parse(e[e.length - 1], e.length - 1, i);
    if (!o) return null;
    if (!i) throw new Error("Can't infer output type");
    return new r18(i, n, o);
  }
  evaluate(e) {
    for (let [t, i] of this.branches) if (t.evaluate(e)) return i.evaluate(e);
    return this.otherwise.evaluate(e);
  }
  eachChild(e) {
    for (let [t, i] of this.branches) e(t), e(i);
    e(this.otherwise);
  }
  outputDefined() {
    return this.branches.every(([e, t]) => t.outputDefined()) && this.otherwise.outputDefined();
  }
};
var jc = class r19 {
  constructor(e, t, i, n) {
    this.type = e, this.input = t, this.beginIndex = i, this.endIndex = n;
  }
  static parse(e, t) {
    if (e.length <= 2 || e.length >= 5) return t.error("Expected 3 or 4 arguments, but found ".concat(e.length - 1, " instead."));
    let i = t.parse(e[1], 1, se), n = t.parse(e[2], 2, q2);
    if (!i || !n) return null;
    if (!tp(i.type, [bt(se), ce, se])) return t.error("Expected first argument to be of type array or string, but found ".concat(Fe(i.type), " instead"));
    if (e.length === 4) {
      let o = t.parse(e[3], 3, q2);
      return o ? new r19(i.type, i, n, o) : null;
    } else return new r19(i.type, i, n);
  }
  evaluate(e) {
    let t = this.input.evaluate(e), i = this.beginIndex.evaluate(e);
    if (!Mn(t, ["string", "array"])) throw new Re("Expected first argument to be of type array or string, but found ".concat(Fe(Ze(t)), " instead."));
    if (this.endIndex) {
      let n = this.endIndex.evaluate(e);
      return t.slice(i, n);
    }
    return t.slice(i);
  }
  eachChild(e) {
    e(this.input), e(this.beginIndex), this.endIndex && e(this.endIndex);
  }
  outputDefined() {
    return false;
  }
};
function fs(r50, e) {
  let t = r50.length - 1, i = 0, n = t, o = 0, a, s3;
  for (; i <= n; ) if (o = Math.floor((i + n) / 2), a = r50[o], s3 = r50[o + 1], a <= e) {
    if (o === t || e < s3) return o;
    i = o + 1;
  } else if (a > e) n = o - 1;
  else throw new Re("Input is not a number.");
  return 0;
}
var Mi = class r20 {
  constructor(e, t, i) {
    this.type = e, this.input = t, this.labels = [], this.outputs = [];
    for (let [n, o] of i) this.labels.push(n), this.outputs.push(o);
  }
  static parse(e, t) {
    if (e.length - 1 < 4) return t.error("Expected at least 4 arguments, but found only ".concat(e.length - 1, "."));
    if ((e.length - 1) % 2 !== 0) return t.error("Expected an even number of arguments.");
    let i = t.parse(e[1], 1, q2);
    if (!i) return null;
    let n = [], o = null;
    t.expectedType && t.expectedType.kind !== "value" && (o = t.expectedType);
    for (let a = 1; a < e.length; a += 2) {
      let s3 = a === 1 ? -1 / 0 : e[a], l = e[a + 1], u = a, c3 = a + 1;
      if (typeof s3 != "number") return t.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', u);
      if (n.length && n[n.length - 1][0] >= s3) return t.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', u);
      let p = t.parse(l, c3, o);
      if (!p) return null;
      o = o || p.type, n.push([s3, p]);
    }
    return new r20(o, i, n);
  }
  evaluate(e) {
    let t = this.labels, i = this.outputs;
    if (t.length === 1) return i[0].evaluate(e);
    let n = this.input.evaluate(e);
    if (n <= t[0]) return i[0].evaluate(e);
    let o = t.length;
    if (n >= t[o - 1]) return i[o - 1].evaluate(e);
    let a = fs(t, n);
    return i[a].evaluate(e);
  }
  eachChild(e) {
    e(this.input);
    for (let t of this.outputs) e(t);
  }
  outputDefined() {
    return this.outputs.every((e) => e.outputDefined());
  }
};
function Hv(r50) {
  return r50 && r50.__esModule && Object.prototype.hasOwnProperty.call(r50, "default") ? r50.default : r50;
}
var $v = im;
function im(r50, e, t, i) {
  this.cx = 3 * r50, this.bx = 3 * (t - r50) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e, this.by = 3 * (i - e) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = r50, this.p1y = e, this.p2x = t, this.p2y = i;
}
im.prototype = { sampleCurveX: function(r50) {
  return ((this.ax * r50 + this.bx) * r50 + this.cx) * r50;
}, sampleCurveY: function(r50) {
  return ((this.ay * r50 + this.by) * r50 + this.cy) * r50;
}, sampleCurveDerivativeX: function(r50) {
  return (3 * this.ax * r50 + 2 * this.bx) * r50 + this.cx;
}, solveCurveX: function(r50, e) {
  if (e === void 0 && (e = 1e-6), r50 < 0) return 0;
  if (r50 > 1) return 1;
  for (var t = r50, i = 0; i < 8; i++) {
    var n = this.sampleCurveX(t) - r50;
    if (Math.abs(n) < e) return t;
    var o = this.sampleCurveDerivativeX(t);
    if (Math.abs(o) < 1e-6) break;
    t = t - n / o;
  }
  var a = 0, s3 = 1;
  for (t = r50, i = 0; i < 20 && (n = this.sampleCurveX(t), !(Math.abs(n - r50) < e)); i++) r50 > n ? a = t : s3 = t, t = (s3 - a) * 0.5 + a;
  return t;
}, solve: function(r50, e) {
  return this.sampleCurveY(this.solveCurveX(r50, e));
} };
var Wv = Hv($v);
function Xv(r50) {
  return r50 === "rgb" || r50 === "hcl" || r50 === "lab";
}
function Hr(r50, e, t) {
  return r50 + t * (e - r50);
}
function Kv(r50, e, t, i = "rgb") {
  switch (i) {
    case "rgb": {
      let [n, o, a, s3] = ts(r50.rgb, e.rgb, t);
      return new W(n, o, a, s3, false);
    }
    case "hcl": {
      let [n, o, a, s3] = r50.hcl, [l, u, c3, p] = e.hcl, h, f;
      if (!isNaN(n) && !isNaN(l)) {
        let v = l - n;
        l > n && v > 180 ? v -= 360 : l < n && n - l > 180 && (v += 360), h = n + t * v;
      } else isNaN(n) ? isNaN(l) ? h = NaN : (h = l, (a === 1 || a === 0) && (f = u)) : (h = n, (c3 === 1 || c3 === 0) && (f = o));
      let [d, y, g, x] = Uv([h, f != null ? f : Hr(o, u, t), Hr(a, c3, t), Hr(s3, p, t)]);
      return new W(d, y, g, x, false);
    }
    case "lab": {
      let [n, o, a, s3] = tm(ts(r50.lab, e.lab, t));
      return new W(n, o, a, s3, false);
    }
  }
}
function ts(r50, e, t) {
  return r50.map((i, n) => Hr(i, e[n], t));
}
function Jv(r50, e, t) {
  return new zt(ts(r50.values, e.values, t));
}
function Yv(r50, e, t) {
  let i = r50.values, n = e.values;
  if (i.length !== n.length) throw new Re("Cannot interpolate values of different length. from: ".concat(r50.toString(), ", to: ").concat(e.toString()));
  let o = [];
  for (let a = 0; a < i.length; a += 2) {
    if (i[a] !== n[a]) throw new Re("Cannot interpolate values containing mismatched anchors. from[".concat(a, "]: ").concat(i[a], ", to[").concat(a, "]: ").concat(n[a]));
    o.push(i[a]);
    let [s3, l] = i[a + 1], [u, c3] = n[a + 1];
    o.push([Hr(s3, u, t), Hr(l, c3, t)]);
  }
  return new er(o);
}
var Se = { number: Hr, color: Kv, array: ts, padding: Jv, variableAnchorOffsetCollection: Yv };
var _t = class r21 {
  constructor(e, t, i, n, o) {
    this.type = e, this.operator = t, this.interpolation = i, this.input = n, this.labels = [], this.outputs = [];
    for (let [a, s3] of o) this.labels.push(a), this.outputs.push(s3);
  }
  static interpolationFactor(e, t, i, n) {
    let o = 0;
    if (e.name === "exponential") o = zc(t, e.base, i, n);
    else if (e.name === "linear") o = zc(t, 1, i, n);
    else if (e.name === "cubic-bezier") {
      let a = e.controlPoints;
      o = new Wv(a[0], a[1], a[2], a[3]).solve(zc(t, 1, i, n));
    }
    return o;
  }
  static parse(e, t) {
    let [i, n, o, ...a] = e;
    if (!Array.isArray(n) || n.length === 0) return t.error("Expected an interpolation type expression.", 1);
    if (n[0] === "linear") n = { name: "linear" };
    else if (n[0] === "exponential") {
      let u = n[1];
      if (typeof u != "number") return t.error("Exponential interpolation requires a numeric base.", 1, 1);
      n = { name: "exponential", base: u };
    } else if (n[0] === "cubic-bezier") {
      let u = n.slice(1);
      if (u.length !== 4 || u.some((c3) => typeof c3 != "number" || c3 < 0 || c3 > 1)) return t.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
      n = { name: "cubic-bezier", controlPoints: u };
    } else return t.error("Unknown interpolation type ".concat(String(n[0])), 1, 0);
    if (e.length - 1 < 4) return t.error("Expected at least 4 arguments, but found only ".concat(e.length - 1, "."));
    if ((e.length - 1) % 2 !== 0) return t.error("Expected an even number of arguments.");
    if (o = t.parse(o, 2, q2), !o) return null;
    let s3 = [], l = null;
    i === "interpolate-hcl" || i === "interpolate-lab" ? l = Mt : t.expectedType && t.expectedType.kind !== "value" && (l = t.expectedType);
    for (let u = 0; u < a.length; u += 2) {
      let c3 = a[u], p = a[u + 1], h = u + 3, f = u + 4;
      if (typeof c3 != "number") return t.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', h);
      if (s3.length && s3[s3.length - 1][0] >= c3) return t.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', h);
      let d = t.parse(p, f, l);
      if (!d) return null;
      l = l || d.type, s3.push([c3, d]);
    }
    return !wn(l, q2) && !wn(l, Mt) && !wn(l, ps) && !wn(l, hs) && !wn(l, bt(q2)) ? t.error("Type ".concat(Fe(l), " is not interpolatable.")) : new r21(l, i, n, o, s3);
  }
  evaluate(e) {
    let t = this.labels, i = this.outputs;
    if (t.length === 1) return i[0].evaluate(e);
    let n = this.input.evaluate(e);
    if (n <= t[0]) return i[0].evaluate(e);
    let o = t.length;
    if (n >= t[o - 1]) return i[o - 1].evaluate(e);
    let a = fs(t, n), s3 = t[a], l = t[a + 1], u = r21.interpolationFactor(this.interpolation, n, s3, l), c3 = i[a].evaluate(e), p = i[a + 1].evaluate(e);
    switch (this.operator) {
      case "interpolate":
        return Se[this.type.kind](c3, p, u);
      case "interpolate-hcl":
        return Se.color(c3, p, u, "hcl");
      case "interpolate-lab":
        return Se.color(c3, p, u, "lab");
    }
  }
  eachChild(e) {
    e(this.input);
    for (let t of this.outputs) e(t);
  }
  outputDefined() {
    return this.outputs.every((e) => e.outputDefined());
  }
};
function zc(r50, e, t, i) {
  let n = i - t, o = r50 - t;
  return n === 0 ? 0 : e === 1 ? o / n : (Math.pow(e, o) - 1) / (Math.pow(e, n) - 1);
}
var rs = class r22 {
  constructor(e, t) {
    this.type = e, this.args = t;
  }
  static parse(e, t) {
    if (e.length < 2) return t.error("Expectected at least one argument.");
    let i = null, n = t.expectedType;
    n && n.kind !== "value" && (i = n);
    let o = [];
    for (let s3 of e.slice(1)) {
      let l = t.parse(s3, 1 + o.length, i, void 0, { typeAnnotation: "omit" });
      if (!l) return null;
      i = i || l.type, o.push(l);
    }
    if (!i) throw new Error("No output type");
    return n && o.some((s3) => An(n, s3.type)) ? new r22(se, o) : new r22(i, o);
  }
  evaluate(e) {
    let t = null, i = 0, n;
    for (let o of this.args) if (i++, t = o.evaluate(e), t && t instanceof ht && !t.available && (n || (n = t.name), t = null, i === this.args.length && (t = n)), t !== null) break;
    return t;
  }
  eachChild(e) {
    this.args.forEach(e);
  }
  outputDefined() {
    return this.args.every((e) => e.outputDefined());
  }
};
function If(r50, e) {
  return r50 === "==" || r50 === "!=" ? e.kind === "boolean" || e.kind === "string" || e.kind === "number" || e.kind === "null" || e.kind === "value" : e.kind === "string" || e.kind === "number" || e.kind === "value";
}
function Qv(r50, e, t) {
  return e === t;
}
function e0(r50, e, t) {
  return e !== t;
}
function t0(r50, e, t) {
  return e < t;
}
function r0(r50, e, t) {
  return e > t;
}
function i0(r50, e, t) {
  return e <= t;
}
function n0(r50, e, t) {
  return e >= t;
}
function nm(r50, e, t, i) {
  return i.compare(e, t) === 0;
}
function o0(r50, e, t, i) {
  return !nm(r50, e, t, i);
}
function a0(r50, e, t, i) {
  return i.compare(e, t) < 0;
}
function s0(r50, e, t, i) {
  return i.compare(e, t) > 0;
}
function l0(r50, e, t, i) {
  return i.compare(e, t) <= 0;
}
function u0(r50, e, t, i) {
  return i.compare(e, t) >= 0;
}
function ki(r50, e, t) {
  let i = r50 !== "==" && r50 !== "!=";
  return class om {
    constructor(o, a, s3) {
      this.type = ae, this.lhs = o, this.rhs = a, this.collator = s3, this.hasUntypedArgument = o.type.kind === "value" || a.type.kind === "value";
    }
    static parse(o, a) {
      if (o.length !== 3 && o.length !== 4) return a.error("Expected two or three arguments.");
      let s3 = o[0], l = a.parse(o[1], 1, se);
      if (!l) return null;
      if (!If(s3, l.type)) return a.concat(1).error('"'.concat(s3, `" comparisons are not supported for type '`).concat(Fe(l.type), "'."));
      let u = a.parse(o[2], 2, se);
      if (!u) return null;
      if (!If(s3, u.type)) return a.concat(2).error('"'.concat(s3, `" comparisons are not supported for type '`).concat(Fe(u.type), "'."));
      if (l.type.kind !== u.type.kind && l.type.kind !== "value" && u.type.kind !== "value") return a.error("Cannot compare types '".concat(Fe(l.type), "' and '").concat(Fe(u.type), "'."));
      i && (l.type.kind === "value" && u.type.kind !== "value" ? l = new Dt(u.type, [l]) : l.type.kind !== "value" && u.type.kind === "value" && (u = new Dt(l.type, [u])));
      let c3 = null;
      if (o.length === 4) {
        if (l.type.kind !== "string" && u.type.kind !== "string" && l.type.kind !== "value" && u.type.kind !== "value") return a.error("Cannot use collator to compare non-string types.");
        if (c3 = a.parse(o[3], 3, cs), !c3) return null;
      }
      return new om(l, u, c3);
    }
    evaluate(o) {
      let a = this.lhs.evaluate(o), s3 = this.rhs.evaluate(o);
      if (i && this.hasUntypedArgument) {
        let l = Ze(a), u = Ze(s3);
        if (l.kind !== u.kind || !(l.kind === "string" || l.kind === "number")) throw new Re('Expected arguments for "'.concat(r50, '" to be (string, string) or (number, number), but found (').concat(l.kind, ", ").concat(u.kind, ") instead."));
      }
      if (this.collator && !i && this.hasUntypedArgument) {
        let l = Ze(a), u = Ze(s3);
        if (l.kind !== "string" || u.kind !== "string") return e(o, a, s3);
      }
      return this.collator ? t(o, a, s3, this.collator.evaluate(o)) : e(o, a, s3);
    }
    eachChild(o) {
      o(this.lhs), o(this.rhs), this.collator && o(this.collator);
    }
    outputDefined() {
      return true;
    }
  };
}
var c0 = ki("==", Qv, nm);
var p0 = ki("!=", e0, o0);
var h0 = ki("<", t0, a0);
var f0 = ki(">", r0, s0);
var m0 = ki("<=", i0, l0);
var d0 = ki(">=", n0, u0);
var is = class r23 {
  constructor(e, t, i) {
    this.type = cs, this.locale = i, this.caseSensitive = e, this.diacriticSensitive = t;
  }
  static parse(e, t) {
    if (e.length !== 2) return t.error("Expected one argument.");
    let i = e[1];
    if (typeof i != "object" || Array.isArray(i)) return t.error("Collator options argument must be an object.");
    let n = t.parse(i["case-sensitive"] === void 0 ? false : i["case-sensitive"], 1, ae);
    if (!n) return null;
    let o = t.parse(i["diacritic-sensitive"] === void 0 ? false : i["diacritic-sensitive"], 1, ae);
    if (!o) return null;
    let a = null;
    return i.locale && (a = t.parse(i.locale, 1, ce), !a) ? null : new r23(n, o, a);
  }
  evaluate(e) {
    return new In(this.caseSensitive.evaluate(e), this.diacriticSensitive.evaluate(e), this.locale ? this.locale.evaluate(e) : null);
  }
  eachChild(e) {
    e(this.caseSensitive), e(this.diacriticSensitive), this.locale && e(this.locale);
  }
  outputDefined() {
    return false;
  }
};
var Zc = class r24 {
  constructor(e, t, i, n, o) {
    this.type = ce, this.number = e, this.locale = t, this.currency = i, this.minFractionDigits = n, this.maxFractionDigits = o;
  }
  static parse(e, t) {
    if (e.length !== 3) return t.error("Expected two arguments.");
    let i = t.parse(e[1], 1, q2);
    if (!i) return null;
    let n = e[2];
    if (typeof n != "object" || Array.isArray(n)) return t.error("NumberFormat options argument must be an object.");
    let o = null;
    if (n.locale && (o = t.parse(n.locale, 1, ce), !o)) return null;
    let a = null;
    if (n.currency && (a = t.parse(n.currency, 1, ce), !a)) return null;
    let s3 = null;
    if (n["min-fraction-digits"] && (s3 = t.parse(n["min-fraction-digits"], 1, q2), !s3)) return null;
    let l = null;
    return n["max-fraction-digits"] && (l = t.parse(n["max-fraction-digits"], 1, q2), !l) ? null : new r24(i, o, a, s3, l);
  }
  evaluate(e) {
    return new Intl.NumberFormat(this.locale ? this.locale.evaluate(e) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(e) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(e) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(e) : void 0 }).format(this.number.evaluate(e));
  }
  eachChild(e) {
    e(this.number), this.locale && e(this.locale), this.currency && e(this.currency), this.minFractionDigits && e(this.minFractionDigits), this.maxFractionDigits && e(this.maxFractionDigits);
  }
  outputDefined() {
    return false;
  }
};
var kn = class r25 {
  constructor(e) {
    this.type = Ei, this.sections = e;
  }
  static parse(e, t) {
    if (e.length < 2) return t.error("Expected at least one argument.");
    let i = e[1];
    if (!Array.isArray(i) && typeof i == "object") return t.error("First argument must be an image or text section.");
    let n = [], o = false;
    for (let a = 1; a <= e.length - 1; ++a) {
      let s3 = e[a];
      if (o && typeof s3 == "object" && !Array.isArray(s3)) {
        o = false;
        let l = null;
        if (s3["font-scale"] && (l = t.parse(s3["font-scale"], 1, q2), !l)) return null;
        let u = null;
        if (s3["text-font"] && (u = t.parse(s3["text-font"], 1, bt(ce)), !u)) return null;
        let c3 = null;
        if (s3["text-color"] && (c3 = t.parse(s3["text-color"], 1, Mt), !c3)) return null;
        let p = n[n.length - 1];
        p.scale = l, p.font = u, p.textColor = c3;
      } else {
        let l = t.parse(e[a], 1, se);
        if (!l) return null;
        let u = l.type.kind;
        if (u !== "string" && u !== "value" && u !== "null" && u !== "resolvedImage") return t.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
        o = true, n.push({ content: l, scale: null, font: null, textColor: null });
      }
    }
    return new r25(n);
  }
  evaluate(e) {
    let t = (i) => {
      let n = i.content.evaluate(e);
      return Ze(n) === Vn ? new Cn("", n, null, null, null) : new Cn(Pn(n), null, i.scale ? i.scale.evaluate(e) : null, i.font ? i.font.evaluate(e).join(",") : null, i.textColor ? i.textColor.evaluate(e) : null);
    };
    return new vt(this.sections.map(t));
  }
  eachChild(e) {
    for (let t of this.sections) e(t.content), t.scale && e(t.scale), t.font && e(t.font), t.textColor && e(t.textColor);
  }
  outputDefined() {
    return false;
  }
};
var Hc = class r26 {
  constructor(e) {
    this.type = Vn, this.input = e;
  }
  static parse(e, t) {
    if (e.length !== 2) return t.error("Expected two arguments.");
    let i = t.parse(e[1], 1, ce);
    return i ? new r26(i) : t.error("No image name provided.");
  }
  evaluate(e) {
    let t = this.input.evaluate(e), i = ht.fromString(t);
    return i && e.availableImages && (i.available = e.availableImages.indexOf(t) > -1), i;
  }
  eachChild(e) {
    e(this.input);
  }
  outputDefined() {
    return false;
  }
};
var $c = class r27 {
  constructor(e) {
    this.type = q2, this.input = e;
  }
  static parse(e, t) {
    if (e.length !== 2) return t.error("Expected 1 argument, but found ".concat(e.length - 1, " instead."));
    let i = t.parse(e[1], 1);
    return i ? i.type.kind !== "array" && i.type.kind !== "string" && i.type.kind !== "value" ? t.error("Expected argument of type string or array, but found ".concat(Fe(i.type), " instead.")) : new r27(i) : null;
  }
  evaluate(e) {
    let t = this.input.evaluate(e);
    if (typeof t == "string") return t.length;
    if (Array.isArray(t)) return t.length;
    throw new Re("Expected value to be of type string or array, but found ".concat(Fe(Ze(t)), " instead."));
  }
  eachChild(e) {
    e(this.input);
  }
  outputDefined() {
    return false;
  }
};
var Bt = 8192;
function y0(r50, e) {
  let t = g0(r50[0]), i = b0(r50[1]), n = Math.pow(2, e.z);
  return [Math.round(t * n * Bt), Math.round(i * n * Bt)];
}
function rp(r50, e) {
  let t = Math.pow(2, e.z), i = (r50[0] / Bt + e.x) / t, n = (r50[1] / Bt + e.y) / t;
  return [x0(i), _0(n)];
}
function g0(r50) {
  return (180 + r50) / 360;
}
function x0(r50) {
  return r50 * 360 - 180;
}
function b0(r50) {
  return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + r50 * Math.PI / 360))) / 360;
}
function _0(r50) {
  return 360 / Math.PI * Math.atan(Math.exp((180 - r50 * 360) * Math.PI / 180)) - 90;
}
function Un(r50, e) {
  r50[0] = Math.min(r50[0], e[0]), r50[1] = Math.min(r50[1], e[1]), r50[2] = Math.max(r50[2], e[0]), r50[3] = Math.max(r50[3], e[1]);
}
function Ln(r50, e) {
  return !(r50[0] <= e[0] || r50[2] >= e[2] || r50[1] <= e[1] || r50[3] >= e[3]);
}
function v0(r50, e, t) {
  return e[1] > r50[1] != t[1] > r50[1] && r50[0] < (t[0] - e[0]) * (r50[1] - e[1]) / (t[1] - e[1]) + e[0];
}
function w0(r50, e, t) {
  let i = r50[0] - e[0], n = r50[1] - e[1], o = r50[0] - t[0], a = r50[1] - t[1];
  return i * a - o * n === 0 && i * o <= 0 && n * a <= 0;
}
function ms(r50, e, t, i) {
  let n = [e[0] - r50[0], e[1] - r50[1]], o = [i[0] - t[0], i[1] - t[1]];
  return A0(o, n) === 0 ? false : !!(Cf(r50, e, t, i) && Cf(t, i, r50, e));
}
function S0(r50, e, t) {
  for (let i of t) for (let n = 0; n < i.length - 1; ++n) if (ms(r50, e, i[n], i[n + 1])) return true;
  return false;
}
function Li(r50, e, t = false) {
  let i = false;
  for (let n of e) for (let o = 0; o < n.length - 1; o++) {
    if (w0(r50, n[o], n[o + 1])) return t;
    v0(r50, n[o], n[o + 1]) && (i = !i);
  }
  return i;
}
function P0(r50, e) {
  for (let t of e) if (Li(r50, t)) return true;
  return false;
}
function am(r50, e) {
  for (let t of r50) if (!Li(t, e)) return false;
  for (let t = 0; t < r50.length - 1; ++t) if (S0(r50[t], r50[t + 1], e)) return false;
  return true;
}
function T0(r50, e) {
  for (let t of e) if (am(r50, t)) return true;
  return false;
}
function A0(r50, e) {
  return r50[0] * e[1] - r50[1] * e[0];
}
function Cf(r50, e, t, i) {
  let n = r50[0] - t[0], o = r50[1] - t[1], a = e[0] - t[0], s3 = e[1] - t[1], l = i[0] - t[0], u = i[1] - t[1], c3 = n * u - l * o, p = a * u - l * s3;
  return c3 > 0 && p < 0 || c3 < 0 && p > 0;
}
function ip(r50, e, t) {
  let i = [];
  for (let n = 0; n < r50.length; n++) {
    let o = [];
    for (let a = 0; a < r50[n].length; a++) {
      let s3 = y0(r50[n][a], t);
      Un(e, s3), o.push(s3);
    }
    i.push(o);
  }
  return i;
}
function sm(r50, e, t) {
  let i = [];
  for (let n = 0; n < r50.length; n++) {
    let o = ip(r50[n], e, t);
    i.push(o);
  }
  return i;
}
function lm(r50, e, t, i) {
  if (r50[0] < t[0] || r50[0] > t[2]) {
    let n = i * 0.5, o = r50[0] - t[0] > n ? -i : t[0] - r50[0] > n ? i : 0;
    o === 0 && (o = r50[0] - t[2] > n ? -i : t[2] - r50[0] > n ? i : 0), r50[0] += o;
  }
  Un(e, r50);
}
function M0(r50) {
  r50[0] = r50[1] = 1 / 0, r50[2] = r50[3] = -1 / 0;
}
function Ef(r50, e, t, i) {
  let n = Math.pow(2, i.z) * Bt, o = [i.x * Bt, i.y * Bt], a = [];
  for (let s3 of r50) for (let l of s3) {
    let u = [l.x + o[0], l.y + o[1]];
    lm(u, e, t, n), a.push(u);
  }
  return a;
}
function kf(r50, e, t, i) {
  let n = Math.pow(2, i.z) * Bt, o = [i.x * Bt, i.y * Bt], a = [];
  for (let s3 of r50) {
    let l = [];
    for (let u of s3) {
      let c3 = [u.x + o[0], u.y + o[1]];
      Un(e, c3), l.push(c3);
    }
    a.push(l);
  }
  if (e[2] - e[0] <= n / 2) {
    M0(e);
    for (let s3 of a) for (let l of s3) lm(l, e, t, n);
  }
  return a;
}
function I0(r50, e) {
  let t = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n = r50.canonicalID();
  if (e.type === "Polygon") {
    let o = ip(e.coordinates, i, n), a = Ef(r50.geometry(), t, i, n);
    if (!Ln(t, i)) return false;
    for (let s3 of a) if (!Li(s3, o)) return false;
  }
  if (e.type === "MultiPolygon") {
    let o = sm(e.coordinates, i, n), a = Ef(r50.geometry(), t, i, n);
    if (!Ln(t, i)) return false;
    for (let s3 of a) if (!P0(s3, o)) return false;
  }
  return true;
}
function C0(r50, e) {
  let t = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n = r50.canonicalID();
  if (e.type === "Polygon") {
    let o = ip(e.coordinates, i, n), a = kf(r50.geometry(), t, i, n);
    if (!Ln(t, i)) return false;
    for (let s3 of a) if (!am(s3, o)) return false;
  }
  if (e.type === "MultiPolygon") {
    let o = sm(e.coordinates, i, n), a = kf(r50.geometry(), t, i, n);
    if (!Ln(t, i)) return false;
    for (let s3 of a) if (!T0(s3, o)) return false;
  }
  return true;
}
var Dn = class r28 {
  constructor(e, t) {
    this.type = ae, this.geojson = e, this.geometries = t;
  }
  static parse(e, t) {
    if (e.length !== 2) return t.error("'within' expression requires exactly one argument, but found ".concat(e.length - 1, " instead."));
    if (En(e[1])) {
      let i = e[1];
      if (i.type === "FeatureCollection") {
        let n = [];
        for (let o of i.features) {
          let { type: a, coordinates: s3 } = o.geometry;
          a === "Polygon" && n.push(s3), a === "MultiPolygon" && n.push(...s3);
        }
        if (n.length) {
          let o = { type: "MultiPolygon", coordinates: n };
          return new r28(i, o);
        }
      } else if (i.type === "Feature") {
        let n = i.geometry.type;
        if (n === "Polygon" || n === "MultiPolygon") return new r28(i, i.geometry);
      } else if (i.type === "Polygon" || i.type === "MultiPolygon") return new r28(i, i);
    }
    return t.error("'within' expression requires valid geojson object that contains polygon geometry type.");
  }
  evaluate(e) {
    if (e.geometry() != null && e.canonicalID() != null) {
      if (e.geometryType() === "Point") return I0(e, this.geometries);
      if (e.geometryType() === "LineString") return C0(e, this.geometries);
    }
    return false;
  }
  eachChild() {
  }
  outputDefined() {
    return true;
  }
};
var ns = class {
  constructor(e = [], t = E0) {
    if (this.data = e, this.length = this.data.length, this.compare = t, this.length > 0) for (let i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);
  }
  push(e) {
    this.data.push(e), this.length++, this._up(this.length - 1);
  }
  pop() {
    if (this.length === 0) return;
    let e = this.data[0], t = this.data.pop();
    return this.length--, this.length > 0 && (this.data[0] = t, this._down(0)), e;
  }
  peek() {
    return this.data[0];
  }
  _up(e) {
    let { data: t, compare: i } = this, n = t[e];
    for (; e > 0; ) {
      let o = e - 1 >> 1, a = t[o];
      if (i(n, a) >= 0) break;
      t[e] = a, e = o;
    }
    t[e] = n;
  }
  _down(e) {
    let { data: t, compare: i } = this, n = this.length >> 1, o = t[e];
    for (; e < n; ) {
      let a = (e << 1) + 1, s3 = t[a], l = a + 1;
      if (l < this.length && i(t[l], s3) < 0 && (a = l, s3 = t[l]), i(s3, o) >= 0) break;
      t[e] = s3, e = a;
    }
    t[e] = o;
  }
};
function E0(r50, e) {
  return r50 < e ? -1 : r50 > e ? 1 : 0;
}
function k0(r50, e, t, i, n) {
  um(r50, e, t, i || r50.length - 1, n || L0);
}
function um(r50, e, t, i, n) {
  for (; i > t; ) {
    if (i - t > 600) {
      var o = i - t + 1, a = e - t + 1, s3 = Math.log(o), l = 0.5 * Math.exp(2 * s3 / 3), u = 0.5 * Math.sqrt(s3 * l * (o - l) / o) * (a - o / 2 < 0 ? -1 : 1), c3 = Math.max(t, Math.floor(e - a * l / o + u)), p = Math.min(i, Math.floor(e + (o - a) * l / o + u));
      um(r50, e, c3, p, n);
    }
    var h = r50[e], f = t, d = i;
    for (Sn(r50, t, e), n(r50[i], h) > 0 && Sn(r50, t, i); f < d; ) {
      for (Sn(r50, f, d), f++, d--; n(r50[f], h) < 0; ) f++;
      for (; n(r50[d], h) > 0; ) d--;
    }
    n(r50[t], h) === 0 ? Sn(r50, t, d) : (d++, Sn(r50, d, i)), d <= e && (t = d + 1), e <= d && (i = d - 1);
  }
}
function Sn(r50, e, t) {
  var i = r50[e];
  r50[e] = r50[t], r50[t] = i;
}
function L0(r50, e) {
  return r50 < e ? -1 : r50 > e ? 1 : 0;
}
function D0(r50, e) {
  if (r50.length <= 1) return [r50];
  let i = [], n, o;
  for (let a of r50) {
    let s3 = F0(a);
    s3 !== 0 && (a.area = Math.abs(s3), o === void 0 && (o = s3 < 0), o === s3 < 0 ? (n && i.push(n), n = [a]) : n.push(a));
  }
  if (n && i.push(n), e > 1) for (let a = 0; a < i.length; a++) i[a].length <= e || (k0(i[a], e, 1, i[a].length - 1, z0), i[a] = i[a].slice(0, e));
  return i;
}
function z0(r50, e) {
  return e.area - r50.area;
}
function F0(r50) {
  let e = 0;
  for (let t = 0, i = r50.length, n = i - 1, o, a; t < i; n = t++) o = r50[t], a = r50[n], e += (a.x - o.x) * (o.y + a.y);
  return e;
}
var R0 = 6378.137;
var Lf = 1 / 298.257223563;
var Df = Lf * (2 - Lf);
var zf = Math.PI / 180;
var zn = class {
  constructor(e) {
    let t = zf * R0 * 1e3, i = Math.cos(e * zf), n = 1 / (1 - Df * (1 - i * i)), o = Math.sqrt(n);
    this.kx = t * o * i, this.ky = t * o * n * (1 - Df);
  }
  distance(e, t) {
    let i = this.wrap(e[0] - t[0]) * this.kx, n = (e[1] - t[1]) * this.ky;
    return Math.sqrt(i * i + n * n);
  }
  pointOnLine(e, t) {
    let i = 1 / 0, n, o, a, s3;
    for (let l = 0; l < e.length - 1; l++) {
      let u = e[l][0], c3 = e[l][1], p = this.wrap(e[l + 1][0] - u) * this.kx, h = (e[l + 1][1] - c3) * this.ky, f = 0;
      (p !== 0 || h !== 0) && (f = (this.wrap(t[0] - u) * this.kx * p + (t[1] - c3) * this.ky * h) / (p * p + h * h), f > 1 ? (u = e[l + 1][0], c3 = e[l + 1][1]) : f > 0 && (u += p / this.kx * f, c3 += h / this.ky * f)), p = this.wrap(t[0] - u) * this.kx, h = (t[1] - c3) * this.ky;
      let d = p * p + h * h;
      d < i && (i = d, n = u, o = c3, a = l, s3 = f);
    }
    return { point: [n, o], index: a, t: Math.max(0, Math.min(1, s3)) };
  }
  wrap(e) {
    for (; e < -180; ) e += 360;
    for (; e > 180; ) e -= 360;
    return e;
  }
};
var Wc = 100;
var Xc = 50;
function cm(r50, e) {
  return e[0] - r50[0];
}
function os(r50) {
  return r50[1] - r50[0] + 1;
}
function tr(r50, e) {
  return r50[1] >= r50[0] && r50[1] < e;
}
function Kc(r50, e) {
  if (r50[0] > r50[1]) return [null, null];
  let t = os(r50);
  if (e) {
    if (t === 2) return [r50, null];
    let n = Math.floor(t / 2);
    return [[r50[0], r50[0] + n], [r50[0] + n, r50[1]]];
  }
  if (t === 1) return [r50, null];
  let i = Math.floor(t / 2) - 1;
  return [[r50[0], r50[0] + i], [r50[0] + i + 1, r50[1]]];
}
function Jc(r50, e) {
  if (!tr(e, r50.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
  let t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
  for (let i = e[0]; i <= e[1]; ++i) Un(t, r50[i]);
  return t;
}
function Yc(r50) {
  let e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
  for (let t of r50) for (let i of t) Un(e, i);
  return e;
}
function Ff(r50) {
  return r50[0] !== -1 / 0 && r50[1] !== -1 / 0 && r50[2] !== 1 / 0 && r50[3] !== 1 / 0;
}
function np(r50, e, t) {
  if (!Ff(r50) || !Ff(e)) return NaN;
  let i = 0, n = 0;
  return r50[2] < e[0] && (i = e[0] - r50[2]), r50[0] > e[2] && (i = r50[0] - e[2]), r50[1] > e[3] && (n = r50[1] - e[3]), r50[3] < e[1] && (n = e[1] - r50[3]), t.distance([0, 0], [i, n]);
}
function Zr(r50, e, t) {
  let i = t.pointOnLine(e, r50);
  return t.distance(r50, i.point);
}
function op(r50, e, t, i, n) {
  let o = Math.min(Zr(r50, [t, i], n), Zr(e, [t, i], n)), a = Math.min(Zr(t, [r50, e], n), Zr(i, [r50, e], n));
  return Math.min(o, a);
}
function B0(r50, e, t, i, n) {
  if (!(tr(e, r50.length) && tr(i, t.length))) return 1 / 0;
  let a = 1 / 0;
  for (let s3 = e[0]; s3 < e[1]; ++s3) {
    let l = r50[s3], u = r50[s3 + 1];
    for (let c3 = i[0]; c3 < i[1]; ++c3) {
      let p = t[c3], h = t[c3 + 1];
      if (ms(l, u, p, h)) return 0;
      a = Math.min(a, op(l, u, p, h, n));
    }
  }
  return a;
}
function O0(r50, e, t, i, n) {
  if (!(tr(e, r50.length) && tr(i, t.length))) return NaN;
  let a = 1 / 0;
  for (let s3 = e[0]; s3 <= e[1]; ++s3) for (let l = i[0]; l <= i[1]; ++l) if (a = Math.min(a, n.distance(r50[s3], t[l])), a === 0) return a;
  return a;
}
function V0(r50, e, t) {
  if (Li(r50, e, true)) return 0;
  let i = 1 / 0;
  for (let n of e) {
    let o = n[0], a = n[n.length - 1];
    if (o !== a && (i = Math.min(i, Zr(r50, [a, o], t)), i === 0)) return i;
    let s3 = t.pointOnLine(n, r50);
    if (i = Math.min(i, t.distance(r50, s3.point)), i === 0) return i;
  }
  return i;
}
function U0(r50, e, t, i) {
  if (!tr(e, r50.length)) return NaN;
  for (let o = e[0]; o <= e[1]; ++o) if (Li(r50[o], t, true)) return 0;
  let n = 1 / 0;
  for (let o = e[0]; o < e[1]; ++o) {
    let a = r50[o], s3 = r50[o + 1];
    for (let l of t) for (let u = 0, c3 = l.length, p = c3 - 1; u < c3; p = u++) {
      let h = l[p], f = l[u];
      if (ms(a, s3, h, f)) return 0;
      n = Math.min(n, op(a, s3, h, f, i));
    }
  }
  return n;
}
function Rf(r50, e) {
  for (let t of r50) for (let i of t) if (Li(i, e, true)) return true;
  return false;
}
function N0(r50, e, t, i = 1 / 0) {
  let n = Yc(r50), o = Yc(e);
  if (i !== 1 / 0 && np(n, o, t) >= i) return i;
  if (Ln(n, o)) {
    if (Rf(r50, e)) return 0;
  } else if (Rf(e, r50)) return 0;
  let a = 1 / 0;
  for (let s3 of r50) for (let l = 0, u = s3.length, c3 = u - 1; l < u; c3 = l++) {
    let p = s3[c3], h = s3[l];
    for (let f of e) for (let d = 0, y = f.length, g = y - 1; d < y; g = d++) {
      let x = f[g], v = f[d];
      if (ms(p, h, x, v)) return 0;
      a = Math.min(a, op(p, h, x, v, t));
    }
  }
  return a;
}
function Bf(r50, e, t, i, n, o) {
  if (!o) return;
  let a = np(Jc(i, o), n, t);
  a < e && r50.push([a, o, [0, 0]]);
}
function Wa(r50, e, t, i, n, o, a) {
  if (!o || !a) return;
  let s3 = np(Jc(i, o), Jc(n, a), t);
  s3 < e && r50.push([s3, o, a]);
}
function as(r50, e, t, i, n = 1 / 0) {
  let o = Math.min(i.distance(r50[0], t[0][0]), n);
  if (o === 0) return o;
  let a = new ns([[0, [0, r50.length - 1], [0, 0]]], cm), s3 = Yc(t);
  for (; a.length > 0; ) {
    let l = a.pop();
    if (l[0] >= o) continue;
    let u = l[1], c3 = e ? Xc : Wc;
    if (os(u) <= c3) {
      if (!tr(u, r50.length)) return NaN;
      if (e) {
        let p = U0(r50, u, t, i);
        if (isNaN(p) || p === 0) return p;
        o = Math.min(o, p);
      } else for (let p = u[0]; p <= u[1]; ++p) {
        let h = V0(r50[p], t, i);
        if (o = Math.min(o, h), o === 0) return 0;
      }
    } else {
      let p = Kc(u, e);
      Bf(a, o, i, r50, s3, p[0]), Bf(a, o, i, r50, s3, p[1]);
    }
  }
  return o;
}
function ss(r50, e, t, i, n, o = 1 / 0) {
  let a = Math.min(o, n.distance(r50[0], t[0]));
  if (a === 0) return a;
  let s3 = new ns([[0, [0, r50.length - 1], [0, t.length - 1]]], cm);
  for (; s3.length > 0; ) {
    let l = s3.pop();
    if (l[0] >= a) continue;
    let u = l[1], c3 = l[2], p = e ? Xc : Wc, h = i ? Xc : Wc;
    if (os(u) <= p && os(c3) <= h) {
      if (!tr(u, r50.length) && tr(c3, t.length)) return NaN;
      let f;
      if (e && i) f = B0(r50, u, t, c3, n), a = Math.min(a, f);
      else if (e && !i) {
        let d = r50.slice(u[0], u[1] + 1);
        for (let y = c3[0]; y <= c3[1]; ++y) if (f = Zr(t[y], d, n), a = Math.min(a, f), a === 0) return a;
      } else if (!e && i) {
        let d = t.slice(c3[0], c3[1] + 1);
        for (let y = u[0]; y <= u[1]; ++y) if (f = Zr(r50[y], d, n), a = Math.min(a, f), a === 0) return a;
      } else f = O0(r50, u, t, c3, n), a = Math.min(a, f);
    } else {
      let f = Kc(u, e), d = Kc(c3, i);
      Wa(s3, a, n, r50, t, f[0], d[0]), Wa(s3, a, n, r50, t, f[0], d[1]), Wa(s3, a, n, r50, t, f[1], d[0]), Wa(s3, a, n, r50, t, f[1], d[1]);
    }
  }
  return a;
}
function G0(r50, e) {
  let t = r50.geometry(), i = t.flat().map((a) => rp([a.x, a.y], r50.canonical));
  if (t.length === 0) return NaN;
  let n = new zn(i[0][1]), o = 1 / 0;
  for (let a of e) {
    switch (a.type) {
      case "Point":
        o = Math.min(o, ss(i, false, [a.coordinates], false, n, o));
        break;
      case "LineString":
        o = Math.min(o, ss(i, false, a.coordinates, true, n, o));
        break;
      case "Polygon":
        o = Math.min(o, as(i, false, a.coordinates, n, o));
        break;
    }
    if (o === 0) return o;
  }
  return o;
}
function q0(r50, e) {
  let t = r50.geometry(), i = t.flat().map((a) => rp([a.x, a.y], r50.canonical));
  if (t.length === 0) return NaN;
  let n = new zn(i[0][1]), o = 1 / 0;
  for (let a of e) {
    switch (a.type) {
      case "Point":
        o = Math.min(o, ss(i, true, [a.coordinates], false, n, o));
        break;
      case "LineString":
        o = Math.min(o, ss(i, true, a.coordinates, true, n, o));
        break;
      case "Polygon":
        o = Math.min(o, as(i, true, a.coordinates, n, o));
        break;
    }
    if (o === 0) return o;
  }
  return o;
}
function j0(r50, e) {
  let t = r50.geometry();
  if (t.length === 0 || t[0].length === 0) return NaN;
  let i = D0(t, 0).map((a) => a.map((s3) => s3.map((l) => rp([l.x, l.y], r50.canonical)))), n = new zn(i[0][0][0][1]), o = 1 / 0;
  for (let a of e) for (let s3 of i) {
    switch (a.type) {
      case "Point":
        o = Math.min(o, as([a.coordinates], false, s3, n, o));
        break;
      case "LineString":
        o = Math.min(o, as(a.coordinates, true, s3, n, o));
        break;
      case "Polygon":
        o = Math.min(o, N0(s3, a.coordinates, n, o));
        break;
    }
    if (o === 0) return o;
  }
  return o;
}
function Fc(r50) {
  return r50.type === "MultiPolygon" ? r50.coordinates.map((e) => ({ type: "Polygon", coordinates: e })) : r50.type === "MultiLineString" ? r50.coordinates.map((e) => ({ type: "LineString", coordinates: e })) : r50.type === "MultiPoint" ? r50.coordinates.map((e) => ({ type: "Point", coordinates: e })) : [r50];
}
var Fn = class r29 {
  constructor(e, t) {
    this.type = q2, this.geojson = e, this.geometries = t;
  }
  static parse(e, t) {
    if (e.length !== 2) return t.error("'distance' expression requires exactly one argument, but found ".concat(e.length - 1, " instead."));
    if (En(e[1])) {
      let i = e[1];
      if (i.type === "FeatureCollection") return new r29(i, i.features.map((n) => Fc(n.geometry)).flat());
      if (i.type === "Feature") return new r29(i, Fc(i.geometry));
      if ("type" in i && "coordinates" in i) return new r29(i, Fc(i));
    }
    return t.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
  }
  evaluate(e) {
    if (e.geometry() != null && e.canonicalID() != null) {
      if (e.geometryType() === "Point") return G0(e, this.geometries);
      if (e.geometryType() === "LineString") return q0(e, this.geometries);
      if (e.geometryType() === "Polygon") return j0(e, this.geometries);
    }
    return NaN;
  }
  eachChild() {
  }
  outputDefined() {
    return true;
  }
};
var Kr = { "==": c0, "!=": p0, ">": f0, "<": h0, ">=": d0, "<=": m0, array: Dt, at: Vc, boolean: Dt, case: qc, coalesce: rs, collator: is, format: kn, image: Hc, in: Uc, "index-of": Nc, interpolate: _t, "interpolate-hcl": _t, "interpolate-lab": _t, length: $c, let: Qa, literal: yr, match: Gc, number: Dt, "number-format": Zc, object: Dt, slice: jc, step: Mi, string: Dt, "to-boolean": dr, "to-color": dr, "to-number": dr, "to-string": dr, var: es, within: Dn, distance: Fn };
var Ot = class r30 {
  constructor(e, t, i, n) {
    this.name = e, this.type = t, this._evaluate = i, this.args = n;
  }
  evaluate(e) {
    return this._evaluate(e, this.args);
  }
  eachChild(e) {
    this.args.forEach(e);
  }
  outputDefined() {
    return false;
  }
  static parse(e, t) {
    let i = e[0], n = r30.definitions[i];
    if (!n) return t.error('Unknown expression "'.concat(i, '". If you wanted a literal array, use ["literal", [...]].'), 0);
    let o = Array.isArray(n) ? n[0] : n.type, a = Array.isArray(n) ? [[n[1], n[2]]] : n.overloads, s3 = a.filter(([u]) => !Array.isArray(u) || u.length === e.length - 1), l = null;
    for (let [u, c3] of s3) {
      l = new Ya(t.registry, ls, t.path, null, t.scope);
      let p = [], h = false;
      for (let f = 1; f < e.length; f++) {
        let d = e[f], y = Array.isArray(u) ? u[f - 1] : u.type, g = l.parse(d, 1 + p.length, y);
        if (!g) {
          h = true;
          break;
        }
        p.push(g);
      }
      if (!h) {
        if (Array.isArray(u) && u.length !== p.length) {
          l.error("Expected ".concat(u.length, " arguments, but found ").concat(p.length, " instead."));
          continue;
        }
        for (let f = 0; f < p.length; f++) {
          let d = Array.isArray(u) ? u[f] : u.type, y = p[f];
          l.concat(f + 1).checkSubtype(d, y.type);
        }
        if (l.errors.length === 0) return new r30(i, o, c3, p);
      }
    }
    if (s3.length === 1) t.errors.push(...l.errors);
    else {
      let c3 = (s3.length ? s3 : a).map(([h]) => H0(h)).join(" | "), p = [];
      for (let h = 1; h < e.length; h++) {
        let f = t.parse(e[h], 1 + p.length);
        if (!f) return null;
        p.push(Fe(f.type));
      }
      t.error("Expected arguments of type ".concat(c3, ", but found (").concat(p.join(", "), ") instead."));
    }
    return null;
  }
  static register(e, t) {
    r30.definitions = t;
    for (let i in t) e[i] = r30;
  }
};
function Of(r50, [e, t, i, n]) {
  e = e.evaluate(r50), t = t.evaluate(r50), i = i.evaluate(r50);
  let o = n ? n.evaluate(r50) : 1, a = rm(e, t, i, o);
  if (a) throw new Re(a);
  return new W(e / 255, t / 255, i / 255, o, false);
}
function Vf(r50, e) {
  return r50 in e;
}
function Rc(r50, e) {
  let t = e[r50];
  return typeof t > "u" ? null : t;
}
function Z0(r50, e, t, i) {
  for (; t <= i; ) {
    let n = t + i >> 1;
    if (e[n] === r50) return true;
    e[n] > r50 ? i = n - 1 : t = n + 1;
  }
  return false;
}
function jr(r50) {
  return { type: r50 };
}
Ot.register(Kr, { error: [zv, [ce], (r50, [e]) => {
  throw new Re(e.evaluate(r50));
}], typeof: [ce, [se], (r50, [e]) => Fe(Ze(e.evaluate(r50)))], "to-rgba": [bt(q2, 4), [Mt], (r50, [e]) => {
  let [t, i, n, o] = e.evaluate(r50).rgb;
  return [t * 255, i * 255, n * 255, o];
}], rgb: [Mt, [q2, q2, q2], Of], rgba: [Mt, [q2, q2, q2, q2], Of], has: { type: ae, overloads: [[[ce], (r50, [e]) => Vf(e.evaluate(r50), r50.properties())], [[ce, Pi], (r50, [e, t]) => Vf(e.evaluate(r50), t.evaluate(r50))]] }, get: { type: se, overloads: [[[ce], (r50, [e]) => Rc(e.evaluate(r50), r50.properties())], [[ce, Pi], (r50, [e, t]) => Rc(e.evaluate(r50), t.evaluate(r50))]] }, "feature-state": [se, [ce], (r50, [e]) => Rc(e.evaluate(r50), r50.featureState || {})], properties: [Pi, [], (r50) => r50.properties()], "geometry-type": [ce, [], (r50) => r50.geometryType()], id: [se, [], (r50) => r50.id()], zoom: [q2, [], (r50) => r50.globals.zoom], "heatmap-density": [q2, [], (r50) => r50.globals.heatmapDensity || 0], "line-progress": [q2, [], (r50) => r50.globals.lineProgress || 0], accumulated: [se, [], (r50) => r50.globals.accumulated === void 0 ? null : r50.globals.accumulated], "+": [q2, jr(q2), (r50, e) => {
  let t = 0;
  for (let i of e) t += i.evaluate(r50);
  return t;
}], "*": [q2, jr(q2), (r50, e) => {
  let t = 1;
  for (let i of e) t *= i.evaluate(r50);
  return t;
}], "-": { type: q2, overloads: [[[q2, q2], (r50, [e, t]) => e.evaluate(r50) - t.evaluate(r50)], [[q2], (r50, [e]) => -e.evaluate(r50)]] }, "/": [q2, [q2, q2], (r50, [e, t]) => e.evaluate(r50) / t.evaluate(r50)], "%": [q2, [q2, q2], (r50, [e, t]) => e.evaluate(r50) % t.evaluate(r50)], ln2: [q2, [], () => Math.LN2], pi: [q2, [], () => Math.PI], e: [q2, [], () => Math.E], "^": [q2, [q2, q2], (r50, [e, t]) => Math.pow(e.evaluate(r50), t.evaluate(r50))], sqrt: [q2, [q2], (r50, [e]) => Math.sqrt(e.evaluate(r50))], log10: [q2, [q2], (r50, [e]) => Math.log(e.evaluate(r50)) / Math.LN10], ln: [q2, [q2], (r50, [e]) => Math.log(e.evaluate(r50))], log2: [q2, [q2], (r50, [e]) => Math.log(e.evaluate(r50)) / Math.LN2], sin: [q2, [q2], (r50, [e]) => Math.sin(e.evaluate(r50))], cos: [q2, [q2], (r50, [e]) => Math.cos(e.evaluate(r50))], tan: [q2, [q2], (r50, [e]) => Math.tan(e.evaluate(r50))], asin: [q2, [q2], (r50, [e]) => Math.asin(e.evaluate(r50))], acos: [q2, [q2], (r50, [e]) => Math.acos(e.evaluate(r50))], atan: [q2, [q2], (r50, [e]) => Math.atan(e.evaluate(r50))], min: [q2, jr(q2), (r50, e) => Math.min(...e.map((t) => t.evaluate(r50)))], max: [q2, jr(q2), (r50, e) => Math.max(...e.map((t) => t.evaluate(r50)))], abs: [q2, [q2], (r50, [e]) => Math.abs(e.evaluate(r50))], round: [q2, [q2], (r50, [e]) => {
  let t = e.evaluate(r50);
  return t < 0 ? -Math.round(-t) : Math.round(t);
}], floor: [q2, [q2], (r50, [e]) => Math.floor(e.evaluate(r50))], ceil: [q2, [q2], (r50, [e]) => Math.ceil(e.evaluate(r50))], "filter-==": [ae, [ce, se], (r50, [e, t]) => r50.properties()[e.value] === t.value], "filter-id-==": [ae, [se], (r50, [e]) => r50.id() === e.value], "filter-type-==": [ae, [ce], (r50, [e]) => r50.geometryType() === e.value], "filter-<": [ae, [ce, se], (r50, [e, t]) => {
  let i = r50.properties()[e.value], n = t.value;
  return typeof i == typeof n && i < n;
}], "filter-id-<": [ae, [se], (r50, [e]) => {
  let t = r50.id(), i = e.value;
  return typeof t == typeof i && t < i;
}], "filter->": [ae, [ce, se], (r50, [e, t]) => {
  let i = r50.properties()[e.value], n = t.value;
  return typeof i == typeof n && i > n;
}], "filter-id->": [ae, [se], (r50, [e]) => {
  let t = r50.id(), i = e.value;
  return typeof t == typeof i && t > i;
}], "filter-<=": [ae, [ce, se], (r50, [e, t]) => {
  let i = r50.properties()[e.value], n = t.value;
  return typeof i == typeof n && i <= n;
}], "filter-id-<=": [ae, [se], (r50, [e]) => {
  let t = r50.id(), i = e.value;
  return typeof t == typeof i && t <= i;
}], "filter->=": [ae, [ce, se], (r50, [e, t]) => {
  let i = r50.properties()[e.value], n = t.value;
  return typeof i == typeof n && i >= n;
}], "filter-id->=": [ae, [se], (r50, [e]) => {
  let t = r50.id(), i = e.value;
  return typeof t == typeof i && t >= i;
}], "filter-has": [ae, [se], (r50, [e]) => e.value in r50.properties()], "filter-has-id": [ae, [], (r50) => r50.id() !== null && r50.id() !== void 0], "filter-type-in": [ae, [bt(ce)], (r50, [e]) => e.value.indexOf(r50.geometryType()) >= 0], "filter-id-in": [ae, [bt(se)], (r50, [e]) => e.value.indexOf(r50.id()) >= 0], "filter-in-small": [ae, [ce, bt(se)], (r50, [e, t]) => t.value.indexOf(r50.properties()[e.value]) >= 0], "filter-in-large": [ae, [ce, bt(se)], (r50, [e, t]) => Z0(r50.properties()[e.value], t.value, 0, t.value.length - 1)], all: { type: ae, overloads: [[[ae, ae], (r50, [e, t]) => e.evaluate(r50) && t.evaluate(r50)], [jr(ae), (r50, e) => {
  for (let t of e) if (!t.evaluate(r50)) return false;
  return true;
}]] }, any: { type: ae, overloads: [[[ae, ae], (r50, [e, t]) => e.evaluate(r50) || t.evaluate(r50)], [jr(ae), (r50, e) => {
  for (let t of e) if (t.evaluate(r50)) return true;
  return false;
}]] }, "!": [ae, [ae], (r50, [e]) => !e.evaluate(r50)], "is-supported-script": [ae, [ce], (r50, [e]) => {
  let t = r50.globals && r50.globals.isSupportedScript;
  return t ? t(e.evaluate(r50)) : true;
}], upcase: [ce, [ce], (r50, [e]) => e.evaluate(r50).toUpperCase()], downcase: [ce, [ce], (r50, [e]) => e.evaluate(r50).toLowerCase()], concat: [ce, jr(se), (r50, e) => e.map((t) => Pn(t.evaluate(r50))).join("")], "resolved-locale": [ce, [cs], (r50, [e]) => e.evaluate(r50).resolvedLocale()] });
function H0(r50) {
  return Array.isArray(r50) ? "(".concat(r50.map(Fe).join(", "), ")") : "(".concat(Fe(r50.type), "...)");
}
function ls(r50) {
  if (r50 instanceof es) return ls(r50.boundExpression);
  if (r50 instanceof Ot && r50.name === "error") return false;
  if (r50 instanceof is) return false;
  if (r50 instanceof Dn) return false;
  if (r50 instanceof Fn) return false;
  let e = r50 instanceof dr || r50 instanceof Dt, t = true;
  return r50.eachChild((i) => {
    e ? t = t && ls(i) : t = t && i instanceof yr;
  }), t ? ds(r50) && ys(r50, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]) : false;
}
function ds(r50) {
  if (r50 instanceof Ot) {
    if (r50.name === "get" && r50.args.length === 1) return false;
    if (r50.name === "feature-state") return false;
    if (r50.name === "has" && r50.args.length === 1) return false;
    if (r50.name === "properties" || r50.name === "geometry-type" || r50.name === "id") return false;
    if (/^filter-/.test(r50.name)) return false;
  }
  if (r50 instanceof Dn || r50 instanceof Fn) return false;
  let e = true;
  return r50.eachChild((t) => {
    e && !ds(t) && (e = false);
  }), e;
}
function Rn(r50) {
  if (r50 instanceof Ot && r50.name === "feature-state") return false;
  let e = true;
  return r50.eachChild((t) => {
    e && !Rn(t) && (e = false);
  }), e;
}
function ys(r50, e) {
  if (r50 instanceof Ot && e.indexOf(r50.name) >= 0) return false;
  let t = true;
  return r50.eachChild((i) => {
    t && !ys(i, e) && (t = false);
  }), t;
}
function Qc(r50) {
  return { result: "success", value: r50 };
}
function Si(r50) {
  return { result: "error", value: r50 };
}
function gr(r50) {
  return r50["property-type"] === "data-driven" || r50["property-type"] === "cross-faded-data-driven";
}
function pm(r50) {
  return !!r50.expression && r50.expression.parameters.indexOf("zoom") > -1;
}
function ap(r50) {
  return !!r50.expression && r50.expression.interpolated;
}
function ge(r50) {
  return r50 instanceof Number ? "number" : r50 instanceof String ? "string" : r50 instanceof Boolean ? "boolean" : Array.isArray(r50) ? "array" : r50 === null ? "null" : typeof r50;
}
function gs(r50) {
  return typeof r50 == "object" && r50 !== null && !Array.isArray(r50);
}
function $0(r50) {
  return r50;
}
function hm(r50, e) {
  let t = e.type === "color", i = r50.stops && typeof r50.stops[0][0] == "object", n = i || r50.property !== void 0, o = i || !n, a = r50.type || (ap(e) ? "exponential" : "interval");
  if (t || e.type === "padding") {
    let c3 = t ? W.parse : zt.parse;
    r50 = Ai({}, r50), r50.stops && (r50.stops = r50.stops.map((p) => [p[0], c3(p[1])])), r50.default ? r50.default = c3(r50.default) : r50.default = c3(e.default);
  }
  if (r50.colorSpace && !Xv(r50.colorSpace)) throw new Error('Unknown color space: "'.concat(r50.colorSpace, '"'));
  let s3, l, u;
  if (a === "exponential") s3 = Uf;
  else if (a === "interval") s3 = X0;
  else if (a === "categorical") {
    s3 = W0, l = /* @__PURE__ */ Object.create(null);
    for (let c3 of r50.stops) l[c3[0]] = c3[1];
    u = typeof r50.stops[0][0];
  } else if (a === "identity") s3 = K0;
  else throw new Error('Unknown function type "'.concat(a, '"'));
  if (i) {
    let c3 = {}, p = [];
    for (let d = 0; d < r50.stops.length; d++) {
      let y = r50.stops[d], g = y[0].zoom;
      c3[g] === void 0 && (c3[g] = { zoom: g, type: r50.type, property: r50.property, default: r50.default, stops: [] }, p.push(g)), c3[g].stops.push([y[0].value, y[1]]);
    }
    let h = [];
    for (let d of p) h.push([c3[d].zoom, hm(c3[d], e)]);
    let f = { name: "linear" };
    return { kind: "composite", interpolationType: f, interpolationFactor: _t.interpolationFactor.bind(void 0, f), zoomStops: h.map((d) => d[0]), evaluate({ zoom: d }, y) {
      return Uf({ stops: h, base: r50.base }, e, d).evaluate(d, y);
    } };
  } else if (o) {
    let c3 = a === "exponential" ? { name: "exponential", base: r50.base !== void 0 ? r50.base : 1 } : null;
    return { kind: "camera", interpolationType: c3, interpolationFactor: _t.interpolationFactor.bind(void 0, c3), zoomStops: r50.stops.map((p) => p[0]), evaluate: ({ zoom: p }) => s3(r50, e, p, l, u) };
  } else return { kind: "source", evaluate(c3, p) {
    let h = p && p.properties ? p.properties[r50.property] : void 0;
    return h === void 0 ? Nn(r50.default, e.default) : s3(r50, e, h, l, u);
  } };
}
function Nn(r50, e, t) {
  if (r50 !== void 0) return r50;
  if (e !== void 0) return e;
  if (t !== void 0) return t;
}
function W0(r50, e, t, i, n) {
  let o = typeof t === n ? i[t] : void 0;
  return Nn(o, r50.default, e.default);
}
function X0(r50, e, t) {
  if (ge(t) !== "number") return Nn(r50.default, e.default);
  let i = r50.stops.length;
  if (i === 1 || t <= r50.stops[0][0]) return r50.stops[0][1];
  if (t >= r50.stops[i - 1][0]) return r50.stops[i - 1][1];
  let n = fs(r50.stops.map((o) => o[0]), t);
  return r50.stops[n][1];
}
function Uf(r50, e, t) {
  let i = r50.base !== void 0 ? r50.base : 1;
  if (ge(t) !== "number") return Nn(r50.default, e.default);
  let n = r50.stops.length;
  if (n === 1 || t <= r50.stops[0][0]) return r50.stops[0][1];
  if (t >= r50.stops[n - 1][0]) return r50.stops[n - 1][1];
  let o = fs(r50.stops.map((c3) => c3[0]), t), a = J0(t, i, r50.stops[o][0], r50.stops[o + 1][0]), s3 = r50.stops[o][1], l = r50.stops[o + 1][1], u = Se[e.type] || $0;
  return typeof s3.evaluate == "function" ? { evaluate(...c3) {
    let p = s3.evaluate.apply(void 0, c3), h = l.evaluate.apply(void 0, c3);
    if (!(p === void 0 || h === void 0)) return u(p, h, a, r50.colorSpace);
  } } : u(s3, l, a, r50.colorSpace);
}
function K0(r50, e, t) {
  switch (e.type) {
    case "color":
      t = W.parse(t);
      break;
    case "formatted":
      t = vt.fromString(t.toString());
      break;
    case "resolvedImage":
      t = ht.fromString(t.toString());
      break;
    case "padding":
      t = zt.parse(t);
      break;
    default:
      ge(t) !== e.type && (e.type !== "enum" || !e.values[t]) && (t = void 0);
  }
  return Nn(t, r50.default, e.default);
}
function J0(r50, e, t, i) {
  let n = i - t, o = r50 - t;
  return n === 0 ? 0 : e === 1 ? o / n : (Math.pow(e, o) - 1) / (Math.pow(e, n) - 1);
}
var $r = class {
  constructor(e, t) {
    this.expression = e, this._warningHistory = {}, this._evaluator = new Ja(), this._defaultValue = t ? Q0(t) : null, this._enumValues = t && t.type === "enum" ? t.values : null;
  }
  evaluateWithoutErrorHandling(e, t, i, n, o, a) {
    return this._evaluator.globals = e, this._evaluator.feature = t, this._evaluator.featureState = i, this._evaluator.canonical = n, this._evaluator.availableImages = o || null, this._evaluator.formattedSection = a, this.expression.evaluate(this._evaluator);
  }
  evaluate(e, t, i, n, o, a) {
    this._evaluator.globals = e, this._evaluator.feature = t || null, this._evaluator.featureState = i || null, this._evaluator.canonical = n, this._evaluator.availableImages = o || null, this._evaluator.formattedSection = a || null;
    try {
      let s3 = this.expression.evaluate(this._evaluator);
      if (s3 == null || typeof s3 == "number" && s3 !== s3) return this._defaultValue;
      if (this._enumValues && !(s3 in this._enumValues)) throw new Re("Expected value to be one of ".concat(Object.keys(this._enumValues).map((l) => JSON.stringify(l)).join(", "), ", but found ").concat(JSON.stringify(s3), " instead."));
      return s3;
    } catch (s3) {
      return this._warningHistory[s3.message] || (this._warningHistory[s3.message] = true, typeof console < "u" && console.warn(s3.message)), this._defaultValue;
    }
  }
};
function Jr(r50) {
  return Array.isArray(r50) && r50.length > 0 && typeof r50[0] == "string" && r50[0] in Kr;
}
function sp(r50, e) {
  let t = new Ya(Kr, ls, [], e ? Y0(e) : void 0), i = t.parse(r50, void 0, void 0, void 0, e && e.type === "string" ? { typeAnnotation: "coerce" } : void 0);
  return i ? Qc(new $r(i, e)) : Si(t.errors);
}
var xr = class {
  constructor(e, t) {
    this.kind = e, this._styleExpression = t, this.isStateDependent = e !== "constant" && !Rn(t.expression);
  }
  evaluateWithoutErrorHandling(e, t, i, n, o, a) {
    return this._styleExpression.evaluateWithoutErrorHandling(e, t, i, n, o, a);
  }
  evaluate(e, t, i, n, o, a) {
    return this._styleExpression.evaluate(e, t, i, n, o, a);
  }
};
var br = class {
  constructor(e, t, i, n) {
    this.kind = e, this.zoomStops = i, this._styleExpression = t, this.isStateDependent = e !== "camera" && !Rn(t.expression), this.interpolationType = n;
  }
  evaluateWithoutErrorHandling(e, t, i, n, o, a) {
    return this._styleExpression.evaluateWithoutErrorHandling(e, t, i, n, o, a);
  }
  evaluate(e, t, i, n, o, a) {
    return this._styleExpression.evaluate(e, t, i, n, o, a);
  }
  interpolationFactor(e, t, i) {
    return this.interpolationType ? _t.interpolationFactor(this.interpolationType, e, t, i) : 0;
  }
};
function fm(r50, e) {
  let t = sp(r50, e);
  if (t.result === "error") return t;
  let i = t.value.expression, n = ds(i);
  if (!n && !gr(e)) return Si([new Tt("", "data expressions not supported")]);
  let o = ys(i, ["zoom"]);
  if (!o && !pm(e)) return Si([new Tt("", "zoom expressions not supported")]);
  let a = Ka(i);
  if (!a && !o) return Si([new Tt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
  if (a instanceof Tt) return Si([a]);
  if (a instanceof _t && !ap(e)) return Si([new Tt("", '"interpolate" expressions cannot be used with this property')]);
  if (!a) return Qc(n ? new xr("constant", t.value) : new xr("source", t.value));
  let s3 = a instanceof _t ? a.interpolation : void 0;
  return Qc(n ? new br("camera", t.value, a.labels, s3) : new br("composite", t.value, a.labels, s3));
}
var Bn = class r31 {
  constructor(e, t) {
    this._parameters = e, this._specification = t, Ai(this, hm(this._parameters, this._specification));
  }
  static deserialize(e) {
    return new r31(e._parameters, e._specification);
  }
  static serialize(e) {
    return { _parameters: e._parameters, _specification: e._specification };
  }
};
function mm(r50, e) {
  if (gs(r50)) return new Bn(r50, e);
  if (Jr(r50)) {
    let t = fm(r50, e);
    if (t.result === "error") throw new Error(t.value.map((i) => "".concat(i.key, ": ").concat(i.message)).join(", "));
    return t.value;
  } else {
    let t = r50;
    return e.type === "color" && typeof r50 == "string" ? t = W.parse(r50) : e.type === "padding" && (typeof r50 == "number" || Array.isArray(r50)) ? t = zt.parse(r50) : e.type === "variableAnchorOffsetCollection" && Array.isArray(r50) && (t = er.parse(r50)), { kind: "constant", evaluate: () => t };
  }
}
function Ka(r50) {
  let e = null;
  if (r50 instanceof Qa) e = Ka(r50.result);
  else if (r50 instanceof rs) {
    for (let t of r50.args) if (e = Ka(t), e) break;
  } else (r50 instanceof Mi || r50 instanceof _t) && r50.input instanceof Ot && r50.input.name === "zoom" && (e = r50);
  return e instanceof Tt || r50.eachChild((t) => {
    let i = Ka(t);
    i instanceof Tt ? e = i : !e && i ? e = new Tt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e && i && e !== i && (e = new Tt("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
  }), e;
}
function Y0(r50) {
  let e = { color: Mt, string: ce, number: q2, enum: ce, boolean: ae, formatted: Ei, padding: ps, resolvedImage: Vn, variableAnchorOffsetCollection: hs };
  return r50.type === "array" ? bt(e[r50.value] || se, r50.length) : e[r50.type];
}
function Q0(r50) {
  return r50.type === "color" && gs(r50.default) ? new W(0, 0, 0, 0) : r50.type === "color" ? W.parse(r50.default) || null : r50.type === "padding" ? zt.parse(r50.default) || null : r50.type === "variableAnchorOffsetCollection" ? er.parse(r50.default) || null : r50.default === void 0 ? null : r50.default;
}
function lp(r50) {
  if (r50 === true || r50 === false) return true;
  if (!Array.isArray(r50) || r50.length === 0) return false;
  switch (r50[0]) {
    case "has":
      return r50.length >= 2 && r50[1] !== "$id" && r50[1] !== "$type";
    case "in":
      return r50.length >= 3 && (typeof r50[1] != "string" || Array.isArray(r50[2]));
    case "!in":
    case "!has":
    case "none":
      return false;
    case "==":
    case "!=":
    case ">":
    case ">=":
    case "<":
    case "<=":
      return r50.length !== 3 || Array.isArray(r50[1]) || Array.isArray(r50[2]);
    case "any":
    case "all":
      for (let e of r50.slice(1)) if (!lp(e) && typeof e != "boolean") return false;
      return true;
    default:
      return true;
  }
}
var e1 = { type: "boolean", default: false, transition: false, "property-type": "data-driven", expression: { interpolated: false, parameters: ["zoom", "feature"] } };
function Gn(r50) {
  if (r50 == null) return { filter: () => true, needGeometry: false };
  lp(r50) || (r50 = us(r50));
  let e = sp(r50, e1);
  if (e.result === "error") throw new Error(e.value.map((t) => "".concat(t.key, ": ").concat(t.message)).join(", "));
  {
    let t = dm(r50);
    return { filter: (i, n, o) => e.value.evaluate(i, n, {}, o), needGeometry: t };
  }
}
function t1(r50, e) {
  return r50 < e ? -1 : r50 > e ? 1 : 0;
}
function dm(r50) {
  if (!Array.isArray(r50)) return false;
  if (r50[0] === "within" || r50[0] === "distance") return true;
  for (let e = 1; e < r50.length; e++) if (dm(r50[e])) return true;
  return false;
}
function us(r50) {
  if (!r50) return true;
  let e = r50[0];
  return r50.length <= 1 ? e !== "any" : e === "==" ? Bc(r50[1], r50[2], "==") : e === "!=" ? Xa(Bc(r50[1], r50[2], "==")) : e === "<" || e === ">" || e === "<=" || e === ">=" ? Bc(r50[1], r50[2], e) : e === "any" ? r1(r50.slice(1)) : e === "all" ? ["all"].concat(r50.slice(1).map(us)) : e === "none" ? ["all"].concat(r50.slice(1).map(us).map(Xa)) : e === "in" ? Nf(r50[1], r50.slice(2)) : e === "!in" ? Xa(Nf(r50[1], r50.slice(2))) : e === "has" ? Gf(r50[1]) : e === "!has" ? Xa(Gf(r50[1])) : true;
}
function Bc(r50, e, t) {
  switch (r50) {
    case "$type":
      return ["filter-type-".concat(t), e];
    case "$id":
      return ["filter-id-".concat(t), e];
    default:
      return ["filter-".concat(t), r50, e];
  }
}
function r1(r50) {
  return ["any"].concat(r50.map(us));
}
function Nf(r50, e) {
  if (e.length === 0) return false;
  switch (r50) {
    case "$type":
      return ["filter-type-in", ["literal", e]];
    case "$id":
      return ["filter-id-in", ["literal", e]];
    default:
      return e.length > 200 && !e.some((t) => typeof t != typeof e[0]) ? ["filter-in-large", r50, ["literal", e.sort(t1)]] : ["filter-in-small", r50, ["literal", e]];
  }
}
function Gf(r50) {
  switch (r50) {
    case "$type":
      return true;
    case "$id":
      return ["filter-has-id"];
    default:
      return ["filter-has", r50];
  }
}
function Xa(r50) {
  return ["!", r50];
}
function ym() {
  let r50 = {}, e = A.$version;
  for (let t in A.$root) {
    let i = A.$root[t];
    if (i.required) {
      let n = null;
      t === "version" ? n = e : i.type === "array" ? n = [] : n = {}, n != null && (r50[t] = n);
    }
  }
  return r50;
}
function gm(r50) {
  let e = r50.key, t = r50.value;
  return t ? [new R(e, t, "constants have been deprecated as of v8")] : [];
}
function Ve(r50) {
  return r50 instanceof Number || r50 instanceof String || r50 instanceof Boolean ? r50.valueOf() : r50;
}
function Wr(r50) {
  if (Array.isArray(r50)) return r50.map(Wr);
  if (r50 instanceof Object && !(r50 instanceof Number || r50 instanceof String || r50 instanceof Boolean)) {
    let e = {};
    for (let t in r50) e[t] = Wr(r50[t]);
    return e;
  }
  return Ve(r50);
}
function At(r50) {
  let e = r50.key, t = r50.value, i = r50.valueSpec || {}, n = r50.objectElementValidators || {}, o = r50.style, a = r50.styleSpec, s3 = r50.validateSpec, l = [], u = ge(t);
  if (u !== "object") return [new R(e, t, "object expected, ".concat(u, " found"))];
  for (let c3 in t) {
    let p = c3.split(".")[0], h = i[p] || i["*"], f;
    if (n[p]) f = n[p];
    else if (i[p]) f = s3;
    else if (n["*"]) f = n["*"];
    else if (i["*"]) f = s3;
    else {
      l.push(new R(e, t[c3], 'unknown property "'.concat(c3, '"')));
      continue;
    }
    l = l.concat(f({ key: (e && "".concat(e, ".")) + c3, value: t[c3], valueSpec: h, style: o, styleSpec: a, object: t, objectKey: c3, validateSpec: s3 }, t));
  }
  for (let c3 in i) n[c3] || i[c3].required && i[c3].default === void 0 && t[c3] === void 0 && l.push(new R(e, t, 'missing required property "'.concat(c3, '"')));
  return l;
}
function up(r50) {
  let e = r50.value, t = r50.valueSpec, i = r50.validateSpec, n = r50.style, o = r50.styleSpec, a = r50.key, s3 = r50.arrayElementValidator || i;
  if (ge(e) !== "array") return [new R(a, e, "array expected, ".concat(ge(e), " found"))];
  if (t.length && e.length !== t.length) return [new R(a, e, "array length ".concat(t.length, " expected, length ").concat(e.length, " found"))];
  if (t["min-length"] && e.length < t["min-length"]) return [new R(a, e, "array length at least ".concat(t["min-length"], " expected, length ").concat(e.length, " found"))];
  let l = { type: t.value, values: t.values };
  o.$version < 7 && (l.function = t.function), ge(t.value) === "object" && (l = t.value);
  let u = [];
  for (let c3 = 0; c3 < e.length; c3++) u = u.concat(s3({ array: e, arrayIndex: c3, value: e[c3], valueSpec: l, validateSpec: r50.validateSpec, style: n, styleSpec: o, key: "".concat(a, "[").concat(c3, "]") }));
  return u;
}
function cp(r50) {
  let e = r50.key, t = r50.value, i = r50.valueSpec, n = ge(t);
  return n === "number" && t !== t && (n = "NaN"), n !== "number" ? [new R(e, t, "number expected, ".concat(n, " found"))] : "minimum" in i && t < i.minimum ? [new R(e, t, "".concat(t, " is less than the minimum value ").concat(i.minimum))] : "maximum" in i && t > i.maximum ? [new R(e, t, "".concat(t, " is greater than the maximum value ").concat(i.maximum))] : [];
}
function xm(r50) {
  let e = r50.valueSpec, t = Ve(r50.value.type), i, n = {}, o, a, s3 = t !== "categorical" && r50.value.property === void 0, l = !s3, u = ge(r50.value.stops) === "array" && ge(r50.value.stops[0]) === "array" && ge(r50.value.stops[0][0]) === "object", c3 = At({ key: r50.key, value: r50.value, valueSpec: r50.styleSpec.function, validateSpec: r50.validateSpec, style: r50.style, styleSpec: r50.styleSpec, objectElementValidators: { stops: p, default: d } });
  return t === "identity" && s3 && c3.push(new R(r50.key, r50.value, 'missing required property "property"')), t !== "identity" && !r50.value.stops && c3.push(new R(r50.key, r50.value, 'missing required property "stops"')), t === "exponential" && r50.valueSpec.expression && !ap(r50.valueSpec) && c3.push(new R(r50.key, r50.value, "exponential functions not supported")), r50.styleSpec.$version >= 8 && (l && !gr(r50.valueSpec) ? c3.push(new R(r50.key, r50.value, "property functions not supported")) : s3 && !pm(r50.valueSpec) && c3.push(new R(r50.key, r50.value, "zoom functions not supported"))), (t === "categorical" || u) && r50.value.property === void 0 && c3.push(new R(r50.key, r50.value, '"property" property is required')), c3;
  function p(y) {
    if (t === "identity") return [new R(y.key, y.value, 'identity function may not have a "stops" property')];
    let g = [], x = y.value;
    return g = g.concat(up({ key: y.key, value: x, valueSpec: y.valueSpec, validateSpec: y.validateSpec, style: y.style, styleSpec: y.styleSpec, arrayElementValidator: h })), ge(x) === "array" && x.length === 0 && g.push(new R(y.key, x, "array must have at least one stop")), g;
  }
  function h(y) {
    let g = [], x = y.value, v = y.key;
    if (ge(x) !== "array") return [new R(v, x, "array expected, ".concat(ge(x), " found"))];
    if (x.length !== 2) return [new R(v, x, "array length 2 expected, length ".concat(x.length, " found"))];
    if (u) {
      if (ge(x[0]) !== "object") return [new R(v, x, "object expected, ".concat(ge(x[0]), " found"))];
      if (x[0].zoom === void 0) return [new R(v, x, "object stop key must have zoom")];
      if (x[0].value === void 0) return [new R(v, x, "object stop key must have value")];
      if (a && a > Ve(x[0].zoom)) return [new R(v, x[0].zoom, "stop zoom values must appear in ascending order")];
      Ve(x[0].zoom) !== a && (a = Ve(x[0].zoom), o = void 0, n = {}), g = g.concat(At({ key: "".concat(v, "[0]"), value: x[0], valueSpec: { zoom: {} }, validateSpec: y.validateSpec, style: y.style, styleSpec: y.styleSpec, objectElementValidators: { zoom: cp, value: f } }));
    } else g = g.concat(f({ key: "".concat(v, "[0]"), value: x[0], valueSpec: {}, validateSpec: y.validateSpec, style: y.style, styleSpec: y.styleSpec }, x));
    return Jr(Wr(x[1])) ? g.concat([new R("".concat(v, "[1]"), x[1], "expressions are not allowed in function stops.")]) : g.concat(y.validateSpec({ key: "".concat(v, "[1]"), value: x[1], valueSpec: e, validateSpec: y.validateSpec, style: y.style, styleSpec: y.styleSpec }));
  }
  function f(y, g) {
    let x = ge(y.value), v = Ve(y.value), b = y.value !== null ? y.value : g;
    if (!i) i = x;
    else if (x !== i) return [new R(y.key, b, "".concat(x, " stop domain type must match previous stop domain type ").concat(i))];
    if (x !== "number" && x !== "string" && x !== "boolean") return [new R(y.key, b, "stop domain value must be a number, string, or boolean")];
    if (x !== "number" && t !== "categorical") {
      let w = "number expected, ".concat(x, " found");
      return gr(e) && t === void 0 && (w += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new R(y.key, b, w)];
    }
    return t === "categorical" && x === "number" && (!isFinite(v) || Math.floor(v) !== v) ? [new R(y.key, b, "integer expected, found ".concat(v))] : t !== "categorical" && x === "number" && o !== void 0 && v < o ? [new R(y.key, b, "stop domain values must appear in ascending order")] : (o = v, t === "categorical" && v in n ? [new R(y.key, b, "stop domain values must be unique")] : (n[v] = true, []));
  }
  function d(y) {
    return y.validateSpec({ key: y.key, value: y.value, valueSpec: e, validateSpec: y.validateSpec, style: y.style, styleSpec: y.styleSpec });
  }
}
function Ii(r50) {
  let e = (r50.expressionContext === "property" ? fm : sp)(Wr(r50.value), r50.valueSpec);
  if (e.result === "error") return e.value.map((i) => new R("".concat(r50.key).concat(i.key), r50.value, i.message));
  let t = e.value.expression || e.value._styleExpression.expression;
  if (r50.expressionContext === "property" && r50.propertyKey === "text-font" && !t.outputDefined()) return [new R(r50.key, r50.value, 'Invalid data expression for "'.concat(r50.propertyKey, '". Output values must be contained as literals within the expression.'))];
  if (r50.expressionContext === "property" && r50.propertyType === "layout" && !Rn(t)) return [new R(r50.key, r50.value, '"feature-state" data expressions are not supported with layout properties.')];
  if (r50.expressionContext === "filter" && !Rn(t)) return [new R(r50.key, r50.value, '"feature-state" data expressions are not supported with filters.')];
  if (r50.expressionContext && r50.expressionContext.indexOf("cluster") === 0) {
    if (!ys(t, ["zoom", "feature-state"])) return [new R(r50.key, r50.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
    if (r50.expressionContext === "cluster-initial" && !ds(t)) return [new R(r50.key, r50.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
  }
  return [];
}
function i1(r50) {
  let e = r50.value, t = r50.key, i = ge(e);
  return i !== "boolean" ? [new R(t, e, "boolean expected, ".concat(i, " found"))] : [];
}
function n1(r50) {
  let e = r50.key, t = r50.value, i = ge(t);
  return i !== "string" ? [new R(e, t, "color expected, ".concat(i, " found"))] : W.parse(String(t)) ? [] : [new R(e, t, 'color expected, "'.concat(t, '" found'))];
}
function On(r50) {
  let e = r50.key, t = r50.value, i = r50.valueSpec, n = [];
  return Array.isArray(i.values) ? i.values.indexOf(Ve(t)) === -1 && n.push(new R(e, t, "expected one of [".concat(i.values.join(", "), "], ").concat(JSON.stringify(t), " found"))) : Object.keys(i.values).indexOf(Ve(t)) === -1 && n.push(new R(e, t, "expected one of [".concat(Object.keys(i.values).join(", "), "], ").concat(JSON.stringify(t), " found"))), n;
}
function pp(r50) {
  return lp(Wr(r50.value)) ? Ii(Ai({}, r50, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : bm(r50);
}
function bm(r50) {
  let e = r50.value, t = r50.key;
  if (ge(e) !== "array") return [new R(t, e, "array expected, ".concat(ge(e), " found"))];
  let i = r50.styleSpec, n, o = [];
  if (e.length < 1) return [new R(t, e, "filter array must have at least 1 element")];
  switch (o = o.concat(On({ key: "".concat(t, "[0]"), value: e[0], valueSpec: i.filter_operator, style: r50.style, styleSpec: r50.styleSpec })), Ve(e[0])) {
    case "<":
    case "<=":
    case ">":
    case ">=":
      e.length >= 2 && Ve(e[1]) === "$type" && o.push(new R(t, e, '"$type" cannot be use with operator "'.concat(e[0], '"')));
    case "==":
    case "!=":
      e.length !== 3 && o.push(new R(t, e, 'filter array for operator "'.concat(e[0], '" must have 3 elements')));
    case "in":
    case "!in":
      e.length >= 2 && (n = ge(e[1]), n !== "string" && o.push(new R("".concat(t, "[1]"), e[1], "string expected, ".concat(n, " found"))));
      for (let a = 2; a < e.length; a++) n = ge(e[a]), Ve(e[1]) === "$type" ? o = o.concat(On({ key: "".concat(t, "[").concat(a, "]"), value: e[a], valueSpec: i.geometry_type, style: r50.style, styleSpec: r50.styleSpec })) : n !== "string" && n !== "number" && n !== "boolean" && o.push(new R("".concat(t, "[").concat(a, "]"), e[a], "string, number, or boolean expected, ".concat(n, " found")));
      break;
    case "any":
    case "all":
    case "none":
      for (let a = 1; a < e.length; a++) o = o.concat(bm({ key: "".concat(t, "[").concat(a, "]"), value: e[a], style: r50.style, styleSpec: r50.styleSpec }));
      break;
    case "has":
    case "!has":
      n = ge(e[1]), e.length !== 2 ? o.push(new R(t, e, 'filter array for "'.concat(e[0], '" operator must have 2 elements'))) : n !== "string" && o.push(new R("".concat(t, "[1]"), e[1], "string expected, ".concat(n, " found")));
      break;
  }
  return o;
}
function _m(r50, e) {
  let t = r50.key, i = r50.validateSpec, n = r50.style, o = r50.styleSpec, a = r50.value, s3 = r50.objectKey, l = o["".concat(e, "_").concat(r50.layerType)];
  if (!l) return [];
  let u = s3.match(/^(.*)-transition$/);
  if (e === "paint" && u && l[u[1]] && l[u[1]].transition) return i({ key: t, value: a, valueSpec: o.transition, style: n, styleSpec: o });
  let c3 = r50.valueSpec || l[s3];
  if (!c3) return [new R(t, a, 'unknown property "'.concat(s3, '"'))];
  let p;
  if (ge(a) === "string" && gr(c3) && !c3.tokens && (p = /^{([^}]+)}$/.exec(a))) return [new R(t, a, '"'.concat(s3, '" does not support interpolation syntax\n') + 'Use an identity property function instead: `{ "type": "identity", "property": '.concat(JSON.stringify(p[1]), " }`."))];
  let h = [];
  return r50.layerType === "symbol" && (s3 === "text-field" && n && !n.glyphs && h.push(new R(t, a, 'use of "text-field" requires a style "glyphs" property')), s3 === "text-font" && gs(Wr(a)) && Ve(a.type) === "identity" && h.push(new R(t, a, '"text-font" does not support identity functions'))), h.concat(i({ key: r50.key, value: a, valueSpec: c3, style: n, styleSpec: o, expressionContext: "property", propertyType: e, propertyKey: s3 }));
}
function vm(r50) {
  return _m(r50, "paint");
}
function wm(r50) {
  return _m(r50, "layout");
}
function Sm(r50) {
  let e = [], t = r50.value, i = r50.key, n = r50.style, o = r50.styleSpec;
  !t.type && !t.ref && e.push(new R(i, t, 'either "type" or "ref" is required'));
  let a = Ve(t.type), s3 = Ve(t.ref);
  if (t.id) {
    let l = Ve(t.id);
    for (let u = 0; u < r50.arrayIndex; u++) {
      let c3 = n.layers[u];
      Ve(c3.id) === l && e.push(new R(i, t.id, 'duplicate layer id "'.concat(t.id, '", previously used at line ').concat(c3.id.__line__)));
    }
  }
  if ("ref" in t) {
    ["type", "source", "source-layer", "filter", "layout"].forEach((u) => {
      u in t && e.push(new R(i, t[u], '"'.concat(u, '" is prohibited for ref layers')));
    });
    let l;
    n.layers.forEach((u) => {
      Ve(u.id) === s3 && (l = u);
    }), l ? l.ref ? e.push(new R(i, t.ref, "ref cannot reference another ref layer")) : a = Ve(l.type) : e.push(new R(i, t.ref, 'ref layer "'.concat(s3, '" not found')));
  } else if (a !== "background") if (!t.source) e.push(new R(i, t, 'missing required property "source"'));
  else {
    let l = n.sources && n.sources[t.source], u = l && Ve(l.type);
    l ? u === "vector" && a === "raster" ? e.push(new R(i, t.source, 'layer "'.concat(t.id, '" requires a raster source'))) : u !== "raster-dem" && a === "hillshade" ? e.push(new R(i, t.source, 'layer "'.concat(t.id, '" requires a raster-dem source'))) : u === "raster" && a !== "raster" ? e.push(new R(i, t.source, 'layer "'.concat(t.id, '" requires a vector source'))) : u === "vector" && !t["source-layer"] ? e.push(new R(i, t, 'layer "'.concat(t.id, '" must specify a "source-layer"'))) : u === "raster-dem" && a !== "hillshade" ? e.push(new R(i, t.source, "raster-dem source can only be used with layer type 'hillshade'.")) : a === "line" && t.paint && t.paint["line-gradient"] && (u !== "geojson" || !l.lineMetrics) && e.push(new R(i, t, 'layer "'.concat(t.id, '" specifies a line-gradient, which requires a GeoJSON source with `lineMetrics` enabled.'))) : e.push(new R(i, t.source, 'source "'.concat(t.source, '" not found')));
  }
  return e = e.concat(At({ key: i, value: t, valueSpec: o.layer, style: r50.style, styleSpec: r50.styleSpec, validateSpec: r50.validateSpec, objectElementValidators: { "*"() {
    return [];
  }, type() {
    return r50.validateSpec({ key: "".concat(i, ".type"), value: t.type, valueSpec: o.layer.type, style: r50.style, styleSpec: r50.styleSpec, validateSpec: r50.validateSpec, object: t, objectKey: "type" });
  }, filter: pp, layout(l) {
    return At({ layer: t, key: l.key, value: l.value, style: l.style, styleSpec: l.styleSpec, validateSpec: l.validateSpec, objectElementValidators: { "*"(u) {
      return wm(Ai({ layerType: a }, u));
    } } });
  }, paint(l) {
    return At({ layer: t, key: l.key, value: l.value, style: l.style, styleSpec: l.styleSpec, validateSpec: l.validateSpec, objectElementValidators: { "*"(u) {
      return vm(Ai({ layerType: a }, u));
    } } });
  } } })), e;
}
function Xr(r50) {
  let e = r50.value, t = r50.key, i = ge(e);
  return i !== "string" ? [new R(t, e, "string expected, ".concat(i, " found"))] : [];
}
function o1(r50) {
  var e;
  let t = (e = r50.sourceName) !== null && e !== void 0 ? e : "", i = r50.value, n = r50.styleSpec, o = n.source_raster_dem, a = r50.style, s3 = [], l = ge(i);
  if (i === void 0) return s3;
  if (l !== "object") return s3.push(new R("source_raster_dem", i, "object expected, ".concat(l, " found"))), s3;
  let c3 = Ve(i.encoding) === "custom", p = ["redFactor", "greenFactor", "blueFactor", "baseShift"], h = r50.value.encoding ? '"'.concat(r50.value.encoding, '"') : "Default";
  for (let f in i) !c3 && p.includes(f) ? s3.push(new R(f, i[f], 'In "'.concat(t, '": "').concat(f, '" is only valid when "encoding" is set to "custom". ').concat(h, " encoding found"))) : o[f] ? s3 = s3.concat(r50.validateSpec({ key: f, value: i[f], valueSpec: o[f], validateSpec: r50.validateSpec, style: a, styleSpec: n })) : s3.push(new R(f, i[f], 'unknown property "'.concat(f, '"')));
  return s3;
}
var qf = { promoteId: a1 };
function Pm(r50) {
  let e = r50.value, t = r50.key, i = r50.styleSpec, n = r50.style, o = r50.validateSpec;
  if (!e.type) return [new R(t, e, '"type" is required')];
  let a = Ve(e.type), s3;
  switch (a) {
    case "vector":
    case "raster":
      return s3 = At({ key: t, value: e, valueSpec: i["source_".concat(a.replace("-", "_"))], style: r50.style, styleSpec: i, objectElementValidators: qf, validateSpec: o }), s3;
    case "raster-dem":
      return s3 = o1({ sourceName: t, value: e, style: r50.style, styleSpec: i, validateSpec: o }), s3;
    case "geojson":
      if (s3 = At({ key: t, value: e, valueSpec: i.source_geojson, style: n, styleSpec: i, validateSpec: o, objectElementValidators: qf }), e.cluster) for (let l in e.clusterProperties) {
        let [u, c3] = e.clusterProperties[l], p = typeof u == "string" ? [u, ["accumulated"], ["get", l]] : u;
        s3.push(...Ii({ key: "".concat(t, ".").concat(l, ".map"), value: c3, validateSpec: o, expressionContext: "cluster-map" })), s3.push(...Ii({ key: "".concat(t, ".").concat(l, ".reduce"), value: p, validateSpec: o, expressionContext: "cluster-reduce" }));
      }
      return s3;
    case "video":
      return At({ key: t, value: e, valueSpec: i.source_video, style: n, validateSpec: o, styleSpec: i });
    case "image":
      return At({ key: t, value: e, valueSpec: i.source_image, style: n, validateSpec: o, styleSpec: i });
    case "canvas":
      return [new R(t, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
    default:
      return On({ key: "".concat(t, ".type"), value: e.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] }, style: n, validateSpec: o, styleSpec: i });
  }
}
function a1({ key: r50, value: e }) {
  if (ge(e) === "string") return Xr({ key: r50, value: e });
  {
    let t = [];
    for (let i in e) t.push(...Xr({ key: "".concat(r50, ".").concat(i), value: e[i] }));
    return t;
  }
}
function Tm(r50) {
  let e = r50.value, t = r50.styleSpec, i = t.light, n = r50.style, o = [], a = ge(e);
  if (e === void 0) return o;
  if (a !== "object") return o = o.concat([new R("light", e, "object expected, ".concat(a, " found"))]), o;
  for (let s3 in e) {
    let l = s3.match(/^(.*)-transition$/);
    l && i[l[1]] && i[l[1]].transition ? o = o.concat(r50.validateSpec({ key: s3, value: e[s3], valueSpec: t.transition, validateSpec: r50.validateSpec, style: n, styleSpec: t })) : i[s3] ? o = o.concat(r50.validateSpec({ key: s3, value: e[s3], valueSpec: i[s3], validateSpec: r50.validateSpec, style: n, styleSpec: t })) : o = o.concat([new R(s3, e[s3], 'unknown property "'.concat(s3, '"'))]);
  }
  return o;
}
function Am(r50) {
  let e = r50.value, t = r50.styleSpec, i = t.sky, n = r50.style, o = ge(e);
  if (e === void 0) return [];
  if (o !== "object") return [new R("sky", e, "object expected, ".concat(o, " found"))];
  let a = [];
  for (let s3 in e) i[s3] ? a = a.concat(r50.validateSpec({ key: s3, value: e[s3], valueSpec: i[s3], style: n, styleSpec: t })) : a = a.concat([new R(s3, e[s3], 'unknown property "'.concat(s3, '"'))]);
  return a;
}
function Mm(r50) {
  let e = r50.value, t = r50.styleSpec, i = t.terrain, n = r50.style, o = [], a = ge(e);
  if (e === void 0) return o;
  if (a !== "object") return o = o.concat([new R("terrain", e, "object expected, ".concat(a, " found"))]), o;
  for (let s3 in e) i[s3] ? o = o.concat(r50.validateSpec({ key: s3, value: e[s3], valueSpec: i[s3], validateSpec: r50.validateSpec, style: n, styleSpec: t })) : o = o.concat([new R(s3, e[s3], 'unknown property "'.concat(s3, '"'))]);
  return o;
}
function s1(r50) {
  return Xr(r50).length === 0 ? [] : Ii(r50);
}
function l1(r50) {
  return Xr(r50).length === 0 ? [] : Ii(r50);
}
function u1(r50) {
  let e = r50.key, t = r50.value;
  if (ge(t) === "array") {
    if (t.length < 1 || t.length > 4) return [new R(e, t, "padding requires 1 to 4 values; ".concat(t.length, " values found"))];
    let n = { type: "number" }, o = [];
    for (let a = 0; a < t.length; a++) o = o.concat(r50.validateSpec({ key: "".concat(e, "[").concat(a, "]"), value: t[a], validateSpec: r50.validateSpec, valueSpec: n }));
    return o;
  } else return cp({ key: e, value: t, valueSpec: {} });
}
function c1(r50) {
  let e = r50.key, t = r50.value, i = ge(t), n = r50.styleSpec;
  if (i !== "array" || t.length < 1 || t.length % 2 !== 0) return [new R(e, t, "variableAnchorOffsetCollection requires a non-empty array of even length")];
  let o = [];
  for (let a = 0; a < t.length; a += 2) o = o.concat(On({ key: "".concat(e, "[").concat(a, "]"), value: t[a], valueSpec: n.layout_symbol["text-anchor"] })), o = o.concat(up({ key: "".concat(e, "[").concat(a + 1, "]"), value: t[a + 1], valueSpec: { length: 2, value: "number" }, validateSpec: r50.validateSpec, style: r50.style, styleSpec: n }));
  return o;
}
function Im(r50) {
  let e = [], t = r50.value, i = r50.key;
  if (Array.isArray(t)) {
    let n = [], o = [];
    for (let a in t) {
      t[a].id && n.includes(t[a].id) && e.push(new R(i, t, "all the sprites' ids must be unique, but ".concat(t[a].id, " is duplicated"))), n.push(t[a].id), t[a].url && o.includes(t[a].url) && e.push(new R(i, t, "all the sprites' URLs must be unique, but ".concat(t[a].url, " is duplicated"))), o.push(t[a].url);
      let s3 = { id: { type: "string", required: true }, url: { type: "string", required: true } };
      e = e.concat(At({ key: "".concat(i, "[").concat(a, "]"), value: t[a], valueSpec: s3, validateSpec: r50.validateSpec }));
    }
    return e;
  } else return Xr({ key: i, value: t });
}
function p1(r50) {
  let e = r50.value, t = r50.styleSpec, i = t.projection, n = r50.style, o = ge(e);
  if (e === void 0) return [];
  if (o !== "object") return [new R("projection", e, "object expected, ".concat(o, " found"))];
  let a = [];
  for (let s3 in e) i[s3] ? a = a.concat(r50.validateSpec({ key: s3, value: e[s3], valueSpec: i[s3], style: n, styleSpec: t })) : a = a.concat([new R(s3, e[s3], 'unknown property "'.concat(s3, '"'))]);
  return a;
}
var jf = { "*"() {
  return [];
}, array: up, boolean: i1, number: cp, color: n1, constants: gm, enum: On, filter: pp, function: xm, layer: Sm, object: At, source: Pm, light: Tm, sky: Am, terrain: Mm, projection: p1, string: Xr, formatted: s1, resolvedImage: l1, padding: u1, variableAnchorOffsetCollection: c1, sprite: Im };
function Tn(r50) {
  let e = r50.value, t = r50.valueSpec, i = r50.styleSpec;
  return r50.validateSpec = Tn, t.expression && gs(Ve(e)) ? xm(r50) : t.expression && Jr(Wr(e)) ? Ii(r50) : t.type && jf[t.type] ? jf[t.type](r50) : At(Ai({}, r50, { valueSpec: t.type ? i[t.type] : t }));
}
function Cm(r50) {
  let e = r50.value, t = r50.key, i = Xr(r50);
  return i.length || (e.indexOf("{fontstack}") === -1 && i.push(new R(t, e, '"glyphs" url must include a "{fontstack}" token')), e.indexOf("{range}") === -1 && i.push(new R(t, e, '"glyphs" url must include a "{range}" token'))), i;
}
function It(r50, e = A) {
  let t = [];
  return t = t.concat(Tn({ key: "", value: r50, valueSpec: e.$root, styleSpec: e, style: r50, validateSpec: Tn, objectElementValidators: { glyphs: Cm, "*"() {
    return [];
  } } })), r50.constants && (t = t.concat(gm({ key: "constants", value: r50.constants, style: r50, styleSpec: e, validateSpec: Tn }))), Em(t);
}
It.source = Ut(Vt(Pm));
It.sprite = Ut(Vt(Im));
It.glyphs = Ut(Vt(Cm));
It.light = Ut(Vt(Tm));
It.sky = Ut(Vt(Am));
It.terrain = Ut(Vt(Mm));
It.layer = Ut(Vt(Sm));
It.filter = Ut(Vt(pp));
It.paintProperty = Ut(Vt(vm));
It.layoutProperty = Ut(Vt(wm));
function Vt(r50) {
  return function(e) {
    return r50({ ...e, validateSpec: Tn });
  };
}
function Em(r50) {
  return [].concat(r50).sort((e, t) => e.line - t.line);
}
function Ut(r50) {
  return function(...e) {
    return Em(r50.apply(this, e));
  };
}
c();
var Ue = It;
var zI = Ue.source;
var km = Ue.light;
var FI = Ue.terrain;
var RI = Ue.filter;
var Lm = Ue.paintProperty;
var Dm = Ue.layoutProperty;
function Di(r50, e) {
  let t = false;
  if (e && e.length) for (let i of e) r50.fire(new Z(new Error(i.message))), t = true;
  return t;
}
c();
c();
c();
var Yr = class r32 {
  constructor(e, t, i) {
    let n = this.cells = [];
    if (e instanceof ArrayBuffer) {
      this.arrayBuffer = e;
      let a = new Int32Array(this.arrayBuffer);
      e = a[0], t = a[1], i = a[2], this.d = t + 2 * i;
      for (let u = 0; u < this.d * this.d; u++) {
        let c3 = a[3 + u], p = a[3 + u + 1];
        n.push(c3 === p ? null : a.subarray(c3, p));
      }
      let s3 = a[3 + n.length], l = a[3 + n.length + 1];
      this.keys = a.subarray(s3, l), this.bboxes = a.subarray(l), this.insert = this._insertReadonly;
    } else {
      this.d = t + 2 * i;
      for (let a = 0; a < this.d * this.d; a++) n.push([]);
      this.keys = [], this.bboxes = [];
    }
    this.n = t, this.extent = e, this.padding = i, this.scale = t / e, this.uid = 0;
    let o = i / t * e;
    this.min = -o, this.max = e + o;
  }
  insert(e, t, i, n, o) {
    this._forEachCell(t, i, n, o, this._insertCell, this.uid++, void 0, void 0), this.keys.push(e), this.bboxes.push(t), this.bboxes.push(i), this.bboxes.push(n), this.bboxes.push(o);
  }
  _insertReadonly() {
    throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
  }
  _insertCell(e, t, i, n, o, a) {
    this.cells[o].push(a);
  }
  query(e, t, i, n, o) {
    let a = this.min, s3 = this.max;
    if (e <= a && t <= a && s3 <= i && s3 <= n && !o) return Array.prototype.slice.call(this.keys);
    {
      let l = [], u = {};
      return this._forEachCell(e, t, i, n, this._queryCell, l, u, o), l;
    }
  }
  _queryCell(e, t, i, n, o, a, s3, l) {
    let u = this.cells[o];
    if (u !== null) {
      let c3 = this.keys, p = this.bboxes;
      for (let h = 0; h < u.length; h++) {
        let f = u[h];
        if (s3[f] === void 0) {
          let d = f * 4;
          (l ? l(p[d + 0], p[d + 1], p[d + 2], p[d + 3]) : e <= p[d + 2] && t <= p[d + 3] && i >= p[d + 0] && n >= p[d + 1]) ? (s3[f] = true, a.push(c3[f])) : s3[f] = false;
        }
      }
    }
  }
  _forEachCell(e, t, i, n, o, a, s3, l) {
    let u = this._convertToCellCoord(e), c3 = this._convertToCellCoord(t), p = this._convertToCellCoord(i), h = this._convertToCellCoord(n);
    for (let f = u; f <= p; f++) for (let d = c3; d <= h; d++) {
      let y = this.d * d + f;
      if (!(l && !l(this._convertFromCellCoord(f), this._convertFromCellCoord(d), this._convertFromCellCoord(f + 1), this._convertFromCellCoord(d + 1))) && o.call(this, e, t, i, n, y, a, s3, l)) return;
    }
  }
  _convertFromCellCoord(e) {
    return (e - this.padding) / this.scale;
  }
  _convertToCellCoord(e) {
    return Math.max(0, Math.min(this.d - 1, Math.floor(e * this.scale) + this.padding));
  }
  toArrayBuffer() {
    if (this.arrayBuffer) return this.arrayBuffer;
    let e = this.cells, t = 3 + this.cells.length + 1 + 1, i = 0;
    for (let a = 0; a < this.cells.length; a++) i += this.cells[a].length;
    let n = new Int32Array(t + i + this.keys.length + this.bboxes.length);
    n[0] = this.extent, n[1] = this.n, n[2] = this.padding;
    let o = t;
    for (let a = 0; a < e.length; a++) {
      let s3 = e[a];
      n[3 + a] = o, n.set(s3, o), o += s3.length;
    }
    return n[3 + e.length] = o, n.set(this.keys, o), o += this.keys.length, n[3 + e.length + 1] = o, n.set(this.bboxes, o), o += this.bboxes.length, n.buffer;
  }
  static serialize(e, t) {
    let i = e.toArrayBuffer();
    return t && t.push(i), { buffer: i };
  }
  static deserialize(e) {
    return new r32(e.buffer);
  }
};
var _r = {};
function U(r50, e, t = {}) {
  if (_r[r50]) throw new Error("".concat(r50, " is already registered."));
  Object.defineProperty(e, "_classRegistryKey", { value: r50, writeable: false }), _r[r50] = { klass: e, omit: t.omit || [], shallow: t.shallow || [] };
}
U("Object", Object);
U("TransferableGridIndex", Yr);
U("Color", W);
U("Error", Error);
U("AJAXError", Gr);
U("ResolvedImage", ht);
U("StylePropertyFunction", Bn);
U("StyleExpression", $r, { omit: ["_evaluator"] });
U("ZoomDependentExpression", br);
U("ZoomConstantExpression", xr);
U("CompoundExpression", Ot, { omit: ["_evaluate"] });
for (let r50 in Kr) Kr[r50]._classRegistryKey || U("Expression_".concat(r50), Kr[r50]);
function zm(r50) {
  return r50 && typeof ArrayBuffer < "u" && (r50 instanceof ArrayBuffer || r50.constructor && r50.constructor.name === "ArrayBuffer");
}
function zi(r50, e) {
  if (r50 == null || typeof r50 == "boolean" || typeof r50 == "number" || typeof r50 == "string" || r50 instanceof Boolean || r50 instanceof Number || r50 instanceof String || r50 instanceof Date || r50 instanceof RegExp || r50 instanceof Blob || r50 instanceof Error) return r50;
  if (zm(r50) || pt(r50)) return e && e.push(r50), r50;
  if (ArrayBuffer.isView(r50)) {
    let t = r50;
    return e && e.push(t.buffer), t;
  }
  if (r50 instanceof ImageData) return e && e.push(r50.data.buffer), r50;
  if (Array.isArray(r50)) {
    let t = [];
    for (let i of r50) t.push(zi(i, e));
    return t;
  }
  if (typeof r50 == "object") {
    let t = r50.constructor, i = t._classRegistryKey;
    if (!i) throw new Error("can't serialize object of unregistered class ".concat(t.name));
    if (!_r[i]) throw new Error("".concat(i, " is not registered."));
    let n = t.serialize ? t.serialize(r50, e) : {};
    if (t.serialize) {
      if (e && n === e[e.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property");
    } else {
      for (let o in r50) {
        if (!r50.hasOwnProperty(o) || _r[i].omit.indexOf(o) >= 0) continue;
        let a = r50[o];
        n[o] = _r[i].shallow.indexOf(o) >= 0 ? a : zi(a, e);
      }
      r50 instanceof Error && (n.message = r50.message);
    }
    if (n.$name) throw new Error("$name property is reserved for worker serialization logic.");
    return i !== "Object" && (n.$name = i), n;
  }
  throw new Error("can't serialize object of type ".concat(typeof r50));
}
function Fi(r50) {
  if (r50 == null || typeof r50 == "boolean" || typeof r50 == "number" || typeof r50 == "string" || r50 instanceof Boolean || r50 instanceof Number || r50 instanceof String || r50 instanceof Date || r50 instanceof RegExp || r50 instanceof Blob || r50 instanceof Error || zm(r50) || pt(r50) || ArrayBuffer.isView(r50) || r50 instanceof ImageData) return r50;
  if (Array.isArray(r50)) return r50.map(Fi);
  if (typeof r50 == "object") {
    let e = r50.$name || "Object";
    if (!_r[e]) throw new Error("can't deserialize unregistered class ".concat(e));
    let { klass: t } = _r[e];
    if (!t) throw new Error("can't deserialize unregistered class ".concat(e));
    if (t.deserialize) return t.deserialize(r50);
    let i = Object.create(t.prototype);
    for (let n of Object.keys(r50)) {
      if (n === "$name") continue;
      let o = r50[n];
      i[n] = _r[e].shallow.indexOf(n) >= 0 ? o : Fi(o);
    }
    return i;
  }
  throw new Error("can't deserialize object of type ".concat(typeof r50));
}
c();
c();
var Ri = class {
  constructor() {
    this.first = true;
  }
  update(e, t) {
    let i = Math.floor(e);
    return this.first ? (this.first = false, this.lastIntegerZoom = i, this.lastIntegerZoomTime = 0, this.lastZoom = e, this.lastFloorZoom = i, true) : (this.lastFloorZoom > i ? (this.lastIntegerZoom = i + 1, this.lastIntegerZoomTime = t) : this.lastFloorZoom < i && (this.lastIntegerZoom = i, this.lastIntegerZoomTime = t), e !== this.lastZoom ? (this.lastZoom = e, this.lastFloorZoom = i, true) : false);
  }
};
c();
c();
var pe = { "Latin-1 Supplement": (r50) => r50 >= 128 && r50 <= 255, Arabic: (r50) => r50 >= 1536 && r50 <= 1791, "Arabic Supplement": (r50) => r50 >= 1872 && r50 <= 1919, "Arabic Extended-A": (r50) => r50 >= 2208 && r50 <= 2303, "Hangul Jamo": (r50) => r50 >= 4352 && r50 <= 4607, "Unified Canadian Aboriginal Syllabics": (r50) => r50 >= 5120 && r50 <= 5759, Khmer: (r50) => r50 >= 6016 && r50 <= 6143, "Unified Canadian Aboriginal Syllabics Extended": (r50) => r50 >= 6320 && r50 <= 6399, "General Punctuation": (r50) => r50 >= 8192 && r50 <= 8303, "Letterlike Symbols": (r50) => r50 >= 8448 && r50 <= 8527, "Number Forms": (r50) => r50 >= 8528 && r50 <= 8591, "Miscellaneous Technical": (r50) => r50 >= 8960 && r50 <= 9215, "Control Pictures": (r50) => r50 >= 9216 && r50 <= 9279, "Optical Character Recognition": (r50) => r50 >= 9280 && r50 <= 9311, "Enclosed Alphanumerics": (r50) => r50 >= 9312 && r50 <= 9471, "Geometric Shapes": (r50) => r50 >= 9632 && r50 <= 9727, "Miscellaneous Symbols": (r50) => r50 >= 9728 && r50 <= 9983, "Miscellaneous Symbols and Arrows": (r50) => r50 >= 11008 && r50 <= 11263, "CJK Radicals Supplement": (r50) => r50 >= 11904 && r50 <= 12031, "Kangxi Radicals": (r50) => r50 >= 12032 && r50 <= 12255, "Ideographic Description Characters": (r50) => r50 >= 12272 && r50 <= 12287, "CJK Symbols and Punctuation": (r50) => r50 >= 12288 && r50 <= 12351, Hiragana: (r50) => r50 >= 12352 && r50 <= 12447, Katakana: (r50) => r50 >= 12448 && r50 <= 12543, Bopomofo: (r50) => r50 >= 12544 && r50 <= 12591, "Hangul Compatibility Jamo": (r50) => r50 >= 12592 && r50 <= 12687, Kanbun: (r50) => r50 >= 12688 && r50 <= 12703, "Bopomofo Extended": (r50) => r50 >= 12704 && r50 <= 12735, "CJK Strokes": (r50) => r50 >= 12736 && r50 <= 12783, "Katakana Phonetic Extensions": (r50) => r50 >= 12784 && r50 <= 12799, "Enclosed CJK Letters and Months": (r50) => r50 >= 12800 && r50 <= 13055, "CJK Compatibility": (r50) => r50 >= 13056 && r50 <= 13311, "CJK Unified Ideographs Extension A": (r50) => r50 >= 13312 && r50 <= 19903, "Yijing Hexagram Symbols": (r50) => r50 >= 19904 && r50 <= 19967, "CJK Unified Ideographs": (r50) => r50 >= 19968 && r50 <= 40959, "Yi Syllables": (r50) => r50 >= 40960 && r50 <= 42127, "Yi Radicals": (r50) => r50 >= 42128 && r50 <= 42191, "Hangul Jamo Extended-A": (r50) => r50 >= 43360 && r50 <= 43391, "Hangul Syllables": (r50) => r50 >= 44032 && r50 <= 55215, "Hangul Jamo Extended-B": (r50) => r50 >= 55216 && r50 <= 55295, "Private Use Area": (r50) => r50 >= 57344 && r50 <= 63743, "CJK Compatibility Ideographs": (r50) => r50 >= 63744 && r50 <= 64255, "Arabic Presentation Forms-A": (r50) => r50 >= 64336 && r50 <= 65023, "Vertical Forms": (r50) => r50 >= 65040 && r50 <= 65055, "CJK Compatibility Forms": (r50) => r50 >= 65072 && r50 <= 65103, "Small Form Variants": (r50) => r50 >= 65104 && r50 <= 65135, "Arabic Presentation Forms-B": (r50) => r50 >= 65136 && r50 <= 65279, "Halfwidth and Fullwidth Forms": (r50) => r50 >= 65280 && r50 <= 65519 };
function hp(r50) {
  for (let e of r50) if (Fm(e.charCodeAt(0))) return true;
  return false;
}
function Fm(r50) {
  return r50 === 746 || r50 === 747 ? true : r50 < 4352 ? false : !!(pe["Bopomofo Extended"](r50) || pe.Bopomofo(r50) || pe["CJK Compatibility Forms"](r50) && !(r50 >= 65097 && r50 <= 65103) || pe["CJK Compatibility Ideographs"](r50) || pe["CJK Compatibility"](r50) || pe["CJK Radicals Supplement"](r50) || pe["CJK Strokes"](r50) || pe["CJK Symbols and Punctuation"](r50) && !(r50 >= 12296 && r50 <= 12305) && !(r50 >= 12308 && r50 <= 12319) && r50 !== 12336 || pe["CJK Unified Ideographs Extension A"](r50) || pe["CJK Unified Ideographs"](r50) || pe["Enclosed CJK Letters and Months"](r50) || pe["Hangul Compatibility Jamo"](r50) || pe["Hangul Jamo Extended-A"](r50) || pe["Hangul Jamo Extended-B"](r50) || pe["Hangul Jamo"](r50) || pe["Hangul Syllables"](r50) || pe.Hiragana(r50) || pe["Ideographic Description Characters"](r50) || pe.Kanbun(r50) || pe["Kangxi Radicals"](r50) || pe["Katakana Phonetic Extensions"](r50) || pe.Katakana(r50) && r50 !== 12540 || pe["Halfwidth and Fullwidth Forms"](r50) && r50 !== 65288 && r50 !== 65289 && r50 !== 65293 && !(r50 >= 65306 && r50 <= 65310) && r50 !== 65339 && r50 !== 65341 && r50 !== 65343 && !(r50 >= 65371 && r50 <= 65503) && r50 !== 65507 && !(r50 >= 65512 && r50 <= 65519) || pe["Small Form Variants"](r50) && !(r50 >= 65112 && r50 <= 65118) && !(r50 >= 65123 && r50 <= 65126) || pe["Unified Canadian Aboriginal Syllabics"](r50) || pe["Unified Canadian Aboriginal Syllabics Extended"](r50) || pe["Vertical Forms"](r50) || pe["Yijing Hexagram Symbols"](r50) || pe["Yi Syllables"](r50) || pe["Yi Radicals"](r50));
}
function Rm(r50) {
  return r50 >= 1424 && r50 <= 2303 || pe["Arabic Presentation Forms-A"](r50) || pe["Arabic Presentation Forms-B"](r50);
}
function h1(r50, e) {
  return !(!e && Rm(r50) || r50 >= 2304 && r50 <= 3583 || r50 >= 3840 && r50 <= 4255 || pe.Khmer(r50));
}
function Bm(r50) {
  for (let e of r50) if (Rm(e.charCodeAt(0))) return true;
  return false;
}
function Om(r50, e) {
  for (let t of r50) if (!h1(t.charCodeAt(0), e)) return false;
  return true;
}
c();
var fp = class {
  constructor() {
    this.applyArabicShaping = null;
    this.processBidirectionalText = null;
    this.processStyledBidirectionalText = null;
    this.pluginStatus = "unavailable";
    this.pluginURL = null;
  }
  setState(e) {
    this.pluginStatus = e.pluginStatus, this.pluginURL = e.pluginURL;
  }
  getState() {
    return { pluginStatus: this.pluginStatus, pluginURL: this.pluginURL };
  }
  setMethods(e) {
    this.applyArabicShaping = e.applyArabicShaping, this.processBidirectionalText = e.processBidirectionalText, this.processStyledBidirectionalText = e.processStyledBidirectionalText;
  }
  isParsed() {
    return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null;
  }
  getPluginURL() {
    return this.pluginURL;
  }
  getRTLTextPluginStatus() {
    return this.pluginStatus;
  }
};
var rr = new fp();
var de = class {
  constructor(e, t) {
    this.zoom = e, t ? (this.now = t.now, this.fadeDuration = t.fadeDuration, this.zoomHistory = t.zoomHistory, this.transition = t.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new Ri(), this.transition = {});
  }
  isSupportedScript(e) {
    return Om(e, rr.getRTLTextPluginStatus() === "loaded");
  }
  crossFadingFactor() {
    return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
  }
  getCrossfadeParameters() {
    let e = this.zoom, t = e - Math.floor(e), i = this.crossFadingFactor();
    return e > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: t + (1 - t) * i } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - i) * t };
  }
};
var Bi = class {
  constructor(e, t) {
    this.property = e, this.value = t, this.expression = mm(t === void 0 ? e.specification.default : t, e.specification);
  }
  isDataDriven() {
    return this.expression.kind === "source" || this.expression.kind === "composite";
  }
  possiblyEvaluate(e, t, i) {
    return this.property.possiblyEvaluate(this, e, t, i);
  }
};
var qn = class {
  constructor(e) {
    this.property = e, this.value = new Bi(e, void 0);
  }
  transitioned(e, t) {
    return new xs(this.property, this.value, t, O({}, e.transition, this.transition), e.now);
  }
  untransitioned() {
    return new xs(this.property, this.value, null, {}, 0);
  }
};
var Oi = class {
  constructor(e) {
    this._properties = e, this._values = Object.create(e.defaultTransitionablePropertyValues);
  }
  getValue(e) {
    return ct(this._values[e].value.value);
  }
  setValue(e, t) {
    Object.prototype.hasOwnProperty.call(this._values, e) || (this._values[e] = new qn(this._values[e].property)), this._values[e].value = new Bi(this._values[e].property, t === null ? void 0 : ct(t));
  }
  getTransition(e) {
    return ct(this._values[e].transition);
  }
  setTransition(e, t) {
    Object.prototype.hasOwnProperty.call(this._values, e) || (this._values[e] = new qn(this._values[e].property)), this._values[e].transition = ct(t) || void 0;
  }
  serialize() {
    let e = {};
    for (let t of Object.keys(this._values)) {
      let i = this.getValue(t);
      i !== void 0 && (e[t] = i);
      let n = this.getTransition(t);
      n !== void 0 && (e["".concat(t, "-transition")] = n);
    }
    return e;
  }
  transitioned(e, t) {
    let i = new bs(this._properties);
    for (let n of Object.keys(this._values)) i._values[n] = this._values[n].transitioned(e, t._values[n]);
    return i;
  }
  untransitioned() {
    let e = new bs(this._properties);
    for (let t of Object.keys(this._values)) e._values[t] = this._values[t].untransitioned();
    return e;
  }
};
var xs = class {
  constructor(e, t, i, n, o) {
    this.property = e, this.value = t, this.begin = o + n.delay || 0, this.end = this.begin + n.duration || 0, e.specification.transition && (n.delay || n.duration) && (this.prior = i);
  }
  possiblyEvaluate(e, t, i) {
    let n = e.now || 0, o = this.value.possiblyEvaluate(e, t, i), a = this.prior;
    if (a) {
      if (n > this.end) return this.prior = null, o;
      if (this.value.isDataDriven()) return this.prior = null, o;
      if (n < this.begin) return a.possiblyEvaluate(e, t, i);
      {
        let s3 = (n - this.begin) / (this.end - this.begin);
        return this.property.interpolate(a.possiblyEvaluate(e, t, i), o, rf(s3));
      }
    } else return o;
  }
};
var bs = class {
  constructor(e) {
    this._properties = e, this._values = Object.create(e.defaultTransitioningPropertyValues);
  }
  possiblyEvaluate(e, t, i) {
    let n = new vr(this._properties);
    for (let o of Object.keys(this._values)) n._values[o] = this._values[o].possiblyEvaluate(e, t, i);
    return n;
  }
  hasTransition() {
    for (let e of Object.keys(this._values)) if (this._values[e].prior) return true;
    return false;
  }
};
var _s = class {
  constructor(e) {
    this._properties = e, this._values = Object.create(e.defaultPropertyValues);
  }
  hasValue(e) {
    return this._values[e].value !== void 0;
  }
  getValue(e) {
    return ct(this._values[e].value);
  }
  setValue(e, t) {
    this._values[e] = new Bi(this._values[e].property, t === null ? void 0 : ct(t));
  }
  serialize() {
    let e = {};
    for (let t of Object.keys(this._values)) {
      let i = this.getValue(t);
      i !== void 0 && (e[t] = i);
    }
    return e;
  }
  possiblyEvaluate(e, t, i) {
    let n = new vr(this._properties);
    for (let o of Object.keys(this._values)) n._values[o] = this._values[o].possiblyEvaluate(e, t, i);
    return n;
  }
};
var ot = class {
  constructor(e, t, i) {
    this.property = e, this.value = t, this.parameters = i;
  }
  isConstant() {
    return this.value.kind === "constant";
  }
  constantOr(e) {
    return this.value.kind === "constant" ? this.value.value : e;
  }
  evaluate(e, t, i, n) {
    return this.property.evaluate(this.value, this.parameters, e, t, i, n);
  }
};
var vr = class {
  constructor(e) {
    this._properties = e, this._values = Object.create(e.defaultPossiblyEvaluatedValues);
  }
  get(e) {
    return this._values[e];
  }
};
var j = class {
  constructor(e) {
    this.specification = e;
  }
  possiblyEvaluate(e, t) {
    if (e.isDataDriven()) throw new Error("Value should not be data driven");
    return e.expression.evaluate(t);
  }
  interpolate(e, t, i) {
    let n = this.specification.type, o = Se[n];
    return o ? o(e, t, i) : e;
  }
};
var H = class {
  constructor(e, t) {
    this.specification = e, this.overrides = t;
  }
  possiblyEvaluate(e, t, i, n) {
    return e.expression.kind === "constant" || e.expression.kind === "camera" ? new ot(this, { kind: "constant", value: e.expression.evaluate(t, null, {}, i, n) }, t) : new ot(this, e.expression, t);
  }
  interpolate(e, t, i) {
    if (e.value.kind !== "constant" || t.value.kind !== "constant") return e;
    if (e.value.value === void 0 || t.value.value === void 0) return new ot(this, { kind: "constant", value: void 0 }, e.parameters);
    let n = this.specification.type, o = Se[n];
    if (o) {
      let a = o(e.value.value, t.value.value, i);
      return new ot(this, { kind: "constant", value: a }, e.parameters);
    } else return e;
  }
  evaluate(e, t, i, n, o, a) {
    return e.kind === "constant" ? e.value : e.evaluate(t, i, n, o, a);
  }
};
var ir = class extends H {
  possiblyEvaluate(e, t, i, n) {
    if (e.value === void 0) return new ot(this, { kind: "constant", value: void 0 }, t);
    if (e.expression.kind === "constant") {
      let o = e.expression.evaluate(t, null, {}, i, n), s3 = e.property.specification.type === "resolvedImage" && typeof o != "string" ? o.name : o, l = this._calculate(s3, s3, s3, t);
      return new ot(this, { kind: "constant", value: l }, t);
    } else if (e.expression.kind === "camera") {
      let o = this._calculate(e.expression.evaluate({ zoom: t.zoom - 1 }), e.expression.evaluate({ zoom: t.zoom }), e.expression.evaluate({ zoom: t.zoom + 1 }), t);
      return new ot(this, { kind: "constant", value: o }, t);
    } else return new ot(this, e.expression, t);
  }
  evaluate(e, t, i, n, o, a) {
    if (e.kind === "source") {
      let s3 = e.evaluate(t, i, n, o, a);
      return this._calculate(s3, s3, s3, t);
    } else return e.kind === "composite" ? this._calculate(e.evaluate({ zoom: Math.floor(t.zoom) - 1 }, i, n), e.evaluate({ zoom: Math.floor(t.zoom) }, i, n), e.evaluate({ zoom: Math.floor(t.zoom) + 1 }, i, n), t) : e.value;
  }
  _calculate(e, t, i, n) {
    return n.zoom > n.zoomHistory.lastIntegerZoom ? { from: e, to: t } : { from: i, to: t };
  }
  interpolate(e) {
    return e;
  }
};
var Qr = class {
  constructor(e) {
    this.specification = e;
  }
  possiblyEvaluate(e, t, i, n) {
    if (e.value !== void 0) if (e.expression.kind === "constant") {
      let o = e.expression.evaluate(t, null, {}, i, n);
      return this._calculate(o, o, o, t);
    } else return this._calculate(e.expression.evaluate(new de(Math.floor(t.zoom - 1), t)), e.expression.evaluate(new de(Math.floor(t.zoom), t)), e.expression.evaluate(new de(Math.floor(t.zoom + 1), t)), t);
  }
  _calculate(e, t, i, n) {
    return n.zoom > n.zoomHistory.lastIntegerZoom ? { from: e, to: t } : { from: i, to: t };
  }
  interpolate(e) {
    return e;
  }
};
var ei = class {
  constructor(e) {
    this.specification = e;
  }
  possiblyEvaluate(e, t, i, n) {
    return !!e.expression.evaluate(t, null, {}, i, n);
  }
  interpolate() {
    return false;
  }
};
var Le = class {
  constructor(e) {
    this.properties = e, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
    for (let t in e) {
      let i = e[t];
      i.specification.overridable && this.overridableProperties.push(t);
      let n = this.defaultPropertyValues[t] = new Bi(i, void 0), o = this.defaultTransitionablePropertyValues[t] = new qn(i);
      this.defaultTransitioningPropertyValues[t] = o.untransitioned(), this.defaultPossiblyEvaluatedValues[t] = n.possiblyEvaluate({});
    }
  }
};
U("DataDrivenProperty", H);
U("DataConstantProperty", j);
U("CrossFadedDataDrivenProperty", ir);
U("CrossFadedProperty", Qr);
U("ColorRampProperty", ei);
var vs = "-transition";
var Ne = class extends me {
  constructor(e, t) {
    if (super(), this.id = e.id, this.type = e.type, this._featureFilter = { filter: () => true, needGeometry: false }, e.type !== "custom" && (e = e, this.metadata = e.metadata, this.minzoom = e.minzoom, this.maxzoom = e.maxzoom, e.type !== "background" && (this.source = e.source, this.sourceLayer = e["source-layer"], this.filter = e.filter), t.layout && (this._unevaluatedLayout = new _s(t.layout)), t.paint)) {
      this._transitionablePaint = new Oi(t.paint);
      for (let i in e.paint) this.setPaintProperty(i, e.paint[i], { validate: false });
      for (let i in e.layout) this.setLayoutProperty(i, e.layout[i], { validate: false });
      this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new vr(t.paint);
    }
  }
  getCrossfadeParameters() {
    return this._crossfadeParameters;
  }
  getLayoutProperty(e) {
    return e === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(e);
  }
  setLayoutProperty(e, t, i = {}) {
    if (t != null) {
      let n = "layers.".concat(this.id, ".layout.").concat(e);
      if (this._validate(Dm, n, e, t, i)) return;
    }
    if (e === "visibility") {
      this.visibility = t;
      return;
    }
    this._unevaluatedLayout.setValue(e, t);
  }
  getPaintProperty(e) {
    return e.endsWith(vs) ? this._transitionablePaint.getTransition(e.slice(0, -vs.length)) : this._transitionablePaint.getValue(e);
  }
  setPaintProperty(e, t, i = {}) {
    if (t != null) {
      let n = "layers.".concat(this.id, ".paint.").concat(e);
      if (this._validate(Lm, n, e, t, i)) return false;
    }
    if (e.endsWith(vs)) return this._transitionablePaint.setTransition(e.slice(0, -vs.length), t || void 0), false;
    {
      let n = this._transitionablePaint._values[e], o = n.property.specification["property-type"] === "cross-faded-data-driven", a = n.value.isDataDriven(), s3 = n.value;
      this._transitionablePaint.setValue(e, t), this._handleSpecialPaintPropertyUpdate(e);
      let l = this._transitionablePaint._values[e].value;
      return l.isDataDriven() || a || o || this._handleOverridablePaintPropertyUpdate(e, s3, l);
    }
  }
  _handleSpecialPaintPropertyUpdate(e) {
  }
  _handleOverridablePaintPropertyUpdate(e, t, i) {
    return false;
  }
  isHidden(e) {
    return this.minzoom && e < this.minzoom || this.maxzoom && e >= this.maxzoom ? true : this.visibility === "none";
  }
  updateTransitions(e) {
    this._transitioningPaint = this._transitionablePaint.transitioned(e, this._transitioningPaint);
  }
  hasTransition() {
    return this._transitioningPaint.hasTransition();
  }
  recalculate(e, t) {
    e.getCrossfadeParameters && (this._crossfadeParameters = e.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(e, void 0, t)), this.paint = this._transitioningPaint.possiblyEvaluate(e, void 0, t);
  }
  serialize() {
    let e = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
    return this.visibility && (e.layout = e.layout || {}, e.layout.visibility = this.visibility), Va(e, (t, i) => t !== void 0 && !(i === "layout" && !Object.keys(t).length) && !(i === "paint" && !Object.keys(t).length));
  }
  _validate(e, t, i, n, o = {}) {
    return o && o.validate === false ? false : Di(this, e.call(Ue, { key: t, layerType: this.type, objectKey: i, value: n, styleSpec: A, style: { glyphs: true, sprite: true } }));
  }
  is3D() {
    return false;
  }
  isTileClipped() {
    return false;
  }
  hasOffscreenPass() {
    return false;
  }
  resize() {
  }
  isStateDependent() {
    for (let e in this.paint._values) {
      let t = this.paint.get(e);
      if (!(!(t instanceof ot) || !gr(t.property.specification)) && (t.value.kind === "source" || t.value.kind === "composite") && t.value.isStateDependent) return true;
    }
    return false;
  }
};
c();
c();
c();
var f1 = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
var wr = class {
  constructor(e, t) {
    this._structArray = e, this._pos1 = t * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
  }
};
var m1 = 128;
var d1 = 5;
var De = class {
  constructor() {
    this.isTransferred = false, this.capacity = -1, this.resize(0);
  }
  static serialize(e, t) {
    return e._trim(), t && (e.isTransferred = true, t.push(e.arrayBuffer)), { length: e.length, arrayBuffer: e.arrayBuffer };
  }
  static deserialize(e) {
    let t = Object.create(this.prototype);
    return t.arrayBuffer = e.arrayBuffer, t.length = e.length, t.capacity = e.arrayBuffer.byteLength / t.bytesPerElement, t._refreshViews(), t;
  }
  _trim() {
    this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
  }
  clear() {
    this.length = 0;
  }
  resize(e) {
    this.reserve(e), this.length = e;
  }
  reserve(e) {
    if (e > this.capacity) {
      this.capacity = Math.max(e, Math.floor(this.capacity * d1), m1), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
      let t = this.uint8;
      this._refreshViews(), t && this.uint8.set(t);
    }
  }
  _refreshViews() {
    throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
  }
};
function be(r50, e = 1) {
  let t = 0, i = 0, n = r50.map((a) => {
    let s3 = y1(a.type), l = t = Vm(t, Math.max(e, s3)), u = a.components || 1;
    return i = Math.max(i, s3), t += s3 * u, { name: a.name, type: a.type, components: u, offset: l };
  }), o = Vm(t, Math.max(i, e));
  return { members: n, size: o, alignment: e };
}
function y1(r50) {
  return f1[r50].BYTES_PER_ELEMENT;
}
function Vm(r50, e) {
  return Math.ceil(r50 / e) * e;
}
var Um = s(ye(), 1);
var ti = class extends De {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
  }
  emplaceBack(e, t) {
    let i = this.length;
    return this.resize(i + 1), this.emplace(i, e, t);
  }
  emplace(e, t, i) {
    let n = e * 2;
    return this.int16[n + 0] = t, this.int16[n + 1] = i, e;
  }
};
ti.prototype.bytesPerElement = 4;
U("StructArrayLayout2i4", ti);
var Vi = class extends De {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
  }
  emplaceBack(e, t, i) {
    let n = this.length;
    return this.resize(n + 1), this.emplace(n, e, t, i);
  }
  emplace(e, t, i, n) {
    let o = e * 3;
    return this.int16[o + 0] = t, this.int16[o + 1] = i, this.int16[o + 2] = n, e;
  }
};
Vi.prototype.bytesPerElement = 6;
U("StructArrayLayout3i6", Vi);
var jn = class extends De {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
  }
  emplaceBack(e, t, i, n) {
    let o = this.length;
    return this.resize(o + 1), this.emplace(o, e, t, i, n);
  }
  emplace(e, t, i, n, o) {
    let a = e * 4;
    return this.int16[a + 0] = t, this.int16[a + 1] = i, this.int16[a + 2] = n, this.int16[a + 3] = o, e;
  }
};
jn.prototype.bytesPerElement = 8;
U("StructArrayLayout4i8", jn);
var Zn = class extends De {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
  }
  emplaceBack(e, t, i, n, o, a) {
    let s3 = this.length;
    return this.resize(s3 + 1), this.emplace(s3, e, t, i, n, o, a);
  }
  emplace(e, t, i, n, o, a, s3) {
    let l = e * 6;
    return this.int16[l + 0] = t, this.int16[l + 1] = i, this.int16[l + 2] = n, this.int16[l + 3] = o, this.int16[l + 4] = a, this.int16[l + 5] = s3, e;
  }
};
Zn.prototype.bytesPerElement = 12;
U("StructArrayLayout2i4i12", Zn);
var Hn = class extends De {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
  }
  emplaceBack(e, t, i, n, o, a) {
    let s3 = this.length;
    return this.resize(s3 + 1), this.emplace(s3, e, t, i, n, o, a);
  }
  emplace(e, t, i, n, o, a, s3) {
    let l = e * 4, u = e * 8;
    return this.int16[l + 0] = t, this.int16[l + 1] = i, this.uint8[u + 4] = n, this.uint8[u + 5] = o, this.uint8[u + 6] = a, this.uint8[u + 7] = s3, e;
  }
};
Hn.prototype.bytesPerElement = 8;
U("StructArrayLayout2i4ub8", Hn);
var Sr = class extends De {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
  }
  emplaceBack(e, t) {
    let i = this.length;
    return this.resize(i + 1), this.emplace(i, e, t);
  }
  emplace(e, t, i) {
    let n = e * 2;
    return this.float32[n + 0] = t, this.float32[n + 1] = i, e;
  }
};
Sr.prototype.bytesPerElement = 8;
U("StructArrayLayout2f8", Sr);
var $n = class extends De {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
  }
  emplaceBack(e, t, i, n, o, a, s3, l, u, c3) {
    let p = this.length;
    return this.resize(p + 1), this.emplace(p, e, t, i, n, o, a, s3, l, u, c3);
  }
  emplace(e, t, i, n, o, a, s3, l, u, c3, p) {
    let h = e * 10;
    return this.uint16[h + 0] = t, this.uint16[h + 1] = i, this.uint16[h + 2] = n, this.uint16[h + 3] = o, this.uint16[h + 4] = a, this.uint16[h + 5] = s3, this.uint16[h + 6] = l, this.uint16[h + 7] = u, this.uint16[h + 8] = c3, this.uint16[h + 9] = p, e;
  }
};
$n.prototype.bytesPerElement = 20;
U("StructArrayLayout10ui20", $n);
var Wn = class extends De {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
  }
  emplaceBack(e, t, i, n, o, a, s3, l, u, c3, p, h) {
    let f = this.length;
    return this.resize(f + 1), this.emplace(f, e, t, i, n, o, a, s3, l, u, c3, p, h);
  }
  emplace(e, t, i, n, o, a, s3, l, u, c3, p, h, f) {
    let d = e * 12;
    return this.int16[d + 0] = t, this.int16[d + 1] = i, this.int16[d + 2] = n, this.int16[d + 3] = o, this.uint16[d + 4] = a, this.uint16[d + 5] = s3, this.uint16[d + 6] = l, this.uint16[d + 7] = u, this.int16[d + 8] = c3, this.int16[d + 9] = p, this.int16[d + 10] = h, this.int16[d + 11] = f, e;
  }
};
Wn.prototype.bytesPerElement = 24;
U("StructArrayLayout4i4ui4i24", Wn);
var Xn = class extends De {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
  }
  emplaceBack(e, t, i) {
    let n = this.length;
    return this.resize(n + 1), this.emplace(n, e, t, i);
  }
  emplace(e, t, i, n) {
    let o = e * 3;
    return this.float32[o + 0] = t, this.float32[o + 1] = i, this.float32[o + 2] = n, e;
  }
};
Xn.prototype.bytesPerElement = 12;
U("StructArrayLayout3f12", Xn);
var Kn = class extends De {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
  }
  emplaceBack(e) {
    let t = this.length;
    return this.resize(t + 1), this.emplace(t, e);
  }
  emplace(e, t) {
    let i = e * 1;
    return this.uint32[i + 0] = t, e;
  }
};
Kn.prototype.bytesPerElement = 4;
U("StructArrayLayout1ul4", Kn);
var Jn = class extends De {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
  }
  emplaceBack(e, t, i, n, o, a, s3, l, u) {
    let c3 = this.length;
    return this.resize(c3 + 1), this.emplace(c3, e, t, i, n, o, a, s3, l, u);
  }
  emplace(e, t, i, n, o, a, s3, l, u, c3) {
    let p = e * 10, h = e * 5;
    return this.int16[p + 0] = t, this.int16[p + 1] = i, this.int16[p + 2] = n, this.int16[p + 3] = o, this.int16[p + 4] = a, this.int16[p + 5] = s3, this.uint32[h + 3] = l, this.uint16[p + 8] = u, this.uint16[p + 9] = c3, e;
  }
};
Jn.prototype.bytesPerElement = 20;
U("StructArrayLayout6i1ul2ui20", Jn);
var Yn = class extends De {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
  }
  emplaceBack(e, t, i, n, o, a) {
    let s3 = this.length;
    return this.resize(s3 + 1), this.emplace(s3, e, t, i, n, o, a);
  }
  emplace(e, t, i, n, o, a, s3) {
    let l = e * 6;
    return this.int16[l + 0] = t, this.int16[l + 1] = i, this.int16[l + 2] = n, this.int16[l + 3] = o, this.int16[l + 4] = a, this.int16[l + 5] = s3, e;
  }
};
Yn.prototype.bytesPerElement = 12;
U("StructArrayLayout2i2i2i12", Yn);
var Qn = class extends De {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
  }
  emplaceBack(e, t, i, n, o) {
    let a = this.length;
    return this.resize(a + 1), this.emplace(a, e, t, i, n, o);
  }
  emplace(e, t, i, n, o, a) {
    let s3 = e * 4, l = e * 8;
    return this.float32[s3 + 0] = t, this.float32[s3 + 1] = i, this.float32[s3 + 2] = n, this.int16[l + 6] = o, this.int16[l + 7] = a, e;
  }
};
Qn.prototype.bytesPerElement = 16;
U("StructArrayLayout2f1f2i16", Qn);
var eo = class extends De {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
  }
  emplaceBack(e, t, i, n) {
    let o = this.length;
    return this.resize(o + 1), this.emplace(o, e, t, i, n);
  }
  emplace(e, t, i, n, o) {
    let a = e * 12, s3 = e * 3;
    return this.uint8[a + 0] = t, this.uint8[a + 1] = i, this.float32[s3 + 1] = n, this.float32[s3 + 2] = o, e;
  }
};
eo.prototype.bytesPerElement = 12;
U("StructArrayLayout2ub2f12", eo);
var Ui = class extends De {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
  }
  emplaceBack(e, t, i) {
    let n = this.length;
    return this.resize(n + 1), this.emplace(n, e, t, i);
  }
  emplace(e, t, i, n) {
    let o = e * 3;
    return this.uint16[o + 0] = t, this.uint16[o + 1] = i, this.uint16[o + 2] = n, e;
  }
};
Ui.prototype.bytesPerElement = 6;
U("StructArrayLayout3ui6", Ui);
var to = class extends De {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
  }
  emplaceBack(e, t, i, n, o, a, s3, l, u, c3, p, h, f, d, y, g, x) {
    let v = this.length;
    return this.resize(v + 1), this.emplace(v, e, t, i, n, o, a, s3, l, u, c3, p, h, f, d, y, g, x);
  }
  emplace(e, t, i, n, o, a, s3, l, u, c3, p, h, f, d, y, g, x, v) {
    let b = e * 24, w = e * 12, S = e * 48;
    return this.int16[b + 0] = t, this.int16[b + 1] = i, this.uint16[b + 2] = n, this.uint16[b + 3] = o, this.uint32[w + 2] = a, this.uint32[w + 3] = s3, this.uint32[w + 4] = l, this.uint16[b + 10] = u, this.uint16[b + 11] = c3, this.uint16[b + 12] = p, this.float32[w + 7] = h, this.float32[w + 8] = f, this.uint8[S + 36] = d, this.uint8[S + 37] = y, this.uint8[S + 38] = g, this.uint32[w + 10] = x, this.int16[b + 22] = v, e;
  }
};
to.prototype.bytesPerElement = 48;
U("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", to);
var ro = class extends De {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
  }
  emplaceBack(e, t, i, n, o, a, s3, l, u, c3, p, h, f, d, y, g, x, v, b, w, S, P, k, I, C, M, F, D) {
    let E = this.length;
    return this.resize(E + 1), this.emplace(E, e, t, i, n, o, a, s3, l, u, c3, p, h, f, d, y, g, x, v, b, w, S, P, k, I, C, M, F, D);
  }
  emplace(e, t, i, n, o, a, s3, l, u, c3, p, h, f, d, y, g, x, v, b, w, S, P, k, I, C, M, F, D, E) {
    let T = e * 32, N = e * 16;
    return this.int16[T + 0] = t, this.int16[T + 1] = i, this.int16[T + 2] = n, this.int16[T + 3] = o, this.int16[T + 4] = a, this.int16[T + 5] = s3, this.int16[T + 6] = l, this.int16[T + 7] = u, this.uint16[T + 8] = c3, this.uint16[T + 9] = p, this.uint16[T + 10] = h, this.uint16[T + 11] = f, this.uint16[T + 12] = d, this.uint16[T + 13] = y, this.uint16[T + 14] = g, this.uint16[T + 15] = x, this.uint16[T + 16] = v, this.uint16[T + 17] = b, this.uint16[T + 18] = w, this.uint16[T + 19] = S, this.uint16[T + 20] = P, this.uint16[T + 21] = k, this.uint16[T + 22] = I, this.uint32[N + 12] = C, this.float32[N + 13] = M, this.float32[N + 14] = F, this.uint16[T + 30] = D, this.uint16[T + 31] = E, e;
  }
};
ro.prototype.bytesPerElement = 64;
U("StructArrayLayout8i15ui1ul2f2ui64", ro);
var ri = class extends De {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
  }
  emplaceBack(e) {
    let t = this.length;
    return this.resize(t + 1), this.emplace(t, e);
  }
  emplace(e, t) {
    let i = e * 1;
    return this.float32[i + 0] = t, e;
  }
};
ri.prototype.bytesPerElement = 4;
U("StructArrayLayout1f4", ri);
var io = class extends De {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
  }
  emplaceBack(e, t, i) {
    let n = this.length;
    return this.resize(n + 1), this.emplace(n, e, t, i);
  }
  emplace(e, t, i, n) {
    let o = e * 6, a = e * 3;
    return this.uint16[o + 0] = t, this.float32[a + 1] = i, this.float32[a + 2] = n, e;
  }
};
io.prototype.bytesPerElement = 12;
U("StructArrayLayout1ui2f12", io);
var no = class extends De {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
  }
  emplaceBack(e, t, i) {
    let n = this.length;
    return this.resize(n + 1), this.emplace(n, e, t, i);
  }
  emplace(e, t, i, n) {
    let o = e * 2, a = e * 4;
    return this.uint32[o + 0] = t, this.uint16[a + 2] = i, this.uint16[a + 3] = n, e;
  }
};
no.prototype.bytesPerElement = 8;
U("StructArrayLayout1ul2ui8", no);
var oo = class extends De {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
  }
  emplaceBack(e, t) {
    let i = this.length;
    return this.resize(i + 1), this.emplace(i, e, t);
  }
  emplace(e, t, i) {
    let n = e * 2;
    return this.uint16[n + 0] = t, this.uint16[n + 1] = i, e;
  }
};
oo.prototype.bytesPerElement = 4;
U("StructArrayLayout2ui4", oo);
var ao = class extends De {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
  }
  emplaceBack(e) {
    let t = this.length;
    return this.resize(t + 1), this.emplace(t, e);
  }
  emplace(e, t) {
    let i = e * 1;
    return this.uint16[i + 0] = t, e;
  }
};
ao.prototype.bytesPerElement = 2;
U("StructArrayLayout1ui2", ao);
var Ni = class extends De {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
  }
  emplaceBack(e, t, i, n) {
    let o = this.length;
    return this.resize(o + 1), this.emplace(o, e, t, i, n);
  }
  emplace(e, t, i, n, o) {
    let a = e * 4;
    return this.float32[a + 0] = t, this.float32[a + 1] = i, this.float32[a + 2] = n, this.float32[a + 3] = o, e;
  }
};
Ni.prototype.bytesPerElement = 16;
U("StructArrayLayout4f16", Ni);
var ws = class extends wr {
  get anchorPointX() {
    return this._structArray.int16[this._pos2 + 0];
  }
  get anchorPointY() {
    return this._structArray.int16[this._pos2 + 1];
  }
  get x1() {
    return this._structArray.int16[this._pos2 + 2];
  }
  get y1() {
    return this._structArray.int16[this._pos2 + 3];
  }
  get x2() {
    return this._structArray.int16[this._pos2 + 4];
  }
  get y2() {
    return this._structArray.int16[this._pos2 + 5];
  }
  get featureIndex() {
    return this._structArray.uint32[this._pos4 + 3];
  }
  get sourceLayerIndex() {
    return this._structArray.uint16[this._pos2 + 8];
  }
  get bucketIndex() {
    return this._structArray.uint16[this._pos2 + 9];
  }
  get anchorPoint() {
    return new Um.default(this.anchorPointX, this.anchorPointY);
  }
};
ws.prototype.size = 20;
var so = class extends Jn {
  get(e) {
    return new ws(this, e);
  }
};
U("CollisionBoxArray", so);
var Ss = class extends wr {
  get anchorX() {
    return this._structArray.int16[this._pos2 + 0];
  }
  get anchorY() {
    return this._structArray.int16[this._pos2 + 1];
  }
  get glyphStartIndex() {
    return this._structArray.uint16[this._pos2 + 2];
  }
  get numGlyphs() {
    return this._structArray.uint16[this._pos2 + 3];
  }
  get vertexStartIndex() {
    return this._structArray.uint32[this._pos4 + 2];
  }
  get lineStartIndex() {
    return this._structArray.uint32[this._pos4 + 3];
  }
  get lineLength() {
    return this._structArray.uint32[this._pos4 + 4];
  }
  get segment() {
    return this._structArray.uint16[this._pos2 + 10];
  }
  get lowerSize() {
    return this._structArray.uint16[this._pos2 + 11];
  }
  get upperSize() {
    return this._structArray.uint16[this._pos2 + 12];
  }
  get lineOffsetX() {
    return this._structArray.float32[this._pos4 + 7];
  }
  get lineOffsetY() {
    return this._structArray.float32[this._pos4 + 8];
  }
  get writingMode() {
    return this._structArray.uint8[this._pos1 + 36];
  }
  get placedOrientation() {
    return this._structArray.uint8[this._pos1 + 37];
  }
  set placedOrientation(e) {
    this._structArray.uint8[this._pos1 + 37] = e;
  }
  get hidden() {
    return this._structArray.uint8[this._pos1 + 38];
  }
  set hidden(e) {
    this._structArray.uint8[this._pos1 + 38] = e;
  }
  get crossTileID() {
    return this._structArray.uint32[this._pos4 + 10];
  }
  set crossTileID(e) {
    this._structArray.uint32[this._pos4 + 10] = e;
  }
  get associatedIconIndex() {
    return this._structArray.int16[this._pos2 + 22];
  }
};
Ss.prototype.size = 48;
var lo = class extends to {
  get(e) {
    return new Ss(this, e);
  }
};
U("PlacedSymbolArray", lo);
var Ps = class extends wr {
  get anchorX() {
    return this._structArray.int16[this._pos2 + 0];
  }
  get anchorY() {
    return this._structArray.int16[this._pos2 + 1];
  }
  get rightJustifiedTextSymbolIndex() {
    return this._structArray.int16[this._pos2 + 2];
  }
  get centerJustifiedTextSymbolIndex() {
    return this._structArray.int16[this._pos2 + 3];
  }
  get leftJustifiedTextSymbolIndex() {
    return this._structArray.int16[this._pos2 + 4];
  }
  get verticalPlacedTextSymbolIndex() {
    return this._structArray.int16[this._pos2 + 5];
  }
  get placedIconSymbolIndex() {
    return this._structArray.int16[this._pos2 + 6];
  }
  get verticalPlacedIconSymbolIndex() {
    return this._structArray.int16[this._pos2 + 7];
  }
  get key() {
    return this._structArray.uint16[this._pos2 + 8];
  }
  get textBoxStartIndex() {
    return this._structArray.uint16[this._pos2 + 9];
  }
  get textBoxEndIndex() {
    return this._structArray.uint16[this._pos2 + 10];
  }
  get verticalTextBoxStartIndex() {
    return this._structArray.uint16[this._pos2 + 11];
  }
  get verticalTextBoxEndIndex() {
    return this._structArray.uint16[this._pos2 + 12];
  }
  get iconBoxStartIndex() {
    return this._structArray.uint16[this._pos2 + 13];
  }
  get iconBoxEndIndex() {
    return this._structArray.uint16[this._pos2 + 14];
  }
  get verticalIconBoxStartIndex() {
    return this._structArray.uint16[this._pos2 + 15];
  }
  get verticalIconBoxEndIndex() {
    return this._structArray.uint16[this._pos2 + 16];
  }
  get featureIndex() {
    return this._structArray.uint16[this._pos2 + 17];
  }
  get numHorizontalGlyphVertices() {
    return this._structArray.uint16[this._pos2 + 18];
  }
  get numVerticalGlyphVertices() {
    return this._structArray.uint16[this._pos2 + 19];
  }
  get numIconVertices() {
    return this._structArray.uint16[this._pos2 + 20];
  }
  get numVerticalIconVertices() {
    return this._structArray.uint16[this._pos2 + 21];
  }
  get useRuntimeCollisionCircles() {
    return this._structArray.uint16[this._pos2 + 22];
  }
  get crossTileID() {
    return this._structArray.uint32[this._pos4 + 12];
  }
  set crossTileID(e) {
    this._structArray.uint32[this._pos4 + 12] = e;
  }
  get textBoxScale() {
    return this._structArray.float32[this._pos4 + 13];
  }
  get collisionCircleDiameter() {
    return this._structArray.float32[this._pos4 + 14];
  }
  get textAnchorOffsetStartIndex() {
    return this._structArray.uint16[this._pos2 + 30];
  }
  get textAnchorOffsetEndIndex() {
    return this._structArray.uint16[this._pos2 + 31];
  }
};
Ps.prototype.size = 64;
var uo = class extends ro {
  get(e) {
    return new Ps(this, e);
  }
};
U("SymbolInstanceArray", uo);
var co = class extends ri {
  getoffsetX(e) {
    return this.float32[e * 1 + 0];
  }
};
U("GlyphOffsetArray", co);
var po = class extends Vi {
  getx(e) {
    return this.int16[e * 3 + 0];
  }
  gety(e) {
    return this.int16[e * 3 + 1];
  }
  gettileUnitDistanceFromAnchor(e) {
    return this.int16[e * 3 + 2];
  }
};
U("SymbolLineVertexArray", po);
var Ts = class extends wr {
  get textAnchor() {
    return this._structArray.uint16[this._pos2 + 0];
  }
  get textOffset0() {
    return this._structArray.float32[this._pos4 + 1];
  }
  get textOffset1() {
    return this._structArray.float32[this._pos4 + 2];
  }
};
Ts.prototype.size = 12;
var ho = class extends io {
  get(e) {
    return new Ts(this, e);
  }
};
U("TextAnchorOffsetArray", ho);
var As = class extends wr {
  get featureIndex() {
    return this._structArray.uint32[this._pos4 + 0];
  }
  get sourceLayerIndex() {
    return this._structArray.uint16[this._pos2 + 2];
  }
  get bucketIndex() {
    return this._structArray.uint16[this._pos2 + 3];
  }
};
As.prototype.size = 8;
var fo = class extends no {
  get(e) {
    return new As(this, e);
  }
};
U("FeatureIndexArray", fo);
var Pr = class extends ti {
};
var Ms = class extends Vi {
};
var Gi = class extends jn {
};
var Is = class extends ti {
};
var Cs = class extends ti {
};
var Es = class extends Zn {
};
var ks = class extends Hn {
};
var Ls = class extends Sr {
};
var nr = class extends $n {
};
var Ds = class extends Wn {
};
var zs = class extends Xn {
};
var Fs = class extends Kn {
};
var mo = class extends Yn {
};
var Rs = class extends Qn {
};
var Bs = class extends eo {
};
var Os = class extends Ui {
};
var tt = class extends Ui {
};
var Tr = class extends oo {
};
var yo = class extends ao {
};
c();
var g1 = be([{ name: "a_pos", components: 2, type: "Int16" }], 4);
var { members: Nm, size: OC, alignment: VC } = g1;
c();
var fe = class r33 {
  constructor(e = []) {
    this.segments = e;
  }
  prepareSegment(e, t, i, n) {
    let o = this.segments[this.segments.length - 1];
    return e > r33.MAX_VERTEX_ARRAY_LENGTH && Ee("Max vertices per segment is ".concat(r33.MAX_VERTEX_ARRAY_LENGTH, ": bucket requested ").concat(e)), (!o || o.vertexLength + e > r33.MAX_VERTEX_ARRAY_LENGTH || o.sortKey !== n) && (o = { vertexOffset: t.length, primitiveOffset: i.length, vertexLength: 0, primitiveLength: 0 }, n !== void 0 && (o.sortKey = n), this.segments.push(o)), o;
  }
  get() {
    return this.segments;
  }
  destroy() {
    for (let e of this.segments) for (let t in e.vaos) e.vaos[t].destroy();
  }
  static simpleSegment(e, t, i, n) {
    return new r33([{ vertexOffset: e, primitiveOffset: t, vertexLength: i, primitiveLength: n, vaos: {}, sortKey: 0 }]);
  }
};
fe.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1;
U("SegmentVector", fe);
c();
c();
function mp(r50, e) {
  return r50 = Ae(Math.floor(r50), 0, 255), e = Ae(Math.floor(e), 0, 255), 256 * r50 + e;
}
c();
var go = be([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]);
c();
var Hm = s(gp(), 1);
var xo = class r34 {
  constructor() {
    this.ids = [], this.positions = [], this.indexed = false;
  }
  add(e, t, i, n) {
    this.ids.push(Zm(e)), this.positions.push(t, i, n);
  }
  getPositions(e) {
    if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
    let t = Zm(e), i = 0, n = this.ids.length - 1;
    for (; i < n; ) {
      let a = i + n >> 1;
      this.ids[a] >= t ? n = a : i = a + 1;
    }
    let o = [];
    for (; this.ids[i] === t; ) {
      let a = this.positions[3 * i], s3 = this.positions[3 * i + 1], l = this.positions[3 * i + 2];
      o.push({ index: a, start: s3, end: l }), i++;
    }
    return o;
  }
  static serialize(e, t) {
    let i = new Float64Array(e.ids), n = new Uint32Array(e.positions);
    return xp(i, n, 0, i.length - 1), t && t.push(i.buffer, n.buffer), { ids: i, positions: n };
  }
  static deserialize(e) {
    let t = new r34();
    return t.ids = e.ids, t.positions = e.positions, t.indexed = true, t;
  }
};
function Zm(r50) {
  let e = +r50;
  return !isNaN(e) && e <= Number.MAX_SAFE_INTEGER ? e : (0, Hm.default)(String(r50));
}
function xp(r50, e, t, i) {
  for (; t < i; ) {
    let n = r50[t + i >> 1], o = t - 1, a = i + 1;
    for (; ; ) {
      do
        o++;
      while (r50[o] < n);
      do
        a--;
      while (r50[a] > n);
      if (o >= a) break;
      Us(r50, o, a), Us(e, 3 * o, 3 * a), Us(e, 3 * o + 1, 3 * a + 1), Us(e, 3 * o + 2, 3 * a + 2);
    }
    a - t < i - a ? (xp(r50, e, t, a), t = a + 1) : (xp(r50, e, a + 1, i), i = a);
  }
}
function Us(r50, e, t) {
  let i = r50[e];
  r50[e] = r50[t], r50[t] = i;
}
U("FeaturePositionMap", xo);
c();
var or = class {
  constructor(e, t) {
    this.gl = e.gl, this.location = t;
  }
};
var Y = class extends or {
  constructor(e, t) {
    super(e, t), this.current = 0;
  }
  set(e) {
    this.current !== e && (this.current = e, this.gl.uniform1i(this.location, e));
  }
};
var V = class extends or {
  constructor(e, t) {
    super(e, t), this.current = 0;
  }
  set(e) {
    this.current !== e && (this.current = e, this.gl.uniform1f(this.location, e));
  }
};
var ee = class extends or {
  constructor(e, t) {
    super(e, t), this.current = [0, 0];
  }
  set(e) {
    (e[0] !== this.current[0] || e[1] !== this.current[1]) && (this.current = e, this.gl.uniform2f(this.location, e[0], e[1]));
  }
};
var st = class extends or {
  constructor(e, t) {
    super(e, t), this.current = [0, 0, 0];
  }
  set(e) {
    (e[0] !== this.current[0] || e[1] !== this.current[1] || e[2] !== this.current[2]) && (this.current = e, this.gl.uniform3f(this.location, e[0], e[1], e[2]));
  }
};
var Ar = class extends or {
  constructor(e, t) {
    super(e, t), this.current = [0, 0, 0, 0];
  }
  set(e) {
    (e[0] !== this.current[0] || e[1] !== this.current[1] || e[2] !== this.current[2] || e[3] !== this.current[3]) && (this.current = e, this.gl.uniform4f(this.location, e[0], e[1], e[2], e[3]));
  }
};
var Ct = class extends or {
  constructor(e, t) {
    super(e, t), this.current = W.transparent;
  }
  set(e) {
    (e.r !== this.current.r || e.g !== this.current.g || e.b !== this.current.b || e.a !== this.current.a) && (this.current = e, this.gl.uniform4f(this.location, e.r, e.g, e.b, e.a));
  }
};
var v1 = new Float32Array(16);
var te = class extends or {
  constructor(e, t) {
    super(e, t), this.current = v1;
  }
  set(e) {
    if (e[12] !== this.current[12] || e[0] !== this.current[0]) {
      this.current = e, this.gl.uniformMatrix4fv(this.location, false, e);
      return;
    }
    for (let t = 1; t < 16; t++) if (e[t] !== this.current[t]) {
      this.current = e, this.gl.uniformMatrix4fv(this.location, false, e);
      break;
    }
  }
};
function bp(r50) {
  return [mp(255 * r50.r, 255 * r50.g), mp(255 * r50.b, 255 * r50.a)];
}
var ii = class {
  constructor(e, t, i) {
    this.value = e, this.uniformNames = t.map((n) => "u_".concat(n)), this.type = i;
  }
  setUniform(e, t, i) {
    e.set(i.constantOr(this.value));
  }
  getBinding(e, t, i) {
    return this.type === "color" ? new Ct(e, t) : new V(e, t);
  }
};
var Mr = class {
  constructor(e, t) {
    this.uniformNames = t.map((i) => "u_".concat(i)), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
  }
  setConstantPatternPositions(e, t) {
    this.pixelRatioFrom = t.pixelRatio, this.pixelRatioTo = e.pixelRatio, this.patternFrom = t.tlbr, this.patternTo = e.tlbr;
  }
  setUniform(e, t, i, n) {
    let o = n === "u_pattern_to" ? this.patternTo : n === "u_pattern_from" ? this.patternFrom : n === "u_pixel_ratio_to" ? this.pixelRatioTo : n === "u_pixel_ratio_from" ? this.pixelRatioFrom : null;
    o && e.set(o);
  }
  getBinding(e, t, i) {
    return i.substr(0, 9) === "u_pattern" ? new Ar(e, t) : new V(e, t);
  }
};
var Ft = class {
  constructor(e, t, i, n) {
    this.expression = e, this.type = i, this.maxValue = 0, this.paintVertexAttributes = t.map((o) => ({ name: "a_".concat(o), type: "Float32", components: i === "color" ? 2 : 1, offset: 0 })), this.paintVertexArray = new n();
  }
  populatePaintArray(e, t, i, n, o) {
    let a = this.paintVertexArray.length, s3 = this.expression.evaluate(new de(0), t, {}, n, [], o);
    this.paintVertexArray.resize(e), this._setPaintValue(a, e, s3);
  }
  updatePaintArray(e, t, i, n) {
    let o = this.expression.evaluate({ zoom: 0 }, i, n);
    this._setPaintValue(e, t, o);
  }
  _setPaintValue(e, t, i) {
    if (this.type === "color") {
      let n = bp(i);
      for (let o = e; o < t; o++) this.paintVertexArray.emplace(o, n[0], n[1]);
    } else {
      for (let n = e; n < t; n++) this.paintVertexArray.emplace(n, i);
      this.maxValue = Math.max(this.maxValue, Math.abs(i));
    }
  }
  upload(e) {
    this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
  }
  destroy() {
    this.paintVertexBuffer && this.paintVertexBuffer.destroy();
  }
};
var wt = class {
  constructor(e, t, i, n, o, a) {
    this.expression = e, this.uniformNames = t.map((s3) => "u_".concat(s3, "_t")), this.type = i, this.useIntegerZoom = n, this.zoom = o, this.maxValue = 0, this.paintVertexAttributes = t.map((s3) => ({ name: "a_".concat(s3), type: "Float32", components: i === "color" ? 4 : 2, offset: 0 })), this.paintVertexArray = new a();
  }
  populatePaintArray(e, t, i, n, o) {
    let a = this.expression.evaluate(new de(this.zoom), t, {}, n, [], o), s3 = this.expression.evaluate(new de(this.zoom + 1), t, {}, n, [], o), l = this.paintVertexArray.length;
    this.paintVertexArray.resize(e), this._setPaintValue(l, e, a, s3);
  }
  updatePaintArray(e, t, i, n) {
    let o = this.expression.evaluate({ zoom: this.zoom }, i, n), a = this.expression.evaluate({ zoom: this.zoom + 1 }, i, n);
    this._setPaintValue(e, t, o, a);
  }
  _setPaintValue(e, t, i, n) {
    if (this.type === "color") {
      let o = bp(i), a = bp(n);
      for (let s3 = e; s3 < t; s3++) this.paintVertexArray.emplace(s3, o[0], o[1], a[0], a[1]);
    } else {
      for (let o = e; o < t; o++) this.paintVertexArray.emplace(o, i, n);
      this.maxValue = Math.max(this.maxValue, Math.abs(i), Math.abs(n));
    }
  }
  upload(e) {
    this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
  }
  destroy() {
    this.paintVertexBuffer && this.paintVertexBuffer.destroy();
  }
  setUniform(e, t) {
    let i = this.useIntegerZoom ? Math.floor(t.zoom) : t.zoom, n = Ae(this.expression.interpolationFactor(i, this.zoom, this.zoom + 1), 0, 1);
    e.set(n);
  }
  getBinding(e, t, i) {
    return new V(e, t);
  }
};
var Nt = class {
  constructor(e, t, i, n, o, a) {
    this.expression = e, this.type = t, this.useIntegerZoom = i, this.zoom = n, this.layerId = a, this.zoomInPaintVertexArray = new o(), this.zoomOutPaintVertexArray = new o();
  }
  populatePaintArray(e, t, i) {
    let n = this.zoomInPaintVertexArray.length;
    this.zoomInPaintVertexArray.resize(e), this.zoomOutPaintVertexArray.resize(e), this._setPaintValues(n, e, t.patterns && t.patterns[this.layerId], i);
  }
  updatePaintArray(e, t, i, n, o) {
    this._setPaintValues(e, t, i.patterns && i.patterns[this.layerId], o);
  }
  _setPaintValues(e, t, i, n) {
    if (!n || !i) return;
    let { min: o, mid: a, max: s3 } = i, l = n[o], u = n[a], c3 = n[s3];
    if (!(!l || !u || !c3)) for (let p = e; p < t; p++) this.zoomInPaintVertexArray.emplace(p, u.tl[0], u.tl[1], u.br[0], u.br[1], l.tl[0], l.tl[1], l.br[0], l.br[1], u.pixelRatio, l.pixelRatio), this.zoomOutPaintVertexArray.emplace(p, u.tl[0], u.tl[1], u.br[0], u.br[1], c3.tl[0], c3.tl[1], c3.br[0], c3.br[1], u.pixelRatio, c3.pixelRatio);
  }
  upload(e) {
    this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = e.createVertexBuffer(this.zoomInPaintVertexArray, go.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = e.createVertexBuffer(this.zoomOutPaintVertexArray, go.members, this.expression.isStateDependent));
  }
  destroy() {
    this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
  }
};
var Ns = class {
  constructor(e, t, i) {
    this.binders = {}, this._buffers = [];
    let n = [];
    for (let o in e.paint._values) {
      if (!i(o)) continue;
      let a = e.paint.get(o);
      if (!(a instanceof ot) || !gr(a.property.specification)) continue;
      let s3 = w1(o, e.type), l = a.value, u = a.property.specification.type, c3 = a.property.useIntegerZoom, p = a.property.specification["property-type"], h = p === "cross-faded" || p === "cross-faded-data-driven";
      if (l.kind === "constant") this.binders[o] = h ? new Mr(l.value, s3) : new ii(l.value, s3, u), n.push("/u_".concat(o));
      else if (l.kind === "source" || h) {
        let f = $m(o, u, "source");
        this.binders[o] = h ? new Nt(l, u, c3, t, f, e.id) : new Ft(l, s3, u, f), n.push("/a_".concat(o));
      } else {
        let f = $m(o, u, "composite");
        this.binders[o] = new wt(l, s3, u, c3, t, f), n.push("/z_".concat(o));
      }
    }
    this.cacheKey = n.sort().join("");
  }
  getMaxValue(e) {
    let t = this.binders[e];
    return t instanceof Ft || t instanceof wt ? t.maxValue : 0;
  }
  populatePaintArrays(e, t, i, n, o) {
    for (let a in this.binders) {
      let s3 = this.binders[a];
      (s3 instanceof Ft || s3 instanceof wt || s3 instanceof Nt) && s3.populatePaintArray(e, t, i, n, o);
    }
  }
  setConstantPatternPositions(e, t) {
    for (let i in this.binders) {
      let n = this.binders[i];
      n instanceof Mr && n.setConstantPatternPositions(e, t);
    }
  }
  updatePaintArrays(e, t, i, n, o) {
    let a = false;
    for (let s3 in e) {
      let l = t.getPositions(s3);
      for (let u of l) {
        let c3 = i.feature(u.index);
        for (let p in this.binders) {
          let h = this.binders[p];
          if ((h instanceof Ft || h instanceof wt || h instanceof Nt) && h.expression.isStateDependent === true) {
            let f = n.paint.get(p);
            h.expression = f.value, h.updatePaintArray(u.start, u.end, c3, e[s3], o), a = true;
          }
        }
      }
    }
    return a;
  }
  defines() {
    let e = [];
    for (let t in this.binders) {
      let i = this.binders[t];
      (i instanceof ii || i instanceof Mr) && e.push(...i.uniformNames.map((n) => "#define HAS_UNIFORM_".concat(n)));
    }
    return e;
  }
  getBinderAttributes() {
    let e = [];
    for (let t in this.binders) {
      let i = this.binders[t];
      if (i instanceof Ft || i instanceof wt) for (let n = 0; n < i.paintVertexAttributes.length; n++) e.push(i.paintVertexAttributes[n].name);
      else if (i instanceof Nt) for (let n = 0; n < go.members.length; n++) e.push(go.members[n].name);
    }
    return e;
  }
  getBinderUniforms() {
    let e = [];
    for (let t in this.binders) {
      let i = this.binders[t];
      if (i instanceof ii || i instanceof Mr || i instanceof wt) for (let n of i.uniformNames) e.push(n);
    }
    return e;
  }
  getPaintVertexBuffers() {
    return this._buffers;
  }
  getUniforms(e, t) {
    let i = [];
    for (let n in this.binders) {
      let o = this.binders[n];
      if (o instanceof ii || o instanceof Mr || o instanceof wt) {
        for (let a of o.uniformNames) if (t[a]) {
          let s3 = o.getBinding(e, t[a], a);
          i.push({ name: a, property: n, binding: s3 });
        }
      }
    }
    return i;
  }
  setUniforms(e, t, i, n) {
    for (let { name: o, property: a, binding: s3 } of t) this.binders[a].setUniform(s3, n, i.get(a), o);
  }
  updatePaintBuffers(e) {
    this._buffers = [];
    for (let t in this.binders) {
      let i = this.binders[t];
      if (e && i instanceof Nt) {
        let n = e.fromScale === 2 ? i.zoomInPaintVertexBuffer : i.zoomOutPaintVertexBuffer;
        n && this._buffers.push(n);
      } else (i instanceof Ft || i instanceof wt) && i.paintVertexBuffer && this._buffers.push(i.paintVertexBuffer);
    }
  }
  upload(e) {
    for (let t in this.binders) {
      let i = this.binders[t];
      (i instanceof Ft || i instanceof wt || i instanceof Nt) && i.upload(e);
    }
    this.updatePaintBuffers();
  }
  destroy() {
    for (let e in this.binders) {
      let t = this.binders[e];
      (t instanceof Ft || t instanceof wt || t instanceof Nt) && t.destroy();
    }
  }
};
var ft = class {
  constructor(e, t, i = () => true) {
    this.programConfigurations = {};
    for (let n of e) this.programConfigurations[n.id] = new Ns(n, t, i);
    this.needsUpload = false, this._featureMap = new xo(), this._bufferOffset = 0;
  }
  populatePaintArrays(e, t, i, n, o, a) {
    for (let s3 in this.programConfigurations) this.programConfigurations[s3].populatePaintArrays(e, t, n, o, a);
    t.id !== void 0 && this._featureMap.add(t.id, i, this._bufferOffset, e), this._bufferOffset = e, this.needsUpload = true;
  }
  updatePaintArrays(e, t, i, n) {
    for (let o of i) this.needsUpload = this.programConfigurations[o.id].updatePaintArrays(e, this._featureMap, t, o, n) || this.needsUpload;
  }
  get(e) {
    return this.programConfigurations[e];
  }
  upload(e) {
    if (this.needsUpload) {
      for (let t in this.programConfigurations) this.programConfigurations[t].upload(e);
      this.needsUpload = false;
    }
  }
  destroy() {
    for (let e in this.programConfigurations) this.programConfigurations[e].destroy();
  }
};
function w1(r50, e) {
  return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[r50] || [r50.replace("".concat(e, "-"), "").replace(/-/g, "_")];
}
function S1(r50) {
  return { "line-pattern": { source: nr, composite: nr }, "fill-pattern": { source: nr, composite: nr }, "fill-extrusion-pattern": { source: nr, composite: nr } }[r50];
}
function $m(r50, e, t) {
  let i = { color: { source: Sr, composite: Ni }, number: { source: ri, composite: Sr } }, n = S1(r50);
  return n && n[t] || i[e][t];
}
U("ConstantBinder", ii);
U("CrossFadedConstantBinder", Mr);
U("SourceExpressionBinder", Ft);
U("CrossFadedCompositeBinder", Nt);
U("CompositeExpressionBinder", wt);
U("ProgramConfiguration", Ns, { omit: ["_buffers"] });
U("ProgramConfigurationSet", ft);
c();
c();
c();
var P1 = 15;
var _p = Math.pow(2, P1 - 1) - 1;
var Wm = -_p - 1;
function mt(r50) {
  let e = 8192 / r50.extent, t = r50.loadGeometry();
  for (let i = 0; i < t.length; i++) {
    let n = t[i];
    for (let o = 0; o < n.length; o++) {
      let a = n[o], s3 = Math.round(a.x * e), l = Math.round(a.y * e);
      a.x = Ae(s3, Wm, _p), a.y = Ae(l, Wm, _p), (s3 < a.x || s3 > a.x + 1 || l < a.y || l > a.y + 1) && Ee("Geometry exceeds allowed extent, reduce your vector tile buffer size");
    }
  }
  return t;
}
c();
function dt(r50, e) {
  return { type: r50.type, id: r50.id, properties: r50.properties, geometry: e ? mt(r50) : [] };
}
function Gs(r50, e, t, i, n) {
  r50.emplaceBack(e * 2 + (i + 1) / 2, t * 2 + (n + 1) / 2);
}
var ni = class {
  constructor(e) {
    this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((t) => t.id), this.index = e.index, this.hasPattern = false, this.layoutVertexArray = new Is(), this.indexArray = new tt(), this.segments = new fe(), this.programConfigurations = new ft(e.layers, e.zoom), this.stateDependentLayerIds = this.layers.filter((t) => t.isStateDependent()).map((t) => t.id);
  }
  populate(e, t, i) {
    let n = this.layers[0], o = [], a = null, s3 = false;
    n.type === "circle" && (a = n.layout.get("circle-sort-key"), s3 = !a.isConstant());
    for (let { feature: l, id: u, index: c3, sourceLayerIndex: p } of e) {
      let h = this.layers[0]._featureFilter.needGeometry, f = dt(l, h);
      if (!this.layers[0]._featureFilter.filter(new de(this.zoom), f, i)) continue;
      let d = s3 ? a.evaluate(f, {}, i) : void 0, y = { id: u, properties: l.properties, type: l.type, sourceLayerIndex: p, index: c3, geometry: h ? f.geometry : mt(l), patterns: {}, sortKey: d };
      o.push(y);
    }
    s3 && o.sort((l, u) => l.sortKey - u.sortKey);
    for (let l of o) {
      let { geometry: u, index: c3, sourceLayerIndex: p } = l, h = e[c3].feature;
      this.addFeature(l, u, c3, i), t.featureIndex.insert(h, u, c3, p, this.index);
    }
  }
  update(e, t, i) {
    this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, t, this.stateDependentLayers, i);
  }
  isEmpty() {
    return this.layoutVertexArray.length === 0;
  }
  uploadPending() {
    return !this.uploaded || this.programConfigurations.needsUpload;
  }
  upload(e) {
    this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, Nm), this.indexBuffer = e.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e), this.uploaded = true;
  }
  destroy() {
    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
  }
  addFeature(e, t, i, n) {
    for (let o of t) for (let a of o) {
      let s3 = a.x, l = a.y;
      if (s3 < 0 || s3 >= 8192 || l < 0 || l >= 8192) continue;
      let u = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, e.sortKey), c3 = u.vertexLength;
      Gs(this.layoutVertexArray, s3, l, -1, -1), Gs(this.layoutVertexArray, s3, l, 1, -1), Gs(this.layoutVertexArray, s3, l, 1, 1), Gs(this.layoutVertexArray, s3, l, -1, 1), this.indexArray.emplaceBack(c3, c3 + 1, c3 + 2), this.indexArray.emplaceBack(c3, c3 + 3, c3 + 2), u.vertexLength += 4, u.primitiveLength += 2;
    }
    this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, i, {}, n);
  }
};
U("CircleBucket", ni, { omit: ["layers"] });
c();
var bo = s(ye(), 1);
function qs(r50, e) {
  for (let t = 0; t < r50.length; t++) if (qi(e, r50[t])) return true;
  for (let t = 0; t < e.length; t++) if (qi(r50, e[t])) return true;
  return !!wp(r50, e);
}
function Km(r50, e, t) {
  return !!(qi(r50, e) || vp(e, r50, t));
}
function js(r50, e) {
  if (r50.length === 1) return Xm(e, r50[0]);
  for (let t = 0; t < e.length; t++) {
    let i = e[t];
    for (let n = 0; n < i.length; n++) if (qi(r50, i[n])) return true;
  }
  for (let t = 0; t < r50.length; t++) if (Xm(e, r50[t])) return true;
  for (let t = 0; t < e.length; t++) if (wp(r50, e[t])) return true;
  return false;
}
function Jm(r50, e, t) {
  for (let i = 0; i < e.length; i++) {
    let n = e[i];
    if (r50.length >= 3) {
      for (let o = 0; o < n.length; o++) if (qi(r50, n[o])) return true;
    }
    if (T1(r50, n, t)) return true;
  }
  return false;
}
function T1(r50, e, t) {
  if (r50.length > 1) {
    if (wp(r50, e)) return true;
    for (let i = 0; i < e.length; i++) if (vp(e[i], r50, t)) return true;
  }
  for (let i = 0; i < r50.length; i++) if (vp(r50[i], e, t)) return true;
  return false;
}
function wp(r50, e) {
  if (r50.length === 0 || e.length === 0) return false;
  for (let t = 0; t < r50.length - 1; t++) {
    let i = r50[t], n = r50[t + 1];
    for (let o = 0; o < e.length - 1; o++) {
      let a = e[o], s3 = e[o + 1];
      if (A1(i, n, a, s3)) return true;
    }
  }
  return false;
}
function A1(r50, e, t, i) {
  return Yt(r50, t, i) !== Yt(e, t, i) && Yt(r50, e, t) !== Yt(r50, e, i);
}
function vp(r50, e, t) {
  let i = t * t;
  if (e.length === 1) return r50.distSqr(e[0]) < i;
  for (let n = 1; n < e.length; n++) {
    let o = e[n - 1], a = e[n];
    if (Ym(r50, o, a) < i) return true;
  }
  return false;
}
function Ym(r50, e, t) {
  let i = e.distSqr(t);
  if (i === 0) return r50.distSqr(e);
  let n = ((r50.x - e.x) * (t.x - e.x) + (r50.y - e.y) * (t.y - e.y)) / i;
  return n < 0 ? r50.distSqr(e) : n > 1 ? r50.distSqr(t) : r50.distSqr(t.sub(e)._mult(n)._add(e));
}
function Xm(r50, e) {
  let t = false, i, n, o;
  for (let a = 0; a < r50.length; a++) {
    i = r50[a];
    for (let s3 = 0, l = i.length - 1; s3 < i.length; l = s3++) n = i[s3], o = i[l], n.y > e.y != o.y > e.y && e.x < (o.x - n.x) * (e.y - n.y) / (o.y - n.y) + n.x && (t = !t);
  }
  return t;
}
function qi(r50, e) {
  let t = false;
  for (let i = 0, n = r50.length - 1; i < r50.length; n = i++) {
    let o = r50[i], a = r50[n];
    o.y > e.y != a.y > e.y && e.x < (a.x - o.x) * (e.y - o.y) / (a.y - o.y) + o.x && (t = !t);
  }
  return t;
}
function Qm(r50, e, t, i, n) {
  for (let a of r50) if (e <= a.x && t <= a.y && i >= a.x && n >= a.y) return true;
  let o = [new bo.default(e, t), new bo.default(e, n), new bo.default(i, n), new bo.default(i, t)];
  if (r50.length > 2) {
    for (let a of o) if (qi(r50, a)) return true;
  }
  for (let a = 0; a < r50.length - 1; a++) {
    let s3 = r50[a], l = r50[a + 1];
    if (M1(s3, l, o)) return true;
  }
  return false;
}
function M1(r50, e, t) {
  let i = t[0], n = t[2];
  if (r50.x < i.x && e.x < i.x || r50.x > n.x && e.x > n.x || r50.y < i.y && e.y < i.y || r50.y > n.y && e.y > n.y) return false;
  let o = Yt(r50, e, t[0]);
  return o !== Yt(r50, e, t[1]) || o !== Yt(r50, e, t[2]) || o !== Yt(r50, e, t[3]);
}
c();
var Zs = s(ye(), 1);
function oi(r50, e, t) {
  let i = e.paint.get(r50).value;
  return i.kind === "constant" ? i.value : t.programConfigurations.get(e.id).getMaxValue(r50);
}
function Ir(r50) {
  return Math.sqrt(r50[0] * r50[0] + r50[1] * r50[1]);
}
function Cr(r50, e, t, i, n) {
  if (!e[0] && !e[1]) return r50;
  let o = Zs.default.convert(e)._mult(n);
  t === "viewport" && o._rotate(-i);
  let a = [];
  for (let s3 = 0; s3 < r50.length; s3++) {
    let l = r50[s3];
    a.push(l.sub(o));
  }
  return a;
}
function ed(r50, e) {
  let t = [];
  for (let i = 0; i < r50.length; i++) {
    let n = r50[i], o = [];
    for (let a = 0; a < n.length; a++) {
      let s3 = n[a - 1], l = n[a], u = n[a + 1], c3 = a === 0 ? new Zs.default(0, 0) : l.sub(s3)._unit()._perp(), p = a === n.length - 1 ? new Zs.default(0, 0) : u.sub(l)._unit()._perp(), h = c3._add(p)._unit(), f = h.x * p.x + h.y * p.y;
      f !== 0 && h._mult(1 / f), o.push(h._mult(e)._add(l));
    }
    t.push(o);
  }
  return t;
}
c();
var td;
var C1 = () => td = td || new Le({ "circle-sort-key": new H(A.layout_circle["circle-sort-key"]) });
var rd;
var E1 = () => rd = rd || new Le({ "circle-radius": new H(A.paint_circle["circle-radius"]), "circle-color": new H(A.paint_circle["circle-color"]), "circle-blur": new H(A.paint_circle["circle-blur"]), "circle-opacity": new H(A.paint_circle["circle-opacity"]), "circle-translate": new j(A.paint_circle["circle-translate"]), "circle-translate-anchor": new j(A.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new j(A.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new j(A.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new H(A.paint_circle["circle-stroke-width"]), "circle-stroke-color": new H(A.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new H(A.paint_circle["circle-stroke-opacity"]) });
var id = { get paint() {
  return E1();
}, get layout() {
  return C1();
} };
c();
c();
var ne = 1e-6;
var ve = typeof Float32Array < "u" ? Float32Array : Array;
var Gt = Math.random;
var sk = Math.PI / 180;
Math.hypot || (Math.hypot = function() {
  for (var r50 = 0, e = arguments.length; e--; ) r50 += arguments[e] * arguments[e];
  return Math.sqrt(r50);
});
var _o = {};
r(_o, { LDU: () => $1, add: () => W1, adjoint: () => V1, clone: () => L1, copy: () => D1, create: () => k1, determinant: () => U1, equals: () => K1, exactEquals: () => X1, frob: () => H1, fromRotation: () => q1, fromScaling: () => j1, fromValues: () => F1, identity: () => z1, invert: () => O1, mul: () => Q1, multiply: () => nd, multiplyScalar: () => J1, multiplyScalarAndAdd: () => Y1, rotate: () => N1, scale: () => G1, set: () => R1, str: () => Z1, sub: () => ew, subtract: () => od, transpose: () => B1 });
c();
function k1() {
  var r50 = new ve(4);
  return ve != Float32Array && (r50[1] = 0, r50[2] = 0), r50[0] = 1, r50[3] = 1, r50;
}
function L1(r50) {
  var e = new ve(4);
  return e[0] = r50[0], e[1] = r50[1], e[2] = r50[2], e[3] = r50[3], e;
}
function D1(r50, e) {
  return r50[0] = e[0], r50[1] = e[1], r50[2] = e[2], r50[3] = e[3], r50;
}
function z1(r50) {
  return r50[0] = 1, r50[1] = 0, r50[2] = 0, r50[3] = 1, r50;
}
function F1(r50, e, t, i) {
  var n = new ve(4);
  return n[0] = r50, n[1] = e, n[2] = t, n[3] = i, n;
}
function R1(r50, e, t, i, n) {
  return r50[0] = e, r50[1] = t, r50[2] = i, r50[3] = n, r50;
}
function B1(r50, e) {
  if (r50 === e) {
    var t = e[1];
    r50[1] = e[2], r50[2] = t;
  } else r50[0] = e[0], r50[1] = e[2], r50[2] = e[1], r50[3] = e[3];
  return r50;
}
function O1(r50, e) {
  var t = e[0], i = e[1], n = e[2], o = e[3], a = t * o - n * i;
  return a ? (a = 1 / a, r50[0] = o * a, r50[1] = -i * a, r50[2] = -n * a, r50[3] = t * a, r50) : null;
}
function V1(r50, e) {
  var t = e[0];
  return r50[0] = e[3], r50[1] = -e[1], r50[2] = -e[2], r50[3] = t, r50;
}
function U1(r50) {
  return r50[0] * r50[3] - r50[2] * r50[1];
}
function nd(r50, e, t) {
  var i = e[0], n = e[1], o = e[2], a = e[3], s3 = t[0], l = t[1], u = t[2], c3 = t[3];
  return r50[0] = i * s3 + o * l, r50[1] = n * s3 + a * l, r50[2] = i * u + o * c3, r50[3] = n * u + a * c3, r50;
}
function N1(r50, e, t) {
  var i = e[0], n = e[1], o = e[2], a = e[3], s3 = Math.sin(t), l = Math.cos(t);
  return r50[0] = i * l + o * s3, r50[1] = n * l + a * s3, r50[2] = i * -s3 + o * l, r50[3] = n * -s3 + a * l, r50;
}
function G1(r50, e, t) {
  var i = e[0], n = e[1], o = e[2], a = e[3], s3 = t[0], l = t[1];
  return r50[0] = i * s3, r50[1] = n * s3, r50[2] = o * l, r50[3] = a * l, r50;
}
function q1(r50, e) {
  var t = Math.sin(e), i = Math.cos(e);
  return r50[0] = i, r50[1] = t, r50[2] = -t, r50[3] = i, r50;
}
function j1(r50, e) {
  return r50[0] = e[0], r50[1] = 0, r50[2] = 0, r50[3] = e[1], r50;
}
function Z1(r50) {
  return "mat2(" + r50[0] + ", " + r50[1] + ", " + r50[2] + ", " + r50[3] + ")";
}
function H1(r50) {
  return Math.hypot(r50[0], r50[1], r50[2], r50[3]);
}
function $1(r50, e, t, i) {
  return r50[2] = i[2] / i[0], t[0] = i[0], t[1] = i[1], t[3] = i[3] - r50[2] * t[1], [r50, e, t];
}
function W1(r50, e, t) {
  return r50[0] = e[0] + t[0], r50[1] = e[1] + t[1], r50[2] = e[2] + t[2], r50[3] = e[3] + t[3], r50;
}
function od(r50, e, t) {
  return r50[0] = e[0] - t[0], r50[1] = e[1] - t[1], r50[2] = e[2] - t[2], r50[3] = e[3] - t[3], r50;
}
function X1(r50, e) {
  return r50[0] === e[0] && r50[1] === e[1] && r50[2] === e[2] && r50[3] === e[3];
}
function K1(r50, e) {
  var t = r50[0], i = r50[1], n = r50[2], o = r50[3], a = e[0], s3 = e[1], l = e[2], u = e[3];
  return Math.abs(t - a) <= ne * Math.max(1, Math.abs(t), Math.abs(a)) && Math.abs(i - s3) <= ne * Math.max(1, Math.abs(i), Math.abs(s3)) && Math.abs(n - l) <= ne * Math.max(1, Math.abs(n), Math.abs(l)) && Math.abs(o - u) <= ne * Math.max(1, Math.abs(o), Math.abs(u));
}
function J1(r50, e, t) {
  return r50[0] = e[0] * t, r50[1] = e[1] * t, r50[2] = e[2] * t, r50[3] = e[3] * t, r50;
}
function Y1(r50, e, t, i) {
  return r50[0] = e[0] + t[0] * i, r50[1] = e[1] + t[1] * i, r50[2] = e[2] + t[2] * i, r50[3] = e[3] + t[3] * i, r50;
}
var Q1 = nd;
var ew = od;
var vo = {};
r(vo, { add: () => Pw, adjoint: () => cw, clone: () => iw, copy: () => nw, create: () => tw, determinant: () => pw, equals: () => Iw, exactEquals: () => Mw, frob: () => Sw, fromMat2d: () => xw, fromMat4: () => rw, fromQuat: () => bw, fromRotation: () => yw, fromScaling: () => gw, fromTranslation: () => dw, fromValues: () => ow, identity: () => sw, invert: () => uw, mul: () => Cw, multiply: () => ad, multiplyScalar: () => Tw, multiplyScalarAndAdd: () => Aw, normalFromMat4: () => _w, projection: () => vw, rotate: () => fw, scale: () => mw, set: () => aw, str: () => ww, sub: () => Ew, subtract: () => sd, translate: () => hw, transpose: () => lw });
c();
function tw() {
  var r50 = new ve(9);
  return ve != Float32Array && (r50[1] = 0, r50[2] = 0, r50[3] = 0, r50[5] = 0, r50[6] = 0, r50[7] = 0), r50[0] = 1, r50[4] = 1, r50[8] = 1, r50;
}
function rw(r50, e) {
  return r50[0] = e[0], r50[1] = e[1], r50[2] = e[2], r50[3] = e[4], r50[4] = e[5], r50[5] = e[6], r50[6] = e[8], r50[7] = e[9], r50[8] = e[10], r50;
}
function iw(r50) {
  var e = new ve(9);
  return e[0] = r50[0], e[1] = r50[1], e[2] = r50[2], e[3] = r50[3], e[4] = r50[4], e[5] = r50[5], e[6] = r50[6], e[7] = r50[7], e[8] = r50[8], e;
}
function nw(r50, e) {
  return r50[0] = e[0], r50[1] = e[1], r50[2] = e[2], r50[3] = e[3], r50[4] = e[4], r50[5] = e[5], r50[6] = e[6], r50[7] = e[7], r50[8] = e[8], r50;
}
function ow(r50, e, t, i, n, o, a, s3, l) {
  var u = new ve(9);
  return u[0] = r50, u[1] = e, u[2] = t, u[3] = i, u[4] = n, u[5] = o, u[6] = a, u[7] = s3, u[8] = l, u;
}
function aw(r50, e, t, i, n, o, a, s3, l, u) {
  return r50[0] = e, r50[1] = t, r50[2] = i, r50[3] = n, r50[4] = o, r50[5] = a, r50[6] = s3, r50[7] = l, r50[8] = u, r50;
}
function sw(r50) {
  return r50[0] = 1, r50[1] = 0, r50[2] = 0, r50[3] = 0, r50[4] = 1, r50[5] = 0, r50[6] = 0, r50[7] = 0, r50[8] = 1, r50;
}
function lw(r50, e) {
  if (r50 === e) {
    var t = e[1], i = e[2], n = e[5];
    r50[1] = e[3], r50[2] = e[6], r50[3] = t, r50[5] = e[7], r50[6] = i, r50[7] = n;
  } else r50[0] = e[0], r50[1] = e[3], r50[2] = e[6], r50[3] = e[1], r50[4] = e[4], r50[5] = e[7], r50[6] = e[2], r50[7] = e[5], r50[8] = e[8];
  return r50;
}
function uw(r50, e) {
  var t = e[0], i = e[1], n = e[2], o = e[3], a = e[4], s3 = e[5], l = e[6], u = e[7], c3 = e[8], p = c3 * a - s3 * u, h = -c3 * o + s3 * l, f = u * o - a * l, d = t * p + i * h + n * f;
  return d ? (d = 1 / d, r50[0] = p * d, r50[1] = (-c3 * i + n * u) * d, r50[2] = (s3 * i - n * a) * d, r50[3] = h * d, r50[4] = (c3 * t - n * l) * d, r50[5] = (-s3 * t + n * o) * d, r50[6] = f * d, r50[7] = (-u * t + i * l) * d, r50[8] = (a * t - i * o) * d, r50) : null;
}
function cw(r50, e) {
  var t = e[0], i = e[1], n = e[2], o = e[3], a = e[4], s3 = e[5], l = e[6], u = e[7], c3 = e[8];
  return r50[0] = a * c3 - s3 * u, r50[1] = n * u - i * c3, r50[2] = i * s3 - n * a, r50[3] = s3 * l - o * c3, r50[4] = t * c3 - n * l, r50[5] = n * o - t * s3, r50[6] = o * u - a * l, r50[7] = i * l - t * u, r50[8] = t * a - i * o, r50;
}
function pw(r50) {
  var e = r50[0], t = r50[1], i = r50[2], n = r50[3], o = r50[4], a = r50[5], s3 = r50[6], l = r50[7], u = r50[8];
  return e * (u * o - a * l) + t * (-u * n + a * s3) + i * (l * n - o * s3);
}
function ad(r50, e, t) {
  var i = e[0], n = e[1], o = e[2], a = e[3], s3 = e[4], l = e[5], u = e[6], c3 = e[7], p = e[8], h = t[0], f = t[1], d = t[2], y = t[3], g = t[4], x = t[5], v = t[6], b = t[7], w = t[8];
  return r50[0] = h * i + f * a + d * u, r50[1] = h * n + f * s3 + d * c3, r50[2] = h * o + f * l + d * p, r50[3] = y * i + g * a + x * u, r50[4] = y * n + g * s3 + x * c3, r50[5] = y * o + g * l + x * p, r50[6] = v * i + b * a + w * u, r50[7] = v * n + b * s3 + w * c3, r50[8] = v * o + b * l + w * p, r50;
}
function hw(r50, e, t) {
  var i = e[0], n = e[1], o = e[2], a = e[3], s3 = e[4], l = e[5], u = e[6], c3 = e[7], p = e[8], h = t[0], f = t[1];
  return r50[0] = i, r50[1] = n, r50[2] = o, r50[3] = a, r50[4] = s3, r50[5] = l, r50[6] = h * i + f * a + u, r50[7] = h * n + f * s3 + c3, r50[8] = h * o + f * l + p, r50;
}
function fw(r50, e, t) {
  var i = e[0], n = e[1], o = e[2], a = e[3], s3 = e[4], l = e[5], u = e[6], c3 = e[7], p = e[8], h = Math.sin(t), f = Math.cos(t);
  return r50[0] = f * i + h * a, r50[1] = f * n + h * s3, r50[2] = f * o + h * l, r50[3] = f * a - h * i, r50[4] = f * s3 - h * n, r50[5] = f * l - h * o, r50[6] = u, r50[7] = c3, r50[8] = p, r50;
}
function mw(r50, e, t) {
  var i = t[0], n = t[1];
  return r50[0] = i * e[0], r50[1] = i * e[1], r50[2] = i * e[2], r50[3] = n * e[3], r50[4] = n * e[4], r50[5] = n * e[5], r50[6] = e[6], r50[7] = e[7], r50[8] = e[8], r50;
}
function dw(r50, e) {
  return r50[0] = 1, r50[1] = 0, r50[2] = 0, r50[3] = 0, r50[4] = 1, r50[5] = 0, r50[6] = e[0], r50[7] = e[1], r50[8] = 1, r50;
}
function yw(r50, e) {
  var t = Math.sin(e), i = Math.cos(e);
  return r50[0] = i, r50[1] = t, r50[2] = 0, r50[3] = -t, r50[4] = i, r50[5] = 0, r50[6] = 0, r50[7] = 0, r50[8] = 1, r50;
}
function gw(r50, e) {
  return r50[0] = e[0], r50[1] = 0, r50[2] = 0, r50[3] = 0, r50[4] = e[1], r50[5] = 0, r50[6] = 0, r50[7] = 0, r50[8] = 1, r50;
}
function xw(r50, e) {
  return r50[0] = e[0], r50[1] = e[1], r50[2] = 0, r50[3] = e[2], r50[4] = e[3], r50[5] = 0, r50[6] = e[4], r50[7] = e[5], r50[8] = 1, r50;
}
function bw(r50, e) {
  var t = e[0], i = e[1], n = e[2], o = e[3], a = t + t, s3 = i + i, l = n + n, u = t * a, c3 = i * a, p = i * s3, h = n * a, f = n * s3, d = n * l, y = o * a, g = o * s3, x = o * l;
  return r50[0] = 1 - p - d, r50[3] = c3 - x, r50[6] = h + g, r50[1] = c3 + x, r50[4] = 1 - u - d, r50[7] = f - y, r50[2] = h - g, r50[5] = f + y, r50[8] = 1 - u - p, r50;
}
function _w(r50, e) {
  var t = e[0], i = e[1], n = e[2], o = e[3], a = e[4], s3 = e[5], l = e[6], u = e[7], c3 = e[8], p = e[9], h = e[10], f = e[11], d = e[12], y = e[13], g = e[14], x = e[15], v = t * s3 - i * a, b = t * l - n * a, w = t * u - o * a, S = i * l - n * s3, P = i * u - o * s3, k = n * u - o * l, I = c3 * y - p * d, C = c3 * g - h * d, M = c3 * x - f * d, F = p * g - h * y, D = p * x - f * y, E = h * x - f * g, T = v * E - b * D + w * F + S * M - P * C + k * I;
  return T ? (T = 1 / T, r50[0] = (s3 * E - l * D + u * F) * T, r50[1] = (l * M - a * E - u * C) * T, r50[2] = (a * D - s3 * M + u * I) * T, r50[3] = (n * D - i * E - o * F) * T, r50[4] = (t * E - n * M + o * C) * T, r50[5] = (i * M - t * D - o * I) * T, r50[6] = (y * k - g * P + x * S) * T, r50[7] = (g * w - d * k - x * b) * T, r50[8] = (d * P - y * w + x * v) * T, r50) : null;
}
function vw(r50, e, t) {
  return r50[0] = 2 / e, r50[1] = 0, r50[2] = 0, r50[3] = 0, r50[4] = -2 / t, r50[5] = 0, r50[6] = -1, r50[7] = 1, r50[8] = 1, r50;
}
function ww(r50) {
  return "mat3(" + r50[0] + ", " + r50[1] + ", " + r50[2] + ", " + r50[3] + ", " + r50[4] + ", " + r50[5] + ", " + r50[6] + ", " + r50[7] + ", " + r50[8] + ")";
}
function Sw(r50) {
  return Math.hypot(r50[0], r50[1], r50[2], r50[3], r50[4], r50[5], r50[6], r50[7], r50[8]);
}
function Pw(r50, e, t) {
  return r50[0] = e[0] + t[0], r50[1] = e[1] + t[1], r50[2] = e[2] + t[2], r50[3] = e[3] + t[3], r50[4] = e[4] + t[4], r50[5] = e[5] + t[5], r50[6] = e[6] + t[6], r50[7] = e[7] + t[7], r50[8] = e[8] + t[8], r50;
}
function sd(r50, e, t) {
  return r50[0] = e[0] - t[0], r50[1] = e[1] - t[1], r50[2] = e[2] - t[2], r50[3] = e[3] - t[3], r50[4] = e[4] - t[4], r50[5] = e[5] - t[5], r50[6] = e[6] - t[6], r50[7] = e[7] - t[7], r50[8] = e[8] - t[8], r50;
}
function Tw(r50, e, t) {
  return r50[0] = e[0] * t, r50[1] = e[1] * t, r50[2] = e[2] * t, r50[3] = e[3] * t, r50[4] = e[4] * t, r50[5] = e[5] * t, r50[6] = e[6] * t, r50[7] = e[7] * t, r50[8] = e[8] * t, r50;
}
function Aw(r50, e, t, i) {
  return r50[0] = e[0] + t[0] * i, r50[1] = e[1] + t[1] * i, r50[2] = e[2] + t[2] * i, r50[3] = e[3] + t[3] * i, r50[4] = e[4] + t[4] * i, r50[5] = e[5] + t[5] * i, r50[6] = e[6] + t[6] * i, r50[7] = e[7] + t[7] * i, r50[8] = e[8] + t[8] * i, r50;
}
function Mw(r50, e) {
  return r50[0] === e[0] && r50[1] === e[1] && r50[2] === e[2] && r50[3] === e[3] && r50[4] === e[4] && r50[5] === e[5] && r50[6] === e[6] && r50[7] === e[7] && r50[8] === e[8];
}
function Iw(r50, e) {
  var t = r50[0], i = r50[1], n = r50[2], o = r50[3], a = r50[4], s3 = r50[5], l = r50[6], u = r50[7], c3 = r50[8], p = e[0], h = e[1], f = e[2], d = e[3], y = e[4], g = e[5], x = e[6], v = e[7], b = e[8];
  return Math.abs(t - p) <= ne * Math.max(1, Math.abs(t), Math.abs(p)) && Math.abs(i - h) <= ne * Math.max(1, Math.abs(i), Math.abs(h)) && Math.abs(n - f) <= ne * Math.max(1, Math.abs(n), Math.abs(f)) && Math.abs(o - d) <= ne * Math.max(1, Math.abs(o), Math.abs(d)) && Math.abs(a - y) <= ne * Math.max(1, Math.abs(a), Math.abs(y)) && Math.abs(s3 - g) <= ne * Math.max(1, Math.abs(s3), Math.abs(g)) && Math.abs(l - x) <= ne * Math.max(1, Math.abs(l), Math.abs(x)) && Math.abs(u - v) <= ne * Math.max(1, Math.abs(u), Math.abs(v)) && Math.abs(c3 - b) <= ne * Math.max(1, Math.abs(c3), Math.abs(b));
}
var Cw = ad;
var Ew = sd;
var G = {};
r(G, { add: () => mS, adjoint: () => Ow, clone: () => Lw, copy: () => Dw, create: () => kw, determinant: () => Vw, equals: () => xS, exactEquals: () => gS, frob: () => fS, fromQuat: () => iS, fromQuat2: () => Yw, fromRotation: () => Ww, fromRotationTranslation: () => cd, fromRotationTranslationScale: () => tS, fromRotationTranslationScaleOrigin: () => rS, fromScaling: () => $w, fromTranslation: () => Hw, fromValues: () => zw, fromXRotation: () => Xw, fromYRotation: () => Kw, fromZRotation: () => Jw, frustum: () => nS, getRotation: () => eS, getScaling: () => pd, getTranslation: () => Qw, identity: () => ld, invert: () => Bw, lookAt: () => cS, mul: () => bS, multiply: () => ud, multiplyScalar: () => dS, multiplyScalarAndAdd: () => yS, ortho: () => lS, orthoNO: () => fd, orthoZO: () => uS, perspective: () => oS, perspectiveFromFieldOfView: () => sS, perspectiveNO: () => hd, perspectiveZO: () => aS, rotate: () => Gw, rotateX: () => qw, rotateY: () => jw, rotateZ: () => Zw, scale: () => Nw, set: () => Fw, str: () => hS, sub: () => _S, subtract: () => md, targetTo: () => pS, translate: () => Uw, transpose: () => Rw });
c();
function kw() {
  var r50 = new ve(16);
  return ve != Float32Array && (r50[1] = 0, r50[2] = 0, r50[3] = 0, r50[4] = 0, r50[6] = 0, r50[7] = 0, r50[8] = 0, r50[9] = 0, r50[11] = 0, r50[12] = 0, r50[13] = 0, r50[14] = 0), r50[0] = 1, r50[5] = 1, r50[10] = 1, r50[15] = 1, r50;
}
function Lw(r50) {
  var e = new ve(16);
  return e[0] = r50[0], e[1] = r50[1], e[2] = r50[2], e[3] = r50[3], e[4] = r50[4], e[5] = r50[5], e[6] = r50[6], e[7] = r50[7], e[8] = r50[8], e[9] = r50[9], e[10] = r50[10], e[11] = r50[11], e[12] = r50[12], e[13] = r50[13], e[14] = r50[14], e[15] = r50[15], e;
}
function Dw(r50, e) {
  return r50[0] = e[0], r50[1] = e[1], r50[2] = e[2], r50[3] = e[3], r50[4] = e[4], r50[5] = e[5], r50[6] = e[6], r50[7] = e[7], r50[8] = e[8], r50[9] = e[9], r50[10] = e[10], r50[11] = e[11], r50[12] = e[12], r50[13] = e[13], r50[14] = e[14], r50[15] = e[15], r50;
}
function zw(r50, e, t, i, n, o, a, s3, l, u, c3, p, h, f, d, y) {
  var g = new ve(16);
  return g[0] = r50, g[1] = e, g[2] = t, g[3] = i, g[4] = n, g[5] = o, g[6] = a, g[7] = s3, g[8] = l, g[9] = u, g[10] = c3, g[11] = p, g[12] = h, g[13] = f, g[14] = d, g[15] = y, g;
}
function Fw(r50, e, t, i, n, o, a, s3, l, u, c3, p, h, f, d, y, g) {
  return r50[0] = e, r50[1] = t, r50[2] = i, r50[3] = n, r50[4] = o, r50[5] = a, r50[6] = s3, r50[7] = l, r50[8] = u, r50[9] = c3, r50[10] = p, r50[11] = h, r50[12] = f, r50[13] = d, r50[14] = y, r50[15] = g, r50;
}
function ld(r50) {
  return r50[0] = 1, r50[1] = 0, r50[2] = 0, r50[3] = 0, r50[4] = 0, r50[5] = 1, r50[6] = 0, r50[7] = 0, r50[8] = 0, r50[9] = 0, r50[10] = 1, r50[11] = 0, r50[12] = 0, r50[13] = 0, r50[14] = 0, r50[15] = 1, r50;
}
function Rw(r50, e) {
  if (r50 === e) {
    var t = e[1], i = e[2], n = e[3], o = e[6], a = e[7], s3 = e[11];
    r50[1] = e[4], r50[2] = e[8], r50[3] = e[12], r50[4] = t, r50[6] = e[9], r50[7] = e[13], r50[8] = i, r50[9] = o, r50[11] = e[14], r50[12] = n, r50[13] = a, r50[14] = s3;
  } else r50[0] = e[0], r50[1] = e[4], r50[2] = e[8], r50[3] = e[12], r50[4] = e[1], r50[5] = e[5], r50[6] = e[9], r50[7] = e[13], r50[8] = e[2], r50[9] = e[6], r50[10] = e[10], r50[11] = e[14], r50[12] = e[3], r50[13] = e[7], r50[14] = e[11], r50[15] = e[15];
  return r50;
}
function Bw(r50, e) {
  var t = e[0], i = e[1], n = e[2], o = e[3], a = e[4], s3 = e[5], l = e[6], u = e[7], c3 = e[8], p = e[9], h = e[10], f = e[11], d = e[12], y = e[13], g = e[14], x = e[15], v = t * s3 - i * a, b = t * l - n * a, w = t * u - o * a, S = i * l - n * s3, P = i * u - o * s3, k = n * u - o * l, I = c3 * y - p * d, C = c3 * g - h * d, M = c3 * x - f * d, F = p * g - h * y, D = p * x - f * y, E = h * x - f * g, T = v * E - b * D + w * F + S * M - P * C + k * I;
  return T ? (T = 1 / T, r50[0] = (s3 * E - l * D + u * F) * T, r50[1] = (n * D - i * E - o * F) * T, r50[2] = (y * k - g * P + x * S) * T, r50[3] = (h * P - p * k - f * S) * T, r50[4] = (l * M - a * E - u * C) * T, r50[5] = (t * E - n * M + o * C) * T, r50[6] = (g * w - d * k - x * b) * T, r50[7] = (c3 * k - h * w + f * b) * T, r50[8] = (a * D - s3 * M + u * I) * T, r50[9] = (i * M - t * D - o * I) * T, r50[10] = (d * P - y * w + x * v) * T, r50[11] = (p * w - c3 * P - f * v) * T, r50[12] = (s3 * C - a * F - l * I) * T, r50[13] = (t * F - i * C + n * I) * T, r50[14] = (y * b - d * S - g * v) * T, r50[15] = (c3 * S - p * b + h * v) * T, r50) : null;
}
function Ow(r50, e) {
  var t = e[0], i = e[1], n = e[2], o = e[3], a = e[4], s3 = e[5], l = e[6], u = e[7], c3 = e[8], p = e[9], h = e[10], f = e[11], d = e[12], y = e[13], g = e[14], x = e[15];
  return r50[0] = s3 * (h * x - f * g) - p * (l * x - u * g) + y * (l * f - u * h), r50[1] = -(i * (h * x - f * g) - p * (n * x - o * g) + y * (n * f - o * h)), r50[2] = i * (l * x - u * g) - s3 * (n * x - o * g) + y * (n * u - o * l), r50[3] = -(i * (l * f - u * h) - s3 * (n * f - o * h) + p * (n * u - o * l)), r50[4] = -(a * (h * x - f * g) - c3 * (l * x - u * g) + d * (l * f - u * h)), r50[5] = t * (h * x - f * g) - c3 * (n * x - o * g) + d * (n * f - o * h), r50[6] = -(t * (l * x - u * g) - a * (n * x - o * g) + d * (n * u - o * l)), r50[7] = t * (l * f - u * h) - a * (n * f - o * h) + c3 * (n * u - o * l), r50[8] = a * (p * x - f * y) - c3 * (s3 * x - u * y) + d * (s3 * f - u * p), r50[9] = -(t * (p * x - f * y) - c3 * (i * x - o * y) + d * (i * f - o * p)), r50[10] = t * (s3 * x - u * y) - a * (i * x - o * y) + d * (i * u - o * s3), r50[11] = -(t * (s3 * f - u * p) - a * (i * f - o * p) + c3 * (i * u - o * s3)), r50[12] = -(a * (p * g - h * y) - c3 * (s3 * g - l * y) + d * (s3 * h - l * p)), r50[13] = t * (p * g - h * y) - c3 * (i * g - n * y) + d * (i * h - n * p), r50[14] = -(t * (s3 * g - l * y) - a * (i * g - n * y) + d * (i * l - n * s3)), r50[15] = t * (s3 * h - l * p) - a * (i * h - n * p) + c3 * (i * l - n * s3), r50;
}
function Vw(r50) {
  var e = r50[0], t = r50[1], i = r50[2], n = r50[3], o = r50[4], a = r50[5], s3 = r50[6], l = r50[7], u = r50[8], c3 = r50[9], p = r50[10], h = r50[11], f = r50[12], d = r50[13], y = r50[14], g = r50[15], x = e * a - t * o, v = e * s3 - i * o, b = e * l - n * o, w = t * s3 - i * a, S = t * l - n * a, P = i * l - n * s3, k = u * d - c3 * f, I = u * y - p * f, C = u * g - h * f, M = c3 * y - p * d, F = c3 * g - h * d, D = p * g - h * y;
  return x * D - v * F + b * M + w * C - S * I + P * k;
}
function ud(r50, e, t) {
  var i = e[0], n = e[1], o = e[2], a = e[3], s3 = e[4], l = e[5], u = e[6], c3 = e[7], p = e[8], h = e[9], f = e[10], d = e[11], y = e[12], g = e[13], x = e[14], v = e[15], b = t[0], w = t[1], S = t[2], P = t[3];
  return r50[0] = b * i + w * s3 + S * p + P * y, r50[1] = b * n + w * l + S * h + P * g, r50[2] = b * o + w * u + S * f + P * x, r50[3] = b * a + w * c3 + S * d + P * v, b = t[4], w = t[5], S = t[6], P = t[7], r50[4] = b * i + w * s3 + S * p + P * y, r50[5] = b * n + w * l + S * h + P * g, r50[6] = b * o + w * u + S * f + P * x, r50[7] = b * a + w * c3 + S * d + P * v, b = t[8], w = t[9], S = t[10], P = t[11], r50[8] = b * i + w * s3 + S * p + P * y, r50[9] = b * n + w * l + S * h + P * g, r50[10] = b * o + w * u + S * f + P * x, r50[11] = b * a + w * c3 + S * d + P * v, b = t[12], w = t[13], S = t[14], P = t[15], r50[12] = b * i + w * s3 + S * p + P * y, r50[13] = b * n + w * l + S * h + P * g, r50[14] = b * o + w * u + S * f + P * x, r50[15] = b * a + w * c3 + S * d + P * v, r50;
}
function Uw(r50, e, t) {
  var i = t[0], n = t[1], o = t[2], a, s3, l, u, c3, p, h, f, d, y, g, x;
  return e === r50 ? (r50[12] = e[0] * i + e[4] * n + e[8] * o + e[12], r50[13] = e[1] * i + e[5] * n + e[9] * o + e[13], r50[14] = e[2] * i + e[6] * n + e[10] * o + e[14], r50[15] = e[3] * i + e[7] * n + e[11] * o + e[15]) : (a = e[0], s3 = e[1], l = e[2], u = e[3], c3 = e[4], p = e[5], h = e[6], f = e[7], d = e[8], y = e[9], g = e[10], x = e[11], r50[0] = a, r50[1] = s3, r50[2] = l, r50[3] = u, r50[4] = c3, r50[5] = p, r50[6] = h, r50[7] = f, r50[8] = d, r50[9] = y, r50[10] = g, r50[11] = x, r50[12] = a * i + c3 * n + d * o + e[12], r50[13] = s3 * i + p * n + y * o + e[13], r50[14] = l * i + h * n + g * o + e[14], r50[15] = u * i + f * n + x * o + e[15]), r50;
}
function Nw(r50, e, t) {
  var i = t[0], n = t[1], o = t[2];
  return r50[0] = e[0] * i, r50[1] = e[1] * i, r50[2] = e[2] * i, r50[3] = e[3] * i, r50[4] = e[4] * n, r50[5] = e[5] * n, r50[6] = e[6] * n, r50[7] = e[7] * n, r50[8] = e[8] * o, r50[9] = e[9] * o, r50[10] = e[10] * o, r50[11] = e[11] * o, r50[12] = e[12], r50[13] = e[13], r50[14] = e[14], r50[15] = e[15], r50;
}
function Gw(r50, e, t, i) {
  var n = i[0], o = i[1], a = i[2], s3 = Math.hypot(n, o, a), l, u, c3, p, h, f, d, y, g, x, v, b, w, S, P, k, I, C, M, F, D, E, T, N;
  return s3 < ne ? null : (s3 = 1 / s3, n *= s3, o *= s3, a *= s3, l = Math.sin(t), u = Math.cos(t), c3 = 1 - u, p = e[0], h = e[1], f = e[2], d = e[3], y = e[4], g = e[5], x = e[6], v = e[7], b = e[8], w = e[9], S = e[10], P = e[11], k = n * n * c3 + u, I = o * n * c3 + a * l, C = a * n * c3 - o * l, M = n * o * c3 - a * l, F = o * o * c3 + u, D = a * o * c3 + n * l, E = n * a * c3 + o * l, T = o * a * c3 - n * l, N = a * a * c3 + u, r50[0] = p * k + y * I + b * C, r50[1] = h * k + g * I + w * C, r50[2] = f * k + x * I + S * C, r50[3] = d * k + v * I + P * C, r50[4] = p * M + y * F + b * D, r50[5] = h * M + g * F + w * D, r50[6] = f * M + x * F + S * D, r50[7] = d * M + v * F + P * D, r50[8] = p * E + y * T + b * N, r50[9] = h * E + g * T + w * N, r50[10] = f * E + x * T + S * N, r50[11] = d * E + v * T + P * N, e !== r50 && (r50[12] = e[12], r50[13] = e[13], r50[14] = e[14], r50[15] = e[15]), r50);
}
function qw(r50, e, t) {
  var i = Math.sin(t), n = Math.cos(t), o = e[4], a = e[5], s3 = e[6], l = e[7], u = e[8], c3 = e[9], p = e[10], h = e[11];
  return e !== r50 && (r50[0] = e[0], r50[1] = e[1], r50[2] = e[2], r50[3] = e[3], r50[12] = e[12], r50[13] = e[13], r50[14] = e[14], r50[15] = e[15]), r50[4] = o * n + u * i, r50[5] = a * n + c3 * i, r50[6] = s3 * n + p * i, r50[7] = l * n + h * i, r50[8] = u * n - o * i, r50[9] = c3 * n - a * i, r50[10] = p * n - s3 * i, r50[11] = h * n - l * i, r50;
}
function jw(r50, e, t) {
  var i = Math.sin(t), n = Math.cos(t), o = e[0], a = e[1], s3 = e[2], l = e[3], u = e[8], c3 = e[9], p = e[10], h = e[11];
  return e !== r50 && (r50[4] = e[4], r50[5] = e[5], r50[6] = e[6], r50[7] = e[7], r50[12] = e[12], r50[13] = e[13], r50[14] = e[14], r50[15] = e[15]), r50[0] = o * n - u * i, r50[1] = a * n - c3 * i, r50[2] = s3 * n - p * i, r50[3] = l * n - h * i, r50[8] = o * i + u * n, r50[9] = a * i + c3 * n, r50[10] = s3 * i + p * n, r50[11] = l * i + h * n, r50;
}
function Zw(r50, e, t) {
  var i = Math.sin(t), n = Math.cos(t), o = e[0], a = e[1], s3 = e[2], l = e[3], u = e[4], c3 = e[5], p = e[6], h = e[7];
  return e !== r50 && (r50[8] = e[8], r50[9] = e[9], r50[10] = e[10], r50[11] = e[11], r50[12] = e[12], r50[13] = e[13], r50[14] = e[14], r50[15] = e[15]), r50[0] = o * n + u * i, r50[1] = a * n + c3 * i, r50[2] = s3 * n + p * i, r50[3] = l * n + h * i, r50[4] = u * n - o * i, r50[5] = c3 * n - a * i, r50[6] = p * n - s3 * i, r50[7] = h * n - l * i, r50;
}
function Hw(r50, e) {
  return r50[0] = 1, r50[1] = 0, r50[2] = 0, r50[3] = 0, r50[4] = 0, r50[5] = 1, r50[6] = 0, r50[7] = 0, r50[8] = 0, r50[9] = 0, r50[10] = 1, r50[11] = 0, r50[12] = e[0], r50[13] = e[1], r50[14] = e[2], r50[15] = 1, r50;
}
function $w(r50, e) {
  return r50[0] = e[0], r50[1] = 0, r50[2] = 0, r50[3] = 0, r50[4] = 0, r50[5] = e[1], r50[6] = 0, r50[7] = 0, r50[8] = 0, r50[9] = 0, r50[10] = e[2], r50[11] = 0, r50[12] = 0, r50[13] = 0, r50[14] = 0, r50[15] = 1, r50;
}
function Ww(r50, e, t) {
  var i = t[0], n = t[1], o = t[2], a = Math.hypot(i, n, o), s3, l, u;
  return a < ne ? null : (a = 1 / a, i *= a, n *= a, o *= a, s3 = Math.sin(e), l = Math.cos(e), u = 1 - l, r50[0] = i * i * u + l, r50[1] = n * i * u + o * s3, r50[2] = o * i * u - n * s3, r50[3] = 0, r50[4] = i * n * u - o * s3, r50[5] = n * n * u + l, r50[6] = o * n * u + i * s3, r50[7] = 0, r50[8] = i * o * u + n * s3, r50[9] = n * o * u - i * s3, r50[10] = o * o * u + l, r50[11] = 0, r50[12] = 0, r50[13] = 0, r50[14] = 0, r50[15] = 1, r50);
}
function Xw(r50, e) {
  var t = Math.sin(e), i = Math.cos(e);
  return r50[0] = 1, r50[1] = 0, r50[2] = 0, r50[3] = 0, r50[4] = 0, r50[5] = i, r50[6] = t, r50[7] = 0, r50[8] = 0, r50[9] = -t, r50[10] = i, r50[11] = 0, r50[12] = 0, r50[13] = 0, r50[14] = 0, r50[15] = 1, r50;
}
function Kw(r50, e) {
  var t = Math.sin(e), i = Math.cos(e);
  return r50[0] = i, r50[1] = 0, r50[2] = -t, r50[3] = 0, r50[4] = 0, r50[5] = 1, r50[6] = 0, r50[7] = 0, r50[8] = t, r50[9] = 0, r50[10] = i, r50[11] = 0, r50[12] = 0, r50[13] = 0, r50[14] = 0, r50[15] = 1, r50;
}
function Jw(r50, e) {
  var t = Math.sin(e), i = Math.cos(e);
  return r50[0] = i, r50[1] = t, r50[2] = 0, r50[3] = 0, r50[4] = -t, r50[5] = i, r50[6] = 0, r50[7] = 0, r50[8] = 0, r50[9] = 0, r50[10] = 1, r50[11] = 0, r50[12] = 0, r50[13] = 0, r50[14] = 0, r50[15] = 1, r50;
}
function cd(r50, e, t) {
  var i = e[0], n = e[1], o = e[2], a = e[3], s3 = i + i, l = n + n, u = o + o, c3 = i * s3, p = i * l, h = i * u, f = n * l, d = n * u, y = o * u, g = a * s3, x = a * l, v = a * u;
  return r50[0] = 1 - (f + y), r50[1] = p + v, r50[2] = h - x, r50[3] = 0, r50[4] = p - v, r50[5] = 1 - (c3 + y), r50[6] = d + g, r50[7] = 0, r50[8] = h + x, r50[9] = d - g, r50[10] = 1 - (c3 + f), r50[11] = 0, r50[12] = t[0], r50[13] = t[1], r50[14] = t[2], r50[15] = 1, r50;
}
function Yw(r50, e) {
  var t = new ve(3), i = -e[0], n = -e[1], o = -e[2], a = e[3], s3 = e[4], l = e[5], u = e[6], c3 = e[7], p = i * i + n * n + o * o + a * a;
  return p > 0 ? (t[0] = (s3 * a + c3 * i + l * o - u * n) * 2 / p, t[1] = (l * a + c3 * n + u * i - s3 * o) * 2 / p, t[2] = (u * a + c3 * o + s3 * n - l * i) * 2 / p) : (t[0] = (s3 * a + c3 * i + l * o - u * n) * 2, t[1] = (l * a + c3 * n + u * i - s3 * o) * 2, t[2] = (u * a + c3 * o + s3 * n - l * i) * 2), cd(r50, e, t), r50;
}
function Qw(r50, e) {
  return r50[0] = e[12], r50[1] = e[13], r50[2] = e[14], r50;
}
function pd(r50, e) {
  var t = e[0], i = e[1], n = e[2], o = e[4], a = e[5], s3 = e[6], l = e[8], u = e[9], c3 = e[10];
  return r50[0] = Math.hypot(t, i, n), r50[1] = Math.hypot(o, a, s3), r50[2] = Math.hypot(l, u, c3), r50;
}
function eS(r50, e) {
  var t = new ve(3);
  pd(t, e);
  var i = 1 / t[0], n = 1 / t[1], o = 1 / t[2], a = e[0] * i, s3 = e[1] * n, l = e[2] * o, u = e[4] * i, c3 = e[5] * n, p = e[6] * o, h = e[8] * i, f = e[9] * n, d = e[10] * o, y = a + c3 + d, g = 0;
  return y > 0 ? (g = Math.sqrt(y + 1) * 2, r50[3] = 0.25 * g, r50[0] = (p - f) / g, r50[1] = (h - l) / g, r50[2] = (s3 - u) / g) : a > c3 && a > d ? (g = Math.sqrt(1 + a - c3 - d) * 2, r50[3] = (p - f) / g, r50[0] = 0.25 * g, r50[1] = (s3 + u) / g, r50[2] = (h + l) / g) : c3 > d ? (g = Math.sqrt(1 + c3 - a - d) * 2, r50[3] = (h - l) / g, r50[0] = (s3 + u) / g, r50[1] = 0.25 * g, r50[2] = (p + f) / g) : (g = Math.sqrt(1 + d - a - c3) * 2, r50[3] = (s3 - u) / g, r50[0] = (h + l) / g, r50[1] = (p + f) / g, r50[2] = 0.25 * g), r50;
}
function tS(r50, e, t, i) {
  var n = e[0], o = e[1], a = e[2], s3 = e[3], l = n + n, u = o + o, c3 = a + a, p = n * l, h = n * u, f = n * c3, d = o * u, y = o * c3, g = a * c3, x = s3 * l, v = s3 * u, b = s3 * c3, w = i[0], S = i[1], P = i[2];
  return r50[0] = (1 - (d + g)) * w, r50[1] = (h + b) * w, r50[2] = (f - v) * w, r50[3] = 0, r50[4] = (h - b) * S, r50[5] = (1 - (p + g)) * S, r50[6] = (y + x) * S, r50[7] = 0, r50[8] = (f + v) * P, r50[9] = (y - x) * P, r50[10] = (1 - (p + d)) * P, r50[11] = 0, r50[12] = t[0], r50[13] = t[1], r50[14] = t[2], r50[15] = 1, r50;
}
function rS(r50, e, t, i, n) {
  var o = e[0], a = e[1], s3 = e[2], l = e[3], u = o + o, c3 = a + a, p = s3 + s3, h = o * u, f = o * c3, d = o * p, y = a * c3, g = a * p, x = s3 * p, v = l * u, b = l * c3, w = l * p, S = i[0], P = i[1], k = i[2], I = n[0], C = n[1], M = n[2], F = (1 - (y + x)) * S, D = (f + w) * S, E = (d - b) * S, T = (f - w) * P, N = (1 - (h + x)) * P, X = (g + v) * P, ie = (d + b) * k, K = (g - v) * k, $ = (1 - (h + y)) * k;
  return r50[0] = F, r50[1] = D, r50[2] = E, r50[3] = 0, r50[4] = T, r50[5] = N, r50[6] = X, r50[7] = 0, r50[8] = ie, r50[9] = K, r50[10] = $, r50[11] = 0, r50[12] = t[0] + I - (F * I + T * C + ie * M), r50[13] = t[1] + C - (D * I + N * C + K * M), r50[14] = t[2] + M - (E * I + X * C + $ * M), r50[15] = 1, r50;
}
function iS(r50, e) {
  var t = e[0], i = e[1], n = e[2], o = e[3], a = t + t, s3 = i + i, l = n + n, u = t * a, c3 = i * a, p = i * s3, h = n * a, f = n * s3, d = n * l, y = o * a, g = o * s3, x = o * l;
  return r50[0] = 1 - p - d, r50[1] = c3 + x, r50[2] = h - g, r50[3] = 0, r50[4] = c3 - x, r50[5] = 1 - u - d, r50[6] = f + y, r50[7] = 0, r50[8] = h + g, r50[9] = f - y, r50[10] = 1 - u - p, r50[11] = 0, r50[12] = 0, r50[13] = 0, r50[14] = 0, r50[15] = 1, r50;
}
function nS(r50, e, t, i, n, o, a) {
  var s3 = 1 / (t - e), l = 1 / (n - i), u = 1 / (o - a);
  return r50[0] = o * 2 * s3, r50[1] = 0, r50[2] = 0, r50[3] = 0, r50[4] = 0, r50[5] = o * 2 * l, r50[6] = 0, r50[7] = 0, r50[8] = (t + e) * s3, r50[9] = (n + i) * l, r50[10] = (a + o) * u, r50[11] = -1, r50[12] = 0, r50[13] = 0, r50[14] = a * o * 2 * u, r50[15] = 0, r50;
}
function hd(r50, e, t, i, n) {
  var o = 1 / Math.tan(e / 2), a;
  return r50[0] = o / t, r50[1] = 0, r50[2] = 0, r50[3] = 0, r50[4] = 0, r50[5] = o, r50[6] = 0, r50[7] = 0, r50[8] = 0, r50[9] = 0, r50[11] = -1, r50[12] = 0, r50[13] = 0, r50[15] = 0, n != null && n !== 1 / 0 ? (a = 1 / (i - n), r50[10] = (n + i) * a, r50[14] = 2 * n * i * a) : (r50[10] = -1, r50[14] = -2 * i), r50;
}
var oS = hd;
function aS(r50, e, t, i, n) {
  var o = 1 / Math.tan(e / 2), a;
  return r50[0] = o / t, r50[1] = 0, r50[2] = 0, r50[3] = 0, r50[4] = 0, r50[5] = o, r50[6] = 0, r50[7] = 0, r50[8] = 0, r50[9] = 0, r50[11] = -1, r50[12] = 0, r50[13] = 0, r50[15] = 0, n != null && n !== 1 / 0 ? (a = 1 / (i - n), r50[10] = n * a, r50[14] = n * i * a) : (r50[10] = -1, r50[14] = -i), r50;
}
function sS(r50, e, t, i) {
  var n = Math.tan(e.upDegrees * Math.PI / 180), o = Math.tan(e.downDegrees * Math.PI / 180), a = Math.tan(e.leftDegrees * Math.PI / 180), s3 = Math.tan(e.rightDegrees * Math.PI / 180), l = 2 / (a + s3), u = 2 / (n + o);
  return r50[0] = l, r50[1] = 0, r50[2] = 0, r50[3] = 0, r50[4] = 0, r50[5] = u, r50[6] = 0, r50[7] = 0, r50[8] = -((a - s3) * l * 0.5), r50[9] = (n - o) * u * 0.5, r50[10] = i / (t - i), r50[11] = -1, r50[12] = 0, r50[13] = 0, r50[14] = i * t / (t - i), r50[15] = 0, r50;
}
function fd(r50, e, t, i, n, o, a) {
  var s3 = 1 / (e - t), l = 1 / (i - n), u = 1 / (o - a);
  return r50[0] = -2 * s3, r50[1] = 0, r50[2] = 0, r50[3] = 0, r50[4] = 0, r50[5] = -2 * l, r50[6] = 0, r50[7] = 0, r50[8] = 0, r50[9] = 0, r50[10] = 2 * u, r50[11] = 0, r50[12] = (e + t) * s3, r50[13] = (n + i) * l, r50[14] = (a + o) * u, r50[15] = 1, r50;
}
var lS = fd;
function uS(r50, e, t, i, n, o, a) {
  var s3 = 1 / (e - t), l = 1 / (i - n), u = 1 / (o - a);
  return r50[0] = -2 * s3, r50[1] = 0, r50[2] = 0, r50[3] = 0, r50[4] = 0, r50[5] = -2 * l, r50[6] = 0, r50[7] = 0, r50[8] = 0, r50[9] = 0, r50[10] = u, r50[11] = 0, r50[12] = (e + t) * s3, r50[13] = (n + i) * l, r50[14] = o * u, r50[15] = 1, r50;
}
function cS(r50, e, t, i) {
  var n, o, a, s3, l, u, c3, p, h, f, d = e[0], y = e[1], g = e[2], x = i[0], v = i[1], b = i[2], w = t[0], S = t[1], P = t[2];
  return Math.abs(d - w) < ne && Math.abs(y - S) < ne && Math.abs(g - P) < ne ? ld(r50) : (c3 = d - w, p = y - S, h = g - P, f = 1 / Math.hypot(c3, p, h), c3 *= f, p *= f, h *= f, n = v * h - b * p, o = b * c3 - x * h, a = x * p - v * c3, f = Math.hypot(n, o, a), f ? (f = 1 / f, n *= f, o *= f, a *= f) : (n = 0, o = 0, a = 0), s3 = p * a - h * o, l = h * n - c3 * a, u = c3 * o - p * n, f = Math.hypot(s3, l, u), f ? (f = 1 / f, s3 *= f, l *= f, u *= f) : (s3 = 0, l = 0, u = 0), r50[0] = n, r50[1] = s3, r50[2] = c3, r50[3] = 0, r50[4] = o, r50[5] = l, r50[6] = p, r50[7] = 0, r50[8] = a, r50[9] = u, r50[10] = h, r50[11] = 0, r50[12] = -(n * d + o * y + a * g), r50[13] = -(s3 * d + l * y + u * g), r50[14] = -(c3 * d + p * y + h * g), r50[15] = 1, r50);
}
function pS(r50, e, t, i) {
  var n = e[0], o = e[1], a = e[2], s3 = i[0], l = i[1], u = i[2], c3 = n - t[0], p = o - t[1], h = a - t[2], f = c3 * c3 + p * p + h * h;
  f > 0 && (f = 1 / Math.sqrt(f), c3 *= f, p *= f, h *= f);
  var d = l * h - u * p, y = u * c3 - s3 * h, g = s3 * p - l * c3;
  return f = d * d + y * y + g * g, f > 0 && (f = 1 / Math.sqrt(f), d *= f, y *= f, g *= f), r50[0] = d, r50[1] = y, r50[2] = g, r50[3] = 0, r50[4] = p * g - h * y, r50[5] = h * d - c3 * g, r50[6] = c3 * y - p * d, r50[7] = 0, r50[8] = c3, r50[9] = p, r50[10] = h, r50[11] = 0, r50[12] = n, r50[13] = o, r50[14] = a, r50[15] = 1, r50;
}
function hS(r50) {
  return "mat4(" + r50[0] + ", " + r50[1] + ", " + r50[2] + ", " + r50[3] + ", " + r50[4] + ", " + r50[5] + ", " + r50[6] + ", " + r50[7] + ", " + r50[8] + ", " + r50[9] + ", " + r50[10] + ", " + r50[11] + ", " + r50[12] + ", " + r50[13] + ", " + r50[14] + ", " + r50[15] + ")";
}
function fS(r50) {
  return Math.hypot(r50[0], r50[1], r50[2], r50[3], r50[4], r50[5], r50[6], r50[7], r50[8], r50[9], r50[10], r50[11], r50[12], r50[13], r50[14], r50[15]);
}
function mS(r50, e, t) {
  return r50[0] = e[0] + t[0], r50[1] = e[1] + t[1], r50[2] = e[2] + t[2], r50[3] = e[3] + t[3], r50[4] = e[4] + t[4], r50[5] = e[5] + t[5], r50[6] = e[6] + t[6], r50[7] = e[7] + t[7], r50[8] = e[8] + t[8], r50[9] = e[9] + t[9], r50[10] = e[10] + t[10], r50[11] = e[11] + t[11], r50[12] = e[12] + t[12], r50[13] = e[13] + t[13], r50[14] = e[14] + t[14], r50[15] = e[15] + t[15], r50;
}
function md(r50, e, t) {
  return r50[0] = e[0] - t[0], r50[1] = e[1] - t[1], r50[2] = e[2] - t[2], r50[3] = e[3] - t[3], r50[4] = e[4] - t[4], r50[5] = e[5] - t[5], r50[6] = e[6] - t[6], r50[7] = e[7] - t[7], r50[8] = e[8] - t[8], r50[9] = e[9] - t[9], r50[10] = e[10] - t[10], r50[11] = e[11] - t[11], r50[12] = e[12] - t[12], r50[13] = e[13] - t[13], r50[14] = e[14] - t[14], r50[15] = e[15] - t[15], r50;
}
function dS(r50, e, t) {
  return r50[0] = e[0] * t, r50[1] = e[1] * t, r50[2] = e[2] * t, r50[3] = e[3] * t, r50[4] = e[4] * t, r50[5] = e[5] * t, r50[6] = e[6] * t, r50[7] = e[7] * t, r50[8] = e[8] * t, r50[9] = e[9] * t, r50[10] = e[10] * t, r50[11] = e[11] * t, r50[12] = e[12] * t, r50[13] = e[13] * t, r50[14] = e[14] * t, r50[15] = e[15] * t, r50;
}
function yS(r50, e, t, i) {
  return r50[0] = e[0] + t[0] * i, r50[1] = e[1] + t[1] * i, r50[2] = e[2] + t[2] * i, r50[3] = e[3] + t[3] * i, r50[4] = e[4] + t[4] * i, r50[5] = e[5] + t[5] * i, r50[6] = e[6] + t[6] * i, r50[7] = e[7] + t[7] * i, r50[8] = e[8] + t[8] * i, r50[9] = e[9] + t[9] * i, r50[10] = e[10] + t[10] * i, r50[11] = e[11] + t[11] * i, r50[12] = e[12] + t[12] * i, r50[13] = e[13] + t[13] * i, r50[14] = e[14] + t[14] * i, r50[15] = e[15] + t[15] * i, r50;
}
function gS(r50, e) {
  return r50[0] === e[0] && r50[1] === e[1] && r50[2] === e[2] && r50[3] === e[3] && r50[4] === e[4] && r50[5] === e[5] && r50[6] === e[6] && r50[7] === e[7] && r50[8] === e[8] && r50[9] === e[9] && r50[10] === e[10] && r50[11] === e[11] && r50[12] === e[12] && r50[13] === e[13] && r50[14] === e[14] && r50[15] === e[15];
}
function xS(r50, e) {
  var t = r50[0], i = r50[1], n = r50[2], o = r50[3], a = r50[4], s3 = r50[5], l = r50[6], u = r50[7], c3 = r50[8], p = r50[9], h = r50[10], f = r50[11], d = r50[12], y = r50[13], g = r50[14], x = r50[15], v = e[0], b = e[1], w = e[2], S = e[3], P = e[4], k = e[5], I = e[6], C = e[7], M = e[8], F = e[9], D = e[10], E = e[11], T = e[12], N = e[13], X = e[14], ie = e[15];
  return Math.abs(t - v) <= ne * Math.max(1, Math.abs(t), Math.abs(v)) && Math.abs(i - b) <= ne * Math.max(1, Math.abs(i), Math.abs(b)) && Math.abs(n - w) <= ne * Math.max(1, Math.abs(n), Math.abs(w)) && Math.abs(o - S) <= ne * Math.max(1, Math.abs(o), Math.abs(S)) && Math.abs(a - P) <= ne * Math.max(1, Math.abs(a), Math.abs(P)) && Math.abs(s3 - k) <= ne * Math.max(1, Math.abs(s3), Math.abs(k)) && Math.abs(l - I) <= ne * Math.max(1, Math.abs(l), Math.abs(I)) && Math.abs(u - C) <= ne * Math.max(1, Math.abs(u), Math.abs(C)) && Math.abs(c3 - M) <= ne * Math.max(1, Math.abs(c3), Math.abs(M)) && Math.abs(p - F) <= ne * Math.max(1, Math.abs(p), Math.abs(F)) && Math.abs(h - D) <= ne * Math.max(1, Math.abs(h), Math.abs(D)) && Math.abs(f - E) <= ne * Math.max(1, Math.abs(f), Math.abs(E)) && Math.abs(d - T) <= ne * Math.max(1, Math.abs(d), Math.abs(T)) && Math.abs(y - N) <= ne * Math.max(1, Math.abs(y), Math.abs(N)) && Math.abs(g - X) <= ne * Math.max(1, Math.abs(g), Math.abs(X)) && Math.abs(x - ie) <= ne * Math.max(1, Math.abs(x), Math.abs(ie));
}
var bS = ud;
var _S = md;
var yt = {};
r(yt, { add: () => TS, angle: () => $S, bezier: () => VS, ceil: () => AS, clone: () => vS, copy: () => SS, create: () => dd, cross: () => RS, dist: () => t2, distance: () => _d, div: () => e2, divide: () => bd, dot: () => Sd, equals: () => JS, exactEquals: () => KS, floor: () => MS, forEach: () => o2, fromValues: () => wS, hermite: () => OS, inverse: () => zS, len: () => i2, length: () => yd, lerp: () => BS, max: () => CS, min: () => IS, mul: () => QS, multiply: () => xd, negate: () => DS, normalize: () => FS, random: () => US, rotateX: () => jS, rotateY: () => ZS, rotateZ: () => HS, round: () => ES, scale: () => kS, scaleAndAdd: () => LS, set: () => PS, sqrDist: () => r210, sqrLen: () => n2, squaredDistance: () => vd, squaredLength: () => wd, str: () => XS, sub: () => YS, subtract: () => gd, transformMat3: () => GS, transformMat4: () => NS, transformQuat: () => qS, zero: () => WS });
c();
function dd() {
  var r50 = new ve(3);
  return ve != Float32Array && (r50[0] = 0, r50[1] = 0, r50[2] = 0), r50;
}
function vS(r50) {
  var e = new ve(3);
  return e[0] = r50[0], e[1] = r50[1], e[2] = r50[2], e;
}
function yd(r50) {
  var e = r50[0], t = r50[1], i = r50[2];
  return Math.hypot(e, t, i);
}
function wS(r50, e, t) {
  var i = new ve(3);
  return i[0] = r50, i[1] = e, i[2] = t, i;
}
function SS(r50, e) {
  return r50[0] = e[0], r50[1] = e[1], r50[2] = e[2], r50;
}
function PS(r50, e, t, i) {
  return r50[0] = e, r50[1] = t, r50[2] = i, r50;
}
function TS(r50, e, t) {
  return r50[0] = e[0] + t[0], r50[1] = e[1] + t[1], r50[2] = e[2] + t[2], r50;
}
function gd(r50, e, t) {
  return r50[0] = e[0] - t[0], r50[1] = e[1] - t[1], r50[2] = e[2] - t[2], r50;
}
function xd(r50, e, t) {
  return r50[0] = e[0] * t[0], r50[1] = e[1] * t[1], r50[2] = e[2] * t[2], r50;
}
function bd(r50, e, t) {
  return r50[0] = e[0] / t[0], r50[1] = e[1] / t[1], r50[2] = e[2] / t[2], r50;
}
function AS(r50, e) {
  return r50[0] = Math.ceil(e[0]), r50[1] = Math.ceil(e[1]), r50[2] = Math.ceil(e[2]), r50;
}
function MS(r50, e) {
  return r50[0] = Math.floor(e[0]), r50[1] = Math.floor(e[1]), r50[2] = Math.floor(e[2]), r50;
}
function IS(r50, e, t) {
  return r50[0] = Math.min(e[0], t[0]), r50[1] = Math.min(e[1], t[1]), r50[2] = Math.min(e[2], t[2]), r50;
}
function CS(r50, e, t) {
  return r50[0] = Math.max(e[0], t[0]), r50[1] = Math.max(e[1], t[1]), r50[2] = Math.max(e[2], t[2]), r50;
}
function ES(r50, e) {
  return r50[0] = Math.round(e[0]), r50[1] = Math.round(e[1]), r50[2] = Math.round(e[2]), r50;
}
function kS(r50, e, t) {
  return r50[0] = e[0] * t, r50[1] = e[1] * t, r50[2] = e[2] * t, r50;
}
function LS(r50, e, t, i) {
  return r50[0] = e[0] + t[0] * i, r50[1] = e[1] + t[1] * i, r50[2] = e[2] + t[2] * i, r50;
}
function _d(r50, e) {
  var t = e[0] - r50[0], i = e[1] - r50[1], n = e[2] - r50[2];
  return Math.hypot(t, i, n);
}
function vd(r50, e) {
  var t = e[0] - r50[0], i = e[1] - r50[1], n = e[2] - r50[2];
  return t * t + i * i + n * n;
}
function wd(r50) {
  var e = r50[0], t = r50[1], i = r50[2];
  return e * e + t * t + i * i;
}
function DS(r50, e) {
  return r50[0] = -e[0], r50[1] = -e[1], r50[2] = -e[2], r50;
}
function zS(r50, e) {
  return r50[0] = 1 / e[0], r50[1] = 1 / e[1], r50[2] = 1 / e[2], r50;
}
function FS(r50, e) {
  var t = e[0], i = e[1], n = e[2], o = t * t + i * i + n * n;
  return o > 0 && (o = 1 / Math.sqrt(o)), r50[0] = e[0] * o, r50[1] = e[1] * o, r50[2] = e[2] * o, r50;
}
function Sd(r50, e) {
  return r50[0] * e[0] + r50[1] * e[1] + r50[2] * e[2];
}
function RS(r50, e, t) {
  var i = e[0], n = e[1], o = e[2], a = t[0], s3 = t[1], l = t[2];
  return r50[0] = n * l - o * s3, r50[1] = o * a - i * l, r50[2] = i * s3 - n * a, r50;
}
function BS(r50, e, t, i) {
  var n = e[0], o = e[1], a = e[2];
  return r50[0] = n + i * (t[0] - n), r50[1] = o + i * (t[1] - o), r50[2] = a + i * (t[2] - a), r50;
}
function OS(r50, e, t, i, n, o) {
  var a = o * o, s3 = a * (2 * o - 3) + 1, l = a * (o - 2) + o, u = a * (o - 1), c3 = a * (3 - 2 * o);
  return r50[0] = e[0] * s3 + t[0] * l + i[0] * u + n[0] * c3, r50[1] = e[1] * s3 + t[1] * l + i[1] * u + n[1] * c3, r50[2] = e[2] * s3 + t[2] * l + i[2] * u + n[2] * c3, r50;
}
function VS(r50, e, t, i, n, o) {
  var a = 1 - o, s3 = a * a, l = o * o, u = s3 * a, c3 = 3 * o * s3, p = 3 * l * a, h = l * o;
  return r50[0] = e[0] * u + t[0] * c3 + i[0] * p + n[0] * h, r50[1] = e[1] * u + t[1] * c3 + i[1] * p + n[1] * h, r50[2] = e[2] * u + t[2] * c3 + i[2] * p + n[2] * h, r50;
}
function US(r50, e) {
  e = e || 1;
  var t = Gt() * 2 * Math.PI, i = Gt() * 2 - 1, n = Math.sqrt(1 - i * i) * e;
  return r50[0] = Math.cos(t) * n, r50[1] = Math.sin(t) * n, r50[2] = i * e, r50;
}
function NS(r50, e, t) {
  var i = e[0], n = e[1], o = e[2], a = t[3] * i + t[7] * n + t[11] * o + t[15];
  return a = a || 1, r50[0] = (t[0] * i + t[4] * n + t[8] * o + t[12]) / a, r50[1] = (t[1] * i + t[5] * n + t[9] * o + t[13]) / a, r50[2] = (t[2] * i + t[6] * n + t[10] * o + t[14]) / a, r50;
}
function GS(r50, e, t) {
  var i = e[0], n = e[1], o = e[2];
  return r50[0] = i * t[0] + n * t[3] + o * t[6], r50[1] = i * t[1] + n * t[4] + o * t[7], r50[2] = i * t[2] + n * t[5] + o * t[8], r50;
}
function qS(r50, e, t) {
  var i = t[0], n = t[1], o = t[2], a = t[3], s3 = e[0], l = e[1], u = e[2], c3 = n * u - o * l, p = o * s3 - i * u, h = i * l - n * s3, f = n * h - o * p, d = o * c3 - i * h, y = i * p - n * c3, g = a * 2;
  return c3 *= g, p *= g, h *= g, f *= 2, d *= 2, y *= 2, r50[0] = s3 + c3 + f, r50[1] = l + p + d, r50[2] = u + h + y, r50;
}
function jS(r50, e, t, i) {
  var n = [], o = [];
  return n[0] = e[0] - t[0], n[1] = e[1] - t[1], n[2] = e[2] - t[2], o[0] = n[0], o[1] = n[1] * Math.cos(i) - n[2] * Math.sin(i), o[2] = n[1] * Math.sin(i) + n[2] * Math.cos(i), r50[0] = o[0] + t[0], r50[1] = o[1] + t[1], r50[2] = o[2] + t[2], r50;
}
function ZS(r50, e, t, i) {
  var n = [], o = [];
  return n[0] = e[0] - t[0], n[1] = e[1] - t[1], n[2] = e[2] - t[2], o[0] = n[2] * Math.sin(i) + n[0] * Math.cos(i), o[1] = n[1], o[2] = n[2] * Math.cos(i) - n[0] * Math.sin(i), r50[0] = o[0] + t[0], r50[1] = o[1] + t[1], r50[2] = o[2] + t[2], r50;
}
function HS(r50, e, t, i) {
  var n = [], o = [];
  return n[0] = e[0] - t[0], n[1] = e[1] - t[1], n[2] = e[2] - t[2], o[0] = n[0] * Math.cos(i) - n[1] * Math.sin(i), o[1] = n[0] * Math.sin(i) + n[1] * Math.cos(i), o[2] = n[2], r50[0] = o[0] + t[0], r50[1] = o[1] + t[1], r50[2] = o[2] + t[2], r50;
}
function $S(r50, e) {
  var t = r50[0], i = r50[1], n = r50[2], o = e[0], a = e[1], s3 = e[2], l = Math.sqrt(t * t + i * i + n * n), u = Math.sqrt(o * o + a * a + s3 * s3), c3 = l * u, p = c3 && Sd(r50, e) / c3;
  return Math.acos(Math.min(Math.max(p, -1), 1));
}
function WS(r50) {
  return r50[0] = 0, r50[1] = 0, r50[2] = 0, r50;
}
function XS(r50) {
  return "vec3(" + r50[0] + ", " + r50[1] + ", " + r50[2] + ")";
}
function KS(r50, e) {
  return r50[0] === e[0] && r50[1] === e[1] && r50[2] === e[2];
}
function JS(r50, e) {
  var t = r50[0], i = r50[1], n = r50[2], o = e[0], a = e[1], s3 = e[2];
  return Math.abs(t - o) <= ne * Math.max(1, Math.abs(t), Math.abs(o)) && Math.abs(i - a) <= ne * Math.max(1, Math.abs(i), Math.abs(a)) && Math.abs(n - s3) <= ne * Math.max(1, Math.abs(n), Math.abs(s3));
}
var YS = gd;
var QS = xd;
var e2 = bd;
var t2 = _d;
var r210 = vd;
var i2 = yd;
var n2 = wd;
var o2 = function() {
  var r50 = dd();
  return function(e, t, i, n, o, a) {
    var s3, l;
    for (t || (t = 3), i || (i = 0), n ? l = Math.min(n * t + i, e.length) : l = e.length, s3 = i; s3 < l; s3 += t) r50[0] = e[s3], r50[1] = e[s3 + 1], r50[2] = e[s3 + 2], o(r50, r50, a), e[s3] = r50[0], e[s3 + 1] = r50[1], e[s3 + 2] = r50[2];
    return e;
  };
}();
var Ge = {};
r(Ge, { add: () => c2, ceil: () => p2, clone: () => a2, copy: () => l2, create: () => Pd, cross: () => w2, dist: () => z2, distance: () => Id, div: () => D2, divide: () => Md, dot: () => v2, equals: () => E2, exactEquals: () => C2, floor: () => h2, forEach: () => O2, fromValues: () => s2, inverse: () => b2, len: () => R2, length: () => Ed, lerp: () => S2, max: () => m2, min: () => f2, mul: () => L2, multiply: () => Ad, negate: () => x2, normalize: () => _2, random: () => P2, round: () => d2, scale: () => y2, scaleAndAdd: () => g2, set: () => u2, sqrDist: () => F2, sqrLen: () => B2, squaredDistance: () => Cd, squaredLength: () => kd, str: () => I2, sub: () => k2, subtract: () => Td, transformMat4: () => T2, transformQuat: () => A2, zero: () => M2 });
c();
function Pd() {
  var r50 = new ve(4);
  return ve != Float32Array && (r50[0] = 0, r50[1] = 0, r50[2] = 0, r50[3] = 0), r50;
}
function a2(r50) {
  var e = new ve(4);
  return e[0] = r50[0], e[1] = r50[1], e[2] = r50[2], e[3] = r50[3], e;
}
function s2(r50, e, t, i) {
  var n = new ve(4);
  return n[0] = r50, n[1] = e, n[2] = t, n[3] = i, n;
}
function l2(r50, e) {
  return r50[0] = e[0], r50[1] = e[1], r50[2] = e[2], r50[3] = e[3], r50;
}
function u2(r50, e, t, i, n) {
  return r50[0] = e, r50[1] = t, r50[2] = i, r50[3] = n, r50;
}
function c2(r50, e, t) {
  return r50[0] = e[0] + t[0], r50[1] = e[1] + t[1], r50[2] = e[2] + t[2], r50[3] = e[3] + t[3], r50;
}
function Td(r50, e, t) {
  return r50[0] = e[0] - t[0], r50[1] = e[1] - t[1], r50[2] = e[2] - t[2], r50[3] = e[3] - t[3], r50;
}
function Ad(r50, e, t) {
  return r50[0] = e[0] * t[0], r50[1] = e[1] * t[1], r50[2] = e[2] * t[2], r50[3] = e[3] * t[3], r50;
}
function Md(r50, e, t) {
  return r50[0] = e[0] / t[0], r50[1] = e[1] / t[1], r50[2] = e[2] / t[2], r50[3] = e[3] / t[3], r50;
}
function p2(r50, e) {
  return r50[0] = Math.ceil(e[0]), r50[1] = Math.ceil(e[1]), r50[2] = Math.ceil(e[2]), r50[3] = Math.ceil(e[3]), r50;
}
function h2(r50, e) {
  return r50[0] = Math.floor(e[0]), r50[1] = Math.floor(e[1]), r50[2] = Math.floor(e[2]), r50[3] = Math.floor(e[3]), r50;
}
function f2(r50, e, t) {
  return r50[0] = Math.min(e[0], t[0]), r50[1] = Math.min(e[1], t[1]), r50[2] = Math.min(e[2], t[2]), r50[3] = Math.min(e[3], t[3]), r50;
}
function m2(r50, e, t) {
  return r50[0] = Math.max(e[0], t[0]), r50[1] = Math.max(e[1], t[1]), r50[2] = Math.max(e[2], t[2]), r50[3] = Math.max(e[3], t[3]), r50;
}
function d2(r50, e) {
  return r50[0] = Math.round(e[0]), r50[1] = Math.round(e[1]), r50[2] = Math.round(e[2]), r50[3] = Math.round(e[3]), r50;
}
function y2(r50, e, t) {
  return r50[0] = e[0] * t, r50[1] = e[1] * t, r50[2] = e[2] * t, r50[3] = e[3] * t, r50;
}
function g2(r50, e, t, i) {
  return r50[0] = e[0] + t[0] * i, r50[1] = e[1] + t[1] * i, r50[2] = e[2] + t[2] * i, r50[3] = e[3] + t[3] * i, r50;
}
function Id(r50, e) {
  var t = e[0] - r50[0], i = e[1] - r50[1], n = e[2] - r50[2], o = e[3] - r50[3];
  return Math.hypot(t, i, n, o);
}
function Cd(r50, e) {
  var t = e[0] - r50[0], i = e[1] - r50[1], n = e[2] - r50[2], o = e[3] - r50[3];
  return t * t + i * i + n * n + o * o;
}
function Ed(r50) {
  var e = r50[0], t = r50[1], i = r50[2], n = r50[3];
  return Math.hypot(e, t, i, n);
}
function kd(r50) {
  var e = r50[0], t = r50[1], i = r50[2], n = r50[3];
  return e * e + t * t + i * i + n * n;
}
function x2(r50, e) {
  return r50[0] = -e[0], r50[1] = -e[1], r50[2] = -e[2], r50[3] = -e[3], r50;
}
function b2(r50, e) {
  return r50[0] = 1 / e[0], r50[1] = 1 / e[1], r50[2] = 1 / e[2], r50[3] = 1 / e[3], r50;
}
function _2(r50, e) {
  var t = e[0], i = e[1], n = e[2], o = e[3], a = t * t + i * i + n * n + o * o;
  return a > 0 && (a = 1 / Math.sqrt(a)), r50[0] = t * a, r50[1] = i * a, r50[2] = n * a, r50[3] = o * a, r50;
}
function v2(r50, e) {
  return r50[0] * e[0] + r50[1] * e[1] + r50[2] * e[2] + r50[3] * e[3];
}
function w2(r50, e, t, i) {
  var n = t[0] * i[1] - t[1] * i[0], o = t[0] * i[2] - t[2] * i[0], a = t[0] * i[3] - t[3] * i[0], s3 = t[1] * i[2] - t[2] * i[1], l = t[1] * i[3] - t[3] * i[1], u = t[2] * i[3] - t[3] * i[2], c3 = e[0], p = e[1], h = e[2], f = e[3];
  return r50[0] = p * u - h * l + f * s3, r50[1] = -(c3 * u) + h * a - f * o, r50[2] = c3 * l - p * a + f * n, r50[3] = -(c3 * s3) + p * o - h * n, r50;
}
function S2(r50, e, t, i) {
  var n = e[0], o = e[1], a = e[2], s3 = e[3];
  return r50[0] = n + i * (t[0] - n), r50[1] = o + i * (t[1] - o), r50[2] = a + i * (t[2] - a), r50[3] = s3 + i * (t[3] - s3), r50;
}
function P2(r50, e) {
  e = e || 1;
  var t, i, n, o, a, s3;
  do
    t = Gt() * 2 - 1, i = Gt() * 2 - 1, a = t * t + i * i;
  while (a >= 1);
  do
    n = Gt() * 2 - 1, o = Gt() * 2 - 1, s3 = n * n + o * o;
  while (s3 >= 1);
  var l = Math.sqrt((1 - a) / s3);
  return r50[0] = e * t, r50[1] = e * i, r50[2] = e * n * l, r50[3] = e * o * l, r50;
}
function T2(r50, e, t) {
  var i = e[0], n = e[1], o = e[2], a = e[3];
  return r50[0] = t[0] * i + t[4] * n + t[8] * o + t[12] * a, r50[1] = t[1] * i + t[5] * n + t[9] * o + t[13] * a, r50[2] = t[2] * i + t[6] * n + t[10] * o + t[14] * a, r50[3] = t[3] * i + t[7] * n + t[11] * o + t[15] * a, r50;
}
function A2(r50, e, t) {
  var i = e[0], n = e[1], o = e[2], a = t[0], s3 = t[1], l = t[2], u = t[3], c3 = u * i + s3 * o - l * n, p = u * n + l * i - a * o, h = u * o + a * n - s3 * i, f = -a * i - s3 * n - l * o;
  return r50[0] = c3 * u + f * -a + p * -l - h * -s3, r50[1] = p * u + f * -s3 + h * -a - c3 * -l, r50[2] = h * u + f * -l + c3 * -s3 - p * -a, r50[3] = e[3], r50;
}
function M2(r50) {
  return r50[0] = 0, r50[1] = 0, r50[2] = 0, r50[3] = 0, r50;
}
function I2(r50) {
  return "vec4(" + r50[0] + ", " + r50[1] + ", " + r50[2] + ", " + r50[3] + ")";
}
function C2(r50, e) {
  return r50[0] === e[0] && r50[1] === e[1] && r50[2] === e[2] && r50[3] === e[3];
}
function E2(r50, e) {
  var t = r50[0], i = r50[1], n = r50[2], o = r50[3], a = e[0], s3 = e[1], l = e[2], u = e[3];
  return Math.abs(t - a) <= ne * Math.max(1, Math.abs(t), Math.abs(a)) && Math.abs(i - s3) <= ne * Math.max(1, Math.abs(i), Math.abs(s3)) && Math.abs(n - l) <= ne * Math.max(1, Math.abs(n), Math.abs(l)) && Math.abs(o - u) <= ne * Math.max(1, Math.abs(o), Math.abs(u));
}
var k2 = Td;
var L2 = Ad;
var D2 = Md;
var z2 = Id;
var F2 = Cd;
var R2 = Ed;
var B2 = kd;
var O2 = function() {
  var r50 = Pd();
  return function(e, t, i, n, o, a) {
    var s3, l;
    for (t || (t = 4), i || (i = 0), n ? l = Math.min(n * t + i, e.length) : l = e.length, s3 = i; s3 < l; s3 += t) r50[0] = e[s3], r50[1] = e[s3 + 1], r50[2] = e[s3 + 2], r50[3] = e[s3 + 3], o(r50, r50, a), e[s3] = r50[0], e[s3 + 1] = r50[1], e[s3 + 2] = r50[2], e[s3 + 3] = r50[3];
    return e;
  };
}();
var Zi = {};
r(Zi, { add: () => q22, angle: () => uP, ceil: () => j2, clone: () => V2, copy: () => N2, create: () => Ld, cross: () => tP, dist: () => xP, distance: () => Rd, div: () => gP, divide: () => Fd, dot: () => eP, equals: () => fP, exactEquals: () => hP, floor: () => Z2, forEach: () => vP, fromValues: () => U2, inverse: () => Y2, len: () => mP, length: () => Od, lerp: () => rP, max: () => $2, min: () => H2, mul: () => yP, multiply: () => zd, negate: () => J2, normalize: () => Q2, random: () => iP, rotate: () => lP, round: () => W2, scale: () => X2, scaleAndAdd: () => K2, set: () => G2, sqrDist: () => bP, sqrLen: () => _P, squaredDistance: () => Bd, squaredLength: () => Vd, str: () => pP, sub: () => dP, subtract: () => Dd, transformMat2: () => nP, transformMat2d: () => oP, transformMat3: () => aP, transformMat4: () => sP, zero: () => cP });
c();
function Ld() {
  var r50 = new ve(2);
  return ve != Float32Array && (r50[0] = 0, r50[1] = 0), r50;
}
function V2(r50) {
  var e = new ve(2);
  return e[0] = r50[0], e[1] = r50[1], e;
}
function U2(r50, e) {
  var t = new ve(2);
  return t[0] = r50, t[1] = e, t;
}
function N2(r50, e) {
  return r50[0] = e[0], r50[1] = e[1], r50;
}
function G2(r50, e, t) {
  return r50[0] = e, r50[1] = t, r50;
}
function q22(r50, e, t) {
  return r50[0] = e[0] + t[0], r50[1] = e[1] + t[1], r50;
}
function Dd(r50, e, t) {
  return r50[0] = e[0] - t[0], r50[1] = e[1] - t[1], r50;
}
function zd(r50, e, t) {
  return r50[0] = e[0] * t[0], r50[1] = e[1] * t[1], r50;
}
function Fd(r50, e, t) {
  return r50[0] = e[0] / t[0], r50[1] = e[1] / t[1], r50;
}
function j2(r50, e) {
  return r50[0] = Math.ceil(e[0]), r50[1] = Math.ceil(e[1]), r50;
}
function Z2(r50, e) {
  return r50[0] = Math.floor(e[0]), r50[1] = Math.floor(e[1]), r50;
}
function H2(r50, e, t) {
  return r50[0] = Math.min(e[0], t[0]), r50[1] = Math.min(e[1], t[1]), r50;
}
function $2(r50, e, t) {
  return r50[0] = Math.max(e[0], t[0]), r50[1] = Math.max(e[1], t[1]), r50;
}
function W2(r50, e) {
  return r50[0] = Math.round(e[0]), r50[1] = Math.round(e[1]), r50;
}
function X2(r50, e, t) {
  return r50[0] = e[0] * t, r50[1] = e[1] * t, r50;
}
function K2(r50, e, t, i) {
  return r50[0] = e[0] + t[0] * i, r50[1] = e[1] + t[1] * i, r50;
}
function Rd(r50, e) {
  var t = e[0] - r50[0], i = e[1] - r50[1];
  return Math.hypot(t, i);
}
function Bd(r50, e) {
  var t = e[0] - r50[0], i = e[1] - r50[1];
  return t * t + i * i;
}
function Od(r50) {
  var e = r50[0], t = r50[1];
  return Math.hypot(e, t);
}
function Vd(r50) {
  var e = r50[0], t = r50[1];
  return e * e + t * t;
}
function J2(r50, e) {
  return r50[0] = -e[0], r50[1] = -e[1], r50;
}
function Y2(r50, e) {
  return r50[0] = 1 / e[0], r50[1] = 1 / e[1], r50;
}
function Q2(r50, e) {
  var t = e[0], i = e[1], n = t * t + i * i;
  return n > 0 && (n = 1 / Math.sqrt(n)), r50[0] = e[0] * n, r50[1] = e[1] * n, r50;
}
function eP(r50, e) {
  return r50[0] * e[0] + r50[1] * e[1];
}
function tP(r50, e, t) {
  var i = e[0] * t[1] - e[1] * t[0];
  return r50[0] = r50[1] = 0, r50[2] = i, r50;
}
function rP(r50, e, t, i) {
  var n = e[0], o = e[1];
  return r50[0] = n + i * (t[0] - n), r50[1] = o + i * (t[1] - o), r50;
}
function iP(r50, e) {
  e = e || 1;
  var t = Gt() * 2 * Math.PI;
  return r50[0] = Math.cos(t) * e, r50[1] = Math.sin(t) * e, r50;
}
function nP(r50, e, t) {
  var i = e[0], n = e[1];
  return r50[0] = t[0] * i + t[2] * n, r50[1] = t[1] * i + t[3] * n, r50;
}
function oP(r50, e, t) {
  var i = e[0], n = e[1];
  return r50[0] = t[0] * i + t[2] * n + t[4], r50[1] = t[1] * i + t[3] * n + t[5], r50;
}
function aP(r50, e, t) {
  var i = e[0], n = e[1];
  return r50[0] = t[0] * i + t[3] * n + t[6], r50[1] = t[1] * i + t[4] * n + t[7], r50;
}
function sP(r50, e, t) {
  var i = e[0], n = e[1];
  return r50[0] = t[0] * i + t[4] * n + t[12], r50[1] = t[1] * i + t[5] * n + t[13], r50;
}
function lP(r50, e, t, i) {
  var n = e[0] - t[0], o = e[1] - t[1], a = Math.sin(i), s3 = Math.cos(i);
  return r50[0] = n * s3 - o * a + t[0], r50[1] = n * a + o * s3 + t[1], r50;
}
function uP(r50, e) {
  var t = r50[0], i = r50[1], n = e[0], o = e[1], a = Math.sqrt(t * t + i * i) * Math.sqrt(n * n + o * o), s3 = a && (t * n + i * o) / a;
  return Math.acos(Math.min(Math.max(s3, -1), 1));
}
function cP(r50) {
  return r50[0] = 0, r50[1] = 0, r50;
}
function pP(r50) {
  return "vec2(" + r50[0] + ", " + r50[1] + ")";
}
function hP(r50, e) {
  return r50[0] === e[0] && r50[1] === e[1];
}
function fP(r50, e) {
  var t = r50[0], i = r50[1], n = e[0], o = e[1];
  return Math.abs(t - n) <= ne * Math.max(1, Math.abs(t), Math.abs(n)) && Math.abs(i - o) <= ne * Math.max(1, Math.abs(i), Math.abs(o));
}
var mP = Od;
var dP = Dd;
var yP = zd;
var gP = Fd;
var xP = Rd;
var bP = Bd;
var _P = Vd;
var vP = function() {
  var r50 = Ld();
  return function(e, t, i, n, o, a) {
    var s3, l;
    for (t || (t = 2), i || (i = 0), n ? l = Math.min(n * t + i, e.length) : l = e.length, s3 = i; s3 < l; s3 += t) r50[0] = e[s3], r50[1] = e[s3 + 1], o(r50, r50, a), e[s3] = r50[0], e[s3 + 1] = r50[1];
    return e;
  };
}();
var Ud = s(ye(), 1);
var Hs = class extends Ne {
  constructor(e) {
    super(e, id);
  }
  createBucket(e) {
    return new ni(e);
  }
  queryRadius(e) {
    let t = e;
    return oi("circle-radius", this, t) + oi("circle-stroke-width", this, t) + Ir(this.paint.get("circle-translate"));
  }
  queryIntersectsFeature(e, t, i, n, o, a, s3, l) {
    let u = Cr(e, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), a.angle, s3), c3 = this.paint.get("circle-radius").evaluate(t, i), p = this.paint.get("circle-stroke-width").evaluate(t, i), h = c3 + p, f = this.paint.get("circle-pitch-alignment") === "map", d = f ? u : wP(u, l), y = f ? h * s3 : h;
    for (let g of n) for (let x of g) {
      let v = f ? x : Nd(x, l), b = y, w = Ge.transformMat4([], [x.x, x.y, 0, 1], l);
      if (this.paint.get("circle-pitch-scale") === "viewport" && this.paint.get("circle-pitch-alignment") === "map" ? b *= w[3] / a.cameraToCenterDistance : this.paint.get("circle-pitch-scale") === "map" && this.paint.get("circle-pitch-alignment") === "viewport" && (b *= a.cameraToCenterDistance / w[3]), Km(d, v, b)) return true;
    }
    return false;
  }
};
function Nd(r50, e) {
  let t = Ge.transformMat4([], [r50.x, r50.y, 0, 1], e);
  return new Ud.default(t[0] / t[3], t[1] / t[3]);
}
function wP(r50, e) {
  return r50.map((t) => Nd(t, e));
}
c();
c();
var wo = class extends ni {
};
U("HeatmapBucket", wo, { omit: ["layers"] });
c();
var Gd;
var SP = () => Gd = Gd || new Le({ "heatmap-radius": new H(A.paint_heatmap["heatmap-radius"]), "heatmap-weight": new H(A.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new j(A.paint_heatmap["heatmap-intensity"]), "heatmap-color": new ei(A.paint_heatmap["heatmap-color"]), "heatmap-opacity": new j(A.paint_heatmap["heatmap-opacity"]) });
var qd = { get paint() {
  return SP();
} };
c();
c();
function Sp(r50, { width: e, height: t }, i, n) {
  if (!n) n = new Uint8Array(e * t * i);
  else if (n instanceof Uint8ClampedArray) n = new Uint8Array(n.buffer);
  else if (n.length !== e * t * i) throw new RangeError("mismatched image size. expected: ".concat(n.length, " but got: ").concat(e * t * i));
  return r50.width = e, r50.height = t, r50.data = n, r50;
}
function jd(r50, { width: e, height: t }, i) {
  if (e === r50.width && t === r50.height) return;
  let n = Sp({}, { width: e, height: t }, i);
  Pp(r50, n, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(r50.width, e), height: Math.min(r50.height, t) }, i), r50.width = e, r50.height = t, r50.data = n.data;
}
function Pp(r50, e, t, i, n, o) {
  if (n.width === 0 || n.height === 0) return e;
  if (n.width > r50.width || n.height > r50.height || t.x > r50.width - n.width || t.y > r50.height - n.height) throw new RangeError("out of range source coordinates for image copy");
  if (n.width > e.width || n.height > e.height || i.x > e.width - n.width || i.y > e.height - n.height) throw new RangeError("out of range destination coordinates for image copy");
  let a = r50.data, s3 = e.data;
  if (a === s3) throw new Error("srcData equals dstData, so image is already copied");
  for (let l = 0; l < n.height; l++) {
    let u = ((t.y + l) * r50.width + t.x) * o, c3 = ((i.y + l) * e.width + i.x) * o;
    for (let p = 0; p < n.width * o; p++) s3[c3 + p] = a[u + p];
  }
  return e;
}
var ai = class r35 {
  constructor(e, t) {
    Sp(this, e, 1, t);
  }
  resize(e) {
    jd(this, e, 1);
  }
  clone() {
    return new r35({ width: this.width, height: this.height }, new Uint8Array(this.data));
  }
  static copy(e, t, i, n, o) {
    Pp(e, t, i, n, o, 1);
  }
};
var we = class r36 {
  constructor(e, t) {
    Sp(this, e, 4, t);
  }
  resize(e) {
    jd(this, e, 4);
  }
  replace(e, t) {
    t ? this.data.set(e) : e instanceof Uint8ClampedArray ? this.data = new Uint8Array(e.buffer) : this.data = e;
  }
  clone() {
    return new r36({ width: this.width, height: this.height }, new Uint8Array(this.data));
  }
  static copy(e, t, i, n, o) {
    Pp(e, t, i, n, o, 4);
  }
};
U("AlphaImage", ai);
U("RGBAImage", we);
function $s(r50) {
  let e = {}, t = r50.resolution || 256, i = r50.clips ? r50.clips.length : 1, n = r50.image || new we({ width: t, height: i });
  if (!of(t)) throw new Error("width is not a power of 2 - ".concat(t));
  let o = (a, s3, l) => {
    e[r50.evaluationKey] = l;
    let u = r50.expression.evaluate(e);
    n.data[a + s3 + 0] = Math.floor(u.r * 255 / u.a), n.data[a + s3 + 1] = Math.floor(u.g * 255 / u.a), n.data[a + s3 + 2] = Math.floor(u.b * 255 / u.a), n.data[a + s3 + 3] = Math.floor(u.a * 255);
  };
  if (r50.clips) for (let a = 0, s3 = 0; a < i; ++a, s3 += t * 4) for (let l = 0, u = 0; l < t; l++, u += 4) {
    let c3 = l / (t - 1), { start: p, end: h } = r50.clips[a], f = p * (1 - c3) + h * c3;
    o(s3, u, f);
  }
  else for (let a = 0, s3 = 0; a < t; a++, s3 += 4) {
    let l = a / (t - 1);
    o(0, s3, l);
  }
  return n;
}
var Ws = class extends Ne {
  createBucket(e) {
    return new wo(e);
  }
  constructor(e) {
    super(e, qd), this._updateColorRamp();
  }
  _handleSpecialPaintPropertyUpdate(e) {
    e === "heatmap-color" && this._updateColorRamp();
  }
  _updateColorRamp() {
    let e = this._transitionablePaint._values["heatmap-color"].value.expression;
    this.colorRamp = $s({ expression: e, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
  }
  resize() {
    this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
  }
  queryRadius() {
    return 0;
  }
  queryIntersectsFeature() {
    return false;
  }
  hasOffscreenPass() {
    return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
  }
};
c();
c();
var Zd;
var PP = () => Zd = Zd || new Le({ "hillshade-illumination-direction": new j(A.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new j(A.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new j(A.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new j(A.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new j(A.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new j(A.paint_hillshade["hillshade-accent-color"]) });
var Hd = { get paint() {
  return PP();
} };
var Xs = class extends Ne {
  constructor(e) {
    super(e, Hd);
  }
  hasOffscreenPass() {
    return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
  }
};
c();
c();
c();
var TP = be([{ name: "a_pos", components: 2, type: "Int16" }], 4);
var { members: $d, size: yL, alignment: gL } = TP;
var Qd = s(Cp(), 1);
c();
c();
function Ep(r50, e, t, i, n) {
  Yd(r50, e, t || 0, i || r50.length - 1, n || NP);
}
function Yd(r50, e, t, i, n) {
  for (; i > t; ) {
    if (i - t > 600) {
      var o = i - t + 1, a = e - t + 1, s3 = Math.log(o), l = 0.5 * Math.exp(2 * s3 / 3), u = 0.5 * Math.sqrt(s3 * l * (o - l) / o) * (a - o / 2 < 0 ? -1 : 1), c3 = Math.max(t, Math.floor(e - a * l / o + u)), p = Math.min(i, Math.floor(e + (o - a) * l / o + u));
      Yd(r50, e, c3, p, n);
    }
    var h = r50[e], f = t, d = i;
    for (Ao(r50, t, e), n(r50[i], h) > 0 && Ao(r50, t, i); f < d; ) {
      for (Ao(r50, f, d), f++, d--; n(r50[f], h) < 0; ) f++;
      for (; n(r50[d], h) > 0; ) d--;
    }
    n(r50[t], h) === 0 ? Ao(r50, t, d) : (d++, Ao(r50, d, i)), d <= e && (t = d + 1), e <= d && (i = d - 1);
  }
}
function Ao(r50, e, t) {
  var i = r50[e];
  r50[e] = r50[t], r50[t] = i;
}
function NP(r50, e) {
  return r50 < e ? -1 : r50 > e ? 1 : 0;
}
function Mo(r50, e) {
  let t = r50.length;
  if (t <= 1) return [r50];
  let i = [], n, o;
  for (let a = 0; a < t; a++) {
    let s3 = uf(r50[a]);
    s3 !== 0 && (r50[a].area = Math.abs(s3), o === void 0 && (o = s3 < 0), o === s3 < 0 ? (n && i.push(n), n = [r50[a]]) : n.push(r50[a]));
  }
  if (n && i.push(n), e > 1) for (let a = 0; a < i.length; a++) i[a].length <= e || (Ep(i[a], e, 1, i[a].length - 1, GP), i[a] = i[a].slice(0, e));
  return i;
}
function GP(r50, e) {
  return e.area - r50.area;
}
c();
function $i(r50, e, t) {
  let i = t.patternDependencies, n = false;
  for (let o of e) {
    let a = o.paint.get("".concat(r50, "-pattern"));
    a.isConstant() || (n = true);
    let s3 = a.constantOr(null);
    s3 && (n = true, i[s3.to] = true, i[s3.from] = true);
  }
  return n;
}
function Wi(r50, e, t, i, n) {
  let o = n.patternDependencies;
  for (let a of e) {
    let l = a.paint.get("".concat(r50, "-pattern")).value;
    if (l.kind !== "constant") {
      let u = l.evaluate({ zoom: i - 1 }, t, {}, n.availableImages), c3 = l.evaluate({ zoom: i }, t, {}, n.availableImages), p = l.evaluate({ zoom: i + 1 }, t, {}, n.availableImages);
      u = u && u.name ? u.name : u, c3 = c3 && c3.name ? c3.name : c3, p = p && p.name ? p.name : p, o[u] = true, o[c3] = true, o[p] = true, t.patterns[a.id] = { min: u, mid: c3, max: p };
    }
  }
  return t;
}
var qP = 500;
var Io = class {
  constructor(e) {
    this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((t) => t.id), this.index = e.index, this.hasPattern = false, this.patternFeatures = [], this.layoutVertexArray = new Cs(), this.indexArray = new tt(), this.indexArray2 = new Tr(), this.programConfigurations = new ft(e.layers, e.zoom), this.segments = new fe(), this.segments2 = new fe(), this.stateDependentLayerIds = this.layers.filter((t) => t.isStateDependent()).map((t) => t.id);
  }
  populate(e, t, i) {
    this.hasPattern = $i("fill", this.layers, t);
    let n = this.layers[0].layout.get("fill-sort-key"), o = !n.isConstant(), a = [];
    for (let { feature: s3, id: l, index: u, sourceLayerIndex: c3 } of e) {
      let p = this.layers[0]._featureFilter.needGeometry, h = dt(s3, p);
      if (!this.layers[0]._featureFilter.filter(new de(this.zoom), h, i)) continue;
      let f = o ? n.evaluate(h, {}, i, t.availableImages) : void 0, d = { id: l, properties: s3.properties, type: s3.type, sourceLayerIndex: c3, index: u, geometry: p ? h.geometry : mt(s3), patterns: {}, sortKey: f };
      a.push(d);
    }
    o && a.sort((s3, l) => s3.sortKey - l.sortKey);
    for (let s3 of a) {
      let { geometry: l, index: u, sourceLayerIndex: c3 } = s3;
      if (this.hasPattern) {
        let h = Wi("fill", this.layers, s3, this.zoom, t);
        this.patternFeatures.push(h);
      } else this.addFeature(s3, l, u, i, {});
      let p = e[u].feature;
      t.featureIndex.insert(p, l, u, c3, this.index);
    }
  }
  update(e, t, i) {
    this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, t, this.stateDependentLayers, i);
  }
  addFeatures(e, t, i) {
    for (let n of this.patternFeatures) this.addFeature(n, n.geometry, n.index, t, i);
  }
  isEmpty() {
    return this.layoutVertexArray.length === 0;
  }
  uploadPending() {
    return !this.uploaded || this.programConfigurations.needsUpload;
  }
  upload(e) {
    this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, $d), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.indexBuffer2 = e.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(e), this.uploaded = true;
  }
  destroy() {
    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
  }
  addFeature(e, t, i, n, o) {
    for (let a of Mo(t, qP)) {
      let s3 = 0;
      for (let f of a) s3 += f.length;
      let l = this.segments.prepareSegment(s3, this.layoutVertexArray, this.indexArray), u = l.vertexLength, c3 = [], p = [];
      for (let f of a) {
        if (f.length === 0) continue;
        f !== a[0] && p.push(c3.length / 2);
        let d = this.segments2.prepareSegment(f.length, this.layoutVertexArray, this.indexArray2), y = d.vertexLength;
        this.layoutVertexArray.emplaceBack(f[0].x, f[0].y), this.indexArray2.emplaceBack(y + f.length - 1, y), c3.push(f[0].x), c3.push(f[0].y);
        for (let g = 1; g < f.length; g++) this.layoutVertexArray.emplaceBack(f[g].x, f[g].y), this.indexArray2.emplaceBack(y + g - 1, y + g), c3.push(f[g].x), c3.push(f[g].y);
        d.vertexLength += f.length, d.primitiveLength += f.length;
      }
      let h = (0, Qd.default)(c3, p);
      for (let f = 0; f < h.length; f += 3) this.indexArray.emplaceBack(u + h[f], u + h[f + 1], u + h[f + 2]);
      l.vertexLength += s3, l.primitiveLength += h.length / 3;
    }
    this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, i, o, n);
  }
};
U("FillBucket", Io, { omit: ["layers", "patternFeatures"] });
c();
var ey;
var jP = () => ey = ey || new Le({ "fill-sort-key": new H(A.layout_fill["fill-sort-key"]) });
var ty;
var ZP = () => ty = ty || new Le({ "fill-antialias": new j(A.paint_fill["fill-antialias"]), "fill-opacity": new H(A.paint_fill["fill-opacity"]), "fill-color": new H(A.paint_fill["fill-color"]), "fill-outline-color": new H(A.paint_fill["fill-outline-color"]), "fill-translate": new j(A.paint_fill["fill-translate"]), "fill-translate-anchor": new j(A.paint_fill["fill-translate-anchor"]), "fill-pattern": new ir(A.paint_fill["fill-pattern"]) });
var ry = { get paint() {
  return ZP();
}, get layout() {
  return jP();
} };
var el = class extends Ne {
  constructor(e) {
    super(e, ry);
  }
  recalculate(e, t) {
    super.recalculate(e, t);
    let i = this.paint._values["fill-outline-color"];
    i.value.kind === "constant" && i.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
  }
  createBucket(e) {
    return new Io(e);
  }
  queryRadius() {
    return Ir(this.paint.get("fill-translate"));
  }
  queryIntersectsFeature(e, t, i, n, o, a, s3) {
    let l = Cr(e, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), a.angle, s3);
    return js(l, n);
  }
  isTileClipped() {
    return true;
  }
};
c();
c();
c();
var HP = be([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4);
var iy = be([{ name: "a_centroid", components: 2, type: "Int16" }], 4);
var { members: ny, size: sD, alignment: lD } = HP;
var cy = s(Cp(), 1);
var py = s(Co(), 1);
var nT = py.default.VectorTileFeature.types;
var oT = 500;
var Dp = Math.pow(2, 13);
function Eo(r50, e, t, i, n, o, a, s3) {
  r50.emplaceBack(e, t, Math.floor(i * Dp) * 2 + a, n * Dp * 2, o * Dp * 2, Math.round(s3));
}
var ko = class {
  constructor(e) {
    this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((t) => t.id), this.index = e.index, this.hasPattern = false, this.layoutVertexArray = new Es(), this.centroidVertexArray = new Pr(), this.indexArray = new tt(), this.programConfigurations = new ft(e.layers, e.zoom), this.segments = new fe(), this.stateDependentLayerIds = this.layers.filter((t) => t.isStateDependent()).map((t) => t.id);
  }
  populate(e, t, i) {
    this.features = [], this.hasPattern = $i("fill-extrusion", this.layers, t);
    for (let { feature: n, id: o, index: a, sourceLayerIndex: s3 } of e) {
      let l = this.layers[0]._featureFilter.needGeometry, u = dt(n, l);
      if (!this.layers[0]._featureFilter.filter(new de(this.zoom), u, i)) continue;
      let c3 = { id: o, sourceLayerIndex: s3, index: a, geometry: l ? u.geometry : mt(n), properties: n.properties, type: n.type, patterns: {} };
      this.hasPattern ? this.features.push(Wi("fill-extrusion", this.layers, c3, this.zoom, t)) : this.addFeature(c3, c3.geometry, a, i, {}), t.featureIndex.insert(n, c3.geometry, a, s3, this.index, true);
    }
  }
  addFeatures(e, t, i) {
    for (let n of this.features) {
      let { geometry: o } = n;
      this.addFeature(n, o, n.index, t, i);
    }
  }
  update(e, t, i) {
    this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, t, this.stateDependentLayers, i);
  }
  isEmpty() {
    return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0;
  }
  uploadPending() {
    return !this.uploaded || this.programConfigurations.needsUpload;
  }
  upload(e) {
    this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, ny), this.centroidVertexBuffer = e.createVertexBuffer(this.centroidVertexArray, iy.members, true), this.indexBuffer = e.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e), this.uploaded = true;
  }
  destroy() {
    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
  }
  addFeature(e, t, i, n, o) {
    let a = { x: 0, y: 0, vertexCount: 0 };
    for (let s3 of Mo(t, oT)) {
      let l = 0;
      for (let d of s3) l += d.length;
      let u = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray);
      for (let d of s3) {
        if (d.length === 0 || sT(d)) continue;
        let y = 0;
        for (let g = 0; g < d.length; g++) {
          let x = d[g];
          if (g >= 1) {
            let v = d[g - 1];
            if (!aT(x, v)) {
              u.vertexLength + 4 > fe.MAX_VERTEX_ARRAY_LENGTH && (u = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
              let b = x.sub(v)._perp()._unit(), w = v.dist(x);
              y + w > 32768 && (y = 0), Eo(this.layoutVertexArray, x.x, x.y, b.x, b.y, 0, 0, y), Eo(this.layoutVertexArray, x.x, x.y, b.x, b.y, 0, 1, y), a.x += 2 * x.x, a.y += 2 * x.y, a.vertexCount += 2, y += w, Eo(this.layoutVertexArray, v.x, v.y, b.x, b.y, 0, 0, y), Eo(this.layoutVertexArray, v.x, v.y, b.x, b.y, 0, 1, y), a.x += 2 * v.x, a.y += 2 * v.y, a.vertexCount += 2;
              let S = u.vertexLength;
              this.indexArray.emplaceBack(S, S + 2, S + 1), this.indexArray.emplaceBack(S + 1, S + 2, S + 3), u.vertexLength += 4, u.primitiveLength += 2;
            }
          }
        }
      }
      if (u.vertexLength + l > fe.MAX_VERTEX_ARRAY_LENGTH && (u = this.segments.prepareSegment(l, this.layoutVertexArray, this.indexArray)), nT[e.type] !== "Polygon") continue;
      let c3 = [], p = [], h = u.vertexLength;
      for (let d of s3) if (d.length !== 0) {
        d !== s3[0] && p.push(c3.length / 2);
        for (let y = 0; y < d.length; y++) {
          let g = d[y];
          Eo(this.layoutVertexArray, g.x, g.y, 0, 0, 1, 1, 0), a.x += g.x, a.y += g.y, a.vertexCount += 1, c3.push(g.x), c3.push(g.y);
        }
      }
      let f = (0, cy.default)(c3, p);
      for (let d = 0; d < f.length; d += 3) this.indexArray.emplaceBack(h + f[d], h + f[d + 2], h + f[d + 1]);
      u.primitiveLength += f.length / 3, u.vertexLength += l;
    }
    for (let s3 = 0; s3 < a.vertexCount; s3++) this.centroidVertexArray.emplaceBack(Math.floor(a.x / a.vertexCount), Math.floor(a.y / a.vertexCount));
    this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, i, o, n);
  }
};
U("FillExtrusionBucket", ko, { omit: ["layers", "features"] });
function aT(r50, e) {
  return r50.x === e.x && (r50.x < 0 || r50.x > 8192) || r50.y === e.y && (r50.y < 0 || r50.y > 8192);
}
function sT(r50) {
  return r50.every((e) => e.x < 0) || r50.every((e) => e.x > 8192) || r50.every((e) => e.y < 0) || r50.every((e) => e.y > 8192);
}
c();
var hy;
var lT = () => hy = hy || new Le({ "fill-extrusion-opacity": new j(A["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new H(A["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new j(A["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new j(A["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new ir(A["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new H(A["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new H(A["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new j(A["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) });
var fy = { get paint() {
  return lT();
} };
var rl = s(ye(), 1);
var il = class extends Ne {
  constructor(e) {
    super(e, fy);
  }
  createBucket(e) {
    return new ko(e);
  }
  queryRadius() {
    return Ir(this.paint.get("fill-extrusion-translate"));
  }
  is3D() {
    return true;
  }
  queryIntersectsFeature(e, t, i, n, o, a, s3, l) {
    let u = Cr(e, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), a.angle, s3), c3 = this.paint.get("fill-extrusion-height").evaluate(t, i), p = this.paint.get("fill-extrusion-base").evaluate(t, i), h = pT(u, l, a, 0), f = cT(n, p, c3, l), d = f[0], y = f[1];
    return uT(d, y, h);
  }
};
function Lo(r50, e) {
  return r50.x * e.x + r50.y * e.y;
}
function my(r50, e) {
  if (r50.length === 1) {
    let t = 0, i = e[t++], n;
    for (; !n || i.equals(n); ) if (n = e[t++], !n) return 1 / 0;
    for (; t < e.length; t++) {
      let o = e[t], a = r50[0], s3 = n.sub(i), l = o.sub(i), u = a.sub(i), c3 = Lo(s3, s3), p = Lo(s3, l), h = Lo(l, l), f = Lo(u, s3), d = Lo(u, l), y = c3 * h - p * p, g = (h * f - p * d) / y, x = (c3 * d - p * f) / y, v = 1 - g - x, b = i.z * v + n.z * g + o.z * x;
      if (isFinite(b)) return b;
    }
    return 1 / 0;
  } else {
    let t = 1 / 0;
    for (let i of e) t = Math.min(t, i.z);
    return t;
  }
}
function uT(r50, e, t) {
  let i = 1 / 0;
  js(t, e) && (i = my(t, e[0]));
  for (let n = 0; n < e.length; n++) {
    let o = e[n], a = r50[n];
    for (let s3 = 0; s3 < o.length - 1; s3++) {
      let l = o[s3], u = o[s3 + 1], c3 = a[s3], p = a[s3 + 1], h = [l, u, p, c3, l];
      qs(t, h) && (i = Math.min(i, my(t, h)));
    }
  }
  return i === 1 / 0 ? false : i;
}
function cT(r50, e, t, i) {
  let n = [], o = [], a = i[8] * e, s3 = i[9] * e, l = i[10] * e, u = i[11] * e, c3 = i[8] * t, p = i[9] * t, h = i[10] * t, f = i[11] * t;
  for (let d of r50) {
    let y = [], g = [];
    for (let x of d) {
      let v = x.x, b = x.y, w = i[0] * v + i[4] * b + i[12], S = i[1] * v + i[5] * b + i[13], P = i[2] * v + i[6] * b + i[14], k = i[3] * v + i[7] * b + i[15], I = w + a, C = S + s3, M = P + l, F = k + u, D = w + c3, E = S + p, T = P + h, N = k + f, X = new rl.default(I / F, C / F);
      X.z = M / F, y.push(X);
      let ie = new rl.default(D / N, E / N);
      ie.z = T / N, g.push(ie);
    }
    n.push(y), o.push(g);
  }
  return [n, o];
}
function pT(r50, e, t, i) {
  let n = [];
  for (let o of r50) {
    let a = [o.x, o.y, i, 1];
    Ge.transformMat4(a, a, e), n.push(new rl.default(a[0] / a[3], a[1] / a[3]));
  }
  return n;
}
c();
c();
c();
var hT = be([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4);
var { members: dy, size: YD, alignment: QD } = hT;
c();
var fT = be([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]);
var { members: yy, size: iz, alignment: nz } = fT;
var by = s(Co(), 1);
var mT = by.default.VectorTileFeature.types;
var gy = 63;
var dT = Math.cos(75 / 2 * (Math.PI / 180));
var yT = 15;
var gT = 20;
var xT = 15;
var _y = 1 / 2;
var xy = Math.pow(2, xT - 1) / _y;
var Do = class {
  constructor(e) {
    this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((t) => t.id), this.index = e.index, this.hasPattern = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((t) => {
      this.gradients[t.id] = {};
    }), this.layoutVertexArray = new ks(), this.layoutVertexArray2 = new Ls(), this.indexArray = new tt(), this.programConfigurations = new ft(e.layers, e.zoom), this.segments = new fe(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((t) => t.isStateDependent()).map((t) => t.id);
  }
  populate(e, t, i) {
    this.hasPattern = $i("line", this.layers, t);
    let n = this.layers[0].layout.get("line-sort-key"), o = !n.isConstant(), a = [];
    for (let { feature: s3, id: l, index: u, sourceLayerIndex: c3 } of e) {
      let p = this.layers[0]._featureFilter.needGeometry, h = dt(s3, p);
      if (!this.layers[0]._featureFilter.filter(new de(this.zoom), h, i)) continue;
      let f = o ? n.evaluate(h, {}, i) : void 0, d = { id: l, properties: s3.properties, type: s3.type, sourceLayerIndex: c3, index: u, geometry: p ? h.geometry : mt(s3), patterns: {}, sortKey: f };
      a.push(d);
    }
    o && a.sort((s3, l) => s3.sortKey - l.sortKey);
    for (let s3 of a) {
      let { geometry: l, index: u, sourceLayerIndex: c3 } = s3;
      if (this.hasPattern) {
        let h = Wi("line", this.layers, s3, this.zoom, t);
        this.patternFeatures.push(h);
      } else this.addFeature(s3, l, u, i, {});
      let p = e[u].feature;
      t.featureIndex.insert(p, l, u, c3, this.index);
    }
  }
  update(e, t, i) {
    this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, t, this.stateDependentLayers, i);
  }
  addFeatures(e, t, i) {
    for (let n of this.patternFeatures) this.addFeature(n, n.geometry, n.index, t, i);
  }
  isEmpty() {
    return this.layoutVertexArray.length === 0;
  }
  uploadPending() {
    return !this.uploaded || this.programConfigurations.needsUpload;
  }
  upload(e) {
    this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = e.createVertexBuffer(this.layoutVertexArray2, yy)), this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, dy), this.indexBuffer = e.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e), this.uploaded = true;
  }
  destroy() {
    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
  }
  lineFeatureClips(e) {
    if (e.properties && Object.prototype.hasOwnProperty.call(e.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(e.properties, "mapbox_clip_end")) {
      let t = +e.properties.mapbox_clip_start, i = +e.properties.mapbox_clip_end;
      return { start: t, end: i };
    }
  }
  addFeature(e, t, i, n, o) {
    let a = this.layers[0].layout, s3 = a.get("line-join").evaluate(e, {}), l = a.get("line-cap"), u = a.get("line-miter-limit"), c3 = a.get("line-round-limit");
    this.lineClips = this.lineFeatureClips(e);
    for (let p of t) this.addLine(p, e, s3, l, u, c3);
    this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, i, o, n);
  }
  addLine(e, t, i, n, o, a) {
    if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineClips) {
      this.lineClipsArray.push(this.lineClips);
      for (let x = 0; x < e.length - 1; x++) this.totalDistance += e[x].dist(e[x + 1]);
      this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
    }
    let s3 = mT[t.type] === "Polygon", l = e.length;
    for (; l >= 2 && e[l - 1].equals(e[l - 2]); ) l--;
    let u = 0;
    for (; u < l - 1 && e[u].equals(e[u + 1]); ) u++;
    if (l < (s3 ? 3 : 2)) return;
    i === "bevel" && (o = 1.05);
    let c3 = this.overscaling <= 16 ? yT * 8192 / (512 * this.overscaling) : 0, p = this.segments.prepareSegment(l * 10, this.layoutVertexArray, this.indexArray), h, f, d, y, g;
    this.e1 = this.e2 = -1, s3 && (h = e[l - 2], g = e[u].sub(h)._unit()._perp());
    for (let x = u; x < l; x++) {
      if (d = x === l - 1 ? s3 ? e[u + 1] : void 0 : e[x + 1], d && e[x].equals(d)) continue;
      g && (y = g), h && (f = h), h = e[x], g = d ? d.sub(h)._unit()._perp() : y, y = y || g;
      let v = y.add(g);
      (v.x !== 0 || v.y !== 0) && v._unit();
      let b = y.x * g.x + y.y * g.y, w = v.x * g.x + v.y * g.y, S = w !== 0 ? 1 / w : 1 / 0, P = 2 * Math.sqrt(2 - 2 * w), k = w < dT && f && d, I = y.x * g.y - y.y * g.x > 0;
      if (k && x > u) {
        let F = h.dist(f);
        if (F > 2 * c3) {
          let D = h.sub(h.sub(f)._mult(c3 / F)._round());
          this.updateDistance(f, D), this.addCurrentVertex(D, y, 0, 0, p), f = D;
        }
      }
      let C = f && d, M = C ? i : s3 ? "butt" : n;
      if (C && M === "round" && (S < a ? M = "miter" : S <= 2 && (M = "fakeround")), M === "miter" && S > o && (M = "bevel"), M === "bevel" && (S > 2 && (M = "flipbevel"), S < o && (M = "miter")), f && this.updateDistance(f, h), M === "miter") v._mult(S), this.addCurrentVertex(h, v, 0, 0, p);
      else if (M === "flipbevel") {
        if (S > 100) v = g.mult(-1);
        else {
          let F = S * y.add(g).mag() / y.sub(g).mag();
          v._perp()._mult(F * (I ? -1 : 1));
        }
        this.addCurrentVertex(h, v, 0, 0, p), this.addCurrentVertex(h, v.mult(-1), 0, 0, p);
      } else if (M === "bevel" || M === "fakeround") {
        let F = -Math.sqrt(S * S - 1), D = I ? F : 0, E = I ? 0 : F;
        if (f && this.addCurrentVertex(h, y, D, E, p), M === "fakeround") {
          let T = Math.round(P * 180 / Math.PI / gT);
          for (let N = 1; N < T; N++) {
            let X = N / T;
            if (X !== 0.5) {
              let K = X - 0.5, $ = 1.0904 + b * (-3.2452 + b * (3.55645 - b * 1.43519)), Ke = 0.848013 + b * (-1.06021 + b * 0.215638);
              X = X + X * K * (X - 1) * ($ * K * K + Ke);
            }
            let ie = g.sub(y)._mult(X)._add(y)._unit()._mult(I ? -1 : 1);
            this.addHalfVertex(h, ie.x, ie.y, false, I, 0, p);
          }
        }
        d && this.addCurrentVertex(h, g, -D, -E, p);
      } else if (M === "butt") this.addCurrentVertex(h, v, 0, 0, p);
      else if (M === "square") {
        let F = f ? 1 : -1;
        this.addCurrentVertex(h, v, F, F, p);
      } else M === "round" && (f && (this.addCurrentVertex(h, y, 0, 0, p), this.addCurrentVertex(h, y, 1, 1, p, true)), d && (this.addCurrentVertex(h, g, -1, -1, p, true), this.addCurrentVertex(h, g, 0, 0, p)));
      if (k && x < l - 1) {
        let F = h.dist(d);
        if (F > 2 * c3) {
          let D = h.add(d.sub(h)._mult(c3 / F)._round());
          this.updateDistance(h, D), this.addCurrentVertex(D, g, 0, 0, p), h = D;
        }
      }
    }
  }
  addCurrentVertex(e, t, i, n, o, a = false) {
    let s3 = t.x + t.y * i, l = t.y - t.x * i, u = -t.x + t.y * n, c3 = -t.y - t.x * n;
    this.addHalfVertex(e, s3, l, a, false, i, o), this.addHalfVertex(e, u, c3, a, true, -n, o), this.distance > xy / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(e, t, i, n, o, a));
  }
  addHalfVertex({ x: e, y: t }, i, n, o, a, s3, l) {
    let c3 = (this.lineClips ? this.scaledDistance * (xy - 1) : this.scaledDistance) * _y;
    if (this.layoutVertexArray.emplaceBack((e << 1) + (o ? 1 : 0), (t << 1) + (a ? 1 : 0), Math.round(gy * i) + 128, Math.round(gy * n) + 128, (s3 === 0 ? 0 : s3 < 0 ? -1 : 1) + 1 | (c3 & 63) << 2, c3 >> 6), this.lineClips) {
      let h = this.scaledDistance - this.lineClips.start, f = this.lineClips.end - this.lineClips.start, d = h / f;
      this.layoutVertexArray2.emplaceBack(d, this.lineClipsArray.length);
    }
    let p = l.vertexLength++;
    this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, p), l.primitiveLength++), a ? this.e2 = p : this.e1 = p;
  }
  updateScaledDistance() {
    this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
  }
  updateDistance(e, t) {
    this.distance += e.dist(t), this.updateScaledDistance();
  }
};
U("LineBucket", Do, { omit: ["layers", "patternFeatures"] });
c();
var vy;
var bT = () => vy = vy || new Le({ "line-cap": new j(A.layout_line["line-cap"]), "line-join": new H(A.layout_line["line-join"]), "line-miter-limit": new j(A.layout_line["line-miter-limit"]), "line-round-limit": new j(A.layout_line["line-round-limit"]), "line-sort-key": new H(A.layout_line["line-sort-key"]) });
var wy;
var _T = () => wy = wy || new Le({ "line-opacity": new H(A.paint_line["line-opacity"]), "line-color": new H(A.paint_line["line-color"]), "line-translate": new j(A.paint_line["line-translate"]), "line-translate-anchor": new j(A.paint_line["line-translate-anchor"]), "line-width": new H(A.paint_line["line-width"]), "line-gap-width": new H(A.paint_line["line-gap-width"]), "line-offset": new H(A.paint_line["line-offset"]), "line-blur": new H(A.paint_line["line-blur"]), "line-dasharray": new Qr(A.paint_line["line-dasharray"]), "line-pattern": new ir(A.paint_line["line-pattern"]), "line-gradient": new ei(A.paint_line["line-gradient"]) });
var zp = { get paint() {
  return _T();
}, get layout() {
  return bT();
} };
var Fp = class extends H {
  possiblyEvaluate(e, t) {
    return t = new de(Math.floor(t.zoom), { now: t.now, fadeDuration: t.fadeDuration, zoomHistory: t.zoomHistory, transition: t.transition }), super.possiblyEvaluate(e, t);
  }
  evaluate(e, t, i, n) {
    return t = O({}, t, { zoom: Math.floor(t.zoom) }), super.evaluate(e, t, i, n);
  }
};
var nl;
var ol = class extends Ne {
  constructor(e) {
    super(e, zp), this.gradientVersion = 0, nl || (nl = new Fp(zp.paint.properties["line-width"].specification), nl.useIntegerZoom = true);
  }
  _handleSpecialPaintPropertyUpdate(e) {
    if (e === "line-gradient") {
      let t = this.gradientExpression();
      Jr(t) ? this.stepInterpolant = t._styleExpression.expression instanceof Mi : this.stepInterpolant = false, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
    }
  }
  gradientExpression() {
    return this._transitionablePaint._values["line-gradient"].value.expression;
  }
  recalculate(e, t) {
    super.recalculate(e, t), this.paint._values["line-floorwidth"] = nl.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, e);
  }
  createBucket(e) {
    return new Do(e);
  }
  queryRadius(e) {
    let t = e, i = Sy(oi("line-width", this, t), oi("line-gap-width", this, t)), n = oi("line-offset", this, t);
    return i / 2 + Math.abs(n) + Ir(this.paint.get("line-translate"));
  }
  queryIntersectsFeature(e, t, i, n, o, a, s3) {
    let l = Cr(e, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), a.angle, s3), u = s3 / 2 * Sy(this.paint.get("line-width").evaluate(t, i), this.paint.get("line-gap-width").evaluate(t, i)), c3 = this.paint.get("line-offset").evaluate(t, i);
    return c3 && (n = ed(n, c3 * s3)), Jm(l, n, u);
  }
  isTileClipped() {
    return true;
  }
};
function Sy(r50, e) {
  return e > 0 ? e + 2 * r50 : r50;
}
c();
c();
c();
var Py = be([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4);
var Ty = be([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
var Zz = be([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
var Ay = be([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }]);
var Hz = be([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
var Rp = be([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4);
var My = be([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
var $z = be([{ name: "triangle", components: 3, type: "Uint16" }]);
var Wz = be([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]);
var Xz = be([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Uint16", name: "textAnchorOffsetStartIndex" }, { type: "Uint16", name: "textAnchorOffsetEndIndex" }]);
var Kz = be([{ type: "Float32", name: "offsetX" }]);
var Jz = be([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]);
var Yz = be([{ type: "Uint16", name: "textAnchor" }, { type: "Float32", components: 2, name: "textOffset" }]);
var Ro = s(ye(), 1);
c();
function vT(r50, e, t) {
  let i = e.layout.get("text-transform").evaluate(t, {});
  return i === "uppercase" ? r50 = r50.toLocaleUpperCase() : i === "lowercase" && (r50 = r50.toLocaleLowerCase()), rr.applyArabicShaping && (r50 = rr.applyArabicShaping(r50)), r50;
}
function Iy(r50, e, t) {
  return r50.sections.forEach((i) => {
    i.text = vT(i.text, e, t);
  }), r50;
}
c();
function Cy(r50) {
  let e = {}, t = {}, i = [], n = 0;
  function o(u) {
    i.push(r50[u]), n++;
  }
  function a(u, c3, p) {
    let h = t[u];
    return delete t[u], t[c3] = h, i[h].geometry[0].pop(), i[h].geometry[0] = i[h].geometry[0].concat(p[0]), h;
  }
  function s3(u, c3, p) {
    let h = e[c3];
    return delete e[c3], e[u] = h, i[h].geometry[0].shift(), i[h].geometry[0] = p[0].concat(i[h].geometry[0]), h;
  }
  function l(u, c3, p) {
    let h = p ? c3[0][c3[0].length - 1] : c3[0][0];
    return "".concat(u, ":").concat(h.x, ":").concat(h.y);
  }
  for (let u = 0; u < r50.length; u++) {
    let c3 = r50[u], p = c3.geometry, h = c3.text ? c3.text.toString() : null;
    if (!h) {
      o(u);
      continue;
    }
    let f = l(h, p), d = l(h, p, true);
    if (f in t && d in e && t[f] !== e[d]) {
      let y = s3(f, d, p), g = a(f, d, i[y].geometry);
      delete e[f], delete t[d], t[l(h, i[g].geometry, true)] = g, i[y].geometry = null;
    } else f in t ? a(f, d, p) : d in e ? s3(f, d, p) : (o(u), e[f] = n - 1, t[d] = n - 1);
  }
  return i.filter((u) => u.geometry);
}
c();
c();
var Ey = { "!": "", "#": "", $: "", "%": "", "&": "", "(": "", ")": "", "*": "", "+": "", ",": "", "-": "", ".": "", "/": "", ":": "", ";": "", "<": "", "=": "", ">": "", "?": "", "@": "", "[": "", "\\": "", "]": "", "^": "", _: "", "`": "", "{": "", "|": "", "}": "", "~": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "" };
c();
var Er = 24;
c();
var Oy = s(Vp(), 1);
var By = 3;
function VT(r50, e, t) {
  r50 === 1 && t.readMessage(UT, e);
}
function UT(r50, e, t) {
  if (r50 === 3) {
    let { id: i, bitmap: n, width: o, height: a, left: s3, top: l, advance: u } = t.readMessage(NT, {});
    e.push({ id: i, bitmap: new ai({ width: o + 2 * By, height: a + 2 * By }, n), metrics: { width: o, height: a, left: s3, top: l, advance: u } });
  }
}
function NT(r50, e, t) {
  r50 === 1 ? e.id = t.readVarint() : r50 === 2 ? e.bitmap = t.readBytes() : r50 === 3 ? e.width = t.readVarint() : r50 === 4 ? e.height = t.readVarint() : r50 === 5 ? e.left = t.readSVarint() : r50 === 6 ? e.top = t.readSVarint() : r50 === 7 && (e.advance = t.readVarint());
}
function Vy(r50) {
  return new Oy.default(r50).readFields(VT, []);
}
c();
c();
function zo(r50) {
  let e = 0, t = 0;
  for (let s3 of r50) e += s3.w * s3.h, t = Math.max(t, s3.w);
  r50.sort((s3, l) => l.h - s3.h);
  let n = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e / 0.95)), t), h: 1 / 0 }], o = 0, a = 0;
  for (let s3 of r50) for (let l = n.length - 1; l >= 0; l--) {
    let u = n[l];
    if (!(s3.w > u.w || s3.h > u.h)) {
      if (s3.x = u.x, s3.y = u.y, a = Math.max(a, s3.y + s3.h), o = Math.max(o, s3.x + s3.w), s3.w === u.w && s3.h === u.h) {
        let c3 = n.pop();
        l < n.length && (n[l] = c3);
      } else s3.h === u.h ? (u.x += s3.w, u.w -= s3.w) : s3.w === u.w ? (u.y += s3.h, u.h -= s3.h) : (n.push({ x: u.x + s3.w, y: u.y, w: u.w - s3.w, h: s3.h }), u.y += s3.h, u.h -= s3.h);
      break;
    }
  }
  return { w: o, h: a, fill: e / (o * a) || 0 };
}
var gt = 1;
var Yi = class {
  constructor(e, { pixelRatio: t, version: i, stretchX: n, stretchY: o, content: a }) {
    this.paddedRect = e, this.pixelRatio = t, this.stretchX = n, this.stretchY = o, this.content = a, this.version = i;
  }
  get tl() {
    return [this.paddedRect.x + gt, this.paddedRect.y + gt];
  }
  get br() {
    return [this.paddedRect.x + this.paddedRect.w - gt, this.paddedRect.y + this.paddedRect.h - gt];
  }
  get tlbr() {
    return this.tl.concat(this.br);
  }
  get displaySize() {
    return [(this.paddedRect.w - gt * 2) / this.pixelRatio, (this.paddedRect.h - gt * 2) / this.pixelRatio];
  }
};
var Up = class {
  constructor(e, t) {
    let i = {}, n = {};
    this.haveRenderCallbacks = [];
    let o = [];
    this.addImages(e, i, o), this.addImages(t, n, o);
    let { w: a, h: s3 } = zo(o), l = new we({ width: a || 1, height: s3 || 1 });
    for (let u in e) {
      let c3 = e[u], p = i[u].paddedRect;
      we.copy(c3.data, l, { x: 0, y: 0 }, { x: p.x + gt, y: p.y + gt }, c3.data);
    }
    for (let u in t) {
      let c3 = t[u], p = n[u].paddedRect, h = p.x + gt, f = p.y + gt, d = c3.data.width, y = c3.data.height;
      we.copy(c3.data, l, { x: 0, y: 0 }, { x: h, y: f }, c3.data), we.copy(c3.data, l, { x: 0, y: y - 1 }, { x: h, y: f - 1 }, { width: d, height: 1 }), we.copy(c3.data, l, { x: 0, y: 0 }, { x: h, y: f + y }, { width: d, height: 1 }), we.copy(c3.data, l, { x: d - 1, y: 0 }, { x: h - 1, y: f }, { width: 1, height: y }), we.copy(c3.data, l, { x: 0, y: 0 }, { x: h + d, y: f }, { width: 1, height: y });
    }
    this.image = l, this.iconPositions = i, this.patternPositions = n;
  }
  addImages(e, t, i) {
    for (let n in e) {
      let o = e[n], a = { x: 0, y: 0, w: o.data.width + 2 * gt, h: o.data.height + 2 * gt };
      i.push(a), t[n] = new Yi(a, o), o.hasRenderCallback && this.haveRenderCallbacks.push(n);
    }
  }
  patchUpdatedImages(e, t) {
    e.dispatchRenderCallbacks(this.haveRenderCallbacks);
    for (let i in e.updatedImages) this.patchUpdatedImage(this.iconPositions[i], e.getImage(i), t), this.patchUpdatedImage(this.patternPositions[i], e.getImage(i), t);
  }
  patchUpdatedImage(e, t, i) {
    if (!e || !t || e.version === t.version) return;
    e.version = t.version;
    let [n, o] = e.tl;
    i.update(t.data, void 0, { x: n, y: o });
  }
};
U("ImagePosition", Yi);
U("ImageAtlas", Up);
var li = ((n) => (n[n.none = 0] = "none", n[n.horizontal = 1] = "horizontal", n[n.vertical = 2] = "vertical", n[n.horizontalOnly = 3] = "horizontalOnly", n))(li || {});
function ll(r50) {
  let e = 0.5, t = 0.5;
  switch (r50) {
    case "right":
    case "top-right":
    case "bottom-right":
      e = 1;
      break;
    case "left":
    case "top-left":
    case "bottom-left":
      e = 0;
      break;
  }
  switch (r50) {
    case "bottom":
    case "bottom-right":
    case "bottom-left":
      t = 1;
      break;
    case "top":
    case "top-right":
    case "top-left":
      t = 0;
      break;
  }
  return { horizontalAlign: e, verticalAlign: t };
}
var Gy = s(Co(), 1);
c();
var Uy = 255;
var Fo = 128;
var ul = Uy * Fo;
function Np(r50, e) {
  let { expression: t } = e;
  if (t.kind === "constant") return { kind: "constant", layoutSize: t.evaluate(new de(r50 + 1)) };
  if (t.kind === "source") return { kind: "source" };
  {
    let { zoomStops: i, interpolationType: n } = t, o = 0;
    for (; o < i.length && i[o] <= r50; ) o++;
    o = Math.max(0, o - 1);
    let a = o;
    for (; a < i.length && i[a] < r50 + 1; ) a++;
    a = Math.min(i.length - 1, a);
    let s3 = i[o], l = i[a];
    if (t.kind === "composite") return { kind: "composite", minZoom: s3, maxZoom: l, interpolationType: n };
    let u = t.evaluate(new de(s3)), c3 = t.evaluate(new de(l));
    return { kind: "camera", minZoom: s3, maxZoom: l, minSize: u, maxSize: c3, interpolationType: n };
  }
}
function Qi(r50, { uSize: e, uSizeT: t }, { lowerSize: i, upperSize: n }) {
  return r50.kind === "source" ? i / Fo : r50.kind === "composite" ? Se.number(i / Fo, n / Fo, t) : e;
}
function ui(r50, e) {
  let t = 0, i = 0;
  if (r50.kind === "constant") i = r50.layoutSize;
  else if (r50.kind !== "source") {
    let { interpolationType: n, minZoom: o, maxZoom: a } = r50, s3 = n ? Ae(_t.interpolationFactor(n, e, o, a), 0, 1) : 0;
    r50.kind === "camera" ? i = Se.number(r50.minSize, r50.maxSize, s3) : t = s3;
  }
  return { uSizeT: t, uSize: i };
}
c();
function en(r50, e, t) {
  let i = "never", n = r50.get(e);
  return n ? i = n : r50.get(t) && (i = "always"), i;
}
var qT = Gy.default.VectorTileFeature.types;
var jT = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
function cl(r50, e, t, i, n, o, a, s3, l, u, c3, p, h) {
  let f = s3 ? Math.min(ul, Math.round(s3[0])) : 0, d = s3 ? Math.min(ul, Math.round(s3[1])) : 0;
  r50.emplaceBack(e, t, Math.round(i * 32), Math.round(n * 32), o, a, (f << 1) + (l ? 1 : 0), d, u * 16, c3 * 16, p * 256, h * 256);
}
function ci(r50, e, t) {
  r50.emplaceBack(e.x, e.y, t), r50.emplaceBack(e.x, e.y, t), r50.emplaceBack(e.x, e.y, t), r50.emplaceBack(e.x, e.y, t);
}
function ZT(r50) {
  for (let e of r50.sections) if (Bm(e.text)) return true;
  return false;
}
var Bo = class {
  constructor(e) {
    this.layoutVertexArray = new Ds(), this.indexArray = new tt(), this.programConfigurations = e, this.segments = new fe(), this.dynamicLayoutVertexArray = new zs(), this.opacityVertexArray = new Fs(), this.hasVisibleVertices = false, this.placedSymbolArray = new lo();
  }
  isEmpty() {
    return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0;
  }
  upload(e, t, i, n) {
    this.isEmpty() || (i && (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, Py.members), this.indexBuffer = e.createIndexBuffer(this.indexArray, t), this.dynamicLayoutVertexBuffer = e.createVertexBuffer(this.dynamicLayoutVertexArray, Ty.members, true), this.opacityVertexBuffer = e.createVertexBuffer(this.opacityVertexArray, jT, true), this.opacityVertexBuffer.itemSize = 1), (i || n) && this.programConfigurations.upload(e));
  }
  destroy() {
    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
  }
};
U("SymbolBuffers", Bo);
var Oo = class {
  constructor(e, t, i) {
    this.layoutVertexArray = new e(), this.layoutAttributes = t, this.indexArray = new i(), this.segments = new fe(), this.collisionVertexArray = new Bs();
  }
  upload(e) {
    this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = e.createVertexBuffer(this.collisionVertexArray, Ay.members, true);
  }
  destroy() {
    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
  }
};
U("CollisionBuffers", Oo);
var Rt = class {
  constructor(e) {
    this.collisionBoxArray = e.collisionBoxArray, this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((l) => l.id), this.index = e.index, this.pixelRatio = e.pixelRatio, this.sourceLayerIndex = e.sourceLayerIndex, this.hasPattern = false, this.hasRTLText = false, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = G.identity([]), this.placementViewportMatrix = G.identity([]);
    let i = this.layers[0]._unevaluatedLayout._values;
    this.textSizeData = Np(this.zoom, i["text-size"]), this.iconSizeData = Np(this.zoom, i["icon-size"]);
    let n = this.layers[0].layout, o = n.get("symbol-sort-key"), a = n.get("symbol-z-order");
    this.canOverlap = en(n, "text-overlap", "text-allow-overlap") !== "never" || en(n, "icon-overlap", "icon-allow-overlap") !== "never" || n.get("text-ignore-placement") || n.get("icon-ignore-placement"), this.sortFeaturesByKey = a !== "viewport-y" && !o.isConstant();
    let s3 = a === "viewport-y" || a === "auto" && !this.sortFeaturesByKey;
    this.sortFeaturesByY = s3 && this.canOverlap, n.get("symbol-placement") === "point" && (this.writingModes = n.get("text-writing-mode").map((l) => li[l])), this.stateDependentLayerIds = this.layers.filter((l) => l.isStateDependent()).map((l) => l.id), this.sourceID = e.sourceID;
  }
  createArrays() {
    this.text = new Bo(new ft(this.layers, this.zoom, (e) => /^text/.test(e))), this.icon = new Bo(new ft(this.layers, this.zoom, (e) => /^icon/.test(e))), this.glyphOffsetArray = new co(), this.lineVertexArray = new po(), this.symbolInstances = new uo(), this.textAnchorOffsets = new ho();
  }
  calculateGlyphDependencies(e, t, i, n, o) {
    for (let a = 0; a < e.length; a++) if (t[e.charCodeAt(a)] = true, (i || n) && o) {
      let s3 = Ey[e.charAt(a)];
      s3 && (t[s3.charCodeAt(0)] = true);
    }
  }
  populate(e, t, i) {
    let n = this.layers[0], o = n.layout, a = o.get("text-font"), s3 = o.get("text-field"), l = o.get("icon-image"), u = (s3.value.kind !== "constant" || s3.value.value instanceof vt && !s3.value.value.isEmpty() || s3.value.value.toString().length > 0) && (a.value.kind !== "constant" || a.value.value.length > 0), c3 = l.value.kind !== "constant" || !!l.value.value || Object.keys(l.parameters).length > 0, p = o.get("symbol-sort-key");
    if (this.features = [], !u && !c3) return;
    let h = t.iconDependencies, f = t.glyphDependencies, d = t.availableImages, y = new de(this.zoom);
    for (let { feature: g, id: x, index: v, sourceLayerIndex: b } of e) {
      let w = n._featureFilter.needGeometry, S = dt(g, w);
      if (!n._featureFilter.filter(y, S, i)) continue;
      w || (S.geometry = mt(g));
      let P;
      if (u) {
        let M = n.getValueAndResolveTokens("text-field", S, i, d), F = vt.factory(M), D = this.hasRTLText = this.hasRTLText || ZT(F);
        (!D || rr.getRTLTextPluginStatus() === "unavailable" || D && rr.isParsed()) && (P = Iy(F, n, S));
      }
      let k;
      if (c3) {
        let M = n.getValueAndResolveTokens("icon-image", S, i, d);
        M instanceof ht ? k = M : k = ht.fromString(M);
      }
      if (!P && !k) continue;
      let I = this.sortFeaturesByKey ? p.evaluate(S, {}, i) : void 0, C = { id: x, text: P, icon: k, index: v, sourceLayerIndex: b, geometry: S.geometry, properties: g.properties, type: qT[g.type], sortKey: I };
      if (this.features.push(C), k && (h[k.name] = true), P) {
        let M = a.evaluate(S, {}, i).join(","), F = o.get("text-rotation-alignment") !== "viewport" && o.get("symbol-placement") !== "point";
        this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(2) >= 0;
        for (let D of P.sections) if (D.image) h[D.image.name] = true;
        else {
          let E = hp(P.toString()), T = D.fontStack || M, N = f[T] = f[T] || {};
          this.calculateGlyphDependencies(D.text, N, F, this.allowVerticalPlacement, E);
        }
      }
    }
    o.get("symbol-placement") === "line" && (this.features = Cy(this.features)), this.sortFeaturesByKey && this.features.sort((g, x) => g.sortKey - x.sortKey);
  }
  update(e, t, i) {
    this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(e, t, this.layers, i), this.icon.programConfigurations.updatePaintArrays(e, t, this.layers, i));
  }
  isEmpty() {
    return this.symbolInstances.length === 0 && !this.hasRTLText;
  }
  uploadPending() {
    return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
  }
  upload(e) {
    !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(e), this.iconCollisionBox.upload(e)), this.text.upload(e, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(e, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = true;
  }
  destroyDebugData() {
    this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
  }
  destroy() {
    this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
  }
  addToLineVertexArray(e, t) {
    let i = this.lineVertexArray.length;
    if (e.segment !== void 0) {
      let n = e.dist(t[e.segment + 1]), o = e.dist(t[e.segment]), a = {};
      for (let s3 = e.segment + 1; s3 < t.length; s3++) a[s3] = { x: t[s3].x, y: t[s3].y, tileUnitDistanceFromAnchor: n }, s3 < t.length - 1 && (n += t[s3 + 1].dist(t[s3]));
      for (let s3 = e.segment || 0; s3 >= 0; s3--) a[s3] = { x: t[s3].x, y: t[s3].y, tileUnitDistanceFromAnchor: o }, s3 > 0 && (o += t[s3 - 1].dist(t[s3]));
      for (let s3 = 0; s3 < t.length; s3++) {
        let l = a[s3];
        this.lineVertexArray.emplaceBack(l.x, l.y, l.tileUnitDistanceFromAnchor);
      }
    }
    return { lineStartIndex: i, lineLength: this.lineVertexArray.length - i };
  }
  addSymbols(e, t, i, n, o, a, s3, l, u, c3, p, h) {
    let f = e.indexArray, d = e.layoutVertexArray, y = e.segments.prepareSegment(4 * t.length, d, f, this.canOverlap ? a.sortKey : void 0), g = this.glyphOffsetArray.length, x = y.vertexLength, v = this.allowVerticalPlacement && s3 === 2 ? Math.PI / 2 : 0, b = a.text && a.text.sections;
    for (let w = 0; w < t.length; w++) {
      let { tl: S, tr: P, bl: k, br: I, tex: C, pixelOffsetTL: M, pixelOffsetBR: F, minFontScaleX: D, minFontScaleY: E, glyphOffset: T, isSDF: N, sectionIndex: X } = t[w], ie = y.vertexLength, K = T[1];
      cl(d, l.x, l.y, S.x, K + S.y, C.x, C.y, i, N, M.x, M.y, D, E), cl(d, l.x, l.y, P.x, K + P.y, C.x + C.w, C.y, i, N, F.x, M.y, D, E), cl(d, l.x, l.y, k.x, K + k.y, C.x, C.y + C.h, i, N, M.x, F.y, D, E), cl(d, l.x, l.y, I.x, K + I.y, C.x + C.w, C.y + C.h, i, N, F.x, F.y, D, E), ci(e.dynamicLayoutVertexArray, l, v), f.emplaceBack(ie, ie + 1, ie + 2), f.emplaceBack(ie + 1, ie + 2, ie + 3), y.vertexLength += 4, y.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(T[0]), (w === t.length - 1 || X !== t[w + 1].sectionIndex) && e.programConfigurations.populatePaintArrays(d.length, a, a.index, {}, h, b && b[X]);
    }
    e.placedSymbolArray.emplaceBack(l.x, l.y, g, this.glyphOffsetArray.length - g, x, u, c3, l.segment, i ? i[0] : 0, i ? i[1] : 0, n[0], n[1], s3, 0, false, 0, p);
  }
  _addCollisionDebugVertex(e, t, i, n, o, a) {
    return t.emplaceBack(0, 0), e.emplaceBack(i.x, i.y, n, o, Math.round(a.x), Math.round(a.y));
  }
  addCollisionDebugVertices(e, t, i, n, o, a, s3) {
    let l = o.segments.prepareSegment(4, o.layoutVertexArray, o.indexArray), u = l.vertexLength, c3 = o.layoutVertexArray, p = o.collisionVertexArray, h = s3.anchorX, f = s3.anchorY;
    this._addCollisionDebugVertex(c3, p, a, h, f, new Ro.default(e, t)), this._addCollisionDebugVertex(c3, p, a, h, f, new Ro.default(i, t)), this._addCollisionDebugVertex(c3, p, a, h, f, new Ro.default(i, n)), this._addCollisionDebugVertex(c3, p, a, h, f, new Ro.default(e, n)), l.vertexLength += 4;
    let d = o.indexArray;
    d.emplaceBack(u, u + 1), d.emplaceBack(u + 1, u + 2), d.emplaceBack(u + 2, u + 3), d.emplaceBack(u + 3, u), l.primitiveLength += 4;
  }
  addDebugCollisionBoxes(e, t, i, n) {
    for (let o = e; o < t; o++) {
      let a = this.collisionBoxArray.get(o), s3 = a.x1, l = a.y1, u = a.x2, c3 = a.y2;
      this.addCollisionDebugVertices(s3, l, u, c3, n ? this.textCollisionBox : this.iconCollisionBox, a.anchorPoint, i);
    }
  }
  generateCollisionDebugBuffers() {
    this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Oo(mo, Rp.members, Tr), this.iconCollisionBox = new Oo(mo, Rp.members, Tr);
    for (let e = 0; e < this.symbolInstances.length; e++) {
      let t = this.symbolInstances.get(e);
      this.addDebugCollisionBoxes(t.textBoxStartIndex, t.textBoxEndIndex, t, true), this.addDebugCollisionBoxes(t.verticalTextBoxStartIndex, t.verticalTextBoxEndIndex, t, true), this.addDebugCollisionBoxes(t.iconBoxStartIndex, t.iconBoxEndIndex, t, false), this.addDebugCollisionBoxes(t.verticalIconBoxStartIndex, t.verticalIconBoxEndIndex, t, false);
    }
  }
  _deserializeCollisionBoxesForSymbol(e, t, i, n, o, a, s3, l, u) {
    let c3 = {};
    for (let p = t; p < i; p++) {
      let h = e.get(p);
      c3.textBox = { x1: h.x1, y1: h.y1, x2: h.x2, y2: h.y2, anchorPointX: h.anchorPointX, anchorPointY: h.anchorPointY }, c3.textFeatureIndex = h.featureIndex;
      break;
    }
    for (let p = n; p < o; p++) {
      let h = e.get(p);
      c3.verticalTextBox = { x1: h.x1, y1: h.y1, x2: h.x2, y2: h.y2, anchorPointX: h.anchorPointX, anchorPointY: h.anchorPointY }, c3.verticalTextFeatureIndex = h.featureIndex;
      break;
    }
    for (let p = a; p < s3; p++) {
      let h = e.get(p);
      c3.iconBox = { x1: h.x1, y1: h.y1, x2: h.x2, y2: h.y2, anchorPointX: h.anchorPointX, anchorPointY: h.anchorPointY }, c3.iconFeatureIndex = h.featureIndex;
      break;
    }
    for (let p = l; p < u; p++) {
      let h = e.get(p);
      c3.verticalIconBox = { x1: h.x1, y1: h.y1, x2: h.x2, y2: h.y2, anchorPointX: h.anchorPointX, anchorPointY: h.anchorPointY }, c3.verticalIconFeatureIndex = h.featureIndex;
      break;
    }
    return c3;
  }
  deserializeCollisionBoxes(e) {
    this.collisionArrays = [];
    for (let t = 0; t < this.symbolInstances.length; t++) {
      let i = this.symbolInstances.get(t);
      this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(e, i.textBoxStartIndex, i.textBoxEndIndex, i.verticalTextBoxStartIndex, i.verticalTextBoxEndIndex, i.iconBoxStartIndex, i.iconBoxEndIndex, i.verticalIconBoxStartIndex, i.verticalIconBoxEndIndex));
    }
  }
  hasTextData() {
    return this.text.segments.get().length > 0;
  }
  hasIconData() {
    return this.icon.segments.get().length > 0;
  }
  hasDebugData() {
    return this.textCollisionBox && this.iconCollisionBox;
  }
  hasTextCollisionBoxData() {
    return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
  }
  hasIconCollisionBoxData() {
    return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
  }
  addIndicesForPlacedSymbol(e, t) {
    let i = e.placedSymbolArray.get(t), n = i.vertexStartIndex + i.numGlyphs * 4;
    for (let o = i.vertexStartIndex; o < n; o += 4) e.indexArray.emplaceBack(o, o + 1, o + 2), e.indexArray.emplaceBack(o + 1, o + 2, o + 3);
  }
  getSortedSymbolIndexes(e) {
    if (this.sortedAngle === e && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes;
    let t = Math.sin(e), i = Math.cos(e), n = [], o = [], a = [];
    for (let s3 = 0; s3 < this.symbolInstances.length; ++s3) {
      a.push(s3);
      let l = this.symbolInstances.get(s3);
      n.push(Math.round(t * l.anchorX + i * l.anchorY) | 0), o.push(l.featureIndex);
    }
    return a.sort((s3, l) => n[s3] - n[l] || o[l] - o[s3]), a;
  }
  addToSortKeyRanges(e, t) {
    let i = this.sortKeyRanges[this.sortKeyRanges.length - 1];
    i && i.sortKey === t ? i.symbolInstanceEnd = e + 1 : this.sortKeyRanges.push({ sortKey: t, symbolInstanceStart: e, symbolInstanceEnd: e + 1 });
  }
  sortFeatures(e) {
    if (this.sortFeaturesByY && this.sortedAngle !== e && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
      this.symbolInstanceIndexes = this.getSortedSymbolIndexes(e), this.sortedAngle = e, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
      for (let t of this.symbolInstanceIndexes) {
        let i = this.symbolInstances.get(t);
        this.featureSortOrder.push(i.featureIndex), [i.rightJustifiedTextSymbolIndex, i.centerJustifiedTextSymbolIndex, i.leftJustifiedTextSymbolIndex].forEach((n, o, a) => {
          n >= 0 && a.indexOf(n) === o && this.addIndicesForPlacedSymbol(this.text, n);
        }), i.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, i.verticalPlacedTextSymbolIndex), i.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, i.placedIconSymbolIndex), i.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, i.verticalPlacedIconSymbolIndex);
      }
      this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
    }
  }
};
U("SymbolBucket", Rt, { omit: ["layers", "collisionBoxArray", "features", "compareText"] });
Rt.MAX_GLYPHS = 65535;
Rt.addDynamicAttributes = ci;
c();
function qy(r50, e) {
  return e.replace(/{([^{}]+)}/g, (t, i) => r50 && i in r50 ? String(r50[i]) : "");
}
c();
var jy;
var HT = () => jy = jy || new Le({ "symbol-placement": new j(A.layout_symbol["symbol-placement"]), "symbol-spacing": new j(A.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new j(A.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new H(A.layout_symbol["symbol-sort-key"]), "symbol-z-order": new j(A.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new j(A.layout_symbol["icon-allow-overlap"]), "icon-overlap": new j(A.layout_symbol["icon-overlap"]), "icon-ignore-placement": new j(A.layout_symbol["icon-ignore-placement"]), "icon-optional": new j(A.layout_symbol["icon-optional"]), "icon-rotation-alignment": new j(A.layout_symbol["icon-rotation-alignment"]), "icon-size": new H(A.layout_symbol["icon-size"]), "icon-text-fit": new j(A.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new j(A.layout_symbol["icon-text-fit-padding"]), "icon-image": new H(A.layout_symbol["icon-image"]), "icon-rotate": new H(A.layout_symbol["icon-rotate"]), "icon-padding": new H(A.layout_symbol["icon-padding"]), "icon-keep-upright": new j(A.layout_symbol["icon-keep-upright"]), "icon-offset": new H(A.layout_symbol["icon-offset"]), "icon-anchor": new H(A.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new j(A.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new j(A.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new j(A.layout_symbol["text-rotation-alignment"]), "text-field": new H(A.layout_symbol["text-field"]), "text-font": new H(A.layout_symbol["text-font"]), "text-size": new H(A.layout_symbol["text-size"]), "text-max-width": new H(A.layout_symbol["text-max-width"]), "text-line-height": new j(A.layout_symbol["text-line-height"]), "text-letter-spacing": new H(A.layout_symbol["text-letter-spacing"]), "text-justify": new H(A.layout_symbol["text-justify"]), "text-radial-offset": new H(A.layout_symbol["text-radial-offset"]), "text-variable-anchor": new j(A.layout_symbol["text-variable-anchor"]), "text-variable-anchor-offset": new H(A.layout_symbol["text-variable-anchor-offset"]), "text-anchor": new H(A.layout_symbol["text-anchor"]), "text-max-angle": new j(A.layout_symbol["text-max-angle"]), "text-writing-mode": new j(A.layout_symbol["text-writing-mode"]), "text-rotate": new H(A.layout_symbol["text-rotate"]), "text-padding": new j(A.layout_symbol["text-padding"]), "text-keep-upright": new j(A.layout_symbol["text-keep-upright"]), "text-transform": new H(A.layout_symbol["text-transform"]), "text-offset": new H(A.layout_symbol["text-offset"]), "text-allow-overlap": new j(A.layout_symbol["text-allow-overlap"]), "text-overlap": new j(A.layout_symbol["text-overlap"]), "text-ignore-placement": new j(A.layout_symbol["text-ignore-placement"]), "text-optional": new j(A.layout_symbol["text-optional"]) });
var Zy;
var $T = () => Zy = Zy || new Le({ "icon-opacity": new H(A.paint_symbol["icon-opacity"]), "icon-color": new H(A.paint_symbol["icon-color"]), "icon-halo-color": new H(A.paint_symbol["icon-halo-color"]), "icon-halo-width": new H(A.paint_symbol["icon-halo-width"]), "icon-halo-blur": new H(A.paint_symbol["icon-halo-blur"]), "icon-translate": new j(A.paint_symbol["icon-translate"]), "icon-translate-anchor": new j(A.paint_symbol["icon-translate-anchor"]), "text-opacity": new H(A.paint_symbol["text-opacity"]), "text-color": new H(A.paint_symbol["text-color"], { runtimeType: Mt, getOverride: (r50) => r50.textColor, hasOverride: (r50) => !!r50.textColor }), "text-halo-color": new H(A.paint_symbol["text-halo-color"]), "text-halo-width": new H(A.paint_symbol["text-halo-width"]), "text-halo-blur": new H(A.paint_symbol["text-halo-blur"]), "text-translate": new j(A.paint_symbol["text-translate"]), "text-translate-anchor": new j(A.paint_symbol["text-translate-anchor"]) });
var pl = { get paint() {
  return $T();
}, get layout() {
  return HT();
} };
c();
var Vo = class {
  constructor(e) {
    if (e.property.overrides === void 0) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
    this.type = e.property.overrides ? e.property.overrides.runtimeType : Ci, this.defaultValue = e;
  }
  evaluate(e) {
    if (e.formattedSection) {
      let t = this.defaultValue.property.overrides;
      if (t && t.hasOverride(e.formattedSection)) return t.getOverride(e.formattedSection);
    }
    return e.feature && e.featureState ? this.defaultValue.evaluate(e.feature, e.featureState) : this.defaultValue.property.specification.default;
  }
  eachChild(e) {
    if (!this.defaultValue.isConstant()) {
      let t = this.defaultValue.value;
      e(t._styleExpression.expression);
    }
  }
  outputDefined() {
    return false;
  }
  serialize() {
    return null;
  }
};
U("FormatSectionOverride", Vo, { omit: ["defaultValue"] });
var hl = class r37 extends Ne {
  constructor(e) {
    super(e, pl);
  }
  recalculate(e, t) {
    if (super.recalculate(e, t), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout.get("symbol-placement") !== "point" ? this.layout._values["icon-rotation-alignment"] = "map" : this.layout._values["icon-rotation-alignment"] = "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout.get("symbol-placement") !== "point" ? this.layout._values["text-rotation-alignment"] = "map" : this.layout._values["text-rotation-alignment"] = "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
      let i = this.layout.get("text-writing-mode");
      if (i) {
        let n = [];
        for (let o of i) n.indexOf(o) < 0 && n.push(o);
        this.layout._values["text-writing-mode"] = n;
      } else this.layout._values["text-writing-mode"] = ["horizontal"];
    }
    this._setPaintOverrides();
  }
  getValueAndResolveTokens(e, t, i, n) {
    let o = this.layout.get(e).evaluate(t, {}, i, n), a = this._unevaluatedLayout._values[e];
    return !a.isDataDriven() && !Jr(a.value) && o ? qy(t.properties, o) : o;
  }
  createBucket(e) {
    return new Rt(e);
  }
  queryRadius() {
    return 0;
  }
  queryIntersectsFeature() {
    throw new Error("Should take a different path in FeatureIndex");
  }
  _setPaintOverrides() {
    for (let e of pl.paint.overridableProperties) {
      if (!r37.hasPaintOverride(this.layout, e)) continue;
      let t = this.paint.get(e), i = new Vo(t), n = new $r(i, t.property.specification), o = null;
      t.value.kind === "constant" || t.value.kind === "source" ? o = new xr("source", n) : o = new br("composite", n, t.value.zoomStops), this.paint._values[e] = new ot(t.property, o, t.parameters);
    }
  }
  _handleOverridablePaintPropertyUpdate(e, t, i) {
    return !this.layout || t.isDataDriven() || i.isDataDriven() ? false : r37.hasPaintOverride(this.layout, e);
  }
  static hasPaintOverride(e, t) {
    let i = e.get("text-field"), n = pl.paint.properties[t], o = false, a = (s3) => {
      for (let l of s3) if (n.overrides && n.overrides.hasOverride(l)) {
        o = true;
        return;
      }
    };
    if (i.value.kind === "constant" && i.value.value instanceof vt) a(i.value.value.sections);
    else if (i.value.kind === "source") {
      let s3 = (u) => {
        if (!o) if (u instanceof yr && Ze(u.value) === Ei) {
          let c3 = u.value;
          a(c3.sections);
        } else u instanceof kn ? a(u.sections) : u.eachChild(s3);
      }, l = i.value;
      l._styleExpression && s3(l._styleExpression.expression);
    }
    return o;
  }
};
c();
c();
var Hy;
var WT = () => Hy = Hy || new Le({ "background-color": new j(A.paint_background["background-color"]), "background-pattern": new Qr(A.paint_background["background-pattern"]), "background-opacity": new j(A.paint_background["background-opacity"]) });
var $y = { get paint() {
  return WT();
} };
var fl = class extends Ne {
  constructor(e) {
    super(e, $y);
  }
};
c();
c();
var Wy;
var XT = () => Wy = Wy || new Le({ "raster-opacity": new j(A.paint_raster["raster-opacity"]), "raster-hue-rotate": new j(A.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new j(A.paint_raster["raster-brightness-min"]), "raster-brightness-max": new j(A.paint_raster["raster-brightness-max"]), "raster-saturation": new j(A.paint_raster["raster-saturation"]), "raster-contrast": new j(A.paint_raster["raster-contrast"]), "raster-resampling": new j(A.paint_raster["raster-resampling"]), "raster-fade-duration": new j(A.paint_raster["raster-fade-duration"]) });
var Xy = { get paint() {
  return XT();
} };
var ml = class extends Ne {
  constructor(e) {
    super(e, Xy);
  }
};
c();
function Ky(r50) {
  let e = [], t = r50.id;
  return t === void 0 && e.push({ message: "layers.".concat(t, ': missing required property "id"') }), r50.render === void 0 && e.push({ message: "layers.".concat(t, ': missing required method "render"') }), r50.renderingMode && r50.renderingMode !== "2d" && r50.renderingMode !== "3d" && e.push({ message: "layers.".concat(t, ': property "renderingMode" must be either "2d" or "3d"') }), e;
}
var dl = class extends Ne {
  constructor(t) {
    super(t, {});
    this.onAdd = (t3) => {
      this.implementation.onAdd && this.implementation.onAdd(t3, t3.painter.context.gl);
    };
    this.onRemove = (t3) => {
      this.implementation.onRemove && this.implementation.onRemove(t3, t3.painter.context.gl);
    };
    this.implementation = t;
  }
  is3D() {
    return this.implementation.renderingMode === "3d";
  }
  hasOffscreenPass() {
    return this.implementation.prerender !== void 0;
  }
  recalculate() {
  }
  updateTransitions() {
  }
  hasTransition() {
    return false;
  }
  serialize() {
    throw new Error("Custom layers cannot be serialized");
  }
};
function yl(r50) {
  if (r50.type === "custom") return new dl(r50);
  switch (r50.type) {
    case "background":
      return new fl(r50);
    case "circle":
      return new Hs(r50);
    case "fill":
      return new el(r50);
    case "fill-extrusion":
      return new il(r50);
    case "heatmap":
      return new Ws(r50);
    case "hillshade":
      return new Xs(r50);
    case "line":
      return new ol(r50);
    case "raster":
      return new ml(r50);
    case "symbol":
      return new hl(r50);
  }
}
c();
c();
function tn(r50) {
  let e = [];
  if (typeof r50 == "string") e.push({ id: "default", url: r50 });
  else if (r50 && r50.length > 0) {
    let t = [];
    for (let { id: i, url: n } of r50) {
      let o = "".concat(i).concat(n);
      t.indexOf(o) === -1 && (t.push(o), e.push({ id: i, url: n }));
    }
  }
  return e;
}
async function Jy(r50, e, t, i) {
  let n = tn(r50), o = t > 1 ? "@2x" : "", a = {}, s3 = {};
  for (let { id: l, url: u } of n) {
    let c3 = e.transformRequest(e.normalizeSpriteURL(u, o, ".json"), "SpriteJSON");
    a[l] = mr(c3, i);
    let p = e.transformRequest(e.normalizeSpriteURL(u, o, ".png"), "SpriteImage");
    s3[l] = at.getImage(p, i);
  }
  return await Promise.all([...Object.values(a), ...Object.values(s3)]), KT(a, s3);
}
async function KT(r50, e) {
  let t = {};
  for (let i in r50) {
    t[i] = {};
    let n = J.getImageCanvasContext((await e[i]).data), o = (await r50[i]).data;
    for (let a in o) {
      let { width: s3, height: l, x: u, y: c3, sdf: p, pixelRatio: h, stretchX: f, stretchY: d, content: y } = o[a], g = { width: s3, height: l, x: u, y: c3, context: n };
      t[i][a] = { data: null, pixelRatio: h, sdf: p, stretchX: f, stretchY: d, content: y, spriteData: g };
    }
  }
  return t;
}
c();
c();
var _e = class {
  constructor(e, t, i, n) {
    this.context = e, this.format = i, this.texture = e.gl.createTexture(), this.update(t, n);
  }
  update(e, t, i) {
    let { width: n, height: o } = e, a = (!this.size || this.size[0] !== n || this.size[1] !== o) && !i, { context: s3 } = this, { gl: l } = s3;
    if (this.useMipmap = !!(t && t.useMipmap), l.bindTexture(l.TEXTURE_2D, this.texture), s3.pixelStoreUnpackFlipY.set(false), s3.pixelStoreUnpack.set(1), s3.pixelStoreUnpackPremultiplyAlpha.set(this.format === l.RGBA && (!t || t.premultiply !== false)), a) this.size = [n, o], e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof HTMLVideoElement || e instanceof ImageData || pt(e) ? l.texImage2D(l.TEXTURE_2D, 0, this.format, this.format, l.UNSIGNED_BYTE, e) : l.texImage2D(l.TEXTURE_2D, 0, this.format, n, o, 0, this.format, l.UNSIGNED_BYTE, e.data);
    else {
      let { x: u, y: c3 } = i || { x: 0, y: 0 };
      e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof HTMLVideoElement || e instanceof ImageData || pt(e) ? l.texSubImage2D(l.TEXTURE_2D, 0, u, c3, l.RGBA, l.UNSIGNED_BYTE, e) : l.texSubImage2D(l.TEXTURE_2D, 0, u, c3, n, o, l.RGBA, l.UNSIGNED_BYTE, e.data);
    }
    this.useMipmap && this.isSizePowerOfTwo() && l.generateMipmap(l.TEXTURE_2D);
  }
  bind(e, t, i) {
    let { context: n } = this, { gl: o } = n;
    o.bindTexture(o.TEXTURE_2D, this.texture), i === o.LINEAR_MIPMAP_NEAREST && !this.isSizePowerOfTwo() && (i = o.LINEAR), e !== this.filter && (o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MAG_FILTER, e), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MIN_FILTER, i || e), this.filter = e), t !== this.wrap && (o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_S, t), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_T, t), this.wrap = t);
  }
  isSizePowerOfTwo() {
    return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 === 0;
  }
  destroy() {
    let { gl: e } = this.context;
    e.deleteTexture(this.texture), this.texture = null;
  }
};
c();
function Yy(r50) {
  let { userImage: e } = r50;
  return e && e.render && e.render() ? (r50.data.replace(new Uint8Array(e.data.buffer)), true) : false;
}
var gl = 1;
var xl = class extends me {
  constructor() {
    super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = false, this.requestors = [], this.patterns = {}, this.atlasImage = new we({ width: 1, height: 1 }), this.dirty = true;
  }
  isLoaded() {
    return this.loaded;
  }
  setLoaded(e) {
    if (this.loaded !== e && (this.loaded = e, e)) {
      for (let { ids: t, promiseResolve: i } of this.requestors) i(this._getImagesForIds(t));
      this.requestors = [];
    }
  }
  getImage(e) {
    let t = this.images[e];
    if (t && !t.data && t.spriteData) {
      let i = t.spriteData;
      t.data = new we({ width: i.width, height: i.height }, i.context.getImageData(i.x, i.y, i.width, i.height).data), t.spriteData = null;
    }
    return t;
  }
  addImage(e, t) {
    if (this.images[e]) throw new Error("Image id ".concat(e, " already exist, use updateImage instead"));
    this._validate(e, t) && (this.images[e] = t);
  }
  _validate(e, t) {
    let i = true, n = t.data || t.spriteData;
    return this._validateStretch(t.stretchX, n && n.width) || (this.fire(new Z(new Error('Image "'.concat(e, '" has invalid "stretchX" value')))), i = false), this._validateStretch(t.stretchY, n && n.height) || (this.fire(new Z(new Error('Image "'.concat(e, '" has invalid "stretchY" value')))), i = false), this._validateContent(t.content, t) || (this.fire(new Z(new Error('Image "'.concat(e, '" has invalid "content" value')))), i = false), i;
  }
  _validateStretch(e, t) {
    if (!e) return true;
    let i = 0;
    for (let n of e) {
      if (n[0] < i || n[1] < n[0] || t < n[1]) return false;
      i = n[1];
    }
    return true;
  }
  _validateContent(e, t) {
    if (!e) return true;
    if (e.length !== 4) return false;
    let i = t.spriteData, n = i && i.width || t.data.width, o = i && i.height || t.data.height;
    return !(e[0] < 0 || n < e[0] || e[1] < 0 || o < e[1] || e[2] < 0 || n < e[2] || e[3] < 0 || o < e[3] || e[2] < e[0] || e[3] < e[1]);
  }
  updateImage(e, t, i = true) {
    let n = this.getImage(e);
    if (i && (n.data.width !== t.data.width || n.data.height !== t.data.height)) throw new Error("size mismatch between old image (".concat(n.data.width, "x").concat(n.data.height, ") and new image (").concat(t.data.width, "x").concat(t.data.height, ")."));
    t.version = n.version + 1, this.images[e] = t, this.updatedImages[e] = true;
  }
  removeImage(e) {
    let t = this.images[e];
    delete this.images[e], delete this.patterns[e], t.userImage && t.userImage.onRemove && t.userImage.onRemove();
  }
  listImages() {
    return Object.keys(this.images);
  }
  getImages(e) {
    return new Promise((t, i) => {
      let n = true;
      if (!this.isLoaded()) for (let o of e) this.images[o] || (n = false);
      this.isLoaded() || n ? t(this._getImagesForIds(e)) : this.requestors.push({ ids: e, promiseResolve: t });
    });
  }
  _getImagesForIds(e) {
    let t = {};
    for (let i of e) {
      let n = this.getImage(i);
      n || (this.fire(new z("styleimagemissing", { id: i })), n = this.getImage(i)), n ? t[i] = { data: n.data.clone(), pixelRatio: n.pixelRatio, sdf: n.sdf, version: n.version, stretchX: n.stretchX, stretchY: n.stretchY, content: n.content, hasRenderCallback: !!(n.userImage && n.userImage.render) } : Ee('Image "'.concat(i, '" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.'));
    }
    return t;
  }
  getPixelSize() {
    let { width: e, height: t } = this.atlasImage;
    return { width: e, height: t };
  }
  getPattern(e) {
    let t = this.patterns[e], i = this.getImage(e);
    if (!i) return null;
    if (t && t.position.version === i.version) return t.position;
    if (t) t.position.version = i.version;
    else {
      let n = i.data.width + gl * 2, o = i.data.height + gl * 2, a = { w: n, h: o, x: 0, y: 0 }, s3 = new Yi(a, i);
      this.patterns[e] = { bin: a, position: s3 };
    }
    return this._updatePatternAtlas(), this.patterns[e].position;
  }
  bind(e) {
    let t = e.gl;
    this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = false) : this.atlasTexture = new _e(e, this.atlasImage, t.RGBA), this.atlasTexture.bind(t.LINEAR, t.CLAMP_TO_EDGE);
  }
  _updatePatternAtlas() {
    let e = [];
    for (let o in this.patterns) e.push(this.patterns[o].bin);
    let { w: t, h: i } = zo(e), n = this.atlasImage;
    n.resize({ width: t || 1, height: i || 1 });
    for (let o in this.patterns) {
      let { bin: a } = this.patterns[o], s3 = a.x + gl, l = a.y + gl, u = this.getImage(o).data, c3 = u.width, p = u.height;
      we.copy(u, n, { x: 0, y: 0 }, { x: s3, y: l }, { width: c3, height: p }), we.copy(u, n, { x: 0, y: p - 1 }, { x: s3, y: l - 1 }, { width: c3, height: 1 }), we.copy(u, n, { x: 0, y: 0 }, { x: s3, y: l + p }, { width: c3, height: 1 }), we.copy(u, n, { x: c3 - 1, y: 0 }, { x: s3 - 1, y: l }, { width: 1, height: p }), we.copy(u, n, { x: 0, y: 0 }, { x: s3 + c3, y: l }, { width: 1, height: p });
    }
    this.dirty = true;
  }
  beginFrame() {
    this.callbackDispatchedThisFrame = {};
  }
  dispatchRenderCallbacks(e) {
    for (let t of e) {
      if (this.callbackDispatchedThisFrame[t]) continue;
      this.callbackDispatchedThisFrame[t] = true;
      let i = this.getImage(t);
      i || Ee('Image with ID: "'.concat(t, '" was not found')), Yy(i) && this.updateImage(t, i);
    }
  }
};
c();
c();
async function Qy(r50, e, t, i) {
  let n = e * 256, o = n + 255, a = i.transformRequest(t.replace("{fontstack}", r50).replace("{range}", "".concat(n, "-").concat(o)), "Glyphs"), s3 = await xf(a, new AbortController());
  if (!s3 || !s3.data) throw new Error("Could not load glyph range. range: ".concat(e, ", ").concat(n, "-").concat(o));
  let l = {};
  for (let u of Vy(s3.data)) l[u.id] = u;
  return l;
}
c();
var Uo = class {
  constructor({ fontSize: e = 24, buffer: t = 3, radius: i = 8, cutoff: n = 0.25, fontFamily: o = "sans-serif", fontWeight: a = "normal", fontStyle: s3 = "normal" } = {}) {
    this.buffer = t, this.cutoff = n, this.radius = i;
    let l = this.size = e + t * 4, u = this._createCanvas(l), c3 = this.ctx = u.getContext("2d", { willReadFrequently: true });
    c3.font = "".concat(s3, " ").concat(a, " ").concat(e, "px ").concat(o), c3.textBaseline = "alphabetic", c3.textAlign = "left", c3.fillStyle = "black", this.gridOuter = new Float64Array(l * l), this.gridInner = new Float64Array(l * l), this.f = new Float64Array(l), this.z = new Float64Array(l + 1), this.v = new Uint16Array(l);
  }
  _createCanvas(e) {
    let t = document.createElement("canvas");
    return t.width = t.height = e, t;
  }
  draw(e) {
    let { width: t, actualBoundingBoxAscent: i, actualBoundingBoxDescent: n, actualBoundingBoxLeft: o, actualBoundingBoxRight: a } = this.ctx.measureText(e), s3 = Math.ceil(i), l = 0, u = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(a - o))), c3 = Math.min(this.size - this.buffer, s3 + Math.ceil(n)), p = u + 2 * this.buffer, h = c3 + 2 * this.buffer, f = Math.max(p * h, 0), d = new Uint8ClampedArray(f), y = { data: d, width: p, height: h, glyphWidth: u, glyphHeight: c3, glyphTop: s3, glyphLeft: l, glyphAdvance: t };
    if (u === 0 || c3 === 0) return y;
    let { ctx: g, buffer: x, gridInner: v, gridOuter: b } = this;
    g.clearRect(x, x, u, c3), g.fillText(e, x, x + s3);
    let w = g.getImageData(x, x, u, c3);
    b.fill(1e20, 0, f), v.fill(0, 0, f);
    for (let S = 0; S < c3; S++) for (let P = 0; P < u; P++) {
      let k = w.data[4 * (S * u + P) + 3] / 255;
      if (k === 0) continue;
      let I = (S + x) * p + P + x;
      if (k === 1) b[I] = 0, v[I] = 1e20;
      else {
        let C = 0.5 - k;
        b[I] = C > 0 ? C * C : 0, v[I] = C < 0 ? C * C : 0;
      }
    }
    eg(b, 0, 0, p, h, p, this.f, this.v, this.z), eg(v, x, x, u, c3, p, this.f, this.v, this.z);
    for (let S = 0; S < f; S++) {
      let P = Math.sqrt(b[S]) - Math.sqrt(v[S]);
      d[S] = Math.round(255 - 255 * (P / this.radius + this.cutoff));
    }
    return y;
  }
};
function eg(r50, e, t, i, n, o, a, s3, l) {
  for (let u = e; u < e + i; u++) tg(r50, t * o + u, o, n, a, s3, l);
  for (let u = t; u < t + n; u++) tg(r50, u * o + e, 1, i, a, s3, l);
}
function tg(r50, e, t, i, n, o, a) {
  o[0] = 0, a[0] = -1e20, a[1] = 1e20, n[0] = r50[e];
  for (let s3 = 1, l = 0, u = 0; s3 < i; s3++) {
    n[s3] = r50[e + s3 * t];
    let c3 = s3 * s3;
    do {
      let p = o[l];
      u = (n[s3] - n[p] + c3 - p * p) / (s3 - p) / 2;
    } while (u <= a[l] && --l > -1);
    l++, o[l] = s3, a[l] = u, a[l + 1] = 1e20;
  }
  for (let s3 = 0, l = 0; s3 < i; s3++) {
    for (; a[l + 1] < s3; ) l++;
    let u = o[l], c3 = s3 - u;
    r50[e + s3 * t] = n[u] + c3 * c3;
  }
}
var rn = class rn2 {
  constructor(e, t) {
    this.requestManager = e, this.localIdeographFontFamily = t, this.entries = {};
  }
  setURL(e) {
    this.url = e;
  }
  async getGlyphs(e) {
    let t = [];
    for (let o in e) for (let a of e[o]) t.push(this._getAndCacheGlyphsPromise(o, a));
    let i = await Promise.all(t), n = {};
    for (let { stack: o, id: a, glyph: s3 } of i) n[o] || (n[o] = {}), n[o][a] = s3 && { id: s3.id, bitmap: s3.bitmap.clone(), metrics: s3.metrics };
    return n;
  }
  async _getAndCacheGlyphsPromise(e, t) {
    let i = this.entries[e];
    i || (i = this.entries[e] = { glyphs: {}, requests: {}, ranges: {} });
    let n = i.glyphs[t];
    if (n !== void 0) return { stack: e, id: t, glyph: n };
    if (n = this._tinySDF(i, e, t), n) return i.glyphs[t] = n, { stack: e, id: t, glyph: n };
    let o = Math.floor(t / 256);
    if (o * 256 > 65535) throw new Error("glyphs > 65535 not supported");
    if (i.ranges[o]) return { stack: e, id: t, glyph: n };
    if (!this.url) throw new Error("glyphsUrl is not set");
    if (!i.requests[o]) {
      let s3 = rn2.loadGlyphRange(e, o, this.url, this.requestManager);
      i.requests[o] = s3;
    }
    let a = await i.requests[o];
    for (let s3 in a) this._doesCharSupportLocalGlyph(+s3) || (i.glyphs[+s3] = a[+s3]);
    return i.ranges[o] = true, { stack: e, id: t, glyph: a[t] || null };
  }
  _doesCharSupportLocalGlyph(e) {
    return !!this.localIdeographFontFamily && (pe["CJK Unified Ideographs"](e) || pe["Hangul Syllables"](e) || pe.Hiragana(e) || pe.Katakana(e));
  }
  _tinySDF(e, t, i) {
    let n = this.localIdeographFontFamily;
    if (!n || !this._doesCharSupportLocalGlyph(i)) return;
    let o = 2, a = e.tinySDF;
    if (!a) {
      let c3 = "400";
      /bold/i.test(t) ? c3 = "900" : /medium/i.test(t) ? c3 = "500" : /light/i.test(t) && (c3 = "200"), a = e.tinySDF = new rn2.TinySDF({ fontSize: 24 * o, buffer: 3 * o, radius: 8 * o, cutoff: 0.25, fontFamily: n, fontWeight: c3 });
    }
    let s3 = a.draw(String.fromCharCode(i));
    return { id: i, bitmap: new ai({ width: s3.width || 30 * o, height: s3.height || 30 * o }, s3.data), metrics: { width: s3.glyphWidth / o || 24, height: s3.glyphHeight / o || 24, left: s3.glyphLeft / o + 0.5 || 0, top: s3.glyphTop / o - 27.5 || -8, advance: s3.glyphAdvance / o || 24, isDoubleResolution: true } };
  }
};
rn.loadGlyphRange = Qy, rn.TinySDF = Uo;
var bl = rn;
c();
var qp = class {
  constructor() {
    this.specification = A.light.position;
  }
  possiblyEvaluate(e, t) {
    return cf(e.expression.evaluate(t));
  }
  interpolate(e, t, i) {
    return { x: Se.number(e.x, t.x, i), y: Se.number(e.y, t.y, i), z: Se.number(e.z, t.z, i) };
  }
};
var rg = "-transition";
var Gp;
var _l = class extends me {
  constructor(e) {
    super(), Gp = Gp || new Le({ anchor: new j(A.light.anchor), position: new qp(), color: new j(A.light.color), intensity: new j(A.light.intensity) }), this._transitionable = new Oi(Gp), this.setLight(e), this._transitioning = this._transitionable.untransitioned();
  }
  getLight() {
    return this._transitionable.serialize();
  }
  setLight(e, t = {}) {
    if (!this._validate(km, e, t)) for (let i in e) {
      let n = e[i];
      i.endsWith(rg) ? this._transitionable.setTransition(i.slice(0, -rg.length), n) : this._transitionable.setValue(i, n);
    }
  }
  updateTransitions(e) {
    this._transitioning = this._transitionable.transitioned(e, this._transitioning);
  }
  hasTransition() {
    return this._transitioning.hasTransition();
  }
  recalculate(e) {
    this.properties = this._transitioning.possiblyEvaluate(e);
  }
  _validate(e, t, i) {
    return i && i.validate === false ? false : Di(this, e.call(Ue, { value: t, style: { glyphs: true, sprite: true }, styleSpec: A }));
  }
};
c();
var vl = class {
  constructor(e, t) {
    this.width = e, this.height = t, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
  }
  getDash(e, t) {
    let i = e.join(",") + String(t);
    return this.dashEntry[i] || (this.dashEntry[i] = this.addDash(e, t)), this.dashEntry[i];
  }
  getDashRanges(e, t, i) {
    let n = e.length % 2 === 1, o = [], a = n ? -e[e.length - 1] * i : 0, s3 = e[0] * i, l = true;
    o.push({ left: a, right: s3, isDash: l, zeroLength: e[0] === 0 });
    let u = e[0];
    for (let c3 = 1; c3 < e.length; c3++) {
      l = !l;
      let p = e[c3];
      a = u * i, u += p, s3 = u * i, o.push({ left: a, right: s3, isDash: l, zeroLength: p === 0 });
    }
    return o;
  }
  addRoundDash(e, t, i) {
    let n = t / 2;
    for (let o = -i; o <= i; o++) {
      let a = this.nextRow + i + o, s3 = this.width * a, l = 0, u = e[l];
      for (let c3 = 0; c3 < this.width; c3++) {
        c3 / u.right > 1 && (u = e[++l]);
        let p = Math.abs(c3 - u.left), h = Math.abs(c3 - u.right), f = Math.min(p, h), d, y = o / i * (n + 1);
        if (u.isDash) {
          let g = n - Math.abs(y);
          d = Math.sqrt(f * f + g * g);
        } else d = n - Math.sqrt(f * f + y * y);
        this.data[s3 + c3] = Math.max(0, Math.min(255, d + 128));
      }
    }
  }
  addRegularDash(e) {
    for (let s3 = e.length - 1; s3 >= 0; --s3) {
      let l = e[s3], u = e[s3 + 1];
      l.zeroLength ? e.splice(s3, 1) : u && u.isDash === l.isDash && (u.left = l.left, e.splice(s3, 1));
    }
    let t = e[0], i = e[e.length - 1];
    t.isDash === i.isDash && (t.left = i.left - this.width, i.right = t.right + this.width);
    let n = this.width * this.nextRow, o = 0, a = e[o];
    for (let s3 = 0; s3 < this.width; s3++) {
      s3 / a.right > 1 && (a = e[++o]);
      let l = Math.abs(s3 - a.left), u = Math.abs(s3 - a.right), c3 = Math.min(l, u), p = a.isDash ? c3 : -c3;
      this.data[n + s3] = Math.max(0, Math.min(255, p + 128));
    }
  }
  addDash(e, t) {
    let i = t ? 7 : 0, n = 2 * i + 1;
    if (this.nextRow + n > this.height) return Ee("LineAtlas out of space"), null;
    let o = 0;
    for (let s3 = 0; s3 < e.length; s3++) o += e[s3];
    if (o !== 0) {
      let s3 = this.width / o, l = this.getDashRanges(e, this.width, s3);
      t ? this.addRoundDash(l, s3, i) : this.addRegularDash(l);
    }
    let a = { y: (this.nextRow + i + 0.5) / this.height, height: 2 * i / this.height, width: o };
    return this.nextRow += n, this.dirty = true, a;
  }
  bind(e) {
    let t = e.gl;
    this.texture ? (t.bindTexture(t.TEXTURE_2D, this.texture), this.dirty && (this.dirty = false, t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, this.width, this.height, t.ALPHA, t.UNSIGNED_BYTE, this.data))) : (this.texture = t.createTexture(), t.bindTexture(t.TEXTURE_2D, this.texture), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.REPEAT), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.REPEAT), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.LINEAR), t.texImage2D(t.TEXTURE_2D, 0, t.ALPHA, this.width, this.height, 0, t.ALPHA, t.UNSIGNED_BYTE, this.data));
  }
};
c();
c();
c();
var wl = class {
  constructor(e) {
    this._methodToThrottle = e, this._triggered = false, typeof MessageChannel < "u" && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
      this._triggered = false, this._methodToThrottle();
    });
  }
  trigger() {
    this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout(() => {
      this._triggered = false, this._methodToThrottle();
    }, 0));
  }
  remove() {
    delete this._channel, this._methodToThrottle = () => {
    };
  }
};
var Sl = class {
  constructor(e, t) {
    this.target = e, this.mapId = t, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new wl(() => this.process()), this.subscription = yf(this.target, "message", (i) => this.receive(i), false), this.globalScope = Qt(self) ? e : window;
  }
  registerMessageHandler(e, t) {
    this.messageHandlers[e] = t;
  }
  sendAsync(e, t) {
    return new Promise((i, n) => {
      let o = Math.round(Math.random() * 1e18).toString(36).substring(0, 10);
      this.resolveRejects[o] = { resolve: i, reject: n }, t && t.signal.addEventListener("abort", () => {
        delete this.resolveRejects[o];
        let l = { id: o, type: "<cancel>", origin: location.origin, targetMapId: e.targetMapId, sourceMapId: this.mapId };
        this.target.postMessage(l);
      }, { once: true });
      let a = [], s3 = { ...e, id: o, sourceMapId: this.mapId, origin: location.origin, data: zi(e.data, a) };
      this.target.postMessage(s3, { transfer: a });
    });
  }
  receive(e) {
    let t = e.data, i = t.id;
    if (!(t.origin !== "file://" && location.origin !== "file://" && t.origin !== location.origin) && !(t.targetMapId && this.mapId !== t.targetMapId)) {
      if (t.type === "<cancel>") {
        delete this.tasks[i];
        let n = this.abortControllers[i];
        delete this.abortControllers[i], n && n.abort();
        return;
      }
      if (Qt(self) || t.mustQueue) {
        this.tasks[i] = t, this.taskQueue.push(i), this.invoker.trigger();
        return;
      }
      this.processTask(i, t);
    }
  }
  process() {
    if (this.taskQueue.length === 0) return;
    let e = this.taskQueue.shift(), t = this.tasks[e];
    delete this.tasks[e], this.taskQueue.length > 0 && this.invoker.trigger(), t && this.processTask(e, t);
  }
  async processTask(e, t) {
    if (t.type === "<response>") {
      let o = this.resolveRejects[e];
      if (delete this.resolveRejects[e], !o) return;
      t.error ? o.reject(Fi(t.error)) : o.resolve(Fi(t.data));
      return;
    }
    if (!this.messageHandlers[t.type]) {
      this.completeTask(e, new Error("Could not find a registered handler for ".concat(t.type, ", map ID: ").concat(this.mapId, ", available handlers: ").concat(Object.keys(this.messageHandlers).join(", "))));
      return;
    }
    let i = Fi(t.data), n = new AbortController();
    this.abortControllers[e] = n;
    try {
      let o = await this.messageHandlers[t.type](t.sourceMapId, i, n);
      this.completeTask(e, null, o);
    } catch (o) {
      this.completeTask(e, o);
    }
  }
  completeTask(e, t, i) {
    let n = [];
    delete this.abortControllers[e];
    let o = { id: e, type: "<response>", sourceMapId: this.mapId, origin: location.origin, error: t ? zi(t) : null, data: zi(i, n) };
    this.target.postMessage(o, { transfer: n });
  }
  remove() {
    this.invoker.remove(), this.subscription.unsubscribe();
  }
};
c();
c();
c();
c();
var ig = `(()=>{var by=Object.create;var Ba=Object.defineProperty;var vy=Object.getOwnPropertyDescriptor;var Py=Object.getOwnPropertyNames;var Sy=Object.getPrototypeOf,wy=Object.prototype.hasOwnProperty;var Ae=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),Ll=(e,t)=>{for(var r in t)Ba(e,r,{get:t[r],enumerable:!0})},Ay=(e,t,r,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let i of Py(t))!wy.call(e,i)&&i!==r&&Ba(e,i,{get:()=>t[i],enumerable:!(n=vy(t,i))||n.enumerable});return e};var Z=(e,t,r)=>(r=e!=null?by(Sy(e)):{},Ay(t||!e||!e.__esModule?Ba(r,"default",{value:e,enumerable:!0}):r,e));var he=Ae((l0,Dl)=>{"use strict";Dl.exports=or;function or(e,t){this.x=e,this.y=t}or.prototype={clone:function(){return new or(this.x,this.y)},add:function(e){return this.clone()._add(e)},sub:function(e){return this.clone()._sub(e)},multByPoint:function(e){return this.clone()._multByPoint(e)},divByPoint:function(e){return this.clone()._divByPoint(e)},mult:function(e){return this.clone()._mult(e)},div:function(e){return this.clone()._div(e)},rotate:function(e){return this.clone()._rotate(e)},rotateAround:function(e,t){return this.clone()._rotateAround(e,t)},matMult:function(e){return this.clone()._matMult(e)},unit:function(){return this.clone()._unit()},perp:function(){return this.clone()._perp()},round:function(){return this.clone()._round()},mag:function(){return Math.sqrt(this.x*this.x+this.y*this.y)},equals:function(e){return this.x===e.x&&this.y===e.y},dist:function(e){return Math.sqrt(this.distSqr(e))},distSqr:function(e){var t=e.x-this.x,r=e.y-this.y;return t*t+r*r},angle:function(){return Math.atan2(this.y,this.x)},angleTo:function(e){return Math.atan2(this.y-e.y,this.x-e.x)},angleWith:function(e){return this.angleWithSep(e.x,e.y)},angleWithSep:function(e,t){return Math.atan2(this.x*t-this.y*e,this.x*e+this.y*t)},_matMult:function(e){var t=e[0]*this.x+e[1]*this.y,r=e[2]*this.x+e[3]*this.y;return this.x=t,this.y=r,this},_add:function(e){return this.x+=e.x,this.y+=e.y,this},_sub:function(e){return this.x-=e.x,this.y-=e.y,this},_mult:function(e){return this.x*=e,this.y*=e,this},_div:function(e){return this.x/=e,this.y/=e,this},_multByPoint:function(e){return this.x*=e.x,this.y*=e.y,this},_divByPoint:function(e){return this.x/=e.x,this.y/=e.y,this},_unit:function(){return this._div(this.mag()),this},_perp:function(){var e=this.y;return this.y=this.x,this.x=-e,this},_rotate:function(e){var t=Math.cos(e),r=Math.sin(e),n=t*this.x-r*this.y,i=r*this.x+t*this.y;return this.x=n,this.y=i,this},_rotateAround:function(e,t){var r=Math.cos(e),n=Math.sin(e),i=t.x+r*(this.x-t.x)-n*(this.y-t.y),o=t.y+n*(this.x-t.x)+r*(this.y-t.y);return this.x=i,this.y=o,this},_round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}};or.convert=function(e){return e instanceof or?e:Array.isArray(e)?new or(e[0],e[1]):e}});var zl=Ae((u0,Bl)=>{"use strict";Bl.exports=Vl;function Vl(e,t,r,n){this.cx=3*e,this.bx=3*(r-e)-this.cx,this.ax=1-this.cx-this.bx,this.cy=3*t,this.by=3*(n-t)-this.cy,this.ay=1-this.cy-this.by,this.p1x=e,this.p1y=t,this.p2x=r,this.p2y=n}Vl.prototype={sampleCurveX:function(e){return((this.ax*e+this.bx)*e+this.cx)*e},sampleCurveY:function(e){return((this.ay*e+this.by)*e+this.cy)*e},sampleCurveDerivativeX:function(e){return(3*this.ax*e+2*this.bx)*e+this.cx},solveCurveX:function(e,t){if(t===void 0&&(t=1e-6),e<0)return 0;if(e>1)return 1;for(var r=e,n=0;n<8;n++){var i=this.sampleCurveX(r)-e;if(Math.abs(i)<t)return r;var o=this.sampleCurveDerivativeX(r);if(Math.abs(o)<1e-6)break;r=r-i/o}var a=0,s=1;for(r=e,n=0;n<20&&(i=this.sampleCurveX(r),!(Math.abs(i-e)<t));n++)e>i?a=r:s=r,r=(s-a)*.5+a;return r},solve:function(e,t){return this.sampleCurveY(this.solveCurveX(e,t))}}});var Ac=Ae(($v,As)=>{function sd(e,t){var r,n,i,o,a,s,l,u,c,p;for(r=e.length&3,n=e.length-r,i=t,a=3432918353,l=461845907,p=0;p<n;)c=e.charCodeAt(p)&255|(e.charCodeAt(++p)&255)<<8|(e.charCodeAt(++p)&255)<<16|(e.charCodeAt(++p)&255)<<24,++p,c=(c&65535)*a+(((c>>>16)*a&65535)<<16)&4294967295,c=c<<15|c>>>17,c=(c&65535)*l+(((c>>>16)*l&65535)<<16)&4294967295,i^=c,i=i<<13|i>>>19,o=(i&65535)*5+(((i>>>16)*5&65535)<<16)&4294967295,i=(o&65535)+27492+(((o>>>16)+58964&65535)<<16);switch(c=0,r){case 3:c^=(e.charCodeAt(p+2)&255)<<16;case 2:c^=(e.charCodeAt(p+1)&255)<<8;case 1:c^=e.charCodeAt(p)&255,c=(c&65535)*a+(((c>>>16)*a&65535)<<16)&4294967295,c=c<<15|c>>>17,c=(c&65535)*l+(((c>>>16)*l&65535)<<16)&4294967295,i^=c}return i^=e.length,i^=i>>>16,i=(i&65535)*2246822507+(((i>>>16)*2246822507&65535)<<16)&4294967295,i^=i>>>13,i=(i&65535)*3266489909+(((i>>>16)*3266489909&65535)<<16)&4294967295,i^=i>>>16,i>>>0}typeof As<"u"&&(As.exports=sd)});var _c=Ae((Gv,_s)=>{function ld(e,t){for(var r=e.length,n=t^r,i=0,o;r>=4;)o=e.charCodeAt(i)&255|(e.charCodeAt(++i)&255)<<8|(e.charCodeAt(++i)&255)<<16|(e.charCodeAt(++i)&255)<<24,o=(o&65535)*1540483477+(((o>>>16)*1540483477&65535)<<16),o^=o>>>24,o=(o&65535)*1540483477+(((o>>>16)*1540483477&65535)<<16),n=(n&65535)*1540483477+(((n>>>16)*1540483477&65535)<<16)^o,r-=4,++i;switch(r){case 3:n^=(e.charCodeAt(i+2)&255)<<16;case 2:n^=(e.charCodeAt(i+1)&255)<<8;case 1:n^=e.charCodeAt(i)&255,n=(n&65535)*1540483477+(((n>>>16)*1540483477&65535)<<16)}return n^=n>>>13,n=(n&65535)*1540483477+(((n>>>16)*1540483477&65535)<<16),n^=n>>>15,n>>>0}typeof _s!==void 0&&(_s.exports=ld)});var Is=Ae((qv,Mo)=>{var Ic=Ac(),ud=_c();Mo.exports=Ic;Mo.exports.murmur3=Ic;Mo.exports.murmur2=ud});var Os=Ae((BP,Rs)=>{"use strict";Rs.exports=Go;Rs.exports.default=Go;function Go(e,t,r){r=r||2;var n=t&&t.length,i=n?t[0]*r:e.length,o=fp(e,0,i,r,!0),a=[];if(!o||o.next===o.prev)return a;var s,l,u,c,p,f,y;if(n&&(o=Hg(e,t,o,r)),e.length>80*r){s=u=e[0],l=c=e[1];for(var m=r;m<i;m+=r)p=e[m],f=e[m+1],p<s&&(s=p),f<l&&(l=f),p>u&&(u=p),f>c&&(c=f);y=Math.max(u-s,c-l),y=y!==0?32767/y:0}return Zn(o,a,r,s,l,y,0),a}function fp(e,t,r,n,i){var o,a;if(i===zs(e,t,r,n)>0)for(o=t;o<r;o+=n)a=pp(o,e[o],e[o+1],a);else for(o=r-n;o>=t;o-=n)a=pp(o,e[o],e[o+1],a);return a&&qo(a,a.next)&&(Hn(a),a=a.next),a}function Qt(e,t){if(!e)return e;t||(t=e);var r=e,n;do if(n=!1,!r.steiner&&(qo(r,r.next)||oe(r.prev,r,r.next)===0)){if(Hn(r),r=t=r.prev,r===r.next)break;n=!0}else r=r.next;while(n||r!==t);return t}function Zn(e,t,r,n,i,o,a){if(e){!a&&o&&ex(e,n,i,o);for(var s=e,l,u;e.prev!==e.next;){if(l=e.prev,u=e.next,o?Jg(e,n,i,o):jg(e)){t.push(l.i/r|0),t.push(e.i/r|0),t.push(u.i/r|0),Hn(e),e=u.next,s=u.next;continue}if(e=u,e===s){a?a===1?(e=Zg(Qt(e),t,r),Zn(e,t,r,n,i,o,2)):a===2&&Wg(e,t,r,n,i,o):Zn(Qt(e),t,r,n,i,o,1);break}}}}function jg(e){var t=e.prev,r=e,n=e.next;if(oe(t,r,n)>=0)return!1;for(var i=t.x,o=r.x,a=n.x,s=t.y,l=r.y,u=n.y,c=i<o?i<a?i:a:o<a?o:a,p=s<l?s<u?s:u:l<u?l:u,f=i>o?i>a?i:a:o>a?o:a,y=s>l?s>u?s:u:l>u?l:u,m=n.next;m!==t;){if(m.x>=c&&m.x<=f&&m.y>=p&&m.y<=y&&Ar(i,s,o,l,a,u,m.x,m.y)&&oe(m.prev,m,m.next)>=0)return!1;m=m.next}return!0}function Jg(e,t,r,n){var i=e.prev,o=e,a=e.next;if(oe(i,o,a)>=0)return!1;for(var s=i.x,l=o.x,u=a.x,c=i.y,p=o.y,f=a.y,y=s<l?s<u?s:u:l<u?l:u,m=c<p?c<f?c:f:p<f?p:f,h=s>l?s>u?s:u:l>u?l:u,d=c>p?c>f?c:f:p>f?p:f,g=Vs(y,m,t,r,n),b=Vs(h,d,t,r,n),x=e.prevZ,v=e.nextZ;x&&x.z>=g&&v&&v.z<=b;){if(x.x>=y&&x.x<=h&&x.y>=m&&x.y<=d&&x!==i&&x!==a&&Ar(s,c,l,p,u,f,x.x,x.y)&&oe(x.prev,x,x.next)>=0||(x=x.prevZ,v.x>=y&&v.x<=h&&v.y>=m&&v.y<=d&&v!==i&&v!==a&&Ar(s,c,l,p,u,f,v.x,v.y)&&oe(v.prev,v,v.next)>=0))return!1;v=v.nextZ}for(;x&&x.z>=g;){if(x.x>=y&&x.x<=h&&x.y>=m&&x.y<=d&&x!==i&&x!==a&&Ar(s,c,l,p,u,f,x.x,x.y)&&oe(x.prev,x,x.next)>=0)return!1;x=x.prevZ}for(;v&&v.z<=b;){if(v.x>=y&&v.x<=h&&v.y>=m&&v.y<=d&&v!==i&&v!==a&&Ar(s,c,l,p,u,f,v.x,v.y)&&oe(v.prev,v,v.next)>=0)return!1;v=v.nextZ}return!0}function Zg(e,t,r){var n=e;do{var i=n.prev,o=n.next.next;!qo(i,o)&&yp(i,n,n.next,o)&&Wn(i,o)&&Wn(o,i)&&(t.push(i.i/r|0),t.push(n.i/r|0),t.push(o.i/r|0),Hn(n),Hn(n.next),n=e=o),n=n.next}while(n!==e);return Qt(n)}function Wg(e,t,r,n,i,o){var a=e;do{for(var s=a.next.next;s!==a.prev;){if(a.i!==s.i&&nx(a,s)){var l=mp(a,s);a=Qt(a,a.next),l=Qt(l,l.next),Zn(a,t,r,n,i,o,0),Zn(l,t,r,n,i,o,0);return}s=s.next}a=a.next}while(a!==e)}function Hg(e,t,r,n){var i=[],o,a,s,l,u;for(o=0,a=t.length;o<a;o++)s=t[o]*n,l=o<a-1?t[o+1]*n:e.length,u=fp(e,s,l,n,!1),u===u.next&&(u.steiner=!0),i.push(rx(u));for(i.sort(Xg),o=0;o<i.length;o++)r=Kg(i[o],r);return r}function Xg(e,t){return e.x-t.x}function Kg(e,t){var r=Yg(e,t);if(!r)return t;var n=mp(r,e);return Qt(n,n.next),Qt(r,r.next)}function Yg(e,t){var r=t,n=e.x,i=e.y,o=-1/0,a;do{if(i<=r.y&&i>=r.next.y&&r.next.y!==r.y){var s=r.x+(i-r.y)*(r.next.x-r.x)/(r.next.y-r.y);if(s<=n&&s>o&&(o=s,a=r.x<r.next.x?r:r.next,s===n))return a}r=r.next}while(r!==t);if(!a)return null;var l=a,u=a.x,c=a.y,p=1/0,f;r=a;do n>=r.x&&r.x>=u&&n!==r.x&&Ar(i<c?n:o,i,u,c,i<c?o:n,i,r.x,r.y)&&(f=Math.abs(i-r.y)/(n-r.x),Wn(r,e)&&(f<p||f===p&&(r.x>a.x||r.x===a.x&&Qg(a,r)))&&(a=r,p=f)),r=r.next;while(r!==l);return a}function Qg(e,t){return oe(e.prev,e,t.prev)<0&&oe(t.next,e,e.next)<0}function ex(e,t,r,n){var i=e;do i.z===0&&(i.z=Vs(i.x,i.y,t,r,n)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next;while(i!==e);i.prevZ.nextZ=null,i.prevZ=null,tx(i)}function tx(e){var t,r,n,i,o,a,s,l,u=1;do{for(r=e,e=null,o=null,a=0;r;){for(a++,n=r,s=0,t=0;t<u&&(s++,n=n.nextZ,!!n);t++);for(l=u;s>0||l>0&&n;)s!==0&&(l===0||!n||r.z<=n.z)?(i=r,r=r.nextZ,s--):(i=n,n=n.nextZ,l--),o?o.nextZ=i:e=i,i.prevZ=o,o=i;r=n}o.nextZ=null,u*=2}while(a>1);return e}function Vs(e,t,r,n,i){return e=(e-r)*i|0,t=(t-n)*i|0,e=(e|e<<8)&16711935,e=(e|e<<4)&252645135,e=(e|e<<2)&858993459,e=(e|e<<1)&1431655765,t=(t|t<<8)&16711935,t=(t|t<<4)&252645135,t=(t|t<<2)&858993459,t=(t|t<<1)&1431655765,e|t<<1}function rx(e){var t=e,r=e;do(t.x<r.x||t.x===r.x&&t.y<r.y)&&(r=t),t=t.next;while(t!==e);return r}function Ar(e,t,r,n,i,o,a,s){return(i-a)*(t-s)>=(e-a)*(o-s)&&(e-a)*(n-s)>=(r-a)*(t-s)&&(r-a)*(o-s)>=(i-a)*(n-s)}function nx(e,t){return e.next.i!==t.i&&e.prev.i!==t.i&&!ix(e,t)&&(Wn(e,t)&&Wn(t,e)&&ox(e,t)&&(oe(e.prev,e,t.prev)||oe(e,t.prev,t))||qo(e,t)&&oe(e.prev,e,e.next)>0&&oe(t.prev,t,t.next)>0)}function oe(e,t,r){return(t.y-e.y)*(r.x-t.x)-(t.x-e.x)*(r.y-t.y)}function qo(e,t){return e.x===t.x&&e.y===t.y}function yp(e,t,r,n){var i=$o(oe(e,t,r)),o=$o(oe(e,t,n)),a=$o(oe(r,n,e)),s=$o(oe(r,n,t));return!!(i!==o&&a!==s||i===0&&Uo(e,r,t)||o===0&&Uo(e,n,t)||a===0&&Uo(r,e,n)||s===0&&Uo(r,t,n))}function Uo(e,t,r){return t.x<=Math.max(e.x,r.x)&&t.x>=Math.min(e.x,r.x)&&t.y<=Math.max(e.y,r.y)&&t.y>=Math.min(e.y,r.y)}function $o(e){return e>0?1:e<0?-1:0}function ix(e,t){var r=e;do{if(r.i!==e.i&&r.next.i!==e.i&&r.i!==t.i&&r.next.i!==t.i&&yp(r,r.next,e,t))return!0;r=r.next}while(r!==e);return!1}function Wn(e,t){return oe(e.prev,e,e.next)<0?oe(e,t,e.next)>=0&&oe(e,e.prev,t)>=0:oe(e,t,e.prev)<0||oe(e,e.next,t)<0}function ox(e,t){var r=e,n=!1,i=(e.x+t.x)/2,o=(e.y+t.y)/2;do r.y>o!=r.next.y>o&&r.next.y!==r.y&&i<(r.next.x-r.x)*(o-r.y)/(r.next.y-r.y)+r.x&&(n=!n),r=r.next;while(r!==e);return n}function mp(e,t){var r=new Bs(e.i,e.x,e.y),n=new Bs(t.i,t.x,t.y),i=e.next,o=t.prev;return e.next=t,t.prev=e,r.next=i,i.prev=r,n.next=r,r.prev=n,o.next=n,n.prev=o,n}function pp(e,t,r,n){var i=new Bs(e,t,r);return n?(i.next=n.next,i.prev=n,n.next.prev=i,n.next=i):(i.prev=i,i.next=i),i}function Hn(e){e.next.prev=e.prev,e.prev.next=e.next,e.prevZ&&(e.prevZ.nextZ=e.nextZ),e.nextZ&&(e.nextZ.prevZ=e.prevZ)}function Bs(e,t,r){this.i=e,this.x=t,this.y=r,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}Go.deviation=function(e,t,r,n){var i=t&&t.length,o=i?t[0]*r:e.length,a=Math.abs(zs(e,0,o,r));if(i)for(var s=0,l=t.length;s<l;s++){var u=t[s]*r,c=s<l-1?t[s+1]*r:e.length;a-=Math.abs(zs(e,u,c,r))}var p=0;for(s=0;s<n.length;s+=3){var f=n[s]*r,y=n[s+1]*r,m=n[s+2]*r;p+=Math.abs((e[f]-e[m])*(e[y+1]-e[f+1])-(e[f]-e[y])*(e[m+1]-e[f+1]))}return a===0&&p===0?0:Math.abs((p-a)/a)};function zs(e,t,r,n){for(var i=0,o=t,a=r-n;o<r;o+=n)i+=(e[a]-e[o])*(e[o+1]+e[a+1]),a=o;return i}Go.flatten=function(e){for(var t=e[0][0].length,r={vertices:[],holes:[],dimensions:t},n=0,i=0;i<e.length;i++){for(var o=0;o<e[i].length;o++)for(var a=0;a<t;a++)r.vertices.push(e[i][o][a]);i>0&&(n+=e[i-1].length,r.holes.push(n))}return r}});var Us=Ae((bS,Sp)=>{"use strict";var fx=he();Sp.exports=Cr;function Cr(e,t,r,n,i){this.properties={},this.extent=r,this.type=0,this._pbf=e,this._geometry=-1,this._keys=n,this._values=i,e.readFields(yx,this,t)}function yx(e,t,r){e==1?t.id=r.readVarint():e==2?mx(r,t):e==3?t.type=r.readVarint():e==4&&(t._geometry=r.pos)}function mx(e,t){for(var r=e.readVarint()+e.pos;e.pos<r;){var n=t._keys[e.readVarint()],i=t._values[e.readVarint()];t.properties[n]=i}}Cr.types=["Unknown","Point","LineString","Polygon"];Cr.prototype.loadGeometry=function(){var e=this._pbf;e.pos=this._geometry;for(var t=e.readVarint()+e.pos,r=1,n=0,i=0,o=0,a=[],s;e.pos<t;){if(n<=0){var l=e.readVarint();r=l&7,n=l>>3}if(n--,r===1||r===2)i+=e.readSVarint(),o+=e.readSVarint(),r===1&&(s&&a.push(s),s=[]),s.push(new fx(i,o));else if(r===7)s&&s.push(s[0].clone());else throw new Error("unknown command "+r)}return s&&a.push(s),a};Cr.prototype.bbox=function(){var e=this._pbf;e.pos=this._geometry;for(var t=e.readVarint()+e.pos,r=1,n=0,i=0,o=0,a=1/0,s=-1/0,l=1/0,u=-1/0;e.pos<t;){if(n<=0){var c=e.readVarint();r=c&7,n=c>>3}if(n--,r===1||r===2)i+=e.readSVarint(),o+=e.readSVarint(),i<a&&(a=i),i>s&&(s=i),o<l&&(l=o),o>u&&(u=o);else if(r!==7)throw new Error("unknown command "+r)}return[a,l,s,u]};Cr.prototype.toGeoJSON=function(e,t,r){var n=this.extent*Math.pow(2,r),i=this.extent*e,o=this.extent*t,a=this.loadGeometry(),s=Cr.types[this.type],l,u;function c(y){for(var m=0;m<y.length;m++){var h=y[m],d=180-(h.y+o)*360/n;y[m]=[(h.x+i)*360/n-180,360/Math.PI*Math.atan(Math.exp(d*Math.PI/180))-90]}}switch(this.type){case 1:var p=[];for(l=0;l<a.length;l++)p[l]=a[l][0];a=p,c(a);break;case 2:for(l=0;l<a.length;l++)c(a[l]);break;case 3:for(a=hx(a),l=0;l<a.length;l++)for(u=0;u<a[l].length;u++)c(a[l][u]);break}a.length===1?a=a[0]:s="Multi"+s;var f={type:"Feature",geometry:{type:s,coordinates:a},properties:this.properties};return"id"in this&&(f.id=this.id),f};function hx(e){var t=e.length;if(t<=1)return[e];for(var r=[],n,i,o=0;o<t;o++){var a=dx(e[o]);a!==0&&(i===void 0&&(i=a<0),i===a<0?(n&&r.push(n),n=[e[o]]):n.push(e[o]))}return n&&r.push(n),r}function dx(e){for(var t=0,r=0,n=e.length,i=n-1,o,a;r<n;i=r++)o=e[r],a=e[i],t+=(a.x-o.x)*(o.y+a.y);return t}});var $s=Ae((vS,Ap)=>{"use strict";var gx=Us();Ap.exports=wp;function wp(e,t){this.version=1,this.name=null,this.extent=4096,this.length=0,this._pbf=e,this._keys=[],this._values=[],this._features=[],e.readFields(xx,this,t),this.length=this._features.length}function xx(e,t,r){e===15?t.version=r.readVarint():e===1?t.name=r.readString():e===5?t.extent=r.readVarint():e===2?t._features.push(r.pos):e===3?t._keys.push(r.readString()):e===4&&t._values.push(bx(r))}function bx(e){for(var t=null,r=e.readVarint()+e.pos;e.pos<r;){var n=e.readVarint()>>3;t=n===1?e.readString():n===2?e.readFloat():n===3?e.readDouble():n===4?e.readVarint64():n===5?e.readVarint():n===6?e.readSVarint():n===7?e.readBoolean():null}return t}wp.prototype.feature=function(e){if(e<0||e>=this._features.length)throw new Error("feature index out of bounds");this._pbf.pos=this._features[e];var t=this._pbf.readVarint()+this._pbf.pos;return new gx(this._pbf,t,this.extent,this._keys,this._values)}});var Ip=Ae((PS,_p)=>{"use strict";var vx=$s();_p.exports=Px;function Px(e,t){this.layers=e.readFields(Sx,{},t)}function Sx(e,t,r){if(e===3){var n=new vx(r,r.readVarint()+r.pos);n.length&&(t[n.name]=n)}}});var Tt=Ae((SS,Jo)=>{Jo.exports.VectorTile=Ip();Jo.exports.VectorTileFeature=Us();Jo.exports.VectorTileLayer=$s()});var Zp=Ae(Zs=>{Zs.read=function(e,t,r,n,i){var o,a,s=i*8-n-1,l=(1<<s)-1,u=l>>1,c=-7,p=r?i-1:0,f=r?-1:1,y=e[t+p];for(p+=f,o=y&(1<<-c)-1,y>>=-c,c+=s;c>0;o=o*256+e[t+p],p+=f,c-=8);for(a=o&(1<<-c)-1,o>>=-c,c+=n;c>0;a=a*256+e[t+p],p+=f,c-=8);if(o===0)o=1-u;else{if(o===l)return a?NaN:(y?-1:1)*(1/0);a=a+Math.pow(2,n),o=o-u}return(y?-1:1)*a*Math.pow(2,o-n)};Zs.write=function(e,t,r,n,i,o){var a,s,l,u=o*8-i-1,c=(1<<u)-1,p=c>>1,f=i===23?Math.pow(2,-24)-Math.pow(2,-77):0,y=n?0:o-1,m=n?1:-1,h=t<0||t===0&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(s=isNaN(t)?1:0,a=c):(a=Math.floor(Math.log(t)/Math.LN2),t*(l=Math.pow(2,-a))<1&&(a--,l*=2),a+p>=1?t+=f/l:t+=f*Math.pow(2,1-p),t*l>=2&&(a++,l/=2),a+p>=c?(s=0,a=c):a+p>=1?(s=(t*l-1)*Math.pow(2,i),a=a+p):(s=t*Math.pow(2,p-1)*Math.pow(2,i),a=0));i>=8;e[r+y]=s&255,y+=m,s/=256,i-=8);for(a=a<<i|s,u+=i;u>0;e[r+y]=a&255,y+=m,a/=256,u-=8);e[r+y-m]|=h*128}});var Qn=Ae((i2,Yp)=>{"use strict";Yp.exports=J;var Ko=Zp();function J(e){this.buf=ArrayBuffer.isView&&ArrayBuffer.isView(e)?e:new Uint8Array(e||0),this.pos=0,this.type=0,this.length=this.buf.length}J.Varint=0;J.Fixed64=1;J.Bytes=2;J.Fixed32=5;var Ws=65536*65536,Wp=1/Ws,Ux=12,Kp=typeof TextDecoder>"u"?null:new TextDecoder("utf8");J.prototype={destroy:function(){this.buf=null},readFields:function(e,t,r){for(r=r||this.length;this.pos<r;){var n=this.readVarint(),i=n>>3,o=this.pos;this.type=n&7,e(i,t,this),this.pos===o&&this.skip(n)}return t},readMessage:function(e,t){return this.readFields(e,t,this.readVarint()+this.pos)},readFixed32:function(){var e=Yo(this.buf,this.pos);return this.pos+=4,e},readSFixed32:function(){var e=Xp(this.buf,this.pos);return this.pos+=4,e},readFixed64:function(){var e=Yo(this.buf,this.pos)+Yo(this.buf,this.pos+4)*Ws;return this.pos+=8,e},readSFixed64:function(){var e=Yo(this.buf,this.pos)+Xp(this.buf,this.pos+4)*Ws;return this.pos+=8,e},readFloat:function(){var e=Ko.read(this.buf,this.pos,!0,23,4);return this.pos+=4,e},readDouble:function(){var e=Ko.read(this.buf,this.pos,!0,52,8);return this.pos+=8,e},readVarint:function(e){var t=this.buf,r,n;return n=t[this.pos++],r=n&127,n<128||(n=t[this.pos++],r|=(n&127)<<7,n<128)||(n=t[this.pos++],r|=(n&127)<<14,n<128)||(n=t[this.pos++],r|=(n&127)<<21,n<128)?r:(n=t[this.pos],r|=(n&15)<<28,$x(r,e,this))},readVarint64:function(){return this.readVarint(!0)},readSVarint:function(){var e=this.readVarint();return e%2===1?(e+1)/-2:e/2},readBoolean:function(){return!!this.readVarint()},readString:function(){var e=this.readVarint()+this.pos,t=this.pos;return this.pos=e,e-t>=Ux&&Kp?rb(this.buf,t,e):tb(this.buf,t,e)},readBytes:function(){var e=this.readVarint()+this.pos,t=this.buf.subarray(this.pos,e);return this.pos=e,t},readPackedVarint:function(e,t){if(this.type!==J.Bytes)return e.push(this.readVarint(t));var r=ct(this);for(e=e||[];this.pos<r;)e.push(this.readVarint(t));return e},readPackedSVarint:function(e){if(this.type!==J.Bytes)return e.push(this.readSVarint());var t=ct(this);for(e=e||[];this.pos<t;)e.push(this.readSVarint());return e},readPackedBoolean:function(e){if(this.type!==J.Bytes)return e.push(this.readBoolean());var t=ct(this);for(e=e||[];this.pos<t;)e.push(this.readBoolean());return e},readPackedFloat:function(e){if(this.type!==J.Bytes)return e.push(this.readFloat());var t=ct(this);for(e=e||[];this.pos<t;)e.push(this.readFloat());return e},readPackedDouble:function(e){if(this.type!==J.Bytes)return e.push(this.readDouble());var t=ct(this);for(e=e||[];this.pos<t;)e.push(this.readDouble());return e},readPackedFixed32:function(e){if(this.type!==J.Bytes)return e.push(this.readFixed32());var t=ct(this);for(e=e||[];this.pos<t;)e.push(this.readFixed32());return e},readPackedSFixed32:function(e){if(this.type!==J.Bytes)return e.push(this.readSFixed32());var t=ct(this);for(e=e||[];this.pos<t;)e.push(this.readSFixed32());return e},readPackedFixed64:function(e){if(this.type!==J.Bytes)return e.push(this.readFixed64());var t=ct(this);for(e=e||[];this.pos<t;)e.push(this.readFixed64());return e},readPackedSFixed64:function(e){if(this.type!==J.Bytes)return e.push(this.readSFixed64());var t=ct(this);for(e=e||[];this.pos<t;)e.push(this.readSFixed64());return e},skip:function(e){var t=e&7;if(t===J.Varint)for(;this.buf[this.pos++]>127;);else if(t===J.Bytes)this.pos=this.readVarint()+this.pos;else if(t===J.Fixed32)this.pos+=4;else if(t===J.Fixed64)this.pos+=8;else throw new Error("Unimplemented type: "+t)},writeTag:function(e,t){this.writeVarint(e<<3|t)},realloc:function(e){for(var t=this.length||16;t<this.pos+e;)t*=2;if(t!==this.length){var r=new Uint8Array(t);r.set(this.buf),this.buf=r,this.length=t}},finish:function(){return this.length=this.pos,this.pos=0,this.buf.subarray(0,this.length)},writeFixed32:function(e){this.realloc(4),Er(this.buf,e,this.pos),this.pos+=4},writeSFixed32:function(e){this.realloc(4),Er(this.buf,e,this.pos),this.pos+=4},writeFixed64:function(e){this.realloc(8),Er(this.buf,e&-1,this.pos),Er(this.buf,Math.floor(e*Wp),this.pos+4),this.pos+=8},writeSFixed64:function(e){this.realloc(8),Er(this.buf,e&-1,this.pos),Er(this.buf,Math.floor(e*Wp),this.pos+4),this.pos+=8},writeVarint:function(e){if(e=+e||0,e>268435455||e<0){Gx(e,this);return}this.realloc(4),this.buf[this.pos++]=e&127|(e>127?128:0),!(e<=127)&&(this.buf[this.pos++]=(e>>>=7)&127|(e>127?128:0),!(e<=127)&&(this.buf[this.pos++]=(e>>>=7)&127|(e>127?128:0),!(e<=127)&&(this.buf[this.pos++]=e>>>7&127)))},writeSVarint:function(e){this.writeVarint(e<0?-e*2-1:e*2)},writeBoolean:function(e){this.writeVarint(!!e)},writeString:function(e){e=String(e),this.realloc(e.length*4),this.pos++;var t=this.pos;this.pos=nb(this.buf,e,this.pos);var r=this.pos-t;r>=128&&Hp(t,r,this),this.pos=t-1,this.writeVarint(r),this.pos+=r},writeFloat:function(e){this.realloc(4),Ko.write(this.buf,e,this.pos,!0,23,4),this.pos+=4},writeDouble:function(e){this.realloc(8),Ko.write(this.buf,e,this.pos,!0,52,8),this.pos+=8},writeBytes:function(e){var t=e.length;this.writeVarint(t),this.realloc(t);for(var r=0;r<t;r++)this.buf[this.pos++]=e[r]},writeRawMessage:function(e,t){this.pos++;var r=this.pos;e(t,this);var n=this.pos-r;n>=128&&Hp(r,n,this),this.pos=r-1,this.writeVarint(n),this.pos+=n},writeMessage:function(e,t,r){this.writeTag(e,J.Bytes),this.writeRawMessage(t,r)},writePackedVarint:function(e,t){t.length&&this.writeMessage(e,Jx,t)},writePackedSVarint:function(e,t){t.length&&this.writeMessage(e,Zx,t)},writePackedBoolean:function(e,t){t.length&&this.writeMessage(e,Xx,t)},writePackedFloat:function(e,t){t.length&&this.writeMessage(e,Wx,t)},writePackedDouble:function(e,t){t.length&&this.writeMessage(e,Hx,t)},writePackedFixed32:function(e,t){t.length&&this.writeMessage(e,Kx,t)},writePackedSFixed32:function(e,t){t.length&&this.writeMessage(e,Yx,t)},writePackedFixed64:function(e,t){t.length&&this.writeMessage(e,Qx,t)},writePackedSFixed64:function(e,t){t.length&&this.writeMessage(e,eb,t)},writeBytesField:function(e,t){this.writeTag(e,J.Bytes),this.writeBytes(t)},writeFixed32Field:function(e,t){this.writeTag(e,J.Fixed32),this.writeFixed32(t)},writeSFixed32Field:function(e,t){this.writeTag(e,J.Fixed32),this.writeSFixed32(t)},writeFixed64Field:function(e,t){this.writeTag(e,J.Fixed64),this.writeFixed64(t)},writeSFixed64Field:function(e,t){this.writeTag(e,J.Fixed64),this.writeSFixed64(t)},writeVarintField:function(e,t){this.writeTag(e,J.Varint),this.writeVarint(t)},writeSVarintField:function(e,t){this.writeTag(e,J.Varint),this.writeSVarint(t)},writeStringField:function(e,t){this.writeTag(e,J.Bytes),this.writeString(t)},writeFloatField:function(e,t){this.writeTag(e,J.Fixed32),this.writeFloat(t)},writeDoubleField:function(e,t){this.writeTag(e,J.Fixed64),this.writeDouble(t)},writeBooleanField:function(e,t){this.writeVarintField(e,!!t)}};function $x(e,t,r){var n=r.buf,i,o;if(o=n[r.pos++],i=(o&112)>>4,o<128||(o=n[r.pos++],i|=(o&127)<<3,o<128)||(o=n[r.pos++],i|=(o&127)<<10,o<128)||(o=n[r.pos++],i|=(o&127)<<17,o<128)||(o=n[r.pos++],i|=(o&127)<<24,o<128)||(o=n[r.pos++],i|=(o&1)<<31,o<128))return Mr(e,i,t);throw new Error("Expected varint not more than 10 bytes")}function ct(e){return e.type===J.Bytes?e.readVarint()+e.pos:e.pos+1}function Mr(e,t,r){return r?t*4294967296+(e>>>0):(t>>>0)*4294967296+(e>>>0)}function Gx(e,t){var r,n;if(e>=0?(r=e%4294967296|0,n=e/4294967296|0):(r=~(-e%4294967296),n=~(-e/4294967296),r^4294967295?r=r+1|0:(r=0,n=n+1|0)),e>=18446744073709552e3||e<-18446744073709552e3)throw new Error("Given varint doesn't fit into 10 bytes");t.realloc(10),qx(r,n,t),jx(n,t)}function qx(e,t,r){r.buf[r.pos++]=e&127|128,e>>>=7,r.buf[r.pos++]=e&127|128,e>>>=7,r.buf[r.pos++]=e&127|128,e>>>=7,r.buf[r.pos++]=e&127|128,e>>>=7,r.buf[r.pos]=e&127}function jx(e,t){var r=(e&7)<<4;t.buf[t.pos++]|=r|((e>>>=3)?128:0),e&&(t.buf[t.pos++]=e&127|((e>>>=7)?128:0),e&&(t.buf[t.pos++]=e&127|((e>>>=7)?128:0),e&&(t.buf[t.pos++]=e&127|((e>>>=7)?128:0),e&&(t.buf[t.pos++]=e&127|((e>>>=7)?128:0),e&&(t.buf[t.pos++]=e&127)))))}function Hp(e,t,r){var n=t<=16383?1:t<=2097151?2:t<=268435455?3:Math.floor(Math.log(t)/(Math.LN2*7));r.realloc(n);for(var i=r.pos-1;i>=e;i--)r.buf[i+n]=r.buf[i]}function Jx(e,t){for(var r=0;r<e.length;r++)t.writeVarint(e[r])}function Zx(e,t){for(var r=0;r<e.length;r++)t.writeSVarint(e[r])}function Wx(e,t){for(var r=0;r<e.length;r++)t.writeFloat(e[r])}function Hx(e,t){for(var r=0;r<e.length;r++)t.writeDouble(e[r])}function Xx(e,t){for(var r=0;r<e.length;r++)t.writeBoolean(e[r])}function Kx(e,t){for(var r=0;r<e.length;r++)t.writeFixed32(e[r])}function Yx(e,t){for(var r=0;r<e.length;r++)t.writeSFixed32(e[r])}function Qx(e,t){for(var r=0;r<e.length;r++)t.writeFixed64(e[r])}function eb(e,t){for(var r=0;r<e.length;r++)t.writeSFixed64(e[r])}function Yo(e,t){return(e[t]|e[t+1]<<8|e[t+2]<<16)+e[t+3]*16777216}function Er(e,t,r){e[r]=t,e[r+1]=t>>>8,e[r+2]=t>>>16,e[r+3]=t>>>24}function Xp(e,t){return(e[t]|e[t+1]<<8|e[t+2]<<16)+(e[t+3]<<24)}function tb(e,t,r){for(var n="",i=t;i<r;){var o=e[i],a=null,s=o>239?4:o>223?3:o>191?2:1;if(i+s>r)break;var l,u,c;s===1?o<128&&(a=o):s===2?(l=e[i+1],(l&192)===128&&(a=(o&31)<<6|l&63,a<=127&&(a=null))):s===3?(l=e[i+1],u=e[i+2],(l&192)===128&&(u&192)===128&&(a=(o&15)<<12|(l&63)<<6|u&63,(a<=2047||a>=55296&&a<=57343)&&(a=null))):s===4&&(l=e[i+1],u=e[i+2],c=e[i+3],(l&192)===128&&(u&192)===128&&(c&192)===128&&(a=(o&15)<<18|(l&63)<<12|(u&63)<<6|c&63,(a<=65535||a>=1114112)&&(a=null))),a===null?(a=65533,s=1):a>65535&&(a-=65536,n+=String.fromCharCode(a>>>10&1023|55296),a=56320|a&1023),n+=String.fromCharCode(a),i+=s}return n}function rb(e,t,r){return Kp.decode(e.subarray(t,r))}function nb(e,t,r){for(var n=0,i,o;n<t.length;n++){if(i=t.charCodeAt(n),i>55295&&i<57344)if(o)if(i<56320){e[r++]=239,e[r++]=191,e[r++]=189,o=i;continue}else i=o-55296<<10|i-56320|65536,o=null;else{i>56319||n+1===t.length?(e[r++]=239,e[r++]=191,e[r++]=189):o=i;continue}else o&&(e[r++]=239,e[r++]=191,e[r++]=189,o=null);i<128?e[r++]=i:(i<2048?e[r++]=i>>6|192:(i<65536?e[r++]=i>>12|224:(e[r++]=i>>18|240,e[r++]=i>>12&63|128),e[r++]=i>>6&63|128),e[r++]=i&63|128)}return r}});var Wf=Ae((tT,Zf)=>{Zf.exports=Pa;function Pa(e,t){var r=e&&e.type,n;if(r==="FeatureCollection")for(n=0;n<e.features.length;n++)Pa(e.features[n],t);else if(r==="GeometryCollection")for(n=0;n<e.geometries.length;n++)Pa(e.geometries[n],t);else if(r==="Feature")Pa(e.geometry,t);else if(r==="Polygon")jf(e.coordinates,t);else if(r==="MultiPolygon")for(n=0;n<e.coordinates.length;n++)jf(e.coordinates[n],t);return e}function jf(e,t){if(e.length!==0){Jf(e[0],t);for(var r=1;r<e.length;r++)Jf(e[r],!t)}}function Jf(e,t){for(var r=0,n=0,i=0,o=e.length,a=o-1;i<o;a=i++){var s=(e[i][0]-e[a][0])*(e[a][1]+e[i][1]),l=r+s;n+=Math.abs(r)>=Math.abs(s)?r-l+s:s-l+r,r=l}r+n>=0!=!!t&&e.reverse()}});var Yf=Ae((iT,Kf)=>{"use strict";var Ob=he(),Nb=Tt().VectorTileFeature;Kf.exports=Xf;function Xf(e,t){this.options=t||{},this.features=e,this.length=e.length}Xf.prototype.feature=function(e){return new wa(this.features[e],this.options.extent)};function wa(e,t){this.id=typeof e.id=="number"?e.id:void 0,this.type=e.type,this.rawGeometry=e.type===1?[e.geometry]:e.geometry,this.properties=e.tags,this.extent=t||4096}wa.prototype.loadGeometry=function(){var e=this.rawGeometry;this.geometry=[];for(var t=0;t<e.length;t++){for(var r=e[t],n=[],i=0;i<r.length;i++)n.push(new Ob(r[i][0],r[i][1]));this.geometry.push(n)}return this.geometry};wa.prototype.bbox=function(){this.geometry||this.loadGeometry();for(var e=this.geometry,t=1/0,r=-1/0,n=1/0,i=-1/0,o=0;o<e.length;o++)for(var a=e[o],s=0;s<a.length;s++){var l=a[s];t=Math.min(t,l.x),r=Math.max(r,l.x),n=Math.min(n,l.y),i=Math.max(i,l.y)}return[t,n,r,i]};wa.prototype.toGeoJSON=Nb.prototype.toGeoJSON});var ty=Ae((oT,di)=>{var Ub=Qn(),ey=Yf();di.exports=yl;di.exports.fromVectorTileJs=yl;di.exports.fromGeojsonVt=$b;di.exports.GeoJSONWrapper=ey;function yl(e){var t=new Ub;return Gb(e,t),t.finish()}function $b(e,t){t=t||{};var r={};for(var n in e)r[n]=new ey(e[n].features,t),r[n].name=n,r[n].version=t.version,r[n].extent=t.extent;return yl({layers:r})}function Gb(e,t){for(var r in e.layers)t.writeMessage(3,qb,e.layers[r])}function qb(e,t){t.writeVarintField(15,e.version||1),t.writeStringField(1,e.name||""),t.writeVarintField(5,e.extent||4096);var r,n={keys:[],values:[],keycache:{},valuecache:{}};for(r=0;r<e.length;r++)n.feature=e.feature(r),t.writeMessage(2,jb,n);var i=n.keys;for(r=0;r<i.length;r++)t.writeStringField(3,i[r]);var o=n.values;for(r=0;r<o.length;r++)t.writeMessage(4,Wb,o[r])}function jb(e,t){var r=e.feature;r.id!==void 0&&t.writeVarintField(1,r.id),t.writeMessage(2,Jb,e),t.writeVarintField(3,r.type),t.writeMessage(4,Zb,r)}function Jb(e,t){var r=e.feature,n=e.keys,i=e.values,o=e.keycache,a=e.valuecache;for(var s in r.properties){var l=r.properties[s],u=o[s];if(l!==null){typeof u>"u"&&(n.push(s),u=n.length-1,o[s]=u),t.writeVarint(u);var c=typeof l;c!=="string"&&c!=="boolean"&&c!=="number"&&(l=JSON.stringify(l));var p=c+":"+l,f=a[p];typeof f>"u"&&(i.push(l),f=i.length-1,a[p]=f),t.writeVarint(f)}}}function fl(e,t){return(t<<3)+(e&7)}function Qf(e){return e<<1^e>>31}function Zb(e,t){for(var r=e.loadGeometry(),n=e.type,i=0,o=0,a=r.length,s=0;s<a;s++){var l=r[s],u=1;n===1&&(u=l.length),t.writeVarint(fl(1,u));for(var c=n===3?l.length-1:l.length,p=0;p<c;p++){p===1&&n!==1&&t.writeVarint(fl(2,c-1));var f=l[p].x-i,y=l[p].y-o;t.writeVarint(Qf(f)),t.writeVarint(Qf(y)),i+=f,o+=y}n===3&&t.writeVarint(fl(7,1))}}function Wb(e,t){var r=typeof e;r==="string"?t.writeStringField(1,e):r==="boolean"?t.writeBooleanField(7,e):r==="number"&&(e%1!==0?t.writeDoubleField(3,e):e<0?t.writeSVarintField(6,e):t.writeVarintField(5,e))}});var _y=Z(he(),1),Ul=Z(zl(),1);var za;function Rl(){return za==null&&(za=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")&&typeof createImageBitmap=="function"),za}var Ii;function Ol(){if(Ii==null&&(Ii=!1,Rl())){let r=new OffscreenCanvas(5,5).getContext("2d",{willReadFrequently:!0});if(r){for(let i=0;i<5*5;i++){let o=i*4;r.fillStyle="rgb(".concat(o,",").concat(o+1,",").concat(o+2,")"),r.fillRect(i%5,Math.floor(i/5),1,1)}let n=r.getImageData(0,0,5,5).data;for(let i=0;i<5*5*4;i++)if(i%4!==3&&n[i]!==i){Ii=!0;break}}}return Ii||!1}function $l(e){if(e<=0)return 0;if(e>=1)return 1;let t=e*e,r=t*e;return 4*(e<.5?r:3*(e-t)+r-.75)}function Iy(e,t,r,n){let i=new Ul.default(e,t,r,n);return function(o){return i.solve(o)}}var m0=Iy(.25,.1,.25,1);function it(e,t,r){return Math.min(r,Math.max(t,e))}function Gl(e,t,r){let n=r-t,i=((e-t)%n+n)%n+t;return i===t?r:i}function Pe(e,...t){for(let r of t)for(let n in r)e[n]=r[n];return e}function ql(e){return Math.log(e)/Math.LN2%1===0}function Gr(e,t,r){let n={};for(let i in e)n[i]=t.call(r||this,e[i],i,e);return n}function jl(e,t,r){let n={};for(let i in e)t.call(r||this,e[i],i,e)&&(n[i]=e[i]);return n}function nt(e){return Array.isArray(e)?e.map(nt):typeof e=="object"&&e?Gr(e,nt):e}function Jl(e,t){for(let r=0;r<e.length;r++)if(t.indexOf(e[r])>=0)return!0;return!1}var Nl={};function fe(e){Nl[e]||(typeof console<"u"&&console.warn(e),Nl[e]=!0)}function ot(e,t,r){return(r.y-e.y)*(t.x-e.x)>(t.y-e.y)*(r.x-e.x)}function Zl(e){let t=0;for(let r=0,n=e.length,i=n-1,o,a;r<n;i=r++)o=e[r],a=e[i],t+=(a.x-o.x)*(o.y+a.y);return t}function at(e){return typeof WorkerGlobalScope<"u"&&typeof e<"u"&&e instanceof WorkerGlobalScope}function qr(e){return typeof ImageBitmap<"u"&&e instanceof ImageBitmap}function Ty(e,t,r,n,i){let o=Math.max(-t,0)*4,l=(Math.max(0,r)-r)*n*4+o,u=n*4,c=Math.max(0,t),p=Math.max(0,r),f=Math.min(e.width,t+n),y=Math.min(e.height,r+i);return{rect:{x:c,y:p,width:f-c,height:y-p},layout:[{offset:l,stride:u}]}}async function Cy(e,t,r,n,i){if(typeof VideoFrame>"u")throw new Error("VideoFrame not supported");let o=new VideoFrame(e,{timestamp:0});try{let a=o==null?void 0:o.format;if(!a||!(a.startsWith("BGR")||a.startsWith("RGB")))throw new Error("Unrecognized format ".concat(a));let s=a.startsWith("BGR"),l=new Uint8ClampedArray(n*i*4);if(await o.copyTo(l,Ty(e,t,r,n,i)),s)for(let u=0;u<l.length;u+=4){let c=l[u];l[u]=l[u+2],l[u+2]=c}return l}finally{o.close()}}var Ur,$r;function ky(e,t,r,n,i){let o=e.width,a=e.height;(!Ur||!$r)&&(Ur=new OffscreenCanvas(o,a),$r=Ur.getContext("2d",{willReadFrequently:!0})),Ur.width=o,Ur.height=a,$r.drawImage(e,0,0,o,a);let s=$r.getImageData(t,r,n,i);return $r.clearRect(0,0,o,a),s.data}async function Wl(e,t,r,n,i){if(Ol())try{return await Cy(e,t,r,n,i)}catch{}return ky(e,t,r,n,i)}function Hl(e,t,r,n){return e.addEventListener(t,r,n),{unsubscribe:()=>{e.removeEventListener(t,r,n)}}}var Dt=class e{constructor(t,r,n){let i=this.cells=[];if(t instanceof ArrayBuffer){this.arrayBuffer=t;let a=new Int32Array(this.arrayBuffer);t=a[0],r=a[1],n=a[2],this.d=r+2*n;for(let u=0;u<this.d*this.d;u++){let c=a[3+u],p=a[3+u+1];i.push(c===p?null:a.subarray(c,p))}let s=a[3+i.length],l=a[3+i.length+1];this.keys=a.subarray(s,l),this.bboxes=a.subarray(l),this.insert=this._insertReadonly}else{this.d=r+2*n;for(let a=0;a<this.d*this.d;a++)i.push([]);this.keys=[],this.bboxes=[]}this.n=r,this.extent=t,this.padding=n,this.scale=r/t,this.uid=0;let o=n/r*t;this.min=-o,this.max=t+o}insert(t,r,n,i,o){this._forEachCell(r,n,i,o,this._insertCell,this.uid++,void 0,void 0),this.keys.push(t),this.bboxes.push(r),this.bboxes.push(n),this.bboxes.push(i),this.bboxes.push(o)}_insertReadonly(){throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.")}_insertCell(t,r,n,i,o,a){this.cells[o].push(a)}query(t,r,n,i,o){let a=this.min,s=this.max;if(t<=a&&r<=a&&s<=n&&s<=i&&!o)return Array.prototype.slice.call(this.keys);{let l=[],u={};return this._forEachCell(t,r,n,i,this._queryCell,l,u,o),l}}_queryCell(t,r,n,i,o,a,s,l){let u=this.cells[o];if(u!==null){let c=this.keys,p=this.bboxes;for(let f=0;f<u.length;f++){let y=u[f];if(s[y]===void 0){let m=y*4;(l?l(p[m+0],p[m+1],p[m+2],p[m+3]):t<=p[m+2]&&r<=p[m+3]&&n>=p[m+0]&&i>=p[m+1])?(s[y]=!0,a.push(c[y])):s[y]=!1}}}}_forEachCell(t,r,n,i,o,a,s,l){let u=this._convertToCellCoord(t),c=this._convertToCellCoord(r),p=this._convertToCellCoord(n),f=this._convertToCellCoord(i);for(let y=u;y<=p;y++)for(let m=c;m<=f;m++){let h=this.d*m+y;if(!(l&&!l(this._convertFromCellCoord(y),this._convertFromCellCoord(m),this._convertFromCellCoord(y+1),this._convertFromCellCoord(m+1)))&&o.call(this,t,r,n,i,h,a,s,l))return}}_convertFromCellCoord(t){return(t-this.padding)/this.scale}_convertToCellCoord(t){return Math.max(0,Math.min(this.d-1,Math.floor(t*this.scale)+this.padding))}toArrayBuffer(){if(this.arrayBuffer)return this.arrayBuffer;let t=this.cells,r=3+this.cells.length+1+1,n=0;for(let a=0;a<this.cells.length;a++)n+=this.cells[a].length;let i=new Int32Array(r+n+this.keys.length+this.bboxes.length);i[0]=this.extent,i[1]=this.n,i[2]=this.padding;let o=r;for(let a=0;a<t.length;a++){let s=t[a];i[3+a]=o,i.set(s,o),o+=s.length}return i[3+t.length]=o,i.set(this.keys,o),o+=this.keys.length,i[3+t.length+1]=o,i.set(this.bboxes,o),o+=this.bboxes.length,i.buffer}static serialize(t,r){let n=t.toArrayBuffer();return r&&r.push(n),{buffer:n}}static deserialize(t){return new e(t.buffer)}};var My=8,Ey={version:{required:!0,type:"enum",values:[8]},name:{type:"string"},metadata:{type:"*"},center:{type:"array",value:"number"},zoom:{type:"number"},bearing:{type:"number",default:0,period:360,units:"degrees"},pitch:{type:"number",default:0,units:"degrees"},light:{type:"light"},sky:{type:"sky"},projection:{type:"projection"},terrain:{type:"terrain"},sources:{required:!0,type:"sources"},sprite:{type:"sprite"},glyphs:{type:"string"},transition:{type:"transition"},layers:{required:!0,type:"array",value:"layer"}},Fy={"*":{type:"source"}},Ly=["source_vector","source_raster","source_raster_dem","source_geojson","source_video","source_image"],Dy={type:{required:!0,type:"enum",values:{vector:{}}},url:{type:"string"},tiles:{type:"array",value:"string"},bounds:{type:"array",value:"number",length:4,default:[-180,-85.051129,180,85.051129]},scheme:{type:"enum",values:{xyz:{},tms:{}},default:"xyz"},minzoom:{type:"number",default:0},maxzoom:{type:"number",default:22},attribution:{type:"string"},promoteId:{type:"promoteId"},volatile:{type:"boolean",default:!1},"*":{type:"*"}},Vy={type:{required:!0,type:"enum",values:{raster:{}}},url:{type:"string"},tiles:{type:"array",value:"string"},bounds:{type:"array",value:"number",length:4,default:[-180,-85.051129,180,85.051129]},minzoom:{type:"number",default:0},maxzoom:{type:"number",default:22},tileSize:{type:"number",default:512,units:"pixels"},scheme:{type:"enum",values:{xyz:{},tms:{}},default:"xyz"},attribution:{type:"string"},volatile:{type:"boolean",default:!1},"*":{type:"*"}},By={type:{required:!0,type:"enum",values:{"raster-dem":{}}},url:{type:"string"},tiles:{type:"array",value:"string"},bounds:{type:"array",value:"number",length:4,default:[-180,-85.051129,180,85.051129]},minzoom:{type:"number",default:0},maxzoom:{type:"number",default:22},tileSize:{type:"number",default:512,units:"pixels"},attribution:{type:"string"},encoding:{type:"enum",values:{terrarium:{},mapbox:{},custom:{}},default:"mapbox"},redFactor:{type:"number",default:1},blueFactor:{type:"number",default:1},greenFactor:{type:"number",default:1},baseShift:{type:"number",default:0},volatile:{type:"boolean",default:!1},"*":{type:"*"}},zy={type:{required:!0,type:"enum",values:{geojson:{}}},data:{required:!0,type:"*"},maxzoom:{type:"number",default:18},attribution:{type:"string"},buffer:{type:"number",default:128,maximum:512,minimum:0},filter:{type:"*"},tolerance:{type:"number",default:.375},cluster:{type:"boolean",default:!1},clusterRadius:{type:"number",default:50,minimum:0},clusterMaxZoom:{type:"number"},clusterMinPoints:{type:"number"},clusterProperties:{type:"*"},lineMetrics:{type:"boolean",default:!1},generateId:{type:"boolean",default:!1},promoteId:{type:"promoteId"}},Ry={type:{required:!0,type:"enum",values:{video:{}}},urls:{required:!0,type:"array",value:"string"},coordinates:{required:!0,type:"array",length:4,value:{type:"array",length:2,value:"number"}}},Oy={type:{required:!0,type:"enum",values:{image:{}}},url:{required:!0,type:"string"},coordinates:{required:!0,type:"array",length:4,value:{type:"array",length:2,value:"number"}}},Ny={id:{type:"string",required:!0},type:{type:"enum",values:{fill:{},line:{},symbol:{},circle:{},heatmap:{},"fill-extrusion":{},raster:{},hillshade:{},background:{}},required:!0},metadata:{type:"*"},source:{type:"string"},"source-layer":{type:"string"},minzoom:{type:"number",minimum:0,maximum:24},maxzoom:{type:"number",minimum:0,maximum:24},filter:{type:"filter"},layout:{type:"layout"},paint:{type:"paint"}},Uy=["layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_symbol","layout_raster","layout_hillshade","layout_background"],$y={visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},Gy={"fill-sort-key":{type:"number",expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},qy={"circle-sort-key":{type:"number",expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},jy={visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},Jy={"line-cap":{type:"enum",values:{butt:{},round:{},square:{}},default:"butt",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"line-join":{type:"enum",values:{bevel:{},round:{},miter:{}},default:"miter",expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{type:"number",default:2,requires:[{"line-join":"miter"}],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"line-round-limit":{type:"number",default:1.05,requires:[{"line-join":"round"}],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"line-sort-key":{type:"number",expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},Zy={"symbol-placement":{type:"enum",values:{point:{},line:{},"line-center":{}},default:"point",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"symbol-spacing":{type:"number",default:250,minimum:1,units:"pixels",requires:[{"symbol-placement":"line"}],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"symbol-avoid-edges":{type:"boolean",default:!1,expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"symbol-sort-key":{type:"number",expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{type:"enum",values:{auto:{},"viewport-y":{},source:{}},default:"auto",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-allow-overlap":{type:"boolean",default:!1,requires:["icon-image",{"!":"icon-overlap"}],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-overlap":{type:"enum",values:{never:{},always:{},cooperative:{}},requires:["icon-image"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-ignore-placement":{type:"boolean",default:!1,requires:["icon-image"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-optional":{type:"boolean",default:!1,requires:["icon-image","text-field"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-rotation-alignment":{type:"enum",values:{map:{},viewport:{},auto:{}},default:"auto",requires:["icon-image"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-size":{type:"number",default:1,minimum:0,units:"factor of the original icon size",requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit":{type:"enum",values:{none:{},width:{},height:{},both:{}},default:"none",requires:["icon-image","text-field"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-text-fit-padding":{type:"array",value:"number",length:4,default:[0,0,0,0],units:"pixels",requires:["icon-image","text-field",{"icon-text-fit":["both","width","height"]}],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"icon-image":{type:"resolvedImage",tokens:!0,expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{type:"number",default:0,period:360,units:"degrees",requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{type:"padding",default:[2],units:"pixels",requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"icon-keep-upright":{type:"boolean",default:!1,requires:["icon-image",{"icon-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-offset":{type:"array",value:"number",length:2,default:[0,0],requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{type:"enum",values:{center:{},left:{},right:{},top:{},bottom:{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},default:"center",requires:["icon-image"],expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{type:"enum",values:{map:{},viewport:{},auto:{}},default:"auto",requires:["icon-image"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-pitch-alignment":{type:"enum",values:{map:{},viewport:{},auto:{}},default:"auto",requires:["text-field"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-rotation-alignment":{type:"enum",values:{map:{},viewport:{},"viewport-glyph":{},auto:{}},default:"auto",requires:["text-field"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-field":{type:"formatted",default:"",tokens:!0,expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-font":{type:"array",value:"string",default:["Open Sans Regular","Arial Unicode MS Regular"],requires:["text-field"],expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-size":{type:"number",default:16,minimum:0,units:"pixels",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-max-width":{type:"number",default:10,minimum:0,units:"ems",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{type:"number",default:1.2,units:"ems",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"text-letter-spacing":{type:"number",default:0,units:"ems",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-justify":{type:"enum",values:{auto:{},left:{},center:{},right:{}},default:"center",requires:["text-field"],expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{type:"number",units:"ems",default:0,requires:["text-field"],"property-type":"data-driven",expression:{interpolated:!0,parameters:["zoom","feature"]}},"text-variable-anchor":{type:"array",value:"enum",values:{center:{},left:{},right:{},top:{},bottom:{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},requires:["text-field",{"symbol-placement":["point"]}],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-variable-anchor-offset":{type:"variableAnchorOffsetCollection",requires:["text-field",{"symbol-placement":["point"]}],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-anchor":{type:"enum",values:{center:{},left:{},right:{},top:{},bottom:{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},default:"center",requires:["text-field",{"!":"text-variable-anchor"}],expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{type:"number",default:45,units:"degrees",requires:["text-field",{"symbol-placement":["line","line-center"]}],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"text-writing-mode":{type:"array",value:"enum",values:{horizontal:{},vertical:{}},requires:["text-field",{"symbol-placement":["point"]}],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-rotate":{type:"number",default:0,period:360,units:"degrees",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-padding":{type:"number",default:2,minimum:0,units:"pixels",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"text-keep-upright":{type:"boolean",default:!0,requires:["text-field",{"text-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-transform":{type:"enum",values:{none:{},uppercase:{},lowercase:{}},default:"none",requires:["text-field"],expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-offset":{type:"array",value:"number",units:"ems",length:2,default:[0,0],requires:["text-field",{"!":"text-radial-offset"}],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{type:"boolean",default:!1,requires:["text-field",{"!":"text-overlap"}],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-overlap":{type:"enum",values:{never:{},always:{},cooperative:{}},requires:["text-field"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-ignore-placement":{type:"boolean",default:!1,requires:["text-field"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-optional":{type:"boolean",default:!1,requires:["text-field","icon-image"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},Wy={visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},Hy={visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},Xy={type:"array",value:"*"},Ky={type:"enum",values:{"==":{},"!=":{},">":{},">=":{},"<":{},"<=":{},in:{},"!in":{},all:{},any:{},none:{},has:{},"!has":{}}},Yy={type:"enum",values:{Point:{},LineString:{},Polygon:{}}},Qy={type:"array",minimum:0,maximum:24,value:["number","color"],length:2},em={type:"array",value:"*",minimum:1},tm={anchor:{type:"enum",default:"viewport",values:{map:{},viewport:{}},"property-type":"data-constant",transition:!1,expression:{interpolated:!1,parameters:["zoom"]}},position:{type:"array",default:[1.15,210,30],length:3,value:"number","property-type":"data-constant",transition:!0,expression:{interpolated:!0,parameters:["zoom"]}},color:{type:"color","property-type":"data-constant",default:"#ffffff",expression:{interpolated:!0,parameters:["zoom"]},transition:!0},intensity:{type:"number","property-type":"data-constant",default:.5,minimum:0,maximum:1,expression:{interpolated:!0,parameters:["zoom"]},transition:!0}},rm={"sky-color":{type:"color","property-type":"data-constant",default:"#88C6FC",expression:{interpolated:!0,parameters:["zoom"]},transition:!0},"horizon-color":{type:"color","property-type":"data-constant",default:"#ffffff",expression:{interpolated:!0,parameters:["zoom"]},transition:!0},"fog-color":{type:"color","property-type":"data-constant",default:"#ffffff",expression:{interpolated:!0,parameters:["zoom"]},transition:!0},"fog-ground-blend":{type:"number","property-type":"data-constant",default:.5,minimum:0,maximum:1,expression:{interpolated:!0,parameters:["zoom"]},transition:!0},"horizon-fog-blend":{type:"number","property-type":"data-constant",default:.8,minimum:0,maximum:1,expression:{interpolated:!0,parameters:["zoom"]},transition:!0},"sky-horizon-blend":{type:"number","property-type":"data-constant",default:.8,minimum:0,maximum:1,expression:{interpolated:!0,parameters:["zoom"]},transition:!0},"atmosphere-blend":{type:"number","property-type":"data-constant",default:.8,minimum:0,maximum:1,expression:{interpolated:!0,parameters:["zoom"]},transition:!0}},nm={source:{type:"string",required:!0},exaggeration:{type:"number",minimum:0,default:1}},im={type:{type:"enum",default:"mercator",values:{mercator:{},globe:{}}}},om=["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_symbol","paint_raster","paint_hillshade","paint_background"],am={"fill-antialias":{type:"boolean",default:!0,expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"fill-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-color":{type:"color",default:"#000000",transition:!0,requires:[{"!":"fill-pattern"}],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-outline-color":{type:"color",transition:!0,requires:[{"!":"fill-pattern"},{"fill-antialias":!0}],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-translate":{type:"array",value:"number",length:2,default:[0,0],transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"fill-translate-anchor":{type:"enum",values:{map:{},viewport:{}},default:"map",requires:["fill-translate"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"fill-pattern":{type:"resolvedImage",transition:!0,expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"cross-faded-data-driven"}},sm={"line-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-color":{type:"color",default:"#000000",transition:!0,requires:[{"!":"line-pattern"}],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-translate":{type:"array",value:"number",length:2,default:[0,0],transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"line-translate-anchor":{type:"enum",values:{map:{},viewport:{}},default:"map",requires:["line-translate"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"line-width":{type:"number",default:1,minimum:0,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-gap-width":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-offset":{type:"number",default:0,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-blur":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-dasharray":{type:"array",value:"number",minimum:0,transition:!0,units:"line widths",requires:[{"!":"line-pattern"}],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"cross-faded"},"line-pattern":{type:"resolvedImage",transition:!0,expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"cross-faded-data-driven"},"line-gradient":{type:"color",transition:!1,requires:[{"!":"line-dasharray"},{"!":"line-pattern"},{source:"geojson",has:{lineMetrics:!0}}],expression:{interpolated:!0,parameters:["line-progress"]},"property-type":"color-ramp"}},lm={"circle-radius":{type:"number",default:5,minimum:0,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-color":{type:"color",default:"#000000",transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-blur":{type:"number",default:0,transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-translate":{type:"array",value:"number",length:2,default:[0,0],transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"circle-translate-anchor":{type:"enum",values:{map:{},viewport:{}},default:"map",requires:["circle-translate"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"circle-pitch-scale":{type:"enum",values:{map:{},viewport:{}},default:"map",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"circle-pitch-alignment":{type:"enum",values:{map:{},viewport:{}},default:"viewport",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"circle-stroke-width":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-color":{type:"color",default:"#000000",transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"}},um={"heatmap-radius":{type:"number",default:30,minimum:1,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-weight":{type:"number",default:1,minimum:0,transition:!1,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-intensity":{type:"number",default:1,minimum:0,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"heatmap-color":{type:"color",default:["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",.1,"royalblue",.3,"cyan",.5,"lime",.7,"yellow",1,"red"],transition:!1,expression:{interpolated:!0,parameters:["heatmap-density"]},"property-type":"color-ramp"},"heatmap-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"}},cm={"icon-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-color":{type:"color",default:"#000000",transition:!0,requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-color":{type:"color",default:"rgba(0, 0, 0, 0)",transition:!0,requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-width":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-blur":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-translate":{type:"array",value:"number",length:2,default:[0,0],transition:!0,units:"pixels",requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"icon-translate-anchor":{type:"enum",values:{map:{},viewport:{}},default:"map",requires:["icon-image","icon-translate"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-color":{type:"color",default:"#000000",transition:!0,overridable:!0,requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-color":{type:"color",default:"rgba(0, 0, 0, 0)",transition:!0,requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-width":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-blur":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-translate":{type:"array",value:"number",length:2,default:[0,0],transition:!0,units:"pixels",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"text-translate-anchor":{type:"enum",values:{map:{},viewport:{}},default:"map",requires:["text-field","text-translate"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"}},pm={"raster-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"raster-hue-rotate":{type:"number",default:0,period:360,transition:!0,units:"degrees",expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"raster-brightness-min":{type:"number",default:0,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"raster-brightness-max":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"raster-saturation":{type:"number",default:0,minimum:-1,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"raster-contrast":{type:"number",default:0,minimum:-1,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"raster-resampling":{type:"enum",values:{linear:{},nearest:{}},default:"linear",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"raster-fade-duration":{type:"number",default:300,minimum:0,transition:!1,units:"milliseconds",expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"}},fm={"hillshade-illumination-direction":{type:"number",default:335,minimum:0,maximum:359,transition:!1,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"hillshade-illumination-anchor":{type:"enum",values:{map:{},viewport:{}},default:"viewport",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"hillshade-exaggeration":{type:"number",default:.5,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"hillshade-shadow-color":{type:"color",default:"#000000",transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"hillshade-highlight-color":{type:"color",default:"#FFFFFF",transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"hillshade-accent-color":{type:"color",default:"#000000",transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"}},ym={"background-color":{type:"color",default:"#000000",transition:!0,requires:[{"!":"background-pattern"}],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"background-pattern":{type:"resolvedImage",transition:!0,expression:{interpolated:!1,parameters:["zoom"]},"property-type":"cross-faded"},"background-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"}},mm={duration:{type:"number",default:300,minimum:0,units:"milliseconds"},delay:{type:"number",default:0,minimum:0,units:"milliseconds"}},hm={"*":{type:"string"}},S={$version:My,$root:Ey,sources:Fy,source:Ly,source_vector:Dy,source_raster:Vy,source_raster_dem:By,source_geojson:zy,source_video:Ry,source_image:Oy,layer:Ny,layout:Uy,layout_background:$y,layout_fill:Gy,layout_circle:qy,layout_heatmap:jy,"layout_fill-extrusion":{visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},layout_line:Jy,layout_symbol:Zy,layout_raster:Wy,layout_hillshade:Hy,filter:Xy,filter_operator:Ky,geometry_type:Yy,function:{expression:{type:"expression"},stops:{type:"array",value:"function_stop"},base:{type:"number",default:1,minimum:0},property:{type:"string",default:"$zoom"},type:{type:"enum",values:{identity:{},exponential:{},interval:{},categorical:{}},default:"exponential"},colorSpace:{type:"enum",values:{rgb:{},lab:{},hcl:{}},default:"rgb"},default:{type:"*",required:!1}},function_stop:Qy,expression:em,light:tm,sky:rm,terrain:nm,projection:im,paint:om,paint_fill:am,"paint_fill-extrusion":{"fill-extrusion-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"fill-extrusion-color":{type:"color",default:"#000000",transition:!0,requires:[{"!":"fill-extrusion-pattern"}],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-translate":{type:"array",value:"number",length:2,default:[0,0],transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"fill-extrusion-translate-anchor":{type:"enum",values:{map:{},viewport:{}},default:"map",requires:["fill-extrusion-translate"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"fill-extrusion-pattern":{type:"resolvedImage",transition:!0,expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"cross-faded-data-driven"},"fill-extrusion-height":{type:"number",default:0,minimum:0,units:"meters",transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{type:"number",default:0,minimum:0,units:"meters",transition:!0,requires:["fill-extrusion-height"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-vertical-gradient":{type:"boolean",default:!0,transition:!1,expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"}},paint_line:sm,paint_circle:lm,paint_heatmap:um,paint_symbol:cm,paint_raster:pm,paint_hillshade:fm,paint_background:ym,transition:mm,"property-type":{"data-driven":{type:"property-type"},"cross-faded":{type:"property-type"},"cross-faded-data-driven":{type:"property-type"},"color-ramp":{type:"property-type"},"data-constant":{type:"property-type"},constant:{type:"property-type"}},promoteId:hm},dm=["type","source","source-layer","minzoom","maxzoom","filter","layout"];var M=class{constructor(t,r,n,i){this.message=(t?"".concat(t,": "):"")+n,i&&(this.identifier=i),r!=null&&r.__line__&&(this.line=r.__line__)}};function cr(e,...t){for(let r of t)for(let n in r)e[n]=r[n];return e}var Be=class extends Error{constructor(t,r){super(r),this.message=r,this.key=t}},Ja=class e{constructor(t,r=[]){this.parent=t,this.bindings={};for(let[n,i]of r)this.bindings[n]=i}concat(t){return new e(this,t)}get(t){if(this.bindings[t])return this.bindings[t];if(this.parent)return this.parent.get(t);throw new Error("".concat(t," not found in scope."))}has(t){return this.bindings[t]?!0:this.parent?this.parent.has(t):!1}},yr={kind:"null"},L={kind:"number"},G={kind:"string"},U={kind:"boolean"},Re={kind:"color"},lr={kind:"object"},$={kind:"value"},gm={kind:"error"},ji={kind:"collator"},mr={kind:"formatted"},Ji={kind:"padding"},un={kind:"resolvedImage"},Zi={kind:"variableAnchorOffsetCollection"};function Ee(e,t){return{kind:"array",itemType:e,N:t}}function te(e){if(e.kind==="array"){let t=te(e.itemType);return typeof e.N=="number"?"array<".concat(t,", ").concat(e.N,">"):e.itemType.kind==="value"?"array":"array<".concat(t,">")}else return e.kind}var xm=[yr,L,G,U,Re,mr,lr,Ee($),Ji,un,Zi];function Hr(e,t){if(t.kind==="error")return null;if(e.kind==="array"){if(t.kind==="array"&&(t.N===0&&t.itemType.kind==="value"||!Hr(e.itemType,t.itemType))&&(typeof e.N!="number"||e.N===t.N))return null}else{if(e.kind===t.kind)return null;if(e.kind==="value"){for(let r of xm)if(!Hr(r,t))return null}}return"Expected ".concat(te(e)," but found ").concat(te(t)," instead.")}function us(e,t){return t.some(r=>r.kind===e.kind)}function Xr(e,t){return t.some(r=>r==="null"?e===null:r==="array"?Array.isArray(e):r==="object"?e&&!Array.isArray(e)&&typeof e=="object":r===typeof e)}function jr(e,t){return e.kind==="array"&&t.kind==="array"?e.itemType.kind===t.itemType.kind&&typeof e.N=="number":e.kind===t.kind}var du=.96422,gu=1,xu=.82521,bu=4/29,ur=6/29,vu=3*ur*ur,bm=ur*ur*ur,vm=Math.PI/180,Pm=180/Math.PI;function Pu(e){return e=e%360,e<0&&(e+=360),e}function Su([e,t,r,n]){e=Ra(e),t=Ra(t),r=Ra(r);let i,o,a=Oa((.2225045*e+.7168786*t+.0606169*r)/gu);e===t&&t===r?i=o=a:(i=Oa((.4360747*e+.3850649*t+.1430804*r)/du),o=Oa((.0139322*e+.0971045*t+.7141733*r)/xu));let s=116*a-16;return[s<0?0:s,500*(i-a),200*(a-o),n]}function Ra(e){return e<=.04045?e/12.92:Math.pow((e+.055)/1.055,2.4)}function Oa(e){return e>bm?Math.pow(e,1/3):e/vu+bu}function wu([e,t,r,n]){let i=(e+16)/116,o=isNaN(t)?i:i+t/500,a=isNaN(r)?i:i-r/200;return i=gu*Ua(i),o=du*Ua(o),a=xu*Ua(a),[Na(3.1338561*o-1.6168667*i-.4906146*a),Na(-.9787684*o+1.9161415*i+.033454*a),Na(.0719453*o-.2289914*i+1.4052427*a),n]}function Na(e){return e=e<=.00304?12.92*e:1.055*Math.pow(e,1/2.4)-.055,e<0?0:e>1?1:e}function Ua(e){return e>ur?e*e*e:vu*(e-bu)}function Sm(e){let[t,r,n,i]=Su(e),o=Math.sqrt(r*r+n*n);return[Math.round(o*1e4)?Pu(Math.atan2(n,r)*Pm):NaN,o,t,i]}function wm([e,t,r,n]){return e=isNaN(e)?0:e*vm,wu([r,Math.cos(e)*t,Math.sin(e)*t,n])}function Am([e,t,r,n]){e=Pu(e),t/=100,r/=100;function i(o){let a=(o+e/30)%12,s=t*Math.min(r,1-r);return r-s*Math.max(-1,Math.min(a-3,9-a,1))}return[i(0),i(8),i(4),n]}function _m(e){if(e=e.toLowerCase().trim(),e==="transparent")return[0,0,0,0];let t=Im[e];if(t){let[i,o,a]=t;return[i/255,o/255,a/255,1]}if(e.startsWith("#")&&/^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(e)){let o=e.length<6?1:2,a=1;return[Ti(e.slice(a,a+=o)),Ti(e.slice(a,a+=o)),Ti(e.slice(a,a+=o)),Ti(e.slice(a,a+o)||"ff")]}if(e.startsWith("rgb")){let i=/^rgba?\\(\\s*([\\de.+-]+)(%)?(?:\\s+|\\s*(,)\\s*)([\\de.+-]+)(%)?(?:\\s+|\\s*(,)\\s*)([\\de.+-]+)(%)?(?:\\s*([,\\/])\\s*([\\de.+-]+)(%)?)?\\s*\\)$/,o=e.match(i);if(o){let[a,s,l,u,c,p,f,y,m,h,d,g]=o,b=[u||" ",f||" ",h].join("");if(b==="  "||b==="  /"||b===",,"||b===",,,"){let x=[l,p,m].join(""),v=x==="%%%"?100:x===""?255:0;if(v){let P=[ar(+s/v,0,1),ar(+c/v,0,1),ar(+y/v,0,1),d?Xl(+d,g):1];if(Kl(P))return P}}return}}let r=/^hsla?\\(\\s*([\\de.+-]+)(?:deg)?(?:\\s+|\\s*(,)\\s*)([\\de.+-]+)%(?:\\s+|\\s*(,)\\s*)([\\de.+-]+)%(?:\\s*([,\\/])\\s*([\\de.+-]+)(%)?)?\\s*\\)$/,n=e.match(r);if(n){let[i,o,a,s,l,u,c,p,f]=n,y=[a||" ",l||" ",c].join("");if(y==="  "||y==="  /"||y===",,"||y===",,,"){let m=[+o,ar(+s,0,100),ar(+u,0,100),p?Xl(+p,f):1];if(Kl(m))return Am(m)}}}function Ti(e){return parseInt(e.padEnd(2,e),16)/255}function Xl(e,t){return ar(t?e/100:e,0,1)}function ar(e,t,r){return Math.min(Math.max(t,e),r)}function Kl(e){return!e.some(Number.isNaN)}var Im={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]},W=class e{constructor(t,r,n,i=1,o=!0){this.r=t,this.g=r,this.b=n,this.a=i,o||(this.r*=i,this.g*=i,this.b*=i,i||this.overwriteGetter("rgb",[t,r,n,i]))}static parse(t){if(t instanceof e)return t;if(typeof t!="string")return;let r=_m(t);if(r)return new e(...r,!1)}get rgb(){let{r:t,g:r,b:n,a:i}=this,o=i||1/0;return this.overwriteGetter("rgb",[t/o,r/o,n/o,i])}get hcl(){return this.overwriteGetter("hcl",Sm(this.rgb))}get lab(){return this.overwriteGetter("lab",Su(this.rgb))}overwriteGetter(t,r){return Object.defineProperty(this,t,{value:r}),r}toString(){let[t,r,n,i]=this.rgb;return"rgba(".concat([t,r,n].map(o=>Math.round(o*255)).join(","),",").concat(i,")")}};W.black=new W(0,0,0,1);W.white=new W(1,1,1,1);W.transparent=new W(0,0,0,0);W.red=new W(1,0,0,1);var Kr=class{constructor(t,r,n){t?this.sensitivity=r?"variant":"case":this.sensitivity=r?"accent":"base",this.locale=n,this.collator=new Intl.Collator(this.locale?this.locale:[],{sensitivity:this.sensitivity,usage:"search"})}compare(t,r){return this.collator.compare(t,r)}resolvedLocale(){return new Intl.Collator(this.locale?this.locale:[]).resolvedOptions().locale}},Yr=class{constructor(t,r,n,i,o){this.text=t,this.image=r,this.scale=n,this.fontStack=i,this.textColor=o}},Fe=class e{constructor(t){this.sections=t}static fromString(t){return new e([new Yr(t,null,null,null,null)])}isEmpty(){return this.sections.length===0?!0:!this.sections.some(t=>t.text.length!==0||t.image&&t.image.name.length!==0)}static factory(t){return t instanceof e?t:e.fromString(t)}toString(){return this.sections.length===0?"":this.sections.map(t=>t.text).join("")}},Ze=class e{constructor(t){this.values=t.slice()}static parse(t){if(t instanceof e)return t;if(typeof t=="number")return new e([t,t,t,t]);if(Array.isArray(t)&&!(t.length<1||t.length>4)){for(let r of t)if(typeof r!="number")return;switch(t.length){case 1:t=[t[0],t[0],t[0],t[0]];break;case 2:t=[t[0],t[1],t[0],t[1]];break;case 3:t=[t[0],t[1],t[2],t[1]];break}return new e(t)}}toString(){return JSON.stringify(this.values)}},Tm=new Set(["center","left","right","top","bottom","top-left","top-right","bottom-left","bottom-right"]),Ne=class e{constructor(t){this.values=t.slice()}static parse(t){if(t instanceof e)return t;if(!(!Array.isArray(t)||t.length<1||t.length%2!==0)){for(let r=0;r<t.length;r+=2){let n=t[r],i=t[r+1];if(typeof n!="string"||!Tm.has(n)||!Array.isArray(i)||i.length!==2||typeof i[0]!="number"||typeof i[1]!="number")return}return new e(t)}}toString(){return JSON.stringify(this.values)}},Te=class e{constructor(t){this.name=t.name,this.available=t.available}toString(){return this.name}static fromString(t){return t?new e({name:t,available:!1}):null}};function Au(e,t,r,n){if(!(typeof e=="number"&&e>=0&&e<=255&&typeof t=="number"&&t>=0&&t<=255&&typeof r=="number"&&r>=0&&r<=255)){let i=typeof n=="number"?[e,t,r,n]:[e,t,r];return"Invalid rgba value [".concat(i.join(", "),"]: 'r', 'g', and 'b' must be between 0 and 255.")}return typeof n>"u"||typeof n=="number"&&n>=0&&n<=1?null:"Invalid rgba value [".concat([e,t,r,n].join(", "),"]: 'a' must be between 0 and 1.")}function Qr(e){if(e===null||typeof e=="string"||typeof e=="boolean"||typeof e=="number"||e instanceof W||e instanceof Kr||e instanceof Fe||e instanceof Ze||e instanceof Ne||e instanceof Te)return!0;if(Array.isArray(e)){for(let t of e)if(!Qr(t))return!1;return!0}else if(typeof e=="object"){for(let t in e)if(!Qr(e[t]))return!1;return!0}else return!1}function ue(e){if(e===null)return yr;if(typeof e=="string")return G;if(typeof e=="boolean")return U;if(typeof e=="number")return L;if(e instanceof W)return Re;if(e instanceof Kr)return ji;if(e instanceof Fe)return mr;if(e instanceof Ze)return Ji;if(e instanceof Ne)return Zi;if(e instanceof Te)return un;if(Array.isArray(e)){let t=e.length,r;for(let n of e){let i=ue(n);if(!r)r=i;else{if(r===i)continue;r=$;break}}return Ee(r||$,t)}else return lr}function Zr(e){let t=typeof e;return e===null?"":t==="string"||t==="number"||t==="boolean"?String(e):e instanceof W||e instanceof Fe||e instanceof Ze||e instanceof Ne||e instanceof Te?e.toString():JSON.stringify(e)}var mt=class e{constructor(t,r){this.type=t,this.value=r}static parse(t,r){if(t.length!==2)return r.error("'literal' expression requires exactly one argument, but found ".concat(t.length-1," instead."));if(!Qr(t[1]))return r.error("invalid value");let n=t[1],i=ue(n),o=r.expectedType;return i.kind==="array"&&i.N===0&&o&&o.kind==="array"&&(typeof o.N!="number"||o.N===0)&&(i=o),new e(i,n)}evaluate(){return this.value}eachChild(){}outputDefined(){return!0}},ie=class{constructor(t){this.name="ExpressionEvaluationError",this.message=t}toJSON(){return this.message}},Ci={string:G,number:L,boolean:U,object:lr},je=class e{constructor(t,r){this.type=t,this.args=r}static parse(t,r){if(t.length<2)return r.error("Expected at least one argument.");let n=1,i,o=t[0];if(o==="array"){let s;if(t.length>2){let u=t[1];if(typeof u!="string"||!(u in Ci)||u==="object")return r.error('The item type argument of "array" must be one of string, number, boolean',1);s=Ci[u],n++}else s=$;let l;if(t.length>3){if(t[2]!==null&&(typeof t[2]!="number"||t[2]<0||t[2]!==Math.floor(t[2])))return r.error('The length argument to "array" must be a positive integer literal',2);l=t[2],n++}i=Ee(s,l)}else{if(!Ci[o])throw new Error("Types doesn't contain name = ".concat(o));i=Ci[o]}let a=[];for(;n<t.length;n++){let s=r.parse(t[n],n,$);if(!s)return null;a.push(s)}return new e(i,a)}evaluate(t){for(let r=0;r<this.args.length;r++){let n=this.args[r].evaluate(t);if(Hr(this.type,ue(n))){if(r===this.args.length-1)throw new ie("Expected value to be of type ".concat(te(this.type),", but found ").concat(te(ue(n))," instead."))}else return n}throw new Error}eachChild(t){this.args.forEach(t)}outputDefined(){return this.args.every(t=>t.outputDefined())}},Yl={"to-boolean":U,"to-color":Re,"to-number":L,"to-string":G},yt=class e{constructor(t,r){this.type=t,this.args=r}static parse(t,r){if(t.length<2)return r.error("Expected at least one argument.");let n=t[0];if(!Yl[n])throw new Error("Can't parse ".concat(n," as it is not part of the known types"));if((n==="to-boolean"||n==="to-string")&&t.length!==2)return r.error("Expected one argument.");let i=Yl[n],o=[];for(let a=1;a<t.length;a++){let s=r.parse(t[a],a,$);if(!s)return null;o.push(s)}return new e(i,o)}evaluate(t){switch(this.type.kind){case"boolean":return!!this.args[0].evaluate(t);case"color":{let r,n;for(let i of this.args){if(r=i.evaluate(t),n=null,r instanceof W)return r;if(typeof r=="string"){let o=t.parseColor(r);if(o)return o}else if(Array.isArray(r)&&(r.length<3||r.length>4?n="Invalid rbga value ".concat(JSON.stringify(r),": expected an array containing either three or four numeric values."):n=Au(r[0],r[1],r[2],r[3]),!n))return new W(r[0]/255,r[1]/255,r[2]/255,r[3])}throw new ie(n||"Could not parse color from value '".concat(typeof r=="string"?r:JSON.stringify(r),"'"))}case"padding":{let r;for(let n of this.args){r=n.evaluate(t);let i=Ze.parse(r);if(i)return i}throw new ie("Could not parse padding from value '".concat(typeof r=="string"?r:JSON.stringify(r),"'"))}case"variableAnchorOffsetCollection":{let r;for(let n of this.args){r=n.evaluate(t);let i=Ne.parse(r);if(i)return i}throw new ie("Could not parse variableAnchorOffsetCollection from value '".concat(typeof r=="string"?r:JSON.stringify(r),"'"))}case"number":{let r=null;for(let n of this.args){if(r=n.evaluate(t),r===null)return 0;let i=Number(r);if(!isNaN(i))return i}throw new ie("Could not convert ".concat(JSON.stringify(r)," to number."))}case"formatted":return Fe.fromString(Zr(this.args[0].evaluate(t)));case"resolvedImage":return Te.fromString(Zr(this.args[0].evaluate(t)));default:return Zr(this.args[0].evaluate(t))}}eachChild(t){this.args.forEach(t)}outputDefined(){return this.args.every(t=>t.outputDefined())}},Cm=["Unknown","Point","LineString","Polygon"],Fi=class{constructor(){this.globals=null,this.feature=null,this.featureState=null,this.formattedSection=null,this._parseColorCache={},this.availableImages=null,this.canonical=null}id(){return this.feature&&"id"in this.feature?this.feature.id:null}geometryType(){return this.feature?typeof this.feature.type=="number"?Cm[this.feature.type]:this.feature.type:null}geometry(){return this.feature&&"geometry"in this.feature?this.feature.geometry:null}canonicalID(){return this.canonical}properties(){return this.feature&&this.feature.properties||{}}parseColor(t){let r=this._parseColorCache[t];return r||(r=this._parseColorCache[t]=W.parse(t)),r}},Li=class e{constructor(t,r,n=[],i,o=new Ja,a=[]){this.registry=t,this.path=n,this.key=n.map(s=>"[".concat(s,"]")).join(""),this.scope=o,this.errors=a,this.expectedType=i,this._isConstant=r}parse(t,r,n,i,o={}){return r?this.concat(r,n,i)._parse(t,o):this._parse(t,o)}_parse(t,r){(t===null||typeof t=="string"||typeof t=="boolean"||typeof t=="number")&&(t=["literal",t]);function n(i,o,a){return a==="assert"?new je(o,[i]):a==="coerce"?new yt(o,[i]):i}if(Array.isArray(t)){if(t.length===0)return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');let i=t[0];if(typeof i!="string")return this.error("Expression name must be a string, but found ".concat(typeof i,' instead. If you wanted a literal array, use ["literal", [...]].'),0),null;let o=this.registry[i];if(o){let a=o.parse(t,this);if(!a)return null;if(this.expectedType){let s=this.expectedType,l=a.type;if((s.kind==="string"||s.kind==="number"||s.kind==="boolean"||s.kind==="object"||s.kind==="array")&&l.kind==="value")a=n(a,s,r.typeAnnotation||"assert");else if((s.kind==="color"||s.kind==="formatted"||s.kind==="resolvedImage")&&(l.kind==="value"||l.kind==="string"))a=n(a,s,r.typeAnnotation||"coerce");else if(s.kind==="padding"&&(l.kind==="value"||l.kind==="number"||l.kind==="array"))a=n(a,s,r.typeAnnotation||"coerce");else if(s.kind==="variableAnchorOffsetCollection"&&(l.kind==="value"||l.kind==="array"))a=n(a,s,r.typeAnnotation||"coerce");else if(this.checkSubtype(s,l))return null}if(!(a instanceof mt)&&a.type.kind!=="resolvedImage"&&this._isConstant(a)){let s=new Fi;try{a=new mt(a.type,a.evaluate(s))}catch(l){return this.error(l.message),null}}return a}return this.error('Unknown expression "'.concat(i,'". If you wanted a literal array, use ["literal", [...]].'),0)}else return typeof t>"u"?this.error("'undefined' value invalid. Use null instead."):typeof t=="object"?this.error('Bare objects invalid. Use ["literal", {...}] instead.'):this.error("Expected an array, but found ".concat(typeof t," instead."))}concat(t,r,n){let i=typeof t=="number"?this.path.concat(t):this.path,o=n?this.scope.concat(n):this.scope;return new e(this.registry,this._isConstant,i,r||null,o,this.errors)}error(t,...r){let n="".concat(this.key).concat(r.map(i=>"[".concat(i,"]")).join(""));this.errors.push(new Be(n,t))}checkSubtype(t,r){let n=Hr(t,r);return n&&this.error(n),n}},Di=class e{constructor(t,r){this.type=r.type,this.bindings=[].concat(t),this.result=r}evaluate(t){return this.result.evaluate(t)}eachChild(t){for(let r of this.bindings)t(r[1]);t(this.result)}static parse(t,r){if(t.length<4)return r.error("Expected at least 3 arguments, but found ".concat(t.length-1," instead."));let n=[];for(let o=1;o<t.length-1;o+=2){let a=t[o];if(typeof a!="string")return r.error("Expected string, but found ".concat(typeof a," instead."),o);if(/[^a-zA-Z0-9_]/.test(a))return r.error("Variable names must contain only alphanumeric characters or '_'.",o);let s=r.parse(t[o+1],o+1);if(!s)return null;n.push([a,s])}let i=r.parse(t[t.length-1],t.length-1,r.expectedType,n);return i?new e(n,i):null}outputDefined(){return this.result.outputDefined()}},Vi=class e{constructor(t,r){this.type=r.type,this.name=t,this.boundExpression=r}static parse(t,r){if(t.length!==2||typeof t[1]!="string")return r.error("'var' expression requires exactly one string literal argument.");let n=t[1];return r.scope.has(n)?new e(n,r.scope.get(n)):r.error('Unknown variable "'.concat(n,'". Make sure "').concat(n,'" has been bound in an enclosing "let" expression before using it.'),1)}evaluate(t){return this.boundExpression.evaluate(t)}eachChild(){}outputDefined(){return!1}},Za=class e{constructor(t,r,n){this.type=t,this.index=r,this.input=n}static parse(t,r){if(t.length!==3)return r.error("Expected 2 arguments, but found ".concat(t.length-1," instead."));let n=r.parse(t[1],1,L),i=r.parse(t[2],2,Ee(r.expectedType||$));if(!n||!i)return null;let o=i.type;return new e(o.itemType,n,i)}evaluate(t){let r=this.index.evaluate(t),n=this.input.evaluate(t);if(r<0)throw new ie("Array index out of bounds: ".concat(r," < 0."));if(r>=n.length)throw new ie("Array index out of bounds: ".concat(r," > ").concat(n.length-1,"."));if(r!==Math.floor(r))throw new ie("Array index must be an integer, but found ".concat(r," instead."));return n[r]}eachChild(t){t(this.index),t(this.input)}outputDefined(){return!1}},Wa=class e{constructor(t,r){this.type=U,this.needle=t,this.haystack=r}static parse(t,r){if(t.length!==3)return r.error("Expected 2 arguments, but found ".concat(t.length-1," instead."));let n=r.parse(t[1],1,$),i=r.parse(t[2],2,$);return!n||!i?null:us(n.type,[U,G,L,yr,$])?new e(n,i):r.error("Expected first argument to be of type boolean, string, number or null, but found ".concat(te(n.type)," instead"))}evaluate(t){let r=this.needle.evaluate(t),n=this.haystack.evaluate(t);if(!n)return!1;if(!Xr(r,["boolean","string","number","null"]))throw new ie("Expected first argument to be of type boolean, string, number or null, but found ".concat(te(ue(r))," instead."));if(!Xr(n,["string","array"]))throw new ie("Expected second argument to be of type array or string, but found ".concat(te(ue(n))," instead."));return n.indexOf(r)>=0}eachChild(t){t(this.needle),t(this.haystack)}outputDefined(){return!0}},Ha=class e{constructor(t,r,n){this.type=L,this.needle=t,this.haystack=r,this.fromIndex=n}static parse(t,r){if(t.length<=2||t.length>=5)return r.error("Expected 3 or 4 arguments, but found ".concat(t.length-1," instead."));let n=r.parse(t[1],1,$),i=r.parse(t[2],2,$);if(!n||!i)return null;if(!us(n.type,[U,G,L,yr,$]))return r.error("Expected first argument to be of type boolean, string, number or null, but found ".concat(te(n.type)," instead"));if(t.length===4){let o=r.parse(t[3],3,L);return o?new e(n,i,o):null}else return new e(n,i)}evaluate(t){let r=this.needle.evaluate(t),n=this.haystack.evaluate(t);if(!Xr(r,["boolean","string","number","null"]))throw new ie("Expected first argument to be of type boolean, string, number or null, but found ".concat(te(ue(r))," instead."));if(!Xr(n,["string","array"]))throw new ie("Expected second argument to be of type array or string, but found ".concat(te(ue(n))," instead."));if(this.fromIndex){let i=this.fromIndex.evaluate(t);return n.indexOf(r,i)}return n.indexOf(r)}eachChild(t){t(this.needle),t(this.haystack),this.fromIndex&&t(this.fromIndex)}outputDefined(){return!1}},Xa=class e{constructor(t,r,n,i,o,a){this.inputType=t,this.type=r,this.input=n,this.cases=i,this.outputs=o,this.otherwise=a}static parse(t,r){if(t.length<5)return r.error("Expected at least 4 arguments, but found only ".concat(t.length-1,"."));if(t.length%2!==1)return r.error("Expected an even number of arguments.");let n,i;r.expectedType&&r.expectedType.kind!=="value"&&(i=r.expectedType);let o={},a=[];for(let u=2;u<t.length-1;u+=2){let c=t[u],p=t[u+1];Array.isArray(c)||(c=[c]);let f=r.concat(u);if(c.length===0)return f.error("Expected at least one branch label.");for(let m of c){if(typeof m!="number"&&typeof m!="string")return f.error("Branch labels must be numbers or strings.");if(typeof m=="number"&&Math.abs(m)>Number.MAX_SAFE_INTEGER)return f.error("Branch labels must be integers no larger than ".concat(Number.MAX_SAFE_INTEGER,"."));if(typeof m=="number"&&Math.floor(m)!==m)return f.error("Numeric branch labels must be integer values.");if(!n)n=ue(m);else if(f.checkSubtype(n,ue(m)))return null;if(typeof o[String(m)]<"u")return f.error("Branch labels must be unique.");o[String(m)]=a.length}let y=r.parse(p,u,i);if(!y)return null;i=i||y.type,a.push(y)}let s=r.parse(t[1],1,$);if(!s)return null;let l=r.parse(t[t.length-1],t.length-1,i);return!l||s.type.kind!=="value"&&r.concat(1).checkSubtype(n,s.type)?null:new e(n,i,s,o,a,l)}evaluate(t){let r=this.input.evaluate(t);return(ue(r)===this.inputType&&this.outputs[this.cases[r]]||this.otherwise).evaluate(t)}eachChild(t){t(this.input),this.outputs.forEach(t),t(this.otherwise)}outputDefined(){return this.outputs.every(t=>t.outputDefined())&&this.otherwise.outputDefined()}},Ka=class e{constructor(t,r,n){this.type=t,this.branches=r,this.otherwise=n}static parse(t,r){if(t.length<4)return r.error("Expected at least 3 arguments, but found only ".concat(t.length-1,"."));if(t.length%2!==0)return r.error("Expected an odd number of arguments.");let n;r.expectedType&&r.expectedType.kind!=="value"&&(n=r.expectedType);let i=[];for(let a=1;a<t.length-1;a+=2){let s=r.parse(t[a],a,U);if(!s)return null;let l=r.parse(t[a+1],a+1,n);if(!l)return null;i.push([s,l]),n=n||l.type}let o=r.parse(t[t.length-1],t.length-1,n);if(!o)return null;if(!n)throw new Error("Can't infer output type");return new e(n,i,o)}evaluate(t){for(let[r,n]of this.branches)if(r.evaluate(t))return n.evaluate(t);return this.otherwise.evaluate(t)}eachChild(t){for(let[r,n]of this.branches)t(r),t(n);t(this.otherwise)}outputDefined(){return this.branches.every(([t,r])=>r.outputDefined())&&this.otherwise.outputDefined()}},Ya=class e{constructor(t,r,n,i){this.type=t,this.input=r,this.beginIndex=n,this.endIndex=i}static parse(t,r){if(t.length<=2||t.length>=5)return r.error("Expected 3 or 4 arguments, but found ".concat(t.length-1," instead."));let n=r.parse(t[1],1,$),i=r.parse(t[2],2,L);if(!n||!i)return null;if(!us(n.type,[Ee($),G,$]))return r.error("Expected first argument to be of type array or string, but found ".concat(te(n.type)," instead"));if(t.length===4){let o=r.parse(t[3],3,L);return o?new e(n.type,n,i,o):null}else return new e(n.type,n,i)}evaluate(t){let r=this.input.evaluate(t),n=this.beginIndex.evaluate(t);if(!Xr(r,["string","array"]))throw new ie("Expected first argument to be of type array or string, but found ".concat(te(ue(r))," instead."));if(this.endIndex){let i=this.endIndex.evaluate(t);return r.slice(n,i)}return r.slice(n)}eachChild(t){t(this.input),t(this.beginIndex),this.endIndex&&t(this.endIndex)}outputDefined(){return!1}};function Wi(e,t){let r=e.length-1,n=0,i=r,o=0,a,s;for(;n<=i;)if(o=Math.floor((n+i)/2),a=e[o],s=e[o+1],a<=t){if(o===r||t<s)return o;n=o+1}else if(a>t)i=o-1;else throw new ie("Input is not a number.");return 0}var pr=class e{constructor(t,r,n){this.type=t,this.input=r,this.labels=[],this.outputs=[];for(let[i,o]of n)this.labels.push(i),this.outputs.push(o)}static parse(t,r){if(t.length-1<4)return r.error("Expected at least 4 arguments, but found only ".concat(t.length-1,"."));if((t.length-1)%2!==0)return r.error("Expected an even number of arguments.");let n=r.parse(t[1],1,L);if(!n)return null;let i=[],o=null;r.expectedType&&r.expectedType.kind!=="value"&&(o=r.expectedType);for(let a=1;a<t.length;a+=2){let s=a===1?-1/0:t[a],l=t[a+1],u=a,c=a+1;if(typeof s!="number")return r.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.',u);if(i.length&&i[i.length-1][0]>=s)return r.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.',u);let p=r.parse(l,c,o);if(!p)return null;o=o||p.type,i.push([s,p])}return new e(o,n,i)}evaluate(t){let r=this.labels,n=this.outputs;if(r.length===1)return n[0].evaluate(t);let i=this.input.evaluate(t);if(i<=r[0])return n[0].evaluate(t);let o=r.length;if(i>=r[o-1])return n[o-1].evaluate(t);let a=Wi(r,i);return n[a].evaluate(t)}eachChild(t){t(this.input);for(let r of this.outputs)t(r)}outputDefined(){return this.outputs.every(t=>t.outputDefined())}};function km(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var Mm=_u;function _u(e,t,r,n){this.cx=3*e,this.bx=3*(r-e)-this.cx,this.ax=1-this.cx-this.bx,this.cy=3*t,this.by=3*(n-t)-this.cy,this.ay=1-this.cy-this.by,this.p1x=e,this.p1y=t,this.p2x=r,this.p2y=n}_u.prototype={sampleCurveX:function(e){return((this.ax*e+this.bx)*e+this.cx)*e},sampleCurveY:function(e){return((this.ay*e+this.by)*e+this.cy)*e},sampleCurveDerivativeX:function(e){return(3*this.ax*e+2*this.bx)*e+this.cx},solveCurveX:function(e,t){if(t===void 0&&(t=1e-6),e<0)return 0;if(e>1)return 1;for(var r=e,n=0;n<8;n++){var i=this.sampleCurveX(r)-e;if(Math.abs(i)<t)return r;var o=this.sampleCurveDerivativeX(r);if(Math.abs(o)<1e-6)break;r=r-i/o}var a=0,s=1;for(r=e,n=0;n<20&&(i=this.sampleCurveX(r),!(Math.abs(i-e)<t));n++)e>i?a=r:s=r,r=(s-a)*.5+a;return r},solve:function(e,t){return this.sampleCurveY(this.solveCurveX(e,t))}};var Em=km(Mm);function Fm(e){return e==="rgb"||e==="hcl"||e==="lab"}function zt(e,t,r){return e+r*(t-e)}function Lm(e,t,r,n="rgb"){switch(n){case"rgb":{let[i,o,a,s]=Bi(e.rgb,t.rgb,r);return new W(i,o,a,s,!1)}case"hcl":{let[i,o,a,s]=e.hcl,[l,u,c,p]=t.hcl,f,y;if(!isNaN(i)&&!isNaN(l)){let b=l-i;l>i&&b>180?b-=360:l<i&&i-l>180&&(b+=360),f=i+r*b}else isNaN(i)?isNaN(l)?f=NaN:(f=l,(a===1||a===0)&&(y=u)):(f=i,(c===1||c===0)&&(y=o));let[m,h,d,g]=wm([f,y!=null?y:zt(o,u,r),zt(a,c,r),zt(s,p,r)]);return new W(m,h,d,g,!1)}case"lab":{let[i,o,a,s]=wu(Bi(e.lab,t.lab,r));return new W(i,o,a,s,!1)}}}function Bi(e,t,r){return e.map((n,i)=>zt(n,t[i],r))}function Dm(e,t,r){return new Ze(Bi(e.values,t.values,r))}function Vm(e,t,r){let n=e.values,i=t.values;if(n.length!==i.length)throw new ie("Cannot interpolate values of different length. from: ".concat(e.toString(),", to: ").concat(t.toString()));let o=[];for(let a=0;a<n.length;a+=2){if(n[a]!==i[a])throw new ie("Cannot interpolate values containing mismatched anchors. from[".concat(a,"]: ").concat(n[a],", to[").concat(a,"]: ").concat(i[a]));o.push(n[a]);let[s,l]=n[a+1],[u,c]=i[a+1];o.push([zt(s,u,r),zt(l,c,r)])}return new Ne(o)}var Oe={number:zt,color:Lm,array:Bi,padding:Dm,variableAnchorOffsetCollection:Vm},Je=class e{constructor(t,r,n,i,o){this.type=t,this.operator=r,this.interpolation=n,this.input=i,this.labels=[],this.outputs=[];for(let[a,s]of o)this.labels.push(a),this.outputs.push(s)}static interpolationFactor(t,r,n,i){let o=0;if(t.name==="exponential")o=$a(r,t.base,n,i);else if(t.name==="linear")o=$a(r,1,n,i);else if(t.name==="cubic-bezier"){let a=t.controlPoints;o=new Em(a[0],a[1],a[2],a[3]).solve($a(r,1,n,i))}return o}static parse(t,r){let[n,i,o,...a]=t;if(!Array.isArray(i)||i.length===0)return r.error("Expected an interpolation type expression.",1);if(i[0]==="linear")i={name:"linear"};else if(i[0]==="exponential"){let u=i[1];if(typeof u!="number")return r.error("Exponential interpolation requires a numeric base.",1,1);i={name:"exponential",base:u}}else if(i[0]==="cubic-bezier"){let u=i.slice(1);if(u.length!==4||u.some(c=>typeof c!="number"||c<0||c>1))return r.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.",1);i={name:"cubic-bezier",controlPoints:u}}else return r.error("Unknown interpolation type ".concat(String(i[0])),1,0);if(t.length-1<4)return r.error("Expected at least 4 arguments, but found only ".concat(t.length-1,"."));if((t.length-1)%2!==0)return r.error("Expected an even number of arguments.");if(o=r.parse(o,2,L),!o)return null;let s=[],l=null;n==="interpolate-hcl"||n==="interpolate-lab"?l=Re:r.expectedType&&r.expectedType.kind!=="value"&&(l=r.expectedType);for(let u=0;u<a.length;u+=2){let c=a[u],p=a[u+1],f=u+3,y=u+4;if(typeof c!="number")return r.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.',f);if(s.length&&s[s.length-1][0]>=c)return r.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.',f);let m=r.parse(p,y,l);if(!m)return null;l=l||m.type,s.push([c,m])}return!jr(l,L)&&!jr(l,Re)&&!jr(l,Ji)&&!jr(l,Zi)&&!jr(l,Ee(L))?r.error("Type ".concat(te(l)," is not interpolatable.")):new e(l,n,i,o,s)}evaluate(t){let r=this.labels,n=this.outputs;if(r.length===1)return n[0].evaluate(t);let i=this.input.evaluate(t);if(i<=r[0])return n[0].evaluate(t);let o=r.length;if(i>=r[o-1])return n[o-1].evaluate(t);let a=Wi(r,i),s=r[a],l=r[a+1],u=e.interpolationFactor(this.interpolation,i,s,l),c=n[a].evaluate(t),p=n[a+1].evaluate(t);switch(this.operator){case"interpolate":return Oe[this.type.kind](c,p,u);case"interpolate-hcl":return Oe.color(c,p,u,"hcl");case"interpolate-lab":return Oe.color(c,p,u,"lab")}}eachChild(t){t(this.input);for(let r of this.outputs)t(r)}outputDefined(){return this.outputs.every(t=>t.outputDefined())}};function $a(e,t,r,n){let i=n-r,o=e-r;return i===0?0:t===1?o/i:(Math.pow(t,o)-1)/(Math.pow(t,i)-1)}var zi=class e{constructor(t,r){this.type=t,this.args=r}static parse(t,r){if(t.length<2)return r.error("Expectected at least one argument.");let n=null,i=r.expectedType;i&&i.kind!=="value"&&(n=i);let o=[];for(let s of t.slice(1)){let l=r.parse(s,1+o.length,n,void 0,{typeAnnotation:"omit"});if(!l)return null;n=n||l.type,o.push(l)}if(!n)throw new Error("No output type");return i&&o.some(s=>Hr(i,s.type))?new e($,o):new e(n,o)}evaluate(t){let r=null,n=0,i;for(let o of this.args)if(n++,r=o.evaluate(t),r&&r instanceof Te&&!r.available&&(i||(i=r.name),r=null,n===this.args.length&&(r=i)),r!==null)break;return r}eachChild(t){this.args.forEach(t)}outputDefined(){return this.args.every(t=>t.outputDefined())}};function Ql(e,t){return e==="=="||e==="!="?t.kind==="boolean"||t.kind==="string"||t.kind==="number"||t.kind==="null"||t.kind==="value":t.kind==="string"||t.kind==="number"||t.kind==="value"}function Bm(e,t,r){return t===r}function zm(e,t,r){return t!==r}function Rm(e,t,r){return t<r}function Om(e,t,r){return t>r}function Nm(e,t,r){return t<=r}function Um(e,t,r){return t>=r}function Iu(e,t,r,n){return n.compare(t,r)===0}function $m(e,t,r,n){return!Iu(e,t,r,n)}function Gm(e,t,r,n){return n.compare(t,r)<0}function qm(e,t,r,n){return n.compare(t,r)>0}function jm(e,t,r,n){return n.compare(t,r)<=0}function Jm(e,t,r,n){return n.compare(t,r)>=0}function hr(e,t,r){let n=e!=="=="&&e!=="!=";return class Tu{constructor(o,a,s){this.type=U,this.lhs=o,this.rhs=a,this.collator=s,this.hasUntypedArgument=o.type.kind==="value"||a.type.kind==="value"}static parse(o,a){if(o.length!==3&&o.length!==4)return a.error("Expected two or three arguments.");let s=o[0],l=a.parse(o[1],1,$);if(!l)return null;if(!Ql(s,l.type))return a.concat(1).error('"'.concat(s,"\\" comparisons are not supported for type '").concat(te(l.type),"'."));let u=a.parse(o[2],2,$);if(!u)return null;if(!Ql(s,u.type))return a.concat(2).error('"'.concat(s,"\\" comparisons are not supported for type '").concat(te(u.type),"'."));if(l.type.kind!==u.type.kind&&l.type.kind!=="value"&&u.type.kind!=="value")return a.error("Cannot compare types '".concat(te(l.type),"' and '").concat(te(u.type),"'."));n&&(l.type.kind==="value"&&u.type.kind!=="value"?l=new je(u.type,[l]):l.type.kind!=="value"&&u.type.kind==="value"&&(u=new je(l.type,[u])));let c=null;if(o.length===4){if(l.type.kind!=="string"&&u.type.kind!=="string"&&l.type.kind!=="value"&&u.type.kind!=="value")return a.error("Cannot use collator to compare non-string types.");if(c=a.parse(o[3],3,ji),!c)return null}return new Tu(l,u,c)}evaluate(o){let a=this.lhs.evaluate(o),s=this.rhs.evaluate(o);if(n&&this.hasUntypedArgument){let l=ue(a),u=ue(s);if(l.kind!==u.kind||!(l.kind==="string"||l.kind==="number"))throw new ie('Expected arguments for "'.concat(e,'" to be (string, string) or (number, number), but found (').concat(l.kind,", ").concat(u.kind,") instead."))}if(this.collator&&!n&&this.hasUntypedArgument){let l=ue(a),u=ue(s);if(l.kind!=="string"||u.kind!=="string")return t(o,a,s)}return this.collator?r(o,a,s,this.collator.evaluate(o)):t(o,a,s)}eachChild(o){o(this.lhs),o(this.rhs),this.collator&&o(this.collator)}outputDefined(){return!0}}}var Zm=hr("==",Bm,Iu),Wm=hr("!=",zm,$m),Hm=hr("<",Rm,Gm),Xm=hr(">",Om,qm),Km=hr("<=",Nm,jm),Ym=hr(">=",Um,Jm),Ri=class e{constructor(t,r,n){this.type=ji,this.locale=n,this.caseSensitive=t,this.diacriticSensitive=r}static parse(t,r){if(t.length!==2)return r.error("Expected one argument.");let n=t[1];if(typeof n!="object"||Array.isArray(n))return r.error("Collator options argument must be an object.");let i=r.parse(n["case-sensitive"]===void 0?!1:n["case-sensitive"],1,U);if(!i)return null;let o=r.parse(n["diacritic-sensitive"]===void 0?!1:n["diacritic-sensitive"],1,U);if(!o)return null;let a=null;return n.locale&&(a=r.parse(n.locale,1,G),!a)?null:new e(i,o,a)}evaluate(t){return new Kr(this.caseSensitive.evaluate(t),this.diacriticSensitive.evaluate(t),this.locale?this.locale.evaluate(t):null)}eachChild(t){t(this.caseSensitive),t(this.diacriticSensitive),this.locale&&t(this.locale)}outputDefined(){return!1}},Qa=class e{constructor(t,r,n,i,o){this.type=G,this.number=t,this.locale=r,this.currency=n,this.minFractionDigits=i,this.maxFractionDigits=o}static parse(t,r){if(t.length!==3)return r.error("Expected two arguments.");let n=r.parse(t[1],1,L);if(!n)return null;let i=t[2];if(typeof i!="object"||Array.isArray(i))return r.error("NumberFormat options argument must be an object.");let o=null;if(i.locale&&(o=r.parse(i.locale,1,G),!o))return null;let a=null;if(i.currency&&(a=r.parse(i.currency,1,G),!a))return null;let s=null;if(i["min-fraction-digits"]&&(s=r.parse(i["min-fraction-digits"],1,L),!s))return null;let l=null;return i["max-fraction-digits"]&&(l=r.parse(i["max-fraction-digits"],1,L),!l)?null:new e(n,o,a,s,l)}evaluate(t){return new Intl.NumberFormat(this.locale?this.locale.evaluate(t):[],{style:this.currency?"currency":"decimal",currency:this.currency?this.currency.evaluate(t):void 0,minimumFractionDigits:this.minFractionDigits?this.minFractionDigits.evaluate(t):void 0,maximumFractionDigits:this.maxFractionDigits?this.maxFractionDigits.evaluate(t):void 0}).format(this.number.evaluate(t))}eachChild(t){t(this.number),this.locale&&t(this.locale),this.currency&&t(this.currency),this.minFractionDigits&&t(this.minFractionDigits),this.maxFractionDigits&&t(this.maxFractionDigits)}outputDefined(){return!1}},en=class e{constructor(t){this.type=mr,this.sections=t}static parse(t,r){if(t.length<2)return r.error("Expected at least one argument.");let n=t[1];if(!Array.isArray(n)&&typeof n=="object")return r.error("First argument must be an image or text section.");let i=[],o=!1;for(let a=1;a<=t.length-1;++a){let s=t[a];if(o&&typeof s=="object"&&!Array.isArray(s)){o=!1;let l=null;if(s["font-scale"]&&(l=r.parse(s["font-scale"],1,L),!l))return null;let u=null;if(s["text-font"]&&(u=r.parse(s["text-font"],1,Ee(G)),!u))return null;let c=null;if(s["text-color"]&&(c=r.parse(s["text-color"],1,Re),!c))return null;let p=i[i.length-1];p.scale=l,p.font=u,p.textColor=c}else{let l=r.parse(t[a],1,$);if(!l)return null;let u=l.type.kind;if(u!=="string"&&u!=="value"&&u!=="null"&&u!=="resolvedImage")return r.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");o=!0,i.push({content:l,scale:null,font:null,textColor:null})}}return new e(i)}evaluate(t){let r=n=>{let i=n.content.evaluate(t);return ue(i)===un?new Yr("",i,null,null,null):new Yr(Zr(i),null,n.scale?n.scale.evaluate(t):null,n.font?n.font.evaluate(t).join(","):null,n.textColor?n.textColor.evaluate(t):null)};return new Fe(this.sections.map(r))}eachChild(t){for(let r of this.sections)t(r.content),r.scale&&t(r.scale),r.font&&t(r.font),r.textColor&&t(r.textColor)}outputDefined(){return!1}},es=class e{constructor(t){this.type=un,this.input=t}static parse(t,r){if(t.length!==2)return r.error("Expected two arguments.");let n=r.parse(t[1],1,G);return n?new e(n):r.error("No image name provided.")}evaluate(t){let r=this.input.evaluate(t),n=Te.fromString(r);return n&&t.availableImages&&(n.available=t.availableImages.indexOf(r)>-1),n}eachChild(t){t(this.input)}outputDefined(){return!1}},ts=class e{constructor(t){this.type=L,this.input=t}static parse(t,r){if(t.length!==2)return r.error("Expected 1 argument, but found ".concat(t.length-1," instead."));let n=r.parse(t[1],1);return n?n.type.kind!=="array"&&n.type.kind!=="string"&&n.type.kind!=="value"?r.error("Expected argument of type string or array, but found ".concat(te(n.type)," instead.")):new e(n):null}evaluate(t){let r=this.input.evaluate(t);if(typeof r=="string")return r.length;if(Array.isArray(r))return r.length;throw new ie("Expected value to be of type string or array, but found ".concat(te(ue(r))," instead."))}eachChild(t){t(this.input)}outputDefined(){return!1}},Xe=8192;function Qm(e,t){let r=eh(e[0]),n=rh(e[1]),i=Math.pow(2,t.z);return[Math.round(r*i*Xe),Math.round(n*i*Xe)]}function cs(e,t){let r=Math.pow(2,t.z),n=(e[0]/Xe+t.x)/r,i=(e[1]/Xe+t.y)/r;return[th(n),nh(i)]}function eh(e){return(180+e)/360}function th(e){return e*360-180}function rh(e){return(180-180/Math.PI*Math.log(Math.tan(Math.PI/4+e*Math.PI/360)))/360}function nh(e){return 360/Math.PI*Math.atan(Math.exp((180-e*360)*Math.PI/180))-90}function cn(e,t){e[0]=Math.min(e[0],t[0]),e[1]=Math.min(e[1],t[1]),e[2]=Math.max(e[2],t[0]),e[3]=Math.max(e[3],t[1])}function tn(e,t){return!(e[0]<=t[0]||e[2]>=t[2]||e[1]<=t[1]||e[3]>=t[3])}function ih(e,t,r){return t[1]>e[1]!=r[1]>e[1]&&e[0]<(r[0]-t[0])*(e[1]-t[1])/(r[1]-t[1])+t[0]}function oh(e,t,r){let n=e[0]-t[0],i=e[1]-t[1],o=e[0]-r[0],a=e[1]-r[1];return n*a-o*i===0&&n*o<=0&&i*a<=0}function Hi(e,t,r,n){let i=[t[0]-e[0],t[1]-e[1]],o=[n[0]-r[0],n[1]-r[1]];return uh(o,i)===0?!1:!!(eu(e,t,r,n)&&eu(r,n,e,t))}function ah(e,t,r){for(let n of r)for(let i=0;i<n.length-1;++i)if(Hi(e,t,n[i],n[i+1]))return!0;return!1}function dr(e,t,r=!1){let n=!1;for(let i of t)for(let o=0;o<i.length-1;o++){if(oh(e,i[o],i[o+1]))return r;ih(e,i[o],i[o+1])&&(n=!n)}return n}function sh(e,t){for(let r of t)if(dr(e,r))return!0;return!1}function Cu(e,t){for(let r of e)if(!dr(r,t))return!1;for(let r=0;r<e.length-1;++r)if(ah(e[r],e[r+1],t))return!1;return!0}function lh(e,t){for(let r of t)if(Cu(e,r))return!0;return!1}function uh(e,t){return e[0]*t[1]-e[1]*t[0]}function eu(e,t,r,n){let i=e[0]-r[0],o=e[1]-r[1],a=t[0]-r[0],s=t[1]-r[1],l=n[0]-r[0],u=n[1]-r[1],c=i*u-l*o,p=a*u-l*s;return c>0&&p<0||c<0&&p>0}function ps(e,t,r){let n=[];for(let i=0;i<e.length;i++){let o=[];for(let a=0;a<e[i].length;a++){let s=Qm(e[i][a],r);cn(t,s),o.push(s)}n.push(o)}return n}function ku(e,t,r){let n=[];for(let i=0;i<e.length;i++){let o=ps(e[i],t,r);n.push(o)}return n}function Mu(e,t,r,n){if(e[0]<r[0]||e[0]>r[2]){let i=n*.5,o=e[0]-r[0]>i?-n:r[0]-e[0]>i?n:0;o===0&&(o=e[0]-r[2]>i?-n:r[2]-e[0]>i?n:0),e[0]+=o}cn(t,e)}function ch(e){e[0]=e[1]=1/0,e[2]=e[3]=-1/0}function tu(e,t,r,n){let i=Math.pow(2,n.z)*Xe,o=[n.x*Xe,n.y*Xe],a=[];for(let s of e)for(let l of s){let u=[l.x+o[0],l.y+o[1]];Mu(u,t,r,i),a.push(u)}return a}function ru(e,t,r,n){let i=Math.pow(2,n.z)*Xe,o=[n.x*Xe,n.y*Xe],a=[];for(let s of e){let l=[];for(let u of s){let c=[u.x+o[0],u.y+o[1]];cn(t,c),l.push(c)}a.push(l)}if(t[2]-t[0]<=i/2){ch(t);for(let s of a)for(let l of s)Mu(l,t,r,i)}return a}function ph(e,t){let r=[1/0,1/0,-1/0,-1/0],n=[1/0,1/0,-1/0,-1/0],i=e.canonicalID();if(t.type==="Polygon"){let o=ps(t.coordinates,n,i),a=tu(e.geometry(),r,n,i);if(!tn(r,n))return!1;for(let s of a)if(!dr(s,o))return!1}if(t.type==="MultiPolygon"){let o=ku(t.coordinates,n,i),a=tu(e.geometry(),r,n,i);if(!tn(r,n))return!1;for(let s of a)if(!sh(s,o))return!1}return!0}function fh(e,t){let r=[1/0,1/0,-1/0,-1/0],n=[1/0,1/0,-1/0,-1/0],i=e.canonicalID();if(t.type==="Polygon"){let o=ps(t.coordinates,n,i),a=ru(e.geometry(),r,n,i);if(!tn(r,n))return!1;for(let s of a)if(!Cu(s,o))return!1}if(t.type==="MultiPolygon"){let o=ku(t.coordinates,n,i),a=ru(e.geometry(),r,n,i);if(!tn(r,n))return!1;for(let s of a)if(!lh(s,o))return!1}return!0}var rn=class e{constructor(t,r){this.type=U,this.geojson=t,this.geometries=r}static parse(t,r){if(t.length!==2)return r.error("'within' expression requires exactly one argument, but found ".concat(t.length-1," instead."));if(Qr(t[1])){let n=t[1];if(n.type==="FeatureCollection"){let i=[];for(let o of n.features){let{type:a,coordinates:s}=o.geometry;a==="Polygon"&&i.push(s),a==="MultiPolygon"&&i.push(...s)}if(i.length){let o={type:"MultiPolygon",coordinates:i};return new e(n,o)}}else if(n.type==="Feature"){let i=n.geometry.type;if(i==="Polygon"||i==="MultiPolygon")return new e(n,n.geometry)}else if(n.type==="Polygon"||n.type==="MultiPolygon")return new e(n,n)}return r.error("'within' expression requires valid geojson object that contains polygon geometry type.")}evaluate(t){if(t.geometry()!=null&&t.canonicalID()!=null){if(t.geometryType()==="Point")return ph(t,this.geometries);if(t.geometryType()==="LineString")return fh(t,this.geometries)}return!1}eachChild(){}outputDefined(){return!0}},Oi=class{constructor(t=[],r=yh){if(this.data=t,this.length=this.data.length,this.compare=r,this.length>0)for(let n=(this.length>>1)-1;n>=0;n--)this._down(n)}push(t){this.data.push(t),this.length++,this._up(this.length-1)}pop(){if(this.length===0)return;let t=this.data[0],r=this.data.pop();return this.length--,this.length>0&&(this.data[0]=r,this._down(0)),t}peek(){return this.data[0]}_up(t){let{data:r,compare:n}=this,i=r[t];for(;t>0;){let o=t-1>>1,a=r[o];if(n(i,a)>=0)break;r[t]=a,t=o}r[t]=i}_down(t){let{data:r,compare:n}=this,i=this.length>>1,o=r[t];for(;t<i;){let a=(t<<1)+1,s=r[a],l=a+1;if(l<this.length&&n(r[l],s)<0&&(a=l,s=r[l]),n(s,o)>=0)break;r[t]=s,t=a}r[t]=o}};function yh(e,t){return e<t?-1:e>t?1:0}function mh(e,t,r,n,i){Eu(e,t,r,n||e.length-1,i||hh)}function Eu(e,t,r,n,i){for(;n>r;){if(n-r>600){var o=n-r+1,a=t-r+1,s=Math.log(o),l=.5*Math.exp(2*s/3),u=.5*Math.sqrt(s*l*(o-l)/o)*(a-o/2<0?-1:1),c=Math.max(r,Math.floor(t-a*l/o+u)),p=Math.min(n,Math.floor(t+(o-a)*l/o+u));Eu(e,t,c,p,i)}var f=e[t],y=r,m=n;for(Jr(e,r,t),i(e[n],f)>0&&Jr(e,r,n);y<m;){for(Jr(e,y,m),y++,m--;i(e[y],f)<0;)y++;for(;i(e[m],f)>0;)m--}i(e[r],f)===0?Jr(e,r,m):(m++,Jr(e,m,n)),m<=t&&(r=m+1),t<=m&&(n=m-1)}}function Jr(e,t,r){var n=e[t];e[t]=e[r],e[r]=n}function hh(e,t){return e<t?-1:e>t?1:0}function dh(e,t){if(e.length<=1)return[e];let n=[],i,o;for(let a of e){let s=xh(a);s!==0&&(a.area=Math.abs(s),o===void 0&&(o=s<0),o===s<0?(i&&n.push(i),i=[a]):i.push(a))}if(i&&n.push(i),t>1)for(let a=0;a<n.length;a++)n[a].length<=t||(mh(n[a],t,1,n[a].length-1,gh),n[a]=n[a].slice(0,t));return n}function gh(e,t){return t.area-e.area}function xh(e){let t=0;for(let r=0,n=e.length,i=n-1,o,a;r<n;i=r++)o=e[r],a=e[i],t+=(a.x-o.x)*(o.y+a.y);return t}var bh=6378.137,nu=1/298.257223563,iu=nu*(2-nu),ou=Math.PI/180,nn=class{constructor(t){let r=ou*bh*1e3,n=Math.cos(t*ou),i=1/(1-iu*(1-n*n)),o=Math.sqrt(i);this.kx=r*o*n,this.ky=r*o*i*(1-iu)}distance(t,r){let n=this.wrap(t[0]-r[0])*this.kx,i=(t[1]-r[1])*this.ky;return Math.sqrt(n*n+i*i)}pointOnLine(t,r){let n=1/0,i,o,a,s;for(let l=0;l<t.length-1;l++){let u=t[l][0],c=t[l][1],p=this.wrap(t[l+1][0]-u)*this.kx,f=(t[l+1][1]-c)*this.ky,y=0;(p!==0||f!==0)&&(y=(this.wrap(r[0]-u)*this.kx*p+(r[1]-c)*this.ky*f)/(p*p+f*f),y>1?(u=t[l+1][0],c=t[l+1][1]):y>0&&(u+=p/this.kx*y,c+=f/this.ky*y)),p=this.wrap(r[0]-u)*this.kx,f=(r[1]-c)*this.ky;let m=p*p+f*f;m<n&&(n=m,i=u,o=c,a=l,s=y)}return{point:[i,o],index:a,t:Math.max(0,Math.min(1,s))}}wrap(t){for(;t<-180;)t+=360;for(;t>180;)t-=360;return t}},rs=100,ns=50;function Fu(e,t){return t[0]-e[0]}function Ni(e){return e[1]-e[0]+1}function st(e,t){return e[1]>=e[0]&&e[1]<t}function is(e,t){if(e[0]>e[1])return[null,null];let r=Ni(e);if(t){if(r===2)return[e,null];let i=Math.floor(r/2);return[[e[0],e[0]+i],[e[0]+i,e[1]]]}if(r===1)return[e,null];let n=Math.floor(r/2)-1;return[[e[0],e[0]+n],[e[0]+n+1,e[1]]]}function os(e,t){if(!st(t,e.length))return[1/0,1/0,-1/0,-1/0];let r=[1/0,1/0,-1/0,-1/0];for(let n=t[0];n<=t[1];++n)cn(r,e[n]);return r}function as(e){let t=[1/0,1/0,-1/0,-1/0];for(let r of e)for(let n of r)cn(t,n);return t}function au(e){return e[0]!==-1/0&&e[1]!==-1/0&&e[2]!==1/0&&e[3]!==1/0}function fs(e,t,r){if(!au(e)||!au(t))return NaN;let n=0,i=0;return e[2]<t[0]&&(n=t[0]-e[2]),e[0]>t[2]&&(n=e[0]-t[2]),e[1]>t[3]&&(i=e[1]-t[3]),e[3]<t[1]&&(i=t[1]-e[3]),r.distance([0,0],[n,i])}function Bt(e,t,r){let n=r.pointOnLine(t,e);return r.distance(e,n.point)}function ys(e,t,r,n,i){let o=Math.min(Bt(e,[r,n],i),Bt(t,[r,n],i)),a=Math.min(Bt(r,[e,t],i),Bt(n,[e,t],i));return Math.min(o,a)}function vh(e,t,r,n,i){if(!(st(t,e.length)&&st(n,r.length)))return 1/0;let a=1/0;for(let s=t[0];s<t[1];++s){let l=e[s],u=e[s+1];for(let c=n[0];c<n[1];++c){let p=r[c],f=r[c+1];if(Hi(l,u,p,f))return 0;a=Math.min(a,ys(l,u,p,f,i))}}return a}function Ph(e,t,r,n,i){if(!(st(t,e.length)&&st(n,r.length)))return NaN;let a=1/0;for(let s=t[0];s<=t[1];++s)for(let l=n[0];l<=n[1];++l)if(a=Math.min(a,i.distance(e[s],r[l])),a===0)return a;return a}function Sh(e,t,r){if(dr(e,t,!0))return 0;let n=1/0;for(let i of t){let o=i[0],a=i[i.length-1];if(o!==a&&(n=Math.min(n,Bt(e,[a,o],r)),n===0))return n;let s=r.pointOnLine(i,e);if(n=Math.min(n,r.distance(e,s.point)),n===0)return n}return n}function wh(e,t,r,n){if(!st(t,e.length))return NaN;for(let o=t[0];o<=t[1];++o)if(dr(e[o],r,!0))return 0;let i=1/0;for(let o=t[0];o<t[1];++o){let a=e[o],s=e[o+1];for(let l of r)for(let u=0,c=l.length,p=c-1;u<c;p=u++){let f=l[p],y=l[u];if(Hi(a,s,f,y))return 0;i=Math.min(i,ys(a,s,f,y,n))}}return i}function su(e,t){for(let r of e)for(let n of r)if(dr(n,t,!0))return!0;return!1}function Ah(e,t,r,n=1/0){let i=as(e),o=as(t);if(n!==1/0&&fs(i,o,r)>=n)return n;if(tn(i,o)){if(su(e,t))return 0}else if(su(t,e))return 0;let a=1/0;for(let s of e)for(let l=0,u=s.length,c=u-1;l<u;c=l++){let p=s[c],f=s[l];for(let y of t)for(let m=0,h=y.length,d=h-1;m<h;d=m++){let g=y[d],b=y[m];if(Hi(p,f,g,b))return 0;a=Math.min(a,ys(p,f,g,b,r))}}return a}function lu(e,t,r,n,i,o){if(!o)return;let a=fs(os(n,o),i,r);a<t&&e.push([a,o,[0,0]])}function ki(e,t,r,n,i,o,a){if(!o||!a)return;let s=fs(os(n,o),os(i,a),r);s<t&&e.push([s,o,a])}function Ui(e,t,r,n,i=1/0){let o=Math.min(n.distance(e[0],r[0][0]),i);if(o===0)return o;let a=new Oi([[0,[0,e.length-1],[0,0]]],Fu),s=as(r);for(;a.length>0;){let l=a.pop();if(l[0]>=o)continue;let u=l[1],c=t?ns:rs;if(Ni(u)<=c){if(!st(u,e.length))return NaN;if(t){let p=wh(e,u,r,n);if(isNaN(p)||p===0)return p;o=Math.min(o,p)}else for(let p=u[0];p<=u[1];++p){let f=Sh(e[p],r,n);if(o=Math.min(o,f),o===0)return 0}}else{let p=is(u,t);lu(a,o,n,e,s,p[0]),lu(a,o,n,e,s,p[1])}}return o}function $i(e,t,r,n,i,o=1/0){let a=Math.min(o,i.distance(e[0],r[0]));if(a===0)return a;let s=new Oi([[0,[0,e.length-1],[0,r.length-1]]],Fu);for(;s.length>0;){let l=s.pop();if(l[0]>=a)continue;let u=l[1],c=l[2],p=t?ns:rs,f=n?ns:rs;if(Ni(u)<=p&&Ni(c)<=f){if(!st(u,e.length)&&st(c,r.length))return NaN;let y;if(t&&n)y=vh(e,u,r,c,i),a=Math.min(a,y);else if(t&&!n){let m=e.slice(u[0],u[1]+1);for(let h=c[0];h<=c[1];++h)if(y=Bt(r[h],m,i),a=Math.min(a,y),a===0)return a}else if(!t&&n){let m=r.slice(c[0],c[1]+1);for(let h=u[0];h<=u[1];++h)if(y=Bt(e[h],m,i),a=Math.min(a,y),a===0)return a}else y=Ph(e,u,r,c,i),a=Math.min(a,y)}else{let y=is(u,t),m=is(c,n);ki(s,a,i,e,r,y[0],m[0]),ki(s,a,i,e,r,y[0],m[1]),ki(s,a,i,e,r,y[1],m[0]),ki(s,a,i,e,r,y[1],m[1])}}return a}function _h(e,t){let r=e.geometry(),n=r.flat().map(a=>cs([a.x,a.y],e.canonical));if(r.length===0)return NaN;let i=new nn(n[0][1]),o=1/0;for(let a of t){switch(a.type){case"Point":o=Math.min(o,$i(n,!1,[a.coordinates],!1,i,o));break;case"LineString":o=Math.min(o,$i(n,!1,a.coordinates,!0,i,o));break;case"Polygon":o=Math.min(o,Ui(n,!1,a.coordinates,i,o));break}if(o===0)return o}return o}function Ih(e,t){let r=e.geometry(),n=r.flat().map(a=>cs([a.x,a.y],e.canonical));if(r.length===0)return NaN;let i=new nn(n[0][1]),o=1/0;for(let a of t){switch(a.type){case"Point":o=Math.min(o,$i(n,!0,[a.coordinates],!1,i,o));break;case"LineString":o=Math.min(o,$i(n,!0,a.coordinates,!0,i,o));break;case"Polygon":o=Math.min(o,Ui(n,!0,a.coordinates,i,o));break}if(o===0)return o}return o}function Th(e,t){let r=e.geometry();if(r.length===0||r[0].length===0)return NaN;let n=dh(r,0).map(a=>a.map(s=>s.map(l=>cs([l.x,l.y],e.canonical)))),i=new nn(n[0][0][0][1]),o=1/0;for(let a of t)for(let s of n){switch(a.type){case"Point":o=Math.min(o,Ui([a.coordinates],!1,s,i,o));break;case"LineString":o=Math.min(o,Ui(a.coordinates,!0,s,i,o));break;case"Polygon":o=Math.min(o,Ah(s,a.coordinates,i,o));break}if(o===0)return o}return o}function Ga(e){return e.type==="MultiPolygon"?e.coordinates.map(t=>({type:"Polygon",coordinates:t})):e.type==="MultiLineString"?e.coordinates.map(t=>({type:"LineString",coordinates:t})):e.type==="MultiPoint"?e.coordinates.map(t=>({type:"Point",coordinates:t})):[e]}var on=class e{constructor(t,r){this.type=L,this.geojson=t,this.geometries=r}static parse(t,r){if(t.length!==2)return r.error("'distance' expression requires exactly one argument, but found ".concat(t.length-1," instead."));if(Qr(t[1])){let n=t[1];if(n.type==="FeatureCollection")return new e(n,n.features.map(i=>Ga(i.geometry)).flat());if(n.type==="Feature")return new e(n,Ga(n.geometry));if("type"in n&&"coordinates"in n)return new e(n,Ga(n))}return r.error("'distance' expression requires valid geojson object that contains polygon geometry type.")}evaluate(t){if(t.geometry()!=null&&t.canonicalID()!=null){if(t.geometryType()==="Point")return _h(t,this.geometries);if(t.geometryType()==="LineString")return Ih(t,this.geometries);if(t.geometryType()==="Polygon")return Th(t,this.geometries)}return NaN}eachChild(){}outputDefined(){return!0}},Ut={"==":Zm,"!=":Wm,">":Xm,"<":Hm,">=":Ym,"<=":Km,array:je,at:Za,boolean:je,case:Ka,coalesce:zi,collator:Ri,format:en,image:es,in:Wa,"index-of":Ha,interpolate:Je,"interpolate-hcl":Je,"interpolate-lab":Je,length:ts,let:Di,literal:mt,match:Xa,number:je,"number-format":Qa,object:je,slice:Ya,step:pr,string:je,"to-boolean":yt,"to-color":yt,"to-number":yt,"to-string":yt,var:Vi,within:rn,distance:on},Ke=class e{constructor(t,r,n,i){this.name=t,this.type=r,this._evaluate=n,this.args=i}evaluate(t){return this._evaluate(t,this.args)}eachChild(t){this.args.forEach(t)}outputDefined(){return!1}static parse(t,r){let n=t[0],i=e.definitions[n];if(!i)return r.error('Unknown expression "'.concat(n,'". If you wanted a literal array, use ["literal", [...]].'),0);let o=Array.isArray(i)?i[0]:i.type,a=Array.isArray(i)?[[i[1],i[2]]]:i.overloads,s=a.filter(([u])=>!Array.isArray(u)||u.length===t.length-1),l=null;for(let[u,c]of s){l=new Li(r.registry,Gi,r.path,null,r.scope);let p=[],f=!1;for(let y=1;y<t.length;y++){let m=t[y],h=Array.isArray(u)?u[y-1]:u.type,d=l.parse(m,1+p.length,h);if(!d){f=!0;break}p.push(d)}if(!f){if(Array.isArray(u)&&u.length!==p.length){l.error("Expected ".concat(u.length," arguments, but found ").concat(p.length," instead."));continue}for(let y=0;y<p.length;y++){let m=Array.isArray(u)?u[y]:u.type,h=p[y];l.concat(y+1).checkSubtype(m,h.type)}if(l.errors.length===0)return new e(n,o,c,p)}}if(s.length===1)r.errors.push(...l.errors);else{let c=(s.length?s:a).map(([f])=>kh(f)).join(" | "),p=[];for(let f=1;f<t.length;f++){let y=r.parse(t[f],1+p.length);if(!y)return null;p.push(te(y.type))}r.error("Expected arguments of type ".concat(c,", but found (").concat(p.join(", "),") instead."))}return null}static register(t,r){e.definitions=r;for(let n in r)t[n]=e}};function uu(e,[t,r,n,i]){t=t.evaluate(e),r=r.evaluate(e),n=n.evaluate(e);let o=i?i.evaluate(e):1,a=Au(t,r,n,o);if(a)throw new ie(a);return new W(t/255,r/255,n/255,o,!1)}function cu(e,t){return e in t}function qa(e,t){let r=t[e];return typeof r>"u"?null:r}function Ch(e,t,r,n){for(;r<=n;){let i=r+n>>1;if(t[i]===e)return!0;t[i]>e?n=i-1:r=i+1}return!1}function Vt(e){return{type:e}}Ke.register(Ut,{error:[gm,[G],(e,[t])=>{throw new ie(t.evaluate(e))}],typeof:[G,[$],(e,[t])=>te(ue(t.evaluate(e)))],"to-rgba":[Ee(L,4),[Re],(e,[t])=>{let[r,n,i,o]=t.evaluate(e).rgb;return[r*255,n*255,i*255,o]}],rgb:[Re,[L,L,L],uu],rgba:[Re,[L,L,L,L],uu],has:{type:U,overloads:[[[G],(e,[t])=>cu(t.evaluate(e),e.properties())],[[G,lr],(e,[t,r])=>cu(t.evaluate(e),r.evaluate(e))]]},get:{type:$,overloads:[[[G],(e,[t])=>qa(t.evaluate(e),e.properties())],[[G,lr],(e,[t,r])=>qa(t.evaluate(e),r.evaluate(e))]]},"feature-state":[$,[G],(e,[t])=>qa(t.evaluate(e),e.featureState||{})],properties:[lr,[],e=>e.properties()],"geometry-type":[G,[],e=>e.geometryType()],id:[$,[],e=>e.id()],zoom:[L,[],e=>e.globals.zoom],"heatmap-density":[L,[],e=>e.globals.heatmapDensity||0],"line-progress":[L,[],e=>e.globals.lineProgress||0],accumulated:[$,[],e=>e.globals.accumulated===void 0?null:e.globals.accumulated],"+":[L,Vt(L),(e,t)=>{let r=0;for(let n of t)r+=n.evaluate(e);return r}],"*":[L,Vt(L),(e,t)=>{let r=1;for(let n of t)r*=n.evaluate(e);return r}],"-":{type:L,overloads:[[[L,L],(e,[t,r])=>t.evaluate(e)-r.evaluate(e)],[[L],(e,[t])=>-t.evaluate(e)]]},"/":[L,[L,L],(e,[t,r])=>t.evaluate(e)/r.evaluate(e)],"%":[L,[L,L],(e,[t,r])=>t.evaluate(e)%r.evaluate(e)],ln2:[L,[],()=>Math.LN2],pi:[L,[],()=>Math.PI],e:[L,[],()=>Math.E],"^":[L,[L,L],(e,[t,r])=>Math.pow(t.evaluate(e),r.evaluate(e))],sqrt:[L,[L],(e,[t])=>Math.sqrt(t.evaluate(e))],log10:[L,[L],(e,[t])=>Math.log(t.evaluate(e))/Math.LN10],ln:[L,[L],(e,[t])=>Math.log(t.evaluate(e))],log2:[L,[L],(e,[t])=>Math.log(t.evaluate(e))/Math.LN2],sin:[L,[L],(e,[t])=>Math.sin(t.evaluate(e))],cos:[L,[L],(e,[t])=>Math.cos(t.evaluate(e))],tan:[L,[L],(e,[t])=>Math.tan(t.evaluate(e))],asin:[L,[L],(e,[t])=>Math.asin(t.evaluate(e))],acos:[L,[L],(e,[t])=>Math.acos(t.evaluate(e))],atan:[L,[L],(e,[t])=>Math.atan(t.evaluate(e))],min:[L,Vt(L),(e,t)=>Math.min(...t.map(r=>r.evaluate(e)))],max:[L,Vt(L),(e,t)=>Math.max(...t.map(r=>r.evaluate(e)))],abs:[L,[L],(e,[t])=>Math.abs(t.evaluate(e))],round:[L,[L],(e,[t])=>{let r=t.evaluate(e);return r<0?-Math.round(-r):Math.round(r)}],floor:[L,[L],(e,[t])=>Math.floor(t.evaluate(e))],ceil:[L,[L],(e,[t])=>Math.ceil(t.evaluate(e))],"filter-==":[U,[G,$],(e,[t,r])=>e.properties()[t.value]===r.value],"filter-id-==":[U,[$],(e,[t])=>e.id()===t.value],"filter-type-==":[U,[G],(e,[t])=>e.geometryType()===t.value],"filter-<":[U,[G,$],(e,[t,r])=>{let n=e.properties()[t.value],i=r.value;return typeof n==typeof i&&n<i}],"filter-id-<":[U,[$],(e,[t])=>{let r=e.id(),n=t.value;return typeof r==typeof n&&r<n}],"filter->":[U,[G,$],(e,[t,r])=>{let n=e.properties()[t.value],i=r.value;return typeof n==typeof i&&n>i}],"filter-id->":[U,[$],(e,[t])=>{let r=e.id(),n=t.value;return typeof r==typeof n&&r>n}],"filter-<=":[U,[G,$],(e,[t,r])=>{let n=e.properties()[t.value],i=r.value;return typeof n==typeof i&&n<=i}],"filter-id-<=":[U,[$],(e,[t])=>{let r=e.id(),n=t.value;return typeof r==typeof n&&r<=n}],"filter->=":[U,[G,$],(e,[t,r])=>{let n=e.properties()[t.value],i=r.value;return typeof n==typeof i&&n>=i}],"filter-id->=":[U,[$],(e,[t])=>{let r=e.id(),n=t.value;return typeof r==typeof n&&r>=n}],"filter-has":[U,[$],(e,[t])=>t.value in e.properties()],"filter-has-id":[U,[],e=>e.id()!==null&&e.id()!==void 0],"filter-type-in":[U,[Ee(G)],(e,[t])=>t.value.indexOf(e.geometryType())>=0],"filter-id-in":[U,[Ee($)],(e,[t])=>t.value.indexOf(e.id())>=0],"filter-in-small":[U,[G,Ee($)],(e,[t,r])=>r.value.indexOf(e.properties()[t.value])>=0],"filter-in-large":[U,[G,Ee($)],(e,[t,r])=>Ch(e.properties()[t.value],r.value,0,r.value.length-1)],all:{type:U,overloads:[[[U,U],(e,[t,r])=>t.evaluate(e)&&r.evaluate(e)],[Vt(U),(e,t)=>{for(let r of t)if(!r.evaluate(e))return!1;return!0}]]},any:{type:U,overloads:[[[U,U],(e,[t,r])=>t.evaluate(e)||r.evaluate(e)],[Vt(U),(e,t)=>{for(let r of t)if(r.evaluate(e))return!0;return!1}]]},"!":[U,[U],(e,[t])=>!t.evaluate(e)],"is-supported-script":[U,[G],(e,[t])=>{let r=e.globals&&e.globals.isSupportedScript;return r?r(t.evaluate(e)):!0}],upcase:[G,[G],(e,[t])=>t.evaluate(e).toUpperCase()],downcase:[G,[G],(e,[t])=>t.evaluate(e).toLowerCase()],concat:[G,Vt($),(e,t)=>t.map(r=>Zr(r.evaluate(e))).join("")],"resolved-locale":[G,[ji],(e,[t])=>t.evaluate(e).resolvedLocale()]});function kh(e){return Array.isArray(e)?"(".concat(e.map(te).join(", "),")"):"(".concat(te(e.type),"...)")}function Gi(e){if(e instanceof Vi)return Gi(e.boundExpression);if(e instanceof Ke&&e.name==="error")return!1;if(e instanceof Ri)return!1;if(e instanceof rn)return!1;if(e instanceof on)return!1;let t=e instanceof yt||e instanceof je,r=!0;return e.eachChild(n=>{t?r=r&&Gi(n):r=r&&n instanceof mt}),r?Xi(e)&&Ki(e,["zoom","heatmap-density","line-progress","accumulated","is-supported-script"]):!1}function Xi(e){if(e instanceof Ke){if(e.name==="get"&&e.args.length===1)return!1;if(e.name==="feature-state")return!1;if(e.name==="has"&&e.args.length===1)return!1;if(e.name==="properties"||e.name==="geometry-type"||e.name==="id")return!1;if(/^filter-/.test(e.name))return!1}if(e instanceof rn||e instanceof on)return!1;let t=!0;return e.eachChild(r=>{t&&!Xi(r)&&(t=!1)}),t}function an(e){if(e instanceof Ke&&e.name==="feature-state")return!1;let t=!0;return e.eachChild(r=>{t&&!an(r)&&(t=!1)}),t}function Ki(e,t){if(e instanceof Ke&&t.indexOf(e.name)>=0)return!1;let r=!0;return e.eachChild(n=>{r&&!Ki(n,t)&&(r=!1)}),r}function ss(e){return{result:"success",value:e}}function sr(e){return{result:"error",value:e}}function ht(e){return e["property-type"]==="data-driven"||e["property-type"]==="cross-faded-data-driven"}function Lu(e){return!!e.expression&&e.expression.parameters.indexOf("zoom")>-1}function ms(e){return!!e.expression&&e.expression.interpolated}function j(e){return e instanceof Number?"number":e instanceof String?"string":e instanceof Boolean?"boolean":Array.isArray(e)?"array":e===null?"null":typeof e}function Yi(e){return typeof e=="object"&&e!==null&&!Array.isArray(e)}function Mh(e){return e}function Du(e,t){let r=t.type==="color",n=e.stops&&typeof e.stops[0][0]=="object",i=n||e.property!==void 0,o=n||!i,a=e.type||(ms(t)?"exponential":"interval");if(r||t.type==="padding"){let c=r?W.parse:Ze.parse;e=cr({},e),e.stops&&(e.stops=e.stops.map(p=>[p[0],c(p[1])])),e.default?e.default=c(e.default):e.default=c(t.default)}if(e.colorSpace&&!Fm(e.colorSpace))throw new Error('Unknown color space: "'.concat(e.colorSpace,'"'));let s,l,u;if(a==="exponential")s=pu;else if(a==="interval")s=Fh;else if(a==="categorical"){s=Eh,l=Object.create(null);for(let c of e.stops)l[c[0]]=c[1];u=typeof e.stops[0][0]}else if(a==="identity")s=Lh;else throw new Error('Unknown function type "'.concat(a,'"'));if(n){let c={},p=[];for(let m=0;m<e.stops.length;m++){let h=e.stops[m],d=h[0].zoom;c[d]===void 0&&(c[d]={zoom:d,type:e.type,property:e.property,default:e.default,stops:[]},p.push(d)),c[d].stops.push([h[0].value,h[1]])}let f=[];for(let m of p)f.push([c[m].zoom,Du(c[m],t)]);let y={name:"linear"};return{kind:"composite",interpolationType:y,interpolationFactor:Je.interpolationFactor.bind(void 0,y),zoomStops:f.map(m=>m[0]),evaluate({zoom:m},h){return pu({stops:f,base:e.base},t,m).evaluate(m,h)}}}else if(o){let c=a==="exponential"?{name:"exponential",base:e.base!==void 0?e.base:1}:null;return{kind:"camera",interpolationType:c,interpolationFactor:Je.interpolationFactor.bind(void 0,c),zoomStops:e.stops.map(p=>p[0]),evaluate:({zoom:p})=>s(e,t,p,l,u)}}else return{kind:"source",evaluate(c,p){let f=p&&p.properties?p.properties[e.property]:void 0;return f===void 0?pn(e.default,t.default):s(e,t,f,l,u)}}}function pn(e,t,r){if(e!==void 0)return e;if(t!==void 0)return t;if(r!==void 0)return r}function Eh(e,t,r,n,i){let o=typeof r===i?n[r]:void 0;return pn(o,e.default,t.default)}function Fh(e,t,r){if(j(r)!=="number")return pn(e.default,t.default);let n=e.stops.length;if(n===1||r<=e.stops[0][0])return e.stops[0][1];if(r>=e.stops[n-1][0])return e.stops[n-1][1];let i=Wi(e.stops.map(o=>o[0]),r);return e.stops[i][1]}function pu(e,t,r){let n=e.base!==void 0?e.base:1;if(j(r)!=="number")return pn(e.default,t.default);let i=e.stops.length;if(i===1||r<=e.stops[0][0])return e.stops[0][1];if(r>=e.stops[i-1][0])return e.stops[i-1][1];let o=Wi(e.stops.map(c=>c[0]),r),a=Dh(r,n,e.stops[o][0],e.stops[o+1][0]),s=e.stops[o][1],l=e.stops[o+1][1],u=Oe[t.type]||Mh;return typeof s.evaluate=="function"?{evaluate(...c){let p=s.evaluate.apply(void 0,c),f=l.evaluate.apply(void 0,c);if(!(p===void 0||f===void 0))return u(p,f,a,e.colorSpace)}}:u(s,l,a,e.colorSpace)}function Lh(e,t,r){switch(t.type){case"color":r=W.parse(r);break;case"formatted":r=Fe.fromString(r.toString());break;case"resolvedImage":r=Te.fromString(r.toString());break;case"padding":r=Ze.parse(r);break;default:j(r)!==t.type&&(t.type!=="enum"||!t.values[r])&&(r=void 0)}return pn(r,e.default,t.default)}function Dh(e,t,r,n){let i=n-r,o=e-r;return i===0?0:t===1?o/i:(Math.pow(t,o)-1)/(Math.pow(t,i)-1)}var Rt=class{constructor(t,r){this.expression=t,this._warningHistory={},this._evaluator=new Fi,this._defaultValue=r?Bh(r):null,this._enumValues=r&&r.type==="enum"?r.values:null}evaluateWithoutErrorHandling(t,r,n,i,o,a){return this._evaluator.globals=t,this._evaluator.feature=r,this._evaluator.featureState=n,this._evaluator.canonical=i,this._evaluator.availableImages=o||null,this._evaluator.formattedSection=a,this.expression.evaluate(this._evaluator)}evaluate(t,r,n,i,o,a){this._evaluator.globals=t,this._evaluator.feature=r||null,this._evaluator.featureState=n||null,this._evaluator.canonical=i,this._evaluator.availableImages=o||null,this._evaluator.formattedSection=a||null;try{let s=this.expression.evaluate(this._evaluator);if(s==null||typeof s=="number"&&s!==s)return this._defaultValue;if(this._enumValues&&!(s in this._enumValues))throw new ie("Expected value to be one of ".concat(Object.keys(this._enumValues).map(l=>JSON.stringify(l)).join(", "),", but found ").concat(JSON.stringify(s)," instead."));return s}catch(s){return this._warningHistory[s.message]||(this._warningHistory[s.message]=!0,typeof console<"u"&&console.warn(s.message)),this._defaultValue}}};function $t(e){return Array.isArray(e)&&e.length>0&&typeof e[0]=="string"&&e[0]in Ut}function Gt(e,t){let r=new Li(Ut,Gi,[],t?Vh(t):void 0),n=r.parse(e,void 0,void 0,void 0,t&&t.type==="string"?{typeAnnotation:"coerce"}:void 0);return n?ss(new Rt(n,t)):sr(r.errors)}var dt=class{constructor(t,r){this.kind=t,this._styleExpression=r,this.isStateDependent=t!=="constant"&&!an(r.expression)}evaluateWithoutErrorHandling(t,r,n,i,o,a){return this._styleExpression.evaluateWithoutErrorHandling(t,r,n,i,o,a)}evaluate(t,r,n,i,o,a){return this._styleExpression.evaluate(t,r,n,i,o,a)}},gt=class{constructor(t,r,n,i){this.kind=t,this.zoomStops=n,this._styleExpression=r,this.isStateDependent=t!=="camera"&&!an(r.expression),this.interpolationType=i}evaluateWithoutErrorHandling(t,r,n,i,o,a){return this._styleExpression.evaluateWithoutErrorHandling(t,r,n,i,o,a)}evaluate(t,r,n,i,o,a){return this._styleExpression.evaluate(t,r,n,i,o,a)}interpolationFactor(t,r,n){return this.interpolationType?Je.interpolationFactor(this.interpolationType,t,r,n):0}};function Vu(e,t){let r=Gt(e,t);if(r.result==="error")return r;let n=r.value.expression,i=Xi(n);if(!i&&!ht(t))return sr([new Be("","data expressions not supported")]);let o=Ki(n,["zoom"]);if(!o&&!Lu(t))return sr([new Be("","zoom expressions not supported")]);let a=Ei(n);if(!a&&!o)return sr([new Be("",'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);if(a instanceof Be)return sr([a]);if(a instanceof Je&&!ms(t))return sr([new Be("",'"interpolate" expressions cannot be used with this property')]);if(!a)return ss(i?new dt("constant",r.value):new dt("source",r.value));let s=a instanceof Je?a.interpolation:void 0;return ss(i?new gt("camera",r.value,a.labels,s):new gt("composite",r.value,a.labels,s))}var sn=class e{constructor(t,r){this._parameters=t,this._specification=r,cr(this,Du(this._parameters,this._specification))}static deserialize(t){return new e(t._parameters,t._specification)}static serialize(t){return{_parameters:t._parameters,_specification:t._specification}}};function Bu(e,t){if(Yi(e))return new sn(e,t);if($t(e)){let r=Vu(e,t);if(r.result==="error")throw new Error(r.value.map(n=>"".concat(n.key,": ").concat(n.message)).join(", "));return r.value}else{let r=e;return t.type==="color"&&typeof e=="string"?r=W.parse(e):t.type==="padding"&&(typeof e=="number"||Array.isArray(e))?r=Ze.parse(e):t.type==="variableAnchorOffsetCollection"&&Array.isArray(e)&&(r=Ne.parse(e)),{kind:"constant",evaluate:()=>r}}}function Ei(e){let t=null;if(e instanceof Di)t=Ei(e.result);else if(e instanceof zi){for(let r of e.args)if(t=Ei(r),t)break}else(e instanceof pr||e instanceof Je)&&e.input instanceof Ke&&e.input.name==="zoom"&&(t=e);return t instanceof Be||e.eachChild(r=>{let n=Ei(r);n instanceof Be?t=n:!t&&n?t=new Be("",'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.'):t&&n&&t!==n&&(t=new Be("",'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'))}),t}function Vh(e){let t={color:Re,string:G,number:L,enum:G,boolean:U,formatted:mr,padding:Ji,resolvedImage:un,variableAnchorOffsetCollection:Zi};return e.type==="array"?Ee(t[e.value]||$,e.length):t[e.type]}function Bh(e){return e.type==="color"&&Yi(e.default)?new W(0,0,0,0):e.type==="color"?W.parse(e.default)||null:e.type==="padding"?Ze.parse(e.default)||null:e.type==="variableAnchorOffsetCollection"?Ne.parse(e.default)||null:e.default===void 0?null:e.default}function hs(e){if(e===!0||e===!1)return!0;if(!Array.isArray(e)||e.length===0)return!1;switch(e[0]){case"has":return e.length>=2&&e[1]!=="$id"&&e[1]!=="$type";case"in":return e.length>=3&&(typeof e[1]!="string"||Array.isArray(e[2]));case"!in":case"!has":case"none":return!1;case"==":case"!=":case">":case">=":case"<":case"<=":return e.length!==3||Array.isArray(e[1])||Array.isArray(e[2]);case"any":case"all":for(let t of e.slice(1))if(!hs(t)&&typeof t!="boolean")return!1;return!0;default:return!0}}var zh={type:"boolean",default:!1,transition:!1,"property-type":"data-driven",expression:{interpolated:!1,parameters:["zoom","feature"]}};function fn(e){if(e==null)return{filter:()=>!0,needGeometry:!1};hs(e)||(e=qi(e));let t=Gt(e,zh);if(t.result==="error")throw new Error(t.value.map(r=>"".concat(r.key,": ").concat(r.message)).join(", "));{let r=zu(e);return{filter:(n,i,o)=>t.value.evaluate(n,i,{},o),needGeometry:r}}}function Rh(e,t){return e<t?-1:e>t?1:0}function zu(e){if(!Array.isArray(e))return!1;if(e[0]==="within"||e[0]==="distance")return!0;for(let t=1;t<e.length;t++)if(zu(e[t]))return!0;return!1}function qi(e){if(!e)return!0;let t=e[0];return e.length<=1?t!=="any":t==="=="?ja(e[1],e[2],"=="):t==="!="?Mi(ja(e[1],e[2],"==")):t==="<"||t===">"||t==="<="||t===">="?ja(e[1],e[2],t):t==="any"?Oh(e.slice(1)):t==="all"?["all"].concat(e.slice(1).map(qi)):t==="none"?["all"].concat(e.slice(1).map(qi).map(Mi)):t==="in"?fu(e[1],e.slice(2)):t==="!in"?Mi(fu(e[1],e.slice(2))):t==="has"?yu(e[1]):t==="!has"?Mi(yu(e[1])):!0}function ja(e,t,r){switch(e){case"$type":return["filter-type-".concat(r),t];case"$id":return["filter-id-".concat(r),t];default:return["filter-".concat(r),e,t]}}function Oh(e){return["any"].concat(e.map(qi))}function fu(e,t){if(t.length===0)return!1;switch(e){case"$type":return["filter-type-in",["literal",t]];case"$id":return["filter-id-in",["literal",t]];default:return t.length>200&&!t.some(r=>typeof r!=typeof t[0])?["filter-in-large",e,["literal",t.sort(Rh)]]:["filter-in-small",e,["literal",t]]}}function yu(e){switch(e){case"$type":return!0;case"$id":return["filter-has-id"];default:return["filter-has",e]}}function Mi(e){return["!",e]}function ls(e){let t=typeof e;if(t==="number"||t==="boolean"||t==="string"||e===void 0||e===null)return JSON.stringify(e);if(Array.isArray(e)){let i="[";for(let o of e)i+="".concat(ls(o),",");return"".concat(i,"]")}let r=Object.keys(e).sort(),n="{";for(let i=0;i<r.length;i++)n+="".concat(JSON.stringify(r[i]),":").concat(ls(e[r[i]]),",");return"".concat(n,"}")}function Nh(e){let t="";for(let r of dm)t+="/".concat(ls(e[r]));return t}function Ru(e,t){let r={};for(let i=0;i<e.length;i++){let o=t&&t[e[i].id]||Nh(e[i]);t&&(t[e[i].id]=o);let a=r[o];a||(a=r[o]=[]),a.push(e[i])}let n=[];for(let i in r)n.push(r[i]);return n}function Ou(e){let t=e.key,r=e.value;return r?[new M(t,r,"constants have been deprecated as of v8")]:[]}function ae(e){return e instanceof Number||e instanceof String||e instanceof Boolean?e.valueOf():e}function Ot(e){if(Array.isArray(e))return e.map(Ot);if(e instanceof Object&&!(e instanceof Number||e instanceof String||e instanceof Boolean)){let t={};for(let r in e)t[r]=Ot(e[r]);return t}return ae(e)}function ze(e){let t=e.key,r=e.value,n=e.valueSpec||{},i=e.objectElementValidators||{},o=e.style,a=e.styleSpec,s=e.validateSpec,l=[],u=j(r);if(u!=="object")return[new M(t,r,"object expected, ".concat(u," found"))];for(let c in r){let p=c.split(".")[0],f=n[p]||n["*"],y;if(i[p])y=i[p];else if(n[p])y=s;else if(i["*"])y=i["*"];else if(n["*"])y=s;else{l.push(new M(t,r[c],'unknown property "'.concat(c,'"')));continue}l=l.concat(y({key:(t&&"".concat(t,"."))+c,value:r[c],valueSpec:f,style:o,styleSpec:a,object:r,objectKey:c,validateSpec:s},r))}for(let c in n)i[c]||n[c].required&&n[c].default===void 0&&r[c]===void 0&&l.push(new M(t,r,'missing required property "'.concat(c,'"')));return l}function ds(e){let t=e.value,r=e.valueSpec,n=e.validateSpec,i=e.style,o=e.styleSpec,a=e.key,s=e.arrayElementValidator||n;if(j(t)!=="array")return[new M(a,t,"array expected, ".concat(j(t)," found"))];if(r.length&&t.length!==r.length)return[new M(a,t,"array length ".concat(r.length," expected, length ").concat(t.length," found"))];if(r["min-length"]&&t.length<r["min-length"])return[new M(a,t,"array length at least ".concat(r["min-length"]," expected, length ").concat(t.length," found"))];let l={type:r.value,values:r.values};o.$version<7&&(l.function=r.function),j(r.value)==="object"&&(l=r.value);let u=[];for(let c=0;c<t.length;c++)u=u.concat(s({array:t,arrayIndex:c,value:t[c],valueSpec:l,validateSpec:e.validateSpec,style:i,styleSpec:o,key:"".concat(a,"[").concat(c,"]")}));return u}function gs(e){let t=e.key,r=e.value,n=e.valueSpec,i=j(r);return i==="number"&&r!==r&&(i="NaN"),i!=="number"?[new M(t,r,"number expected, ".concat(i," found"))]:"minimum"in n&&r<n.minimum?[new M(t,r,"".concat(r," is less than the minimum value ").concat(n.minimum))]:"maximum"in n&&r>n.maximum?[new M(t,r,"".concat(r," is greater than the maximum value ").concat(n.maximum))]:[]}function Nu(e){let t=e.valueSpec,r=ae(e.value.type),n,i={},o,a,s=r!=="categorical"&&e.value.property===void 0,l=!s,u=j(e.value.stops)==="array"&&j(e.value.stops[0])==="array"&&j(e.value.stops[0][0])==="object",c=ze({key:e.key,value:e.value,valueSpec:e.styleSpec.function,validateSpec:e.validateSpec,style:e.style,styleSpec:e.styleSpec,objectElementValidators:{stops:p,default:m}});return r==="identity"&&s&&c.push(new M(e.key,e.value,'missing required property "property"')),r!=="identity"&&!e.value.stops&&c.push(new M(e.key,e.value,'missing required property "stops"')),r==="exponential"&&e.valueSpec.expression&&!ms(e.valueSpec)&&c.push(new M(e.key,e.value,"exponential functions not supported")),e.styleSpec.$version>=8&&(l&&!ht(e.valueSpec)?c.push(new M(e.key,e.value,"property functions not supported")):s&&!Lu(e.valueSpec)&&c.push(new M(e.key,e.value,"zoom functions not supported"))),(r==="categorical"||u)&&e.value.property===void 0&&c.push(new M(e.key,e.value,'"property" property is required')),c;function p(h){if(r==="identity")return[new M(h.key,h.value,'identity function may not have a "stops" property')];let d=[],g=h.value;return d=d.concat(ds({key:h.key,value:g,valueSpec:h.valueSpec,validateSpec:h.validateSpec,style:h.style,styleSpec:h.styleSpec,arrayElementValidator:f})),j(g)==="array"&&g.length===0&&d.push(new M(h.key,g,"array must have at least one stop")),d}function f(h){let d=[],g=h.value,b=h.key;if(j(g)!=="array")return[new M(b,g,"array expected, ".concat(j(g)," found"))];if(g.length!==2)return[new M(b,g,"array length 2 expected, length ".concat(g.length," found"))];if(u){if(j(g[0])!=="object")return[new M(b,g,"object expected, ".concat(j(g[0])," found"))];if(g[0].zoom===void 0)return[new M(b,g,"object stop key must have zoom")];if(g[0].value===void 0)return[new M(b,g,"object stop key must have value")];if(a&&a>ae(g[0].zoom))return[new M(b,g[0].zoom,"stop zoom values must appear in ascending order")];ae(g[0].zoom)!==a&&(a=ae(g[0].zoom),o=void 0,i={}),d=d.concat(ze({key:"".concat(b,"[0]"),value:g[0],valueSpec:{zoom:{}},validateSpec:h.validateSpec,style:h.style,styleSpec:h.styleSpec,objectElementValidators:{zoom:gs,value:y}}))}else d=d.concat(y({key:"".concat(b,"[0]"),value:g[0],valueSpec:{},validateSpec:h.validateSpec,style:h.style,styleSpec:h.styleSpec},g));return $t(Ot(g[1]))?d.concat([new M("".concat(b,"[1]"),g[1],"expressions are not allowed in function stops.")]):d.concat(h.validateSpec({key:"".concat(b,"[1]"),value:g[1],valueSpec:t,validateSpec:h.validateSpec,style:h.style,styleSpec:h.styleSpec}))}function y(h,d){let g=j(h.value),b=ae(h.value),x=h.value!==null?h.value:d;if(!n)n=g;else if(g!==n)return[new M(h.key,x,"".concat(g," stop domain type must match previous stop domain type ").concat(n))];if(g!=="number"&&g!=="string"&&g!=="boolean")return[new M(h.key,x,"stop domain value must be a number, string, or boolean")];if(g!=="number"&&r!=="categorical"){let v="number expected, ".concat(g," found");return ht(t)&&r===void 0&&(v+='\\nIf you intended to use a categorical function, specify \`"type": "categorical"\`.'),[new M(h.key,x,v)]}return r==="categorical"&&g==="number"&&(!isFinite(b)||Math.floor(b)!==b)?[new M(h.key,x,"integer expected, found ".concat(b))]:r!=="categorical"&&g==="number"&&o!==void 0&&b<o?[new M(h.key,x,"stop domain values must appear in ascending order")]:(o=b,r==="categorical"&&b in i?[new M(h.key,x,"stop domain values must be unique")]:(i[b]=!0,[]))}function m(h){return h.validateSpec({key:h.key,value:h.value,valueSpec:t,validateSpec:h.validateSpec,style:h.style,styleSpec:h.styleSpec})}}function fr(e){let t=(e.expressionContext==="property"?Vu:Gt)(Ot(e.value),e.valueSpec);if(t.result==="error")return t.value.map(n=>new M("".concat(e.key).concat(n.key),e.value,n.message));let r=t.value.expression||t.value._styleExpression.expression;if(e.expressionContext==="property"&&e.propertyKey==="text-font"&&!r.outputDefined())return[new M(e.key,e.value,'Invalid data expression for "'.concat(e.propertyKey,'". Output values must be contained as literals within the expression.'))];if(e.expressionContext==="property"&&e.propertyType==="layout"&&!an(r))return[new M(e.key,e.value,'"feature-state" data expressions are not supported with layout properties.')];if(e.expressionContext==="filter"&&!an(r))return[new M(e.key,e.value,'"feature-state" data expressions are not supported with filters.')];if(e.expressionContext&&e.expressionContext.indexOf("cluster")===0){if(!Ki(r,["zoom","feature-state"]))return[new M(e.key,e.value,'"zoom" and "feature-state" expressions are not supported with cluster properties.')];if(e.expressionContext==="cluster-initial"&&!Xi(r))return[new M(e.key,e.value,"Feature data expressions are not supported with initial expression part of cluster properties.")]}return[]}function Uh(e){let t=e.value,r=e.key,n=j(t);return n!=="boolean"?[new M(r,t,"boolean expected, ".concat(n," found"))]:[]}function $h(e){let t=e.key,r=e.value,n=j(r);return n!=="string"?[new M(t,r,"color expected, ".concat(n," found"))]:W.parse(String(r))?[]:[new M(t,r,'color expected, "'.concat(r,'" found'))]}function ln(e){let t=e.key,r=e.value,n=e.valueSpec,i=[];return Array.isArray(n.values)?n.values.indexOf(ae(r))===-1&&i.push(new M(t,r,"expected one of [".concat(n.values.join(", "),"], ").concat(JSON.stringify(r)," found"))):Object.keys(n.values).indexOf(ae(r))===-1&&i.push(new M(t,r,"expected one of [".concat(Object.keys(n.values).join(", "),"], ").concat(JSON.stringify(r)," found"))),i}function xs(e){return hs(Ot(e.value))?fr(cr({},e,{expressionContext:"filter",valueSpec:{value:"boolean"}})):Uu(e)}function Uu(e){let t=e.value,r=e.key;if(j(t)!=="array")return[new M(r,t,"array expected, ".concat(j(t)," found"))];let n=e.styleSpec,i,o=[];if(t.length<1)return[new M(r,t,"filter array must have at least 1 element")];switch(o=o.concat(ln({key:"".concat(r,"[0]"),value:t[0],valueSpec:n.filter_operator,style:e.style,styleSpec:e.styleSpec})),ae(t[0])){case"<":case"<=":case">":case">=":t.length>=2&&ae(t[1])==="$type"&&o.push(new M(r,t,'"$type" cannot be use with operator "'.concat(t[0],'"')));case"==":case"!=":t.length!==3&&o.push(new M(r,t,'filter array for operator "'.concat(t[0],'" must have 3 elements')));case"in":case"!in":t.length>=2&&(i=j(t[1]),i!=="string"&&o.push(new M("".concat(r,"[1]"),t[1],"string expected, ".concat(i," found"))));for(let a=2;a<t.length;a++)i=j(t[a]),ae(t[1])==="$type"?o=o.concat(ln({key:"".concat(r,"[").concat(a,"]"),value:t[a],valueSpec:n.geometry_type,style:e.style,styleSpec:e.styleSpec})):i!=="string"&&i!=="number"&&i!=="boolean"&&o.push(new M("".concat(r,"[").concat(a,"]"),t[a],"string, number, or boolean expected, ".concat(i," found")));break;case"any":case"all":case"none":for(let a=1;a<t.length;a++)o=o.concat(Uu({key:"".concat(r,"[").concat(a,"]"),value:t[a],style:e.style,styleSpec:e.styleSpec}));break;case"has":case"!has":i=j(t[1]),t.length!==2?o.push(new M(r,t,'filter array for "'.concat(t[0],'" operator must have 2 elements'))):i!=="string"&&o.push(new M("".concat(r,"[1]"),t[1],"string expected, ".concat(i," found")));break}return o}function $u(e,t){let r=e.key,n=e.validateSpec,i=e.style,o=e.styleSpec,a=e.value,s=e.objectKey,l=o["".concat(t,"_").concat(e.layerType)];if(!l)return[];let u=s.match(/^(.*)-transition$/);if(t==="paint"&&u&&l[u[1]]&&l[u[1]].transition)return n({key:r,value:a,valueSpec:o.transition,style:i,styleSpec:o});let c=e.valueSpec||l[s];if(!c)return[new M(r,a,'unknown property "'.concat(s,'"'))];let p;if(j(a)==="string"&&ht(c)&&!c.tokens&&(p=/^{([^}]+)}$/.exec(a)))return[new M(r,a,'"'.concat(s,'" does not support interpolation syntax\\n')+'Use an identity property function instead: \`{ "type": "identity", "property": '.concat(JSON.stringify(p[1])," }\`."))];let f=[];return e.layerType==="symbol"&&(s==="text-field"&&i&&!i.glyphs&&f.push(new M(r,a,'use of "text-field" requires a style "glyphs" property')),s==="text-font"&&Yi(Ot(a))&&ae(a.type)==="identity"&&f.push(new M(r,a,'"text-font" does not support identity functions'))),f.concat(n({key:e.key,value:a,valueSpec:c,style:i,styleSpec:o,expressionContext:"property",propertyType:t,propertyKey:s}))}function Gu(e){return $u(e,"paint")}function qu(e){return $u(e,"layout")}function ju(e){let t=[],r=e.value,n=e.key,i=e.style,o=e.styleSpec;!r.type&&!r.ref&&t.push(new M(n,r,'either "type" or "ref" is required'));let a=ae(r.type),s=ae(r.ref);if(r.id){let l=ae(r.id);for(let u=0;u<e.arrayIndex;u++){let c=i.layers[u];ae(c.id)===l&&t.push(new M(n,r.id,'duplicate layer id "'.concat(r.id,'", previously used at line ').concat(c.id.__line__)))}}if("ref"in r){["type","source","source-layer","filter","layout"].forEach(u=>{u in r&&t.push(new M(n,r[u],'"'.concat(u,'" is prohibited for ref layers')))});let l;i.layers.forEach(u=>{ae(u.id)===s&&(l=u)}),l?l.ref?t.push(new M(n,r.ref,"ref cannot reference another ref layer")):a=ae(l.type):t.push(new M(n,r.ref,'ref layer "'.concat(s,'" not found')))}else if(a!=="background")if(!r.source)t.push(new M(n,r,'missing required property "source"'));else{let l=i.sources&&i.sources[r.source],u=l&&ae(l.type);l?u==="vector"&&a==="raster"?t.push(new M(n,r.source,'layer "'.concat(r.id,'" requires a raster source'))):u!=="raster-dem"&&a==="hillshade"?t.push(new M(n,r.source,'layer "'.concat(r.id,'" requires a raster-dem source'))):u==="raster"&&a!=="raster"?t.push(new M(n,r.source,'layer "'.concat(r.id,'" requires a vector source'))):u==="vector"&&!r["source-layer"]?t.push(new M(n,r,'layer "'.concat(r.id,'" must specify a "source-layer"'))):u==="raster-dem"&&a!=="hillshade"?t.push(new M(n,r.source,"raster-dem source can only be used with layer type 'hillshade'.")):a==="line"&&r.paint&&r.paint["line-gradient"]&&(u!=="geojson"||!l.lineMetrics)&&t.push(new M(n,r,'layer "'.concat(r.id,'" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.'))):t.push(new M(n,r.source,'source "'.concat(r.source,'" not found')))}return t=t.concat(ze({key:n,value:r,valueSpec:o.layer,style:e.style,styleSpec:e.styleSpec,validateSpec:e.validateSpec,objectElementValidators:{"*"(){return[]},type(){return e.validateSpec({key:"".concat(n,".type"),value:r.type,valueSpec:o.layer.type,style:e.style,styleSpec:e.styleSpec,validateSpec:e.validateSpec,object:r,objectKey:"type"})},filter:xs,layout(l){return ze({layer:r,key:l.key,value:l.value,style:l.style,styleSpec:l.styleSpec,validateSpec:l.validateSpec,objectElementValidators:{"*"(u){return qu(cr({layerType:a},u))}}})},paint(l){return ze({layer:r,key:l.key,value:l.value,style:l.style,styleSpec:l.styleSpec,validateSpec:l.validateSpec,objectElementValidators:{"*"(u){return Gu(cr({layerType:a},u))}}})}}})),t}function Nt(e){let t=e.value,r=e.key,n=j(t);return n!=="string"?[new M(r,t,"string expected, ".concat(n," found"))]:[]}function Gh(e){var t;let r=(t=e.sourceName)!==null&&t!==void 0?t:"",n=e.value,i=e.styleSpec,o=i.source_raster_dem,a=e.style,s=[],l=j(n);if(n===void 0)return s;if(l!=="object")return s.push(new M("source_raster_dem",n,"object expected, ".concat(l," found"))),s;let c=ae(n.encoding)==="custom",p=["redFactor","greenFactor","blueFactor","baseShift"],f=e.value.encoding?'"'.concat(e.value.encoding,'"'):"Default";for(let y in n)!c&&p.includes(y)?s.push(new M(y,n[y],'In "'.concat(r,'": "').concat(y,'" is only valid when "encoding" is set to "custom". ').concat(f," encoding found"))):o[y]?s=s.concat(e.validateSpec({key:y,value:n[y],valueSpec:o[y],validateSpec:e.validateSpec,style:a,styleSpec:i})):s.push(new M(y,n[y],'unknown property "'.concat(y,'"')));return s}var mu={promoteId:qh};function Ju(e){let t=e.value,r=e.key,n=e.styleSpec,i=e.style,o=e.validateSpec;if(!t.type)return[new M(r,t,'"type" is required')];let a=ae(t.type),s;switch(a){case"vector":case"raster":return s=ze({key:r,value:t,valueSpec:n["source_".concat(a.replace("-","_"))],style:e.style,styleSpec:n,objectElementValidators:mu,validateSpec:o}),s;case"raster-dem":return s=Gh({sourceName:r,value:t,style:e.style,styleSpec:n,validateSpec:o}),s;case"geojson":if(s=ze({key:r,value:t,valueSpec:n.source_geojson,style:i,styleSpec:n,validateSpec:o,objectElementValidators:mu}),t.cluster)for(let l in t.clusterProperties){let[u,c]=t.clusterProperties[l],p=typeof u=="string"?[u,["accumulated"],["get",l]]:u;s.push(...fr({key:"".concat(r,".").concat(l,".map"),value:c,validateSpec:o,expressionContext:"cluster-map"})),s.push(...fr({key:"".concat(r,".").concat(l,".reduce"),value:p,validateSpec:o,expressionContext:"cluster-reduce"}))}return s;case"video":return ze({key:r,value:t,valueSpec:n.source_video,style:i,validateSpec:o,styleSpec:n});case"image":return ze({key:r,value:t,valueSpec:n.source_image,style:i,validateSpec:o,styleSpec:n});case"canvas":return[new M(r,null,"Please use runtime APIs to add canvas sources, rather than including them in stylesheets.","source.canvas")];default:return ln({key:"".concat(r,".type"),value:t.type,valueSpec:{values:["vector","raster","raster-dem","geojson","video","image"]},style:i,validateSpec:o,styleSpec:n})}}function qh({key:e,value:t}){if(j(t)==="string")return Nt({key:e,value:t});{let r=[];for(let n in t)r.push(...Nt({key:"".concat(e,".").concat(n),value:t[n]}));return r}}function Zu(e){let t=e.value,r=e.styleSpec,n=r.light,i=e.style,o=[],a=j(t);if(t===void 0)return o;if(a!=="object")return o=o.concat([new M("light",t,"object expected, ".concat(a," found"))]),o;for(let s in t){let l=s.match(/^(.*)-transition$/);l&&n[l[1]]&&n[l[1]].transition?o=o.concat(e.validateSpec({key:s,value:t[s],valueSpec:r.transition,validateSpec:e.validateSpec,style:i,styleSpec:r})):n[s]?o=o.concat(e.validateSpec({key:s,value:t[s],valueSpec:n[s],validateSpec:e.validateSpec,style:i,styleSpec:r})):o=o.concat([new M(s,t[s],'unknown property "'.concat(s,'"'))])}return o}function Wu(e){let t=e.value,r=e.styleSpec,n=r.sky,i=e.style,o=j(t);if(t===void 0)return[];if(o!=="object")return[new M("sky",t,"object expected, ".concat(o," found"))];let a=[];for(let s in t)n[s]?a=a.concat(e.validateSpec({key:s,value:t[s],valueSpec:n[s],style:i,styleSpec:r})):a=a.concat([new M(s,t[s],'unknown property "'.concat(s,'"'))]);return a}function Hu(e){let t=e.value,r=e.styleSpec,n=r.terrain,i=e.style,o=[],a=j(t);if(t===void 0)return o;if(a!=="object")return o=o.concat([new M("terrain",t,"object expected, ".concat(a," found"))]),o;for(let s in t)n[s]?o=o.concat(e.validateSpec({key:s,value:t[s],valueSpec:n[s],validateSpec:e.validateSpec,style:i,styleSpec:r})):o=o.concat([new M(s,t[s],'unknown property "'.concat(s,'"'))]);return o}function jh(e){return Nt(e).length===0?[]:fr(e)}function Jh(e){return Nt(e).length===0?[]:fr(e)}function Zh(e){let t=e.key,r=e.value;if(j(r)==="array"){if(r.length<1||r.length>4)return[new M(t,r,"padding requires 1 to 4 values; ".concat(r.length," values found"))];let i={type:"number"},o=[];for(let a=0;a<r.length;a++)o=o.concat(e.validateSpec({key:"".concat(t,"[").concat(a,"]"),value:r[a],validateSpec:e.validateSpec,valueSpec:i}));return o}else return gs({key:t,value:r,valueSpec:{}})}function Wh(e){let t=e.key,r=e.value,n=j(r),i=e.styleSpec;if(n!=="array"||r.length<1||r.length%2!==0)return[new M(t,r,"variableAnchorOffsetCollection requires a non-empty array of even length")];let o=[];for(let a=0;a<r.length;a+=2)o=o.concat(ln({key:"".concat(t,"[").concat(a,"]"),value:r[a],valueSpec:i.layout_symbol["text-anchor"]})),o=o.concat(ds({key:"".concat(t,"[").concat(a+1,"]"),value:r[a+1],valueSpec:{length:2,value:"number"},validateSpec:e.validateSpec,style:e.style,styleSpec:i}));return o}function Xu(e){let t=[],r=e.value,n=e.key;if(Array.isArray(r)){let i=[],o=[];for(let a in r){r[a].id&&i.includes(r[a].id)&&t.push(new M(n,r,"all the sprites' ids must be unique, but ".concat(r[a].id," is duplicated"))),i.push(r[a].id),r[a].url&&o.includes(r[a].url)&&t.push(new M(n,r,"all the sprites' URLs must be unique, but ".concat(r[a].url," is duplicated"))),o.push(r[a].url);let s={id:{type:"string",required:!0},url:{type:"string",required:!0}};t=t.concat(ze({key:"".concat(n,"[").concat(a,"]"),value:r[a],valueSpec:s,validateSpec:e.validateSpec}))}return t}else return Nt({key:n,value:r})}function Hh(e){let t=e.value,r=e.styleSpec,n=r.projection,i=e.style,o=j(t);if(t===void 0)return[];if(o!=="object")return[new M("projection",t,"object expected, ".concat(o," found"))];let a=[];for(let s in t)n[s]?a=a.concat(e.validateSpec({key:s,value:t[s],valueSpec:n[s],style:i,styleSpec:r})):a=a.concat([new M(s,t[s],'unknown property "'.concat(s,'"'))]);return a}var hu={"*"(){return[]},array:ds,boolean:Uh,number:gs,color:$h,constants:Ou,enum:ln,filter:xs,function:Nu,layer:ju,object:ze,source:Ju,light:Zu,sky:Wu,terrain:Hu,projection:Hh,string:Nt,formatted:jh,resolvedImage:Jh,padding:Zh,variableAnchorOffsetCollection:Wh,sprite:Xu};function Wr(e){let t=e.value,r=e.valueSpec,n=e.styleSpec;return e.validateSpec=Wr,r.expression&&Yi(ae(t))?Nu(e):r.expression&&$t(Ot(t))?fr(e):r.type&&hu[r.type]?hu[r.type](e):ze(cr({},e,{valueSpec:r.type?n[r.type]:r}))}function Ku(e){let t=e.value,r=e.key,n=Nt(e);return n.length||(t.indexOf("{fontstack}")===-1&&n.push(new M(r,t,'"glyphs" url must include a "{fontstack}" token')),t.indexOf("{range}")===-1&&n.push(new M(r,t,'"glyphs" url must include a "{range}" token'))),n}function Ue(e,t=S){let r=[];return r=r.concat(Wr({key:"",value:e,valueSpec:t.$root,styleSpec:t,style:e,validateSpec:Wr,objectElementValidators:{glyphs:Ku,"*"(){return[]}}})),e.constants&&(r=r.concat(Ou({key:"constants",value:e.constants,style:e,styleSpec:t,validateSpec:Wr}))),Yu(r)}Ue.source=Qe(Ye(Ju));Ue.sprite=Qe(Ye(Xu));Ue.glyphs=Qe(Ye(Ku));Ue.light=Qe(Ye(Zu));Ue.sky=Qe(Ye(Wu));Ue.terrain=Qe(Ye(Hu));Ue.layer=Qe(Ye(ju));Ue.filter=Qe(Ye(xs));Ue.paintProperty=Qe(Ye(Gu));Ue.layoutProperty=Qe(Ye(qu));function Ye(e){return function(t){return e({...t,validateSpec:Wr})}}function Yu(e){return[].concat(e).sort((t,r)=>t.line-r.line)}function Qe(e){return function(...t){return Yu(e.apply(this,t))}}var Qu="AbortError";function ec(e){return e.message===Qu}function bs(){return new Error(Qu)}var Qi={MAX_PARALLEL_IMAGE_REQUESTS:16,MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME:8,MAX_TILE_CACHE_ZOOM_LEVELS:5,REGISTERED_PROTOCOLS:{},WORKER_URL:""};function tc(e){return Qi.REGISTERED_PROTOCOLS[e.substring(0,e.indexOf("://"))]}function rc(e,t){Qi.REGISTERED_PROTOCOLS[e]=t}function nc(e){delete Qi.REGISTERED_PROTOCOLS[e]}var ic="global-dispatcher",gr=class extends Error{constructor(t,r,n,i){super("AJAXError: ".concat(r," (").concat(t,"): ").concat(n)),this.status=t,this.statusText=r,this.url=n,this.body=i}},ac=()=>at(self)?self.worker&&self.worker.referrer:(window.location.protocol==="blob:"?window.parent:window).location.href,Xh=e=>/^file:/.test(e)||/^file:/.test(ac())&&!/^\\w+:/.test(e);async function Kh(e,t){let r=new Request(e.url,{method:e.method||"GET",body:e.body,credentials:e.credentials,headers:e.headers,cache:e.cache,referrer:ac(),signal:t.signal});e.type==="json"&&r.headers.set("Accept","application/json");let n=await fetch(r);if(!n.ok){let a=await n.blob();throw new gr(n.status,n.statusText,e.url,a)}let i;e.type==="arrayBuffer"||e.type==="image"?i=n.arrayBuffer():e.type==="json"?i=n.json():i=n.text();let o=await i;if(t.signal.aborted)throw bs();return{data:o,cacheControl:n.headers.get("Cache-Control"),expires:n.headers.get("Expires")}}function Yh(e,t){return new Promise((r,n)=>{let i=new XMLHttpRequest;i.open(e.method||"GET",e.url,!0),(e.type==="arrayBuffer"||e.type==="image")&&(i.responseType="arraybuffer");for(let o in e.headers)i.setRequestHeader(o,e.headers[o]);e.type==="json"&&(i.responseType="text",i.setRequestHeader("Accept","application/json")),i.withCredentials=e.credentials==="include",i.onerror=()=>{n(new Error(i.statusText))},i.onload=()=>{if(!t.signal.aborted)if((i.status>=200&&i.status<300||i.status===0)&&i.response!==null){let o=i.response;if(e.type==="json")try{o=JSON.parse(i.response)}catch(a){n(a);return}r({data:o,cacheControl:i.getResponseHeader("Cache-Control"),expires:i.getResponseHeader("Expires")})}else{let o=new Blob([i.response],{type:i.getResponseHeader("Content-Type")});n(new gr(i.status,i.statusText,e.url,o))}},t.signal.addEventListener("abort",()=>{i.abort(),n(bs())}),i.send(e.body)})}var sc=function(e,t){if(/:\\/\\//.test(e.url)&&!/^https?:|^file:/.test(e.url)){let r=tc(e.url);if(r)return r(e,t);if(at(self)&&self.worker&&self.worker.actor)return self.worker.actor.sendAsync({type:"GR",data:e,targetMapId:ic},t)}if(!Xh(e.url)){if(fetch&&Request&&AbortController&&Object.prototype.hasOwnProperty.call(Request.prototype,"signal"))return Kh(e,t);if(at(self)&&self.worker&&self.worker.actor)return self.worker.actor.sendAsync({type:"GR",data:e,mustQueue:!0,targetMapId:ic},t)}return Yh(e,t)},lc=(e,t)=>sc(Pe(e,{type:"json"}),t),uc=(e,t)=>sc(Pe(e,{type:"arrayBuffer"}),t);var xt={};function C(e,t,r={}){if(xt[e])throw new Error("".concat(e," is already registered."));Object.defineProperty(t,"_classRegistryKey",{value:e,writeable:!1}),xt[e]={klass:t,omit:r.omit||[],shallow:r.shallow||[]}}C("Object",Object);C("TransferableGridIndex",Dt);C("Color",W);C("Error",Error);C("AJAXError",gr);C("ResolvedImage",Te);C("StylePropertyFunction",sn);C("StyleExpression",Rt,{omit:["_evaluator"]});C("ZoomDependentExpression",gt);C("ZoomConstantExpression",dt);C("CompoundExpression",Ke,{omit:["_evaluate"]});for(let e in Ut)Ut[e]._classRegistryKey||C("Expression_".concat(e),Ut[e]);function cc(e){return e&&typeof ArrayBuffer<"u"&&(e instanceof ArrayBuffer||e.constructor&&e.constructor.name==="ArrayBuffer")}function xr(e,t){if(e==null||typeof e=="boolean"||typeof e=="number"||typeof e=="string"||e instanceof Boolean||e instanceof Number||e instanceof String||e instanceof Date||e instanceof RegExp||e instanceof Blob||e instanceof Error)return e;if(cc(e)||qr(e))return t&&t.push(e),e;if(ArrayBuffer.isView(e)){let r=e;return t&&t.push(r.buffer),r}if(e instanceof ImageData)return t&&t.push(e.data.buffer),e;if(Array.isArray(e)){let r=[];for(let n of e)r.push(xr(n,t));return r}if(typeof e=="object"){let r=e.constructor,n=r._classRegistryKey;if(!n)throw new Error("can't serialize object of unregistered class ".concat(r.name));if(!xt[n])throw new Error("".concat(n," is not registered."));let i=r.serialize?r.serialize(e,t):{};if(r.serialize){if(t&&i===t[t.length-1])throw new Error("statically serialized object won't survive transfer of $name property")}else{for(let o in e){if(!e.hasOwnProperty(o)||xt[n].omit.indexOf(o)>=0)continue;let a=e[o];i[o]=xt[n].shallow.indexOf(o)>=0?a:xr(a,t)}e instanceof Error&&(i.message=e.message)}if(i.$name)throw new Error("$name property is reserved for worker serialization logic.");return n!=="Object"&&(i.$name=n),i}throw new Error("can't serialize object of type ".concat(typeof e))}function br(e){if(e==null||typeof e=="boolean"||typeof e=="number"||typeof e=="string"||e instanceof Boolean||e instanceof Number||e instanceof String||e instanceof Date||e instanceof RegExp||e instanceof Blob||e instanceof Error||cc(e)||qr(e)||ArrayBuffer.isView(e)||e instanceof ImageData)return e;if(Array.isArray(e))return e.map(br);if(typeof e=="object"){let t=e.$name||"Object";if(!xt[t])throw new Error("can't deserialize unregistered class ".concat(t));let{klass:r}=xt[t];if(!r)throw new Error("can't deserialize unregistered class ".concat(t));if(r.deserialize)return r.deserialize(e);let n=Object.create(r.prototype);for(let i of Object.keys(e)){if(i==="$name")continue;let o=e[i];n[i]=xt[t].shallow.indexOf(i)>=0?o:br(o)}return n}throw new Error("can't deserialize object of type ".concat(typeof e))}var eo=class{constructor(t){this._methodToThrottle=t,this._triggered=!1,typeof MessageChannel<"u"&&(this._channel=new MessageChannel,this._channel.port2.onmessage=()=>{this._triggered=!1,this._methodToThrottle()})}trigger(){this._triggered||(this._triggered=!0,this._channel?this._channel.port1.postMessage(!0):setTimeout(()=>{this._triggered=!1,this._methodToThrottle()},0))}remove(){delete this._channel,this._methodToThrottle=()=>{}}};var to=class{constructor(t,r){this.target=t,this.mapId=r,this.resolveRejects={},this.tasks={},this.taskQueue=[],this.abortControllers={},this.messageHandlers={},this.invoker=new eo(()=>this.process()),this.subscription=Hl(this.target,"message",n=>this.receive(n),!1),this.globalScope=at(self)?t:window}registerMessageHandler(t,r){this.messageHandlers[t]=r}sendAsync(t,r){return new Promise((n,i)=>{let o=Math.round(Math.random()*1e18).toString(36).substring(0,10);this.resolveRejects[o]={resolve:n,reject:i},r&&r.signal.addEventListener("abort",()=>{delete this.resolveRejects[o];let l={id:o,type:"<cancel>",origin:location.origin,targetMapId:t.targetMapId,sourceMapId:this.mapId};this.target.postMessage(l)},{once:!0});let a=[],s={...t,id:o,sourceMapId:this.mapId,origin:location.origin,data:xr(t.data,a)};this.target.postMessage(s,{transfer:a})})}receive(t){let r=t.data,n=r.id;if(!(r.origin!=="file://"&&location.origin!=="file://"&&r.origin!==location.origin)&&!(r.targetMapId&&this.mapId!==r.targetMapId)){if(r.type==="<cancel>"){delete this.tasks[n];let i=this.abortControllers[n];delete this.abortControllers[n],i&&i.abort();return}if(at(self)||r.mustQueue){this.tasks[n]=r,this.taskQueue.push(n),this.invoker.trigger();return}this.processTask(n,r)}}process(){if(this.taskQueue.length===0)return;let t=this.taskQueue.shift(),r=this.tasks[t];delete this.tasks[t],this.taskQueue.length>0&&this.invoker.trigger(),r&&this.processTask(t,r)}async processTask(t,r){if(r.type==="<response>"){let o=this.resolveRejects[t];if(delete this.resolveRejects[t],!o)return;r.error?o.reject(br(r.error)):o.resolve(br(r.data));return}if(!this.messageHandlers[r.type]){this.completeTask(t,new Error("Could not find a registered handler for ".concat(r.type,", map ID: ").concat(this.mapId,", available handlers: ").concat(Object.keys(this.messageHandlers).join(", "))));return}let n=br(r.data),i=new AbortController;this.abortControllers[t]=i;try{let o=await this.messageHandlers[r.type](r.sourceMapId,n,i);this.completeTask(t,null,o)}catch(o){this.completeTask(t,o)}}completeTask(t,r,n){let i=[];delete this.abortControllers[t];let o={id:t,type:"<response>",sourceMapId:this.mapId,origin:location.origin,error:r?xr(r):null,data:xr(n,i)};this.target.postMessage(o,{transfer:i})}remove(){this.invoker.remove(),this.subscription.unsubscribe()}};function pc(e,t,r){r[e]&&r[e].indexOf(t)!==-1||(r[e]=r[e]||[],r[e].push(t))}function vs(e,t,r){if(r&&r[e]){let n=r[e].indexOf(t);n!==-1&&r[e].splice(n,1)}}var ro=class{constructor(t,r={}){Pe(this,r),this.type=t}},yn=class extends ro{constructor(t,r={}){super("error",Pe({error:t},r))}},no=class{on(t,r){return this._listeners=this._listeners||{},pc(t,r,this._listeners),this}off(t,r){return vs(t,r,this._listeners),vs(t,r,this._oneTimeListeners),this}once(t,r){return r?(this._oneTimeListeners=this._oneTimeListeners||{},pc(t,r,this._oneTimeListeners),this):new Promise(n=>this.once(t,n))}fire(t,r){typeof t=="string"&&(t=new ro(t,r||{}));let n=t.type;if(this.listens(n)){t.target=this;let i=this._listeners&&this._listeners[n]?this._listeners[n].slice():[];for(let s of i)s.call(this,t);let o=this._oneTimeListeners&&this._oneTimeListeners[n]?this._oneTimeListeners[n].slice():[];for(let s of o)vs(n,s,this._oneTimeListeners),s.call(this,t);let a=this._eventedParent;a&&(Pe(t,typeof this._eventedParentData=="function"?this._eventedParentData():this._eventedParentData),a.fire(t))}else t instanceof yn&&console.error(t.error);return this}listens(t){return this._listeners&&this._listeners[t]&&this._listeners[t].length>0||this._oneTimeListeners&&this._oneTimeListeners[t]&&this._oneTimeListeners[t].length>0||this._eventedParent&&this._eventedParent.listens(t)}setEventedParent(t,r){return this._eventedParent=t,this._eventedParentData=r,this}};var bt=Ue,j0=bt.source,J0=bt.light,Z0=bt.terrain,W0=bt.filter,fc=bt.paintProperty,yc=bt.layoutProperty;function mc(e,t){let r=!1;if(t&&t.length)for(let n of t)e.fire(new yn(new Error(n.message))),r=!0;return r}var io=class{constructor(){this.first=!0}update(t,r){let n=Math.floor(t);return this.first?(this.first=!1,this.lastIntegerZoom=n,this.lastIntegerZoomTime=0,this.lastZoom=t,this.lastFloorZoom=n,!0):(this.lastFloorZoom>n?(this.lastIntegerZoom=n+1,this.lastIntegerZoomTime=r):this.lastFloorZoom<n&&(this.lastIntegerZoom=n,this.lastIntegerZoomTime=r),t!==this.lastZoom?(this.lastZoom=t,this.lastFloorZoom=n,!0):!1)}};var D={"Latin-1 Supplement":e=>e>=128&&e<=255,Arabic:e=>e>=1536&&e<=1791,"Arabic Supplement":e=>e>=1872&&e<=1919,"Arabic Extended-A":e=>e>=2208&&e<=2303,"Hangul Jamo":e=>e>=4352&&e<=4607,"Unified Canadian Aboriginal Syllabics":e=>e>=5120&&e<=5759,Khmer:e=>e>=6016&&e<=6143,"Unified Canadian Aboriginal Syllabics Extended":e=>e>=6320&&e<=6399,"General Punctuation":e=>e>=8192&&e<=8303,"Letterlike Symbols":e=>e>=8448&&e<=8527,"Number Forms":e=>e>=8528&&e<=8591,"Miscellaneous Technical":e=>e>=8960&&e<=9215,"Control Pictures":e=>e>=9216&&e<=9279,"Optical Character Recognition":e=>e>=9280&&e<=9311,"Enclosed Alphanumerics":e=>e>=9312&&e<=9471,"Geometric Shapes":e=>e>=9632&&e<=9727,"Miscellaneous Symbols":e=>e>=9728&&e<=9983,"Miscellaneous Symbols and Arrows":e=>e>=11008&&e<=11263,"CJK Radicals Supplement":e=>e>=11904&&e<=12031,"Kangxi Radicals":e=>e>=12032&&e<=12255,"Ideographic Description Characters":e=>e>=12272&&e<=12287,"CJK Symbols and Punctuation":e=>e>=12288&&e<=12351,Hiragana:e=>e>=12352&&e<=12447,Katakana:e=>e>=12448&&e<=12543,Bopomofo:e=>e>=12544&&e<=12591,"Hangul Compatibility Jamo":e=>e>=12592&&e<=12687,Kanbun:e=>e>=12688&&e<=12703,"Bopomofo Extended":e=>e>=12704&&e<=12735,"CJK Strokes":e=>e>=12736&&e<=12783,"Katakana Phonetic Extensions":e=>e>=12784&&e<=12799,"Enclosed CJK Letters and Months":e=>e>=12800&&e<=13055,"CJK Compatibility":e=>e>=13056&&e<=13311,"CJK Unified Ideographs Extension A":e=>e>=13312&&e<=19903,"Yijing Hexagram Symbols":e=>e>=19904&&e<=19967,"CJK Unified Ideographs":e=>e>=19968&&e<=40959,"Yi Syllables":e=>e>=40960&&e<=42127,"Yi Radicals":e=>e>=42128&&e<=42191,"Hangul Jamo Extended-A":e=>e>=43360&&e<=43391,"Hangul Syllables":e=>e>=44032&&e<=55215,"Hangul Jamo Extended-B":e=>e>=55216&&e<=55295,"Private Use Area":e=>e>=57344&&e<=63743,"CJK Compatibility Ideographs":e=>e>=63744&&e<=64255,"Arabic Presentation Forms-A":e=>e>=64336&&e<=65023,"Vertical Forms":e=>e>=65040&&e<=65055,"CJK Compatibility Forms":e=>e>=65072&&e<=65103,"Small Form Variants":e=>e>=65104&&e<=65135,"Arabic Presentation Forms-B":e=>e>=65136&&e<=65279,"Halfwidth and Fullwidth Forms":e=>e>=65280&&e<=65519};function mn(e){for(let t of e)if(oo(t.charCodeAt(0)))return!0;return!1}function hc(e){for(let t of e)if(!Qh(t.charCodeAt(0)))return!1;return!0}function Qh(e){return!(D.Arabic(e)||D["Arabic Supplement"](e)||D["Arabic Extended-A"](e)||D["Arabic Presentation Forms-A"](e)||D["Arabic Presentation Forms-B"](e))}function dc(e){return e<11904?!1:!!(D["Bopomofo Extended"](e)||D.Bopomofo(e)||D["CJK Compatibility Forms"](e)||D["CJK Compatibility Ideographs"](e)||D["CJK Compatibility"](e)||D["CJK Radicals Supplement"](e)||D["CJK Strokes"](e)||D["CJK Symbols and Punctuation"](e)||D["CJK Unified Ideographs Extension A"](e)||D["CJK Unified Ideographs"](e)||D["Enclosed CJK Letters and Months"](e)||D["Halfwidth and Fullwidth Forms"](e)||D.Hiragana(e)||D["Ideographic Description Characters"](e)||D["Kangxi Radicals"](e)||D["Katakana Phonetic Extensions"](e)||D.Katakana(e)||D["Vertical Forms"](e)||D["Yi Radicals"](e)||D["Yi Syllables"](e))}function oo(e){return e===746||e===747?!0:e<4352?!1:!!(D["Bopomofo Extended"](e)||D.Bopomofo(e)||D["CJK Compatibility Forms"](e)&&!(e>=65097&&e<=65103)||D["CJK Compatibility Ideographs"](e)||D["CJK Compatibility"](e)||D["CJK Radicals Supplement"](e)||D["CJK Strokes"](e)||D["CJK Symbols and Punctuation"](e)&&!(e>=12296&&e<=12305)&&!(e>=12308&&e<=12319)&&e!==12336||D["CJK Unified Ideographs Extension A"](e)||D["CJK Unified Ideographs"](e)||D["Enclosed CJK Letters and Months"](e)||D["Hangul Compatibility Jamo"](e)||D["Hangul Jamo Extended-A"](e)||D["Hangul Jamo Extended-B"](e)||D["Hangul Jamo"](e)||D["Hangul Syllables"](e)||D.Hiragana(e)||D["Ideographic Description Characters"](e)||D.Kanbun(e)||D["Kangxi Radicals"](e)||D["Katakana Phonetic Extensions"](e)||D.Katakana(e)&&e!==12540||D["Halfwidth and Fullwidth Forms"](e)&&e!==65288&&e!==65289&&e!==65293&&!(e>=65306&&e<=65310)&&e!==65339&&e!==65341&&e!==65343&&!(e>=65371&&e<=65503)&&e!==65507&&!(e>=65512&&e<=65519)||D["Small Form Variants"](e)&&!(e>=65112&&e<=65118)&&!(e>=65123&&e<=65126)||D["Unified Canadian Aboriginal Syllabics"](e)||D["Unified Canadian Aboriginal Syllabics Extended"](e)||D["Vertical Forms"](e)||D["Yijing Hexagram Symbols"](e)||D["Yi Syllables"](e)||D["Yi Radicals"](e))}function ed(e){return!!(D["Latin-1 Supplement"](e)&&(e===167||e===169||e===174||e===177||e===188||e===189||e===190||e===215||e===247)||D["General Punctuation"](e)&&(e===8214||e===8224||e===8225||e===8240||e===8241||e===8251||e===8252||e===8258||e===8263||e===8264||e===8265||e===8273)||D["Letterlike Symbols"](e)||D["Number Forms"](e)||D["Miscellaneous Technical"](e)&&(e>=8960&&e<=8967||e>=8972&&e<=8991||e>=8996&&e<=9e3||e===9003||e>=9085&&e<=9114||e>=9150&&e<=9165||e===9167||e>=9169&&e<=9179||e>=9186&&e<=9215)||D["Control Pictures"](e)&&e!==9251||D["Optical Character Recognition"](e)||D["Enclosed Alphanumerics"](e)||D["Geometric Shapes"](e)||D["Miscellaneous Symbols"](e)&&!(e>=9754&&e<=9759)||D["Miscellaneous Symbols and Arrows"](e)&&(e>=11026&&e<=11055||e>=11088&&e<=11097||e>=11192&&e<=11243)||D["CJK Symbols and Punctuation"](e)||D.Katakana(e)||D["Private Use Area"](e)||D["CJK Compatibility Forms"](e)||D["Small Form Variants"](e)||D["Halfwidth and Fullwidth Forms"](e)||e===8734||e===8756||e===8757||e>=9984&&e<=10087||e>=10102&&e<=10131||e===65532||e===65533)}function Ps(e){return!(oo(e)||ed(e))}function gc(e){return D.Arabic(e)||D["Arabic Supplement"](e)||D["Arabic Extended-A"](e)||D["Arabic Presentation Forms-A"](e)||D["Arabic Presentation Forms-B"](e)}function xc(e){return e>=1424&&e<=2303||D["Arabic Presentation Forms-A"](e)||D["Arabic Presentation Forms-B"](e)}function td(e,t){return!(!t&&xc(e)||e>=2304&&e<=3583||e>=3840&&e<=4255||D.Khmer(e))}function bc(e){for(let t of e)if(xc(t.charCodeAt(0)))return!0;return!1}function vc(e,t){for(let r of e)if(!td(r.charCodeAt(0),t))return!1;return!0}var Ss=class{constructor(){this.applyArabicShaping=null;this.processBidirectionalText=null;this.processStyledBidirectionalText=null;this.pluginStatus="unavailable";this.pluginURL=null}setState(t){this.pluginStatus=t.pluginStatus,this.pluginURL=t.pluginURL}getState(){return{pluginStatus:this.pluginStatus,pluginURL:this.pluginURL}}setMethods(t){this.applyArabicShaping=t.applyArabicShaping,this.processBidirectionalText=t.processBidirectionalText,this.processStyledBidirectionalText=t.processStyledBidirectionalText}isParsed(){return this.applyArabicShaping!=null&&this.processBidirectionalText!=null&&this.processStyledBidirectionalText!=null}getPluginURL(){return this.pluginURL}getRTLTextPluginStatus(){return this.pluginStatus}},ye=new Ss;var q=class{constructor(t,r){this.zoom=t,r?(this.now=r.now,this.fadeDuration=r.fadeDuration,this.zoomHistory=r.zoomHistory,this.transition=r.transition):(this.now=0,this.fadeDuration=0,this.zoomHistory=new io,this.transition={})}isSupportedScript(t){return vc(t,ye.getRTLTextPluginStatus()==="loaded")}crossFadingFactor(){return this.fadeDuration===0?1:Math.min((this.now-this.zoomHistory.lastIntegerZoomTime)/this.fadeDuration,1)}getCrossfadeParameters(){let t=this.zoom,r=t-Math.floor(t),n=this.crossFadingFactor();return t>this.zoomHistory.lastIntegerZoom?{fromScale:2,toScale:1,t:r+(1-r)*n}:{fromScale:.5,toScale:1,t:1-(1-n)*r}}};var vr=class{constructor(t,r){this.property=t,this.value=r,this.expression=Bu(r===void 0?t.specification.default:r,t.specification)}isDataDriven(){return this.expression.kind==="source"||this.expression.kind==="composite"}possiblyEvaluate(t,r,n){return this.property.possiblyEvaluate(this,t,r,n)}},hn=class{constructor(t){this.property=t,this.value=new vr(t,void 0)}transitioned(t,r){return new so(this.property,this.value,r,Pe({},t.transition,this.transition),t.now)}untransitioned(){return new so(this.property,this.value,null,{},0)}},ao=class{constructor(t){this._properties=t,this._values=Object.create(t.defaultTransitionablePropertyValues)}getValue(t){return nt(this._values[t].value.value)}setValue(t,r){Object.prototype.hasOwnProperty.call(this._values,t)||(this._values[t]=new hn(this._values[t].property)),this._values[t].value=new vr(this._values[t].property,r===null?void 0:nt(r))}getTransition(t){return nt(this._values[t].transition)}setTransition(t,r){Object.prototype.hasOwnProperty.call(this._values,t)||(this._values[t]=new hn(this._values[t].property)),this._values[t].transition=nt(r)||void 0}serialize(){let t={};for(let r of Object.keys(this._values)){let n=this.getValue(r);n!==void 0&&(t[r]=n);let i=this.getTransition(r);i!==void 0&&(t["".concat(r,"-transition")]=i)}return t}transitioned(t,r){let n=new lo(this._properties);for(let i of Object.keys(this._values))n._values[i]=this._values[i].transitioned(t,r._values[i]);return n}untransitioned(){let t=new lo(this._properties);for(let r of Object.keys(this._values))t._values[r]=this._values[r].untransitioned();return t}},so=class{constructor(t,r,n,i,o){this.property=t,this.value=r,this.begin=o+i.delay||0,this.end=this.begin+i.duration||0,t.specification.transition&&(i.delay||i.duration)&&(this.prior=n)}possiblyEvaluate(t,r,n){let i=t.now||0,o=this.value.possiblyEvaluate(t,r,n),a=this.prior;if(a){if(i>this.end)return this.prior=null,o;if(this.value.isDataDriven())return this.prior=null,o;if(i<this.begin)return a.possiblyEvaluate(t,r,n);{let s=(i-this.begin)/(this.end-this.begin);return this.property.interpolate(a.possiblyEvaluate(t,r,n),o,$l(s))}}else return o}},lo=class{constructor(t){this._properties=t,this._values=Object.create(t.defaultTransitioningPropertyValues)}possiblyEvaluate(t,r,n){let i=new vt(this._properties);for(let o of Object.keys(this._values))i._values[o]=this._values[o].possiblyEvaluate(t,r,n);return i}hasTransition(){for(let t of Object.keys(this._values))if(this._values[t].prior)return!0;return!1}},uo=class{constructor(t){this._properties=t,this._values=Object.create(t.defaultPropertyValues)}hasValue(t){return this._values[t].value!==void 0}getValue(t){return nt(this._values[t].value)}setValue(t,r){this._values[t]=new vr(this._values[t].property,r===null?void 0:nt(r))}serialize(){let t={};for(let r of Object.keys(this._values)){let n=this.getValue(r);n!==void 0&&(t[r]=n)}return t}possiblyEvaluate(t,r,n){let i=new vt(this._properties);for(let o of Object.keys(this._values))i._values[o]=this._values[o].possiblyEvaluate(t,r,n);return i}},Se=class{constructor(t,r,n){this.property=t,this.value=r,this.parameters=n}isConstant(){return this.value.kind==="constant"}constantOr(t){return this.value.kind==="constant"?this.value.value:t}evaluate(t,r,n,i){return this.property.evaluate(this.value,this.parameters,t,r,n,i)}},vt=class{constructor(t){this._properties=t,this._values=Object.create(t.defaultPossiblyEvaluatedValues)}get(t){return this._values[t]}},B=class{constructor(t){this.specification=t}possiblyEvaluate(t,r){if(t.isDataDriven())throw new Error("Value should not be data driven");return t.expression.evaluate(r)}interpolate(t,r,n){let i=this.specification.type,o=Oe[i];return o?o(t,r,n):t}},R=class{constructor(t,r){this.specification=t,this.overrides=r}possiblyEvaluate(t,r,n,i){return t.expression.kind==="constant"||t.expression.kind==="camera"?new Se(this,{kind:"constant",value:t.expression.evaluate(r,null,{},n,i)},r):new Se(this,t.expression,r)}interpolate(t,r,n){if(t.value.kind!=="constant"||r.value.kind!=="constant")return t;if(t.value.value===void 0||r.value.value===void 0)return new Se(this,{kind:"constant",value:void 0},t.parameters);let i=this.specification.type,o=Oe[i];if(o){let a=o(t.value.value,r.value.value,n);return new Se(this,{kind:"constant",value:a},t.parameters)}else return t}evaluate(t,r,n,i,o,a){return t.kind==="constant"?t.value:t.evaluate(r,n,i,o,a)}},lt=class extends R{possiblyEvaluate(t,r,n,i){if(t.value===void 0)return new Se(this,{kind:"constant",value:void 0},r);if(t.expression.kind==="constant"){let o=t.expression.evaluate(r,null,{},n,i),s=t.property.specification.type==="resolvedImage"&&typeof o!="string"?o.name:o,l=this._calculate(s,s,s,r);return new Se(this,{kind:"constant",value:l},r)}else if(t.expression.kind==="camera"){let o=this._calculate(t.expression.evaluate({zoom:r.zoom-1}),t.expression.evaluate({zoom:r.zoom}),t.expression.evaluate({zoom:r.zoom+1}),r);return new Se(this,{kind:"constant",value:o},r)}else return new Se(this,t.expression,r)}evaluate(t,r,n,i,o,a){if(t.kind==="source"){let s=t.evaluate(r,n,i,o,a);return this._calculate(s,s,s,r)}else return t.kind==="composite"?this._calculate(t.evaluate({zoom:Math.floor(r.zoom)-1},n,i),t.evaluate({zoom:Math.floor(r.zoom)},n,i),t.evaluate({zoom:Math.floor(r.zoom)+1},n,i),r):t.value}_calculate(t,r,n,i){return i.zoom>i.zoomHistory.lastIntegerZoom?{from:t,to:r}:{from:n,to:r}}interpolate(t){return t}},qt=class{constructor(t){this.specification=t}possiblyEvaluate(t,r,n,i){if(t.value!==void 0)if(t.expression.kind==="constant"){let o=t.expression.evaluate(r,null,{},n,i);return this._calculate(o,o,o,r)}else return this._calculate(t.expression.evaluate(new q(Math.floor(r.zoom-1),r)),t.expression.evaluate(new q(Math.floor(r.zoom),r)),t.expression.evaluate(new q(Math.floor(r.zoom+1),r)),r)}_calculate(t,r,n,i){return i.zoom>i.zoomHistory.lastIntegerZoom?{from:t,to:r}:{from:n,to:r}}interpolate(t){return t}},jt=class{constructor(t){this.specification=t}possiblyEvaluate(t,r,n,i){return!!t.expression.evaluate(r,null,{},n,i)}interpolate(){return!1}},re=class{constructor(t){this.properties=t,this.defaultPropertyValues={},this.defaultTransitionablePropertyValues={},this.defaultTransitioningPropertyValues={},this.defaultPossiblyEvaluatedValues={},this.overridableProperties=[];for(let r in t){let n=t[r];n.specification.overridable&&this.overridableProperties.push(r);let i=this.defaultPropertyValues[r]=new vr(n,void 0),o=this.defaultTransitionablePropertyValues[r]=new hn(n);this.defaultTransitioningPropertyValues[r]=o.untransitioned(),this.defaultPossiblyEvaluatedValues[r]=i.possiblyEvaluate({})}}};C("DataDrivenProperty",R);C("DataConstantProperty",B);C("CrossFadedDataDrivenProperty",lt);C("CrossFadedProperty",qt);C("ColorRampProperty",jt);var co="-transition",se=class extends no{constructor(t,r){if(super(),this.id=t.id,this.type=t.type,this._featureFilter={filter:()=>!0,needGeometry:!1},t.type!=="custom"&&(t=t,this.metadata=t.metadata,this.minzoom=t.minzoom,this.maxzoom=t.maxzoom,t.type!=="background"&&(this.source=t.source,this.sourceLayer=t["source-layer"],this.filter=t.filter),r.layout&&(this._unevaluatedLayout=new uo(r.layout)),r.paint)){this._transitionablePaint=new ao(r.paint);for(let n in t.paint)this.setPaintProperty(n,t.paint[n],{validate:!1});for(let n in t.layout)this.setLayoutProperty(n,t.layout[n],{validate:!1});this._transitioningPaint=this._transitionablePaint.untransitioned(),this.paint=new vt(r.paint)}}getCrossfadeParameters(){return this._crossfadeParameters}getLayoutProperty(t){return t==="visibility"?this.visibility:this._unevaluatedLayout.getValue(t)}setLayoutProperty(t,r,n={}){if(r!=null){let i="layers.".concat(this.id,".layout.").concat(t);if(this._validate(yc,i,t,r,n))return}if(t==="visibility"){this.visibility=r;return}this._unevaluatedLayout.setValue(t,r)}getPaintProperty(t){return t.endsWith(co)?this._transitionablePaint.getTransition(t.slice(0,-co.length)):this._transitionablePaint.getValue(t)}setPaintProperty(t,r,n={}){if(r!=null){let i="layers.".concat(this.id,".paint.").concat(t);if(this._validate(fc,i,t,r,n))return!1}if(t.endsWith(co))return this._transitionablePaint.setTransition(t.slice(0,-co.length),r||void 0),!1;{let i=this._transitionablePaint._values[t],o=i.property.specification["property-type"]==="cross-faded-data-driven",a=i.value.isDataDriven(),s=i.value;this._transitionablePaint.setValue(t,r),this._handleSpecialPaintPropertyUpdate(t);let l=this._transitionablePaint._values[t].value;return l.isDataDriven()||a||o||this._handleOverridablePaintPropertyUpdate(t,s,l)}}_handleSpecialPaintPropertyUpdate(t){}_handleOverridablePaintPropertyUpdate(t,r,n){return!1}isHidden(t){return this.minzoom&&t<this.minzoom||this.maxzoom&&t>=this.maxzoom?!0:this.visibility==="none"}updateTransitions(t){this._transitioningPaint=this._transitionablePaint.transitioned(t,this._transitioningPaint)}hasTransition(){return this._transitioningPaint.hasTransition()}recalculate(t,r){t.getCrossfadeParameters&&(this._crossfadeParameters=t.getCrossfadeParameters()),this._unevaluatedLayout&&(this.layout=this._unevaluatedLayout.possiblyEvaluate(t,void 0,r)),this.paint=this._transitioningPaint.possiblyEvaluate(t,void 0,r)}serialize(){let t={id:this.id,type:this.type,source:this.source,"source-layer":this.sourceLayer,metadata:this.metadata,minzoom:this.minzoom,maxzoom:this.maxzoom,filter:this.filter,layout:this._unevaluatedLayout&&this._unevaluatedLayout.serialize(),paint:this._transitionablePaint&&this._transitionablePaint.serialize()};return this.visibility&&(t.layout=t.layout||{},t.layout.visibility=this.visibility),jl(t,(r,n)=>r!==void 0&&!(n==="layout"&&!Object.keys(r).length)&&!(n==="paint"&&!Object.keys(r).length))}_validate(t,r,n,i,o={}){return o&&o.validate===!1?!1:mc(this,t.call(bt,{key:r,layerType:this.type,objectKey:n,value:i,styleSpec:S,style:{glyphs:!0,sprite:!0}}))}is3D(){return!1}isTileClipped(){return!1}hasOffscreenPass(){return!1}resize(){}isStateDependent(){for(let t in this.paint._values){let r=this.paint.get(t);if(!(!(r instanceof Se)||!ht(r.property.specification))&&(r.value.kind==="source"||r.value.kind==="composite")&&r.value.isStateDependent)return!0}return!1}};var rd={Int8:Int8Array,Uint8:Uint8Array,Int16:Int16Array,Uint16:Uint16Array,Int32:Int32Array,Uint32:Uint32Array,Float32:Float32Array},Pt=class{constructor(t,r){this._structArray=t,this._pos1=r*this.size,this._pos2=this._pos1/2,this._pos4=this._pos1/4,this._pos8=this._pos1/8}},nd=128,id=5,ee=class{constructor(){this.isTransferred=!1,this.capacity=-1,this.resize(0)}static serialize(t,r){return t._trim(),r&&(t.isTransferred=!0,r.push(t.arrayBuffer)),{length:t.length,arrayBuffer:t.arrayBuffer}}static deserialize(t){let r=Object.create(this.prototype);return r.arrayBuffer=t.arrayBuffer,r.length=t.length,r.capacity=t.arrayBuffer.byteLength/r.bytesPerElement,r._refreshViews(),r}_trim(){this.length!==this.capacity&&(this.capacity=this.length,this.arrayBuffer=this.arrayBuffer.slice(0,this.length*this.bytesPerElement),this._refreshViews())}clear(){this.length=0}resize(t){this.reserve(t),this.length=t}reserve(t){if(t>this.capacity){this.capacity=Math.max(t,Math.floor(this.capacity*id),nd),this.arrayBuffer=new ArrayBuffer(this.capacity*this.bytesPerElement);let r=this.uint8;this._refreshViews(),r&&this.uint8.set(r)}}_refreshViews(){throw new Error("_refreshViews() must be implemented by each concrete StructArray layout")}};function Y(e,t=1){let r=0,n=0,i=e.map(a=>{let s=od(a.type),l=r=Pc(r,Math.max(t,s)),u=a.components||1;return n=Math.max(n,s),r+=s*u,{name:a.name,type:a.type,components:u,offset:l}}),o=Pc(r,Math.max(n,t));return{members:i,size:o,alignment:t}}function od(e){return rd[e].BYTES_PER_ELEMENT}function Pc(e,t){return Math.ceil(e/t)*t}var Sc=Z(he(),1),Jt=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer)}emplaceBack(t,r){let n=this.length;return this.resize(n+1),this.emplace(n,t,r)}emplace(t,r,n){let i=t*2;return this.int16[i+0]=r,this.int16[i+1]=n,t}};Jt.prototype.bytesPerElement=4;C("StructArrayLayout2i4",Jt);var dn=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer)}emplaceBack(t,r,n){let i=this.length;return this.resize(i+1),this.emplace(i,t,r,n)}emplace(t,r,n,i){let o=t*3;return this.int16[o+0]=r,this.int16[o+1]=n,this.int16[o+2]=i,t}};dn.prototype.bytesPerElement=6;C("StructArrayLayout3i6",dn);var po=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer)}emplaceBack(t,r,n,i){let o=this.length;return this.resize(o+1),this.emplace(o,t,r,n,i)}emplace(t,r,n,i,o){let a=t*4;return this.int16[a+0]=r,this.int16[a+1]=n,this.int16[a+2]=i,this.int16[a+3]=o,t}};po.prototype.bytesPerElement=8;C("StructArrayLayout4i8",po);var gn=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer)}emplaceBack(t,r,n,i,o,a){let s=this.length;return this.resize(s+1),this.emplace(s,t,r,n,i,o,a)}emplace(t,r,n,i,o,a,s){let l=t*6;return this.int16[l+0]=r,this.int16[l+1]=n,this.int16[l+2]=i,this.int16[l+3]=o,this.int16[l+4]=a,this.int16[l+5]=s,t}};gn.prototype.bytesPerElement=12;C("StructArrayLayout2i4i12",gn);var xn=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer)}emplaceBack(t,r,n,i,o,a){let s=this.length;return this.resize(s+1),this.emplace(s,t,r,n,i,o,a)}emplace(t,r,n,i,o,a,s){let l=t*4,u=t*8;return this.int16[l+0]=r,this.int16[l+1]=n,this.uint8[u+4]=i,this.uint8[u+5]=o,this.uint8[u+6]=a,this.uint8[u+7]=s,t}};xn.prototype.bytesPerElement=8;C("StructArrayLayout2i4ub8",xn);var St=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer)}emplaceBack(t,r){let n=this.length;return this.resize(n+1),this.emplace(n,t,r)}emplace(t,r,n){let i=t*2;return this.float32[i+0]=r,this.float32[i+1]=n,t}};St.prototype.bytesPerElement=8;C("StructArrayLayout2f8",St);var bn=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer)}emplaceBack(t,r,n,i,o,a,s,l,u,c){let p=this.length;return this.resize(p+1),this.emplace(p,t,r,n,i,o,a,s,l,u,c)}emplace(t,r,n,i,o,a,s,l,u,c,p){let f=t*10;return this.uint16[f+0]=r,this.uint16[f+1]=n,this.uint16[f+2]=i,this.uint16[f+3]=o,this.uint16[f+4]=a,this.uint16[f+5]=s,this.uint16[f+6]=l,this.uint16[f+7]=u,this.uint16[f+8]=c,this.uint16[f+9]=p,t}};bn.prototype.bytesPerElement=20;C("StructArrayLayout10ui20",bn);var vn=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer)}emplaceBack(t,r,n,i,o,a,s,l,u,c,p,f){let y=this.length;return this.resize(y+1),this.emplace(y,t,r,n,i,o,a,s,l,u,c,p,f)}emplace(t,r,n,i,o,a,s,l,u,c,p,f,y){let m=t*12;return this.int16[m+0]=r,this.int16[m+1]=n,this.int16[m+2]=i,this.int16[m+3]=o,this.uint16[m+4]=a,this.uint16[m+5]=s,this.uint16[m+6]=l,this.uint16[m+7]=u,this.int16[m+8]=c,this.int16[m+9]=p,this.int16[m+10]=f,this.int16[m+11]=y,t}};vn.prototype.bytesPerElement=24;C("StructArrayLayout4i4ui4i24",vn);var Pn=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer)}emplaceBack(t,r,n){let i=this.length;return this.resize(i+1),this.emplace(i,t,r,n)}emplace(t,r,n,i){let o=t*3;return this.float32[o+0]=r,this.float32[o+1]=n,this.float32[o+2]=i,t}};Pn.prototype.bytesPerElement=12;C("StructArrayLayout3f12",Pn);var Sn=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint32=new Uint32Array(this.arrayBuffer)}emplaceBack(t){let r=this.length;return this.resize(r+1),this.emplace(r,t)}emplace(t,r){let n=t*1;return this.uint32[n+0]=r,t}};Sn.prototype.bytesPerElement=4;C("StructArrayLayout1ul4",Sn);var wn=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer),this.uint32=new Uint32Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer)}emplaceBack(t,r,n,i,o,a,s,l,u){let c=this.length;return this.resize(c+1),this.emplace(c,t,r,n,i,o,a,s,l,u)}emplace(t,r,n,i,o,a,s,l,u,c){let p=t*10,f=t*5;return this.int16[p+0]=r,this.int16[p+1]=n,this.int16[p+2]=i,this.int16[p+3]=o,this.int16[p+4]=a,this.int16[p+5]=s,this.uint32[f+3]=l,this.uint16[p+8]=u,this.uint16[p+9]=c,t}};wn.prototype.bytesPerElement=20;C("StructArrayLayout6i1ul2ui20",wn);var An=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer)}emplaceBack(t,r,n,i,o,a){let s=this.length;return this.resize(s+1),this.emplace(s,t,r,n,i,o,a)}emplace(t,r,n,i,o,a,s){let l=t*6;return this.int16[l+0]=r,this.int16[l+1]=n,this.int16[l+2]=i,this.int16[l+3]=o,this.int16[l+4]=a,this.int16[l+5]=s,t}};An.prototype.bytesPerElement=12;C("StructArrayLayout2i2i2i12",An);var fo=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer)}emplaceBack(t,r,n,i,o){let a=this.length;return this.resize(a+1),this.emplace(a,t,r,n,i,o)}emplace(t,r,n,i,o,a){let s=t*4,l=t*8;return this.float32[s+0]=r,this.float32[s+1]=n,this.float32[s+2]=i,this.int16[l+6]=o,this.int16[l+7]=a,t}};fo.prototype.bytesPerElement=16;C("StructArrayLayout2f1f2i16",fo);var _n=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer)}emplaceBack(t,r,n,i){let o=this.length;return this.resize(o+1),this.emplace(o,t,r,n,i)}emplace(t,r,n,i,o){let a=t*12,s=t*3;return this.uint8[a+0]=r,this.uint8[a+1]=n,this.float32[s+1]=i,this.float32[s+2]=o,t}};_n.prototype.bytesPerElement=12;C("StructArrayLayout2ub2f12",_n);var In=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer)}emplaceBack(t,r,n){let i=this.length;return this.resize(i+1),this.emplace(i,t,r,n)}emplace(t,r,n,i){let o=t*3;return this.uint16[o+0]=r,this.uint16[o+1]=n,this.uint16[o+2]=i,t}};In.prototype.bytesPerElement=6;C("StructArrayLayout3ui6",In);var Tn=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer),this.uint32=new Uint32Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer)}emplaceBack(t,r,n,i,o,a,s,l,u,c,p,f,y,m,h,d,g){let b=this.length;return this.resize(b+1),this.emplace(b,t,r,n,i,o,a,s,l,u,c,p,f,y,m,h,d,g)}emplace(t,r,n,i,o,a,s,l,u,c,p,f,y,m,h,d,g,b){let x=t*24,v=t*12,P=t*48;return this.int16[x+0]=r,this.int16[x+1]=n,this.uint16[x+2]=i,this.uint16[x+3]=o,this.uint32[v+2]=a,this.uint32[v+3]=s,this.uint32[v+4]=l,this.uint16[x+10]=u,this.uint16[x+11]=c,this.uint16[x+12]=p,this.float32[v+7]=f,this.float32[v+8]=y,this.uint8[P+36]=m,this.uint8[P+37]=h,this.uint8[P+38]=d,this.uint32[v+10]=g,this.int16[x+22]=b,t}};Tn.prototype.bytesPerElement=48;C("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48",Tn);var Cn=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer),this.uint32=new Uint32Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer)}emplaceBack(t,r,n,i,o,a,s,l,u,c,p,f,y,m,h,d,g,b,x,v,P,w,T,F,E,_,I,k){let V=this.length;return this.resize(V+1),this.emplace(V,t,r,n,i,o,a,s,l,u,c,p,f,y,m,h,d,g,b,x,v,P,w,T,F,E,_,I,k)}emplace(t,r,n,i,o,a,s,l,u,c,p,f,y,m,h,d,g,b,x,v,P,w,T,F,E,_,I,k,V){let A=t*32,z=t*16;return this.int16[A+0]=r,this.int16[A+1]=n,this.int16[A+2]=i,this.int16[A+3]=o,this.int16[A+4]=a,this.int16[A+5]=s,this.int16[A+6]=l,this.int16[A+7]=u,this.uint16[A+8]=c,this.uint16[A+9]=p,this.uint16[A+10]=f,this.uint16[A+11]=y,this.uint16[A+12]=m,this.uint16[A+13]=h,this.uint16[A+14]=d,this.uint16[A+15]=g,this.uint16[A+16]=b,this.uint16[A+17]=x,this.uint16[A+18]=v,this.uint16[A+19]=P,this.uint16[A+20]=w,this.uint16[A+21]=T,this.uint16[A+22]=F,this.uint32[z+12]=E,this.float32[z+13]=_,this.float32[z+14]=I,this.uint16[A+30]=k,this.uint16[A+31]=V,t}};Cn.prototype.bytesPerElement=64;C("StructArrayLayout8i15ui1ul2f2ui64",Cn);var Zt=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer)}emplaceBack(t){let r=this.length;return this.resize(r+1),this.emplace(r,t)}emplace(t,r){let n=t*1;return this.float32[n+0]=r,t}};Zt.prototype.bytesPerElement=4;C("StructArrayLayout1f4",Zt);var kn=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer)}emplaceBack(t,r,n){let i=this.length;return this.resize(i+1),this.emplace(i,t,r,n)}emplace(t,r,n,i){let o=t*6,a=t*3;return this.uint16[o+0]=r,this.float32[a+1]=n,this.float32[a+2]=i,t}};kn.prototype.bytesPerElement=12;C("StructArrayLayout1ui2f12",kn);var Mn=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint32=new Uint32Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer)}emplaceBack(t,r,n){let i=this.length;return this.resize(i+1),this.emplace(i,t,r,n)}emplace(t,r,n,i){let o=t*2,a=t*4;return this.uint32[o+0]=r,this.uint16[a+2]=n,this.uint16[a+3]=i,t}};Mn.prototype.bytesPerElement=8;C("StructArrayLayout1ul2ui8",Mn);var En=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer)}emplaceBack(t,r){let n=this.length;return this.resize(n+1),this.emplace(n,t,r)}emplace(t,r,n){let i=t*2;return this.uint16[i+0]=r,this.uint16[i+1]=n,t}};En.prototype.bytesPerElement=4;C("StructArrayLayout2ui4",En);var yo=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer)}emplaceBack(t){let r=this.length;return this.resize(r+1),this.emplace(r,t)}emplace(t,r){let n=t*1;return this.uint16[n+0]=r,t}};yo.prototype.bytesPerElement=2;C("StructArrayLayout1ui2",yo);var Pr=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer)}emplaceBack(t,r,n,i){let o=this.length;return this.resize(o+1),this.emplace(o,t,r,n,i)}emplace(t,r,n,i,o){let a=t*4;return this.float32[a+0]=r,this.float32[a+1]=n,this.float32[a+2]=i,this.float32[a+3]=o,t}};Pr.prototype.bytesPerElement=16;C("StructArrayLayout4f16",Pr);var mo=class extends Pt{get anchorPointX(){return this._structArray.int16[this._pos2+0]}get anchorPointY(){return this._structArray.int16[this._pos2+1]}get x1(){return this._structArray.int16[this._pos2+2]}get y1(){return this._structArray.int16[this._pos2+3]}get x2(){return this._structArray.int16[this._pos2+4]}get y2(){return this._structArray.int16[this._pos2+5]}get featureIndex(){return this._structArray.uint32[this._pos4+3]}get sourceLayerIndex(){return this._structArray.uint16[this._pos2+8]}get bucketIndex(){return this._structArray.uint16[this._pos2+9]}get anchorPoint(){return new Sc.default(this.anchorPointX,this.anchorPointY)}};mo.prototype.size=20;var Fn=class extends wn{get(t){return new mo(this,t)}};C("CollisionBoxArray",Fn);var ho=class extends Pt{get anchorX(){return this._structArray.int16[this._pos2+0]}get anchorY(){return this._structArray.int16[this._pos2+1]}get glyphStartIndex(){return this._structArray.uint16[this._pos2+2]}get numGlyphs(){return this._structArray.uint16[this._pos2+3]}get vertexStartIndex(){return this._structArray.uint32[this._pos4+2]}get lineStartIndex(){return this._structArray.uint32[this._pos4+3]}get lineLength(){return this._structArray.uint32[this._pos4+4]}get segment(){return this._structArray.uint16[this._pos2+10]}get lowerSize(){return this._structArray.uint16[this._pos2+11]}get upperSize(){return this._structArray.uint16[this._pos2+12]}get lineOffsetX(){return this._structArray.float32[this._pos4+7]}get lineOffsetY(){return this._structArray.float32[this._pos4+8]}get writingMode(){return this._structArray.uint8[this._pos1+36]}get placedOrientation(){return this._structArray.uint8[this._pos1+37]}set placedOrientation(t){this._structArray.uint8[this._pos1+37]=t}get hidden(){return this._structArray.uint8[this._pos1+38]}set hidden(t){this._structArray.uint8[this._pos1+38]=t}get crossTileID(){return this._structArray.uint32[this._pos4+10]}set crossTileID(t){this._structArray.uint32[this._pos4+10]=t}get associatedIconIndex(){return this._structArray.int16[this._pos2+22]}};ho.prototype.size=48;var Ln=class extends Tn{get(t){return new ho(this,t)}};C("PlacedSymbolArray",Ln);var go=class extends Pt{get anchorX(){return this._structArray.int16[this._pos2+0]}get anchorY(){return this._structArray.int16[this._pos2+1]}get rightJustifiedTextSymbolIndex(){return this._structArray.int16[this._pos2+2]}get centerJustifiedTextSymbolIndex(){return this._structArray.int16[this._pos2+3]}get leftJustifiedTextSymbolIndex(){return this._structArray.int16[this._pos2+4]}get verticalPlacedTextSymbolIndex(){return this._structArray.int16[this._pos2+5]}get placedIconSymbolIndex(){return this._structArray.int16[this._pos2+6]}get verticalPlacedIconSymbolIndex(){return this._structArray.int16[this._pos2+7]}get key(){return this._structArray.uint16[this._pos2+8]}get textBoxStartIndex(){return this._structArray.uint16[this._pos2+9]}get textBoxEndIndex(){return this._structArray.uint16[this._pos2+10]}get verticalTextBoxStartIndex(){return this._structArray.uint16[this._pos2+11]}get verticalTextBoxEndIndex(){return this._structArray.uint16[this._pos2+12]}get iconBoxStartIndex(){return this._structArray.uint16[this._pos2+13]}get iconBoxEndIndex(){return this._structArray.uint16[this._pos2+14]}get verticalIconBoxStartIndex(){return this._structArray.uint16[this._pos2+15]}get verticalIconBoxEndIndex(){return this._structArray.uint16[this._pos2+16]}get featureIndex(){return this._structArray.uint16[this._pos2+17]}get numHorizontalGlyphVertices(){return this._structArray.uint16[this._pos2+18]}get numVerticalGlyphVertices(){return this._structArray.uint16[this._pos2+19]}get numIconVertices(){return this._structArray.uint16[this._pos2+20]}get numVerticalIconVertices(){return this._structArray.uint16[this._pos2+21]}get useRuntimeCollisionCircles(){return this._structArray.uint16[this._pos2+22]}get crossTileID(){return this._structArray.uint32[this._pos4+12]}set crossTileID(t){this._structArray.uint32[this._pos4+12]=t}get textBoxScale(){return this._structArray.float32[this._pos4+13]}get collisionCircleDiameter(){return this._structArray.float32[this._pos4+14]}get textAnchorOffsetStartIndex(){return this._structArray.uint16[this._pos2+30]}get textAnchorOffsetEndIndex(){return this._structArray.uint16[this._pos2+31]}};go.prototype.size=64;var Dn=class extends Cn{get(t){return new go(this,t)}};C("SymbolInstanceArray",Dn);var Vn=class extends Zt{getoffsetX(t){return this.float32[t*1+0]}};C("GlyphOffsetArray",Vn);var Bn=class extends dn{getx(t){return this.int16[t*3+0]}gety(t){return this.int16[t*3+1]}gettileUnitDistanceFromAnchor(t){return this.int16[t*3+2]}};C("SymbolLineVertexArray",Bn);var xo=class extends Pt{get textAnchor(){return this._structArray.uint16[this._pos2+0]}get textOffset0(){return this._structArray.float32[this._pos4+1]}get textOffset1(){return this._structArray.float32[this._pos4+2]}};xo.prototype.size=12;var zn=class extends kn{get(t){return new xo(this,t)}};C("TextAnchorOffsetArray",zn);var bo=class extends Pt{get featureIndex(){return this._structArray.uint32[this._pos4+0]}get sourceLayerIndex(){return this._structArray.uint16[this._pos2+2]}get bucketIndex(){return this._structArray.uint16[this._pos2+3]}};bo.prototype.size=8;var Rn=class extends Mn{get(t){return new bo(this,t)}};C("FeatureIndexArray",Rn);var vo=class extends Jt{};var Po=class extends Jt{},So=class extends Jt{},wo=class extends gn{};var Ao=class extends xn{},_o=class extends St{},ut=class extends bn{},Io=class extends vn{},To=class extends Pn{},Co=class extends Sn{},On=class extends An{};var ko=class extends _n{};var Le=class extends In{},wt=class extends En{};var ad=Y([{name:"a_pos",components:2,type:"Int16"}],4);var{members:wc,size:Fv,alignment:Lv}=ad;var me=class e{constructor(t=[]){this.segments=t}prepareSegment(t,r,n,i){let o=this.segments[this.segments.length-1];return t>e.MAX_VERTEX_ARRAY_LENGTH&&fe("Max vertices per segment is ".concat(e.MAX_VERTEX_ARRAY_LENGTH,": bucket requested ").concat(t)),(!o||o.vertexLength+t>e.MAX_VERTEX_ARRAY_LENGTH||o.sortKey!==i)&&(o={vertexOffset:r.length,primitiveOffset:n.length,vertexLength:0,primitiveLength:0},i!==void 0&&(o.sortKey=i),this.segments.push(o)),o}get(){return this.segments}destroy(){for(let t of this.segments)for(let r in t.vaos)t.vaos[r].destroy()}static simpleSegment(t,r,n,i){return new e([{vertexOffset:t,primitiveOffset:r,vertexLength:n,primitiveLength:i,vaos:{},sortKey:0}])}};me.MAX_VERTEX_ARRAY_LENGTH=Math.pow(2,16)-1;C("SegmentVector",me);function ws(e,t){return e=it(Math.floor(e),0,255),t=it(Math.floor(t),0,255),256*e+t}var Nn=Y([{name:"a_pattern_from",components:4,type:"Uint16"},{name:"a_pattern_to",components:4,type:"Uint16"},{name:"a_pixel_ratio_from",components:1,type:"Uint16"},{name:"a_pixel_ratio_to",components:1,type:"Uint16"}]);var Cc=Z(Is(),1);var Un=class e{constructor(){this.ids=[],this.positions=[],this.indexed=!1}add(t,r,n,i){this.ids.push(Tc(t)),this.positions.push(r,n,i)}getPositions(t){if(!this.indexed)throw new Error("Trying to get index, but feature positions are not indexed");let r=Tc(t),n=0,i=this.ids.length-1;for(;n<i;){let a=n+i>>1;this.ids[a]>=r?i=a:n=a+1}let o=[];for(;this.ids[n]===r;){let a=this.positions[3*n],s=this.positions[3*n+1],l=this.positions[3*n+2];o.push({index:a,start:s,end:l}),n++}return o}static serialize(t,r){let n=new Float64Array(t.ids),i=new Uint32Array(t.positions);return Ts(n,i,0,n.length-1),r&&r.push(n.buffer,i.buffer),{ids:n,positions:i}}static deserialize(t){let r=new e;return r.ids=t.ids,r.positions=t.positions,r.indexed=!0,r}};function Tc(e){let t=+e;return!isNaN(t)&&t<=Number.MAX_SAFE_INTEGER?t:(0,Cc.default)(String(e))}function Ts(e,t,r,n){for(;r<n;){let i=e[r+n>>1],o=r-1,a=n+1;for(;;){do o++;while(e[o]<i);do a--;while(e[a]>i);if(o>=a)break;Eo(e,o,a),Eo(t,3*o,3*a),Eo(t,3*o+1,3*a+1),Eo(t,3*o+2,3*a+2)}a-r<n-a?(Ts(e,t,r,a),r=a+1):(Ts(e,t,a+1,n),n=a)}}function Eo(e,t,r){let n=e[t];e[t]=e[r],e[r]=n}C("FeaturePositionMap",Un);var $n=class{constructor(t,r){this.gl=t.gl,this.location=r}};var Sr=class extends $n{constructor(t,r){super(t,r),this.current=0}set(t){this.current!==t&&(this.current=t,this.gl.uniform1f(this.location,t))}};var Fo=class extends $n{constructor(t,r){super(t,r),this.current=[0,0,0,0]}set(t){(t[0]!==this.current[0]||t[1]!==this.current[1]||t[2]!==this.current[2]||t[3]!==this.current[3])&&(this.current=t,this.gl.uniform4f(this.location,t[0],t[1],t[2],t[3]))}},Lo=class extends $n{constructor(t,r){super(t,r),this.current=W.transparent}set(t){(t.r!==this.current.r||t.g!==this.current.g||t.b!==this.current.b||t.a!==this.current.a)&&(this.current=t,this.gl.uniform4f(this.location,t.r,t.g,t.b,t.a))}},Wv=new Float32Array(16);function Cs(e){return[ws(255*e.r,255*e.g),ws(255*e.b,255*e.a)]}var Wt=class{constructor(t,r,n){this.value=t,this.uniformNames=r.map(i=>"u_".concat(i)),this.type=n}setUniform(t,r,n){t.set(n.constantOr(this.value))}getBinding(t,r,n){return this.type==="color"?new Lo(t,r):new Sr(t,r)}},At=class{constructor(t,r){this.uniformNames=r.map(n=>"u_".concat(n)),this.patternFrom=null,this.patternTo=null,this.pixelRatioFrom=1,this.pixelRatioTo=1}setConstantPatternPositions(t,r){this.pixelRatioFrom=r.pixelRatio,this.pixelRatioTo=t.pixelRatio,this.patternFrom=r.tlbr,this.patternTo=t.tlbr}setUniform(t,r,n,i){let o=i==="u_pattern_to"?this.patternTo:i==="u_pattern_from"?this.patternFrom:i==="u_pixel_ratio_to"?this.pixelRatioTo:i==="u_pixel_ratio_from"?this.pixelRatioFrom:null;o&&t.set(o)}getBinding(t,r,n){return n.substr(0,9)==="u_pattern"?new Fo(t,r):new Sr(t,r)}},We=class{constructor(t,r,n,i){this.expression=t,this.type=n,this.maxValue=0,this.paintVertexAttributes=r.map(o=>({name:"a_".concat(o),type:"Float32",components:n==="color"?2:1,offset:0})),this.paintVertexArray=new i}populatePaintArray(t,r,n,i,o){let a=this.paintVertexArray.length,s=this.expression.evaluate(new q(0),r,{},i,[],o);this.paintVertexArray.resize(t),this._setPaintValue(a,t,s)}updatePaintArray(t,r,n,i){let o=this.expression.evaluate({zoom:0},n,i);this._setPaintValue(t,r,o)}_setPaintValue(t,r,n){if(this.type==="color"){let i=Cs(n);for(let o=t;o<r;o++)this.paintVertexArray.emplace(o,i[0],i[1])}else{for(let i=t;i<r;i++)this.paintVertexArray.emplace(i,n);this.maxValue=Math.max(this.maxValue,Math.abs(n))}}upload(t){this.paintVertexArray&&this.paintVertexArray.arrayBuffer&&(this.paintVertexBuffer&&this.paintVertexBuffer.buffer?this.paintVertexBuffer.updateData(this.paintVertexArray):this.paintVertexBuffer=t.createVertexBuffer(this.paintVertexArray,this.paintVertexAttributes,this.expression.isStateDependent))}destroy(){this.paintVertexBuffer&&this.paintVertexBuffer.destroy()}},De=class{constructor(t,r,n,i,o,a){this.expression=t,this.uniformNames=r.map(s=>"u_".concat(s,"_t")),this.type=n,this.useIntegerZoom=i,this.zoom=o,this.maxValue=0,this.paintVertexAttributes=r.map(s=>({name:"a_".concat(s),type:"Float32",components:n==="color"?4:2,offset:0})),this.paintVertexArray=new a}populatePaintArray(t,r,n,i,o){let a=this.expression.evaluate(new q(this.zoom),r,{},i,[],o),s=this.expression.evaluate(new q(this.zoom+1),r,{},i,[],o),l=this.paintVertexArray.length;this.paintVertexArray.resize(t),this._setPaintValue(l,t,a,s)}updatePaintArray(t,r,n,i){let o=this.expression.evaluate({zoom:this.zoom},n,i),a=this.expression.evaluate({zoom:this.zoom+1},n,i);this._setPaintValue(t,r,o,a)}_setPaintValue(t,r,n,i){if(this.type==="color"){let o=Cs(n),a=Cs(i);for(let s=t;s<r;s++)this.paintVertexArray.emplace(s,o[0],o[1],a[0],a[1])}else{for(let o=t;o<r;o++)this.paintVertexArray.emplace(o,n,i);this.maxValue=Math.max(this.maxValue,Math.abs(n),Math.abs(i))}}upload(t){this.paintVertexArray&&this.paintVertexArray.arrayBuffer&&(this.paintVertexBuffer&&this.paintVertexBuffer.buffer?this.paintVertexBuffer.updateData(this.paintVertexArray):this.paintVertexBuffer=t.createVertexBuffer(this.paintVertexArray,this.paintVertexAttributes,this.expression.isStateDependent))}destroy(){this.paintVertexBuffer&&this.paintVertexBuffer.destroy()}setUniform(t,r){let n=this.useIntegerZoom?Math.floor(r.zoom):r.zoom,i=it(this.expression.interpolationFactor(n,this.zoom,this.zoom+1),0,1);t.set(i)}getBinding(t,r,n){return new Sr(t,r)}},et=class{constructor(t,r,n,i,o,a){this.expression=t,this.type=r,this.useIntegerZoom=n,this.zoom=i,this.layerId=a,this.zoomInPaintVertexArray=new o,this.zoomOutPaintVertexArray=new o}populatePaintArray(t,r,n){let i=this.zoomInPaintVertexArray.length;this.zoomInPaintVertexArray.resize(t),this.zoomOutPaintVertexArray.resize(t),this._setPaintValues(i,t,r.patterns&&r.patterns[this.layerId],n)}updatePaintArray(t,r,n,i,o){this._setPaintValues(t,r,n.patterns&&n.patterns[this.layerId],o)}_setPaintValues(t,r,n,i){if(!i||!n)return;let{min:o,mid:a,max:s}=n,l=i[o],u=i[a],c=i[s];if(!(!l||!u||!c))for(let p=t;p<r;p++)this.zoomInPaintVertexArray.emplace(p,u.tl[0],u.tl[1],u.br[0],u.br[1],l.tl[0],l.tl[1],l.br[0],l.br[1],u.pixelRatio,l.pixelRatio),this.zoomOutPaintVertexArray.emplace(p,u.tl[0],u.tl[1],u.br[0],u.br[1],c.tl[0],c.tl[1],c.br[0],c.br[1],u.pixelRatio,c.pixelRatio)}upload(t){this.zoomInPaintVertexArray&&this.zoomInPaintVertexArray.arrayBuffer&&this.zoomOutPaintVertexArray&&this.zoomOutPaintVertexArray.arrayBuffer&&(this.zoomInPaintVertexBuffer=t.createVertexBuffer(this.zoomInPaintVertexArray,Nn.members,this.expression.isStateDependent),this.zoomOutPaintVertexBuffer=t.createVertexBuffer(this.zoomOutPaintVertexArray,Nn.members,this.expression.isStateDependent))}destroy(){this.zoomOutPaintVertexBuffer&&this.zoomOutPaintVertexBuffer.destroy(),this.zoomInPaintVertexBuffer&&this.zoomInPaintVertexBuffer.destroy()}},Do=class{constructor(t,r,n){this.binders={},this._buffers=[];let i=[];for(let o in t.paint._values){if(!n(o))continue;let a=t.paint.get(o);if(!(a instanceof Se)||!ht(a.property.specification))continue;let s=cd(o,t.type),l=a.value,u=a.property.specification.type,c=a.property.useIntegerZoom,p=a.property.specification["property-type"],f=p==="cross-faded"||p==="cross-faded-data-driven";if(l.kind==="constant")this.binders[o]=f?new At(l.value,s):new Wt(l.value,s,u),i.push("/u_".concat(o));else if(l.kind==="source"||f){let y=kc(o,u,"source");this.binders[o]=f?new et(l,u,c,r,y,t.id):new We(l,s,u,y),i.push("/a_".concat(o))}else{let y=kc(o,u,"composite");this.binders[o]=new De(l,s,u,c,r,y),i.push("/z_".concat(o))}}this.cacheKey=i.sort().join("")}getMaxValue(t){let r=this.binders[t];return r instanceof We||r instanceof De?r.maxValue:0}populatePaintArrays(t,r,n,i,o){for(let a in this.binders){let s=this.binders[a];(s instanceof We||s instanceof De||s instanceof et)&&s.populatePaintArray(t,r,n,i,o)}}setConstantPatternPositions(t,r){for(let n in this.binders){let i=this.binders[n];i instanceof At&&i.setConstantPatternPositions(t,r)}}updatePaintArrays(t,r,n,i,o){let a=!1;for(let s in t){let l=r.getPositions(s);for(let u of l){let c=n.feature(u.index);for(let p in this.binders){let f=this.binders[p];if((f instanceof We||f instanceof De||f instanceof et)&&f.expression.isStateDependent===!0){let y=i.paint.get(p);f.expression=y.value,f.updatePaintArray(u.start,u.end,c,t[s],o),a=!0}}}}return a}defines(){let t=[];for(let r in this.binders){let n=this.binders[r];(n instanceof Wt||n instanceof At)&&t.push(...n.uniformNames.map(i=>"#define HAS_UNIFORM_".concat(i)))}return t}getBinderAttributes(){let t=[];for(let r in this.binders){let n=this.binders[r];if(n instanceof We||n instanceof De)for(let i=0;i<n.paintVertexAttributes.length;i++)t.push(n.paintVertexAttributes[i].name);else if(n instanceof et)for(let i=0;i<Nn.members.length;i++)t.push(Nn.members[i].name)}return t}getBinderUniforms(){let t=[];for(let r in this.binders){let n=this.binders[r];if(n instanceof Wt||n instanceof At||n instanceof De)for(let i of n.uniformNames)t.push(i)}return t}getPaintVertexBuffers(){return this._buffers}getUniforms(t,r){let n=[];for(let i in this.binders){let o=this.binders[i];if(o instanceof Wt||o instanceof At||o instanceof De){for(let a of o.uniformNames)if(r[a]){let s=o.getBinding(t,r[a],a);n.push({name:a,property:i,binding:s})}}}return n}setUniforms(t,r,n,i){for(let{name:o,property:a,binding:s}of r)this.binders[a].setUniform(s,i,n.get(a),o)}updatePaintBuffers(t){this._buffers=[];for(let r in this.binders){let n=this.binders[r];if(t&&n instanceof et){let i=t.fromScale===2?n.zoomInPaintVertexBuffer:n.zoomOutPaintVertexBuffer;i&&this._buffers.push(i)}else(n instanceof We||n instanceof De)&&n.paintVertexBuffer&&this._buffers.push(n.paintVertexBuffer)}}upload(t){for(let r in this.binders){let n=this.binders[r];(n instanceof We||n instanceof De||n instanceof et)&&n.upload(t)}this.updatePaintBuffers()}destroy(){for(let t in this.binders){let r=this.binders[t];(r instanceof We||r instanceof De||r instanceof et)&&r.destroy()}}},Ce=class{constructor(t,r,n=()=>!0){this.programConfigurations={};for(let i of t)this.programConfigurations[i.id]=new Do(i,r,n);this.needsUpload=!1,this._featureMap=new Un,this._bufferOffset=0}populatePaintArrays(t,r,n,i,o,a){for(let s in this.programConfigurations)this.programConfigurations[s].populatePaintArrays(t,r,i,o,a);r.id!==void 0&&this._featureMap.add(r.id,n,this._bufferOffset,t),this._bufferOffset=t,this.needsUpload=!0}updatePaintArrays(t,r,n,i){for(let o of n)this.needsUpload=this.programConfigurations[o.id].updatePaintArrays(t,this._featureMap,r,o,i)||this.needsUpload}get(t){return this.programConfigurations[t]}upload(t){if(this.needsUpload){for(let r in this.programConfigurations)this.programConfigurations[r].upload(t);this.needsUpload=!1}}destroy(){for(let t in this.programConfigurations)this.programConfigurations[t].destroy()}};function cd(e,t){return{"text-opacity":["opacity"],"icon-opacity":["opacity"],"text-color":["fill_color"],"icon-color":["fill_color"],"text-halo-color":["halo_color"],"icon-halo-color":["halo_color"],"text-halo-blur":["halo_blur"],"icon-halo-blur":["halo_blur"],"text-halo-width":["halo_width"],"icon-halo-width":["halo_width"],"line-gap-width":["gapwidth"],"line-pattern":["pattern_to","pattern_from","pixel_ratio_to","pixel_ratio_from"],"fill-pattern":["pattern_to","pattern_from","pixel_ratio_to","pixel_ratio_from"],"fill-extrusion-pattern":["pattern_to","pattern_from","pixel_ratio_to","pixel_ratio_from"]}[e]||[e.replace("".concat(t,"-"),"").replace(/-/g,"_")]}function pd(e){return{"line-pattern":{source:ut,composite:ut},"fill-pattern":{source:ut,composite:ut},"fill-extrusion-pattern":{source:ut,composite:ut}}[e]}function kc(e,t,r){let n={color:{source:St,composite:Pr},number:{source:Zt,composite:St}},i=pd(e);return i&&i[r]||n[t][r]}C("ConstantBinder",Wt);C("CrossFadedConstantBinder",At);C("SourceExpressionBinder",We);C("CrossFadedCompositeBinder",et);C("CompositeExpressionBinder",De);C("ProgramConfiguration",Do,{omit:["_buffers"]});C("ProgramConfigurationSet",Ce);var fd=15,ks=Math.pow(2,fd-1)-1,Mc=-ks-1;function ke(e){let t=8192/e.extent,r=e.loadGeometry();for(let n=0;n<r.length;n++){let i=r[n];for(let o=0;o<i.length;o++){let a=i[o],s=Math.round(a.x*t),l=Math.round(a.y*t);a.x=it(s,Mc,ks),a.y=it(l,Mc,ks),(s<a.x||s>a.x+1||l<a.y||l>a.y+1)&&fe("Geometry exceeds allowed extent, reduce your vector tile buffer size")}}return r}function $e(e,t){return{type:e.type,id:e.id,properties:e.properties,geometry:t?ke(e):[]}}function Vo(e,t,r,n,i){e.emplaceBack(t*2+(n+1)/2,r*2+(i+1)/2)}var Ht=class{constructor(t){this.zoom=t.zoom,this.overscaling=t.overscaling,this.layers=t.layers,this.layerIds=this.layers.map(r=>r.id),this.index=t.index,this.hasPattern=!1,this.layoutVertexArray=new Po,this.indexArray=new Le,this.segments=new me,this.programConfigurations=new Ce(t.layers,t.zoom),this.stateDependentLayerIds=this.layers.filter(r=>r.isStateDependent()).map(r=>r.id)}populate(t,r,n){let i=this.layers[0],o=[],a=null,s=!1;i.type==="circle"&&(a=i.layout.get("circle-sort-key"),s=!a.isConstant());for(let{feature:l,id:u,index:c,sourceLayerIndex:p}of t){let f=this.layers[0]._featureFilter.needGeometry,y=$e(l,f);if(!this.layers[0]._featureFilter.filter(new q(this.zoom),y,n))continue;let m=s?a.evaluate(y,{},n):void 0,h={id:u,properties:l.properties,type:l.type,sourceLayerIndex:p,index:c,geometry:f?y.geometry:ke(l),patterns:{},sortKey:m};o.push(h)}s&&o.sort((l,u)=>l.sortKey-u.sortKey);for(let l of o){let{geometry:u,index:c,sourceLayerIndex:p}=l,f=t[c].feature;this.addFeature(l,u,c,n),r.featureIndex.insert(f,u,c,p,this.index)}}update(t,r,n){this.stateDependentLayers.length&&this.programConfigurations.updatePaintArrays(t,r,this.stateDependentLayers,n)}isEmpty(){return this.layoutVertexArray.length===0}uploadPending(){return!this.uploaded||this.programConfigurations.needsUpload}upload(t){this.uploaded||(this.layoutVertexBuffer=t.createVertexBuffer(this.layoutVertexArray,wc),this.indexBuffer=t.createIndexBuffer(this.indexArray)),this.programConfigurations.upload(t),this.uploaded=!0}destroy(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.programConfigurations.destroy(),this.segments.destroy())}addFeature(t,r,n,i){for(let o of r)for(let a of o){let s=a.x,l=a.y;if(s<0||s>=8192||l<0||l>=8192)continue;let u=this.segments.prepareSegment(4,this.layoutVertexArray,this.indexArray,t.sortKey),c=u.vertexLength;Vo(this.layoutVertexArray,s,l,-1,-1),Vo(this.layoutVertexArray,s,l,1,-1),Vo(this.layoutVertexArray,s,l,1,1),Vo(this.layoutVertexArray,s,l,-1,1),this.indexArray.emplaceBack(c,c+1,c+2),this.indexArray.emplaceBack(c,c+3,c+2),u.vertexLength+=4,u.primitiveLength+=2}this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length,t,n,{},i)}};C("CircleBucket",Ht,{omit:["layers"]});var Gn=Z(he(),1);function Fc(e,t){for(let r=0;r<e.length;r++)if(wr(t,e[r]))return!0;for(let r=0;r<t.length;r++)if(wr(e,t[r]))return!0;return!!Es(e,t)}function Lc(e,t,r){return!!(wr(e,t)||Ms(t,e,r))}function Bo(e,t){if(e.length===1)return Ec(t,e[0]);for(let r=0;r<t.length;r++){let n=t[r];for(let i=0;i<n.length;i++)if(wr(e,n[i]))return!0}for(let r=0;r<e.length;r++)if(Ec(t,e[r]))return!0;for(let r=0;r<t.length;r++)if(Es(e,t[r]))return!0;return!1}function Dc(e,t,r){for(let n=0;n<t.length;n++){let i=t[n];if(e.length>=3){for(let o=0;o<i.length;o++)if(wr(e,i[o]))return!0}if(yd(e,i,r))return!0}return!1}function yd(e,t,r){if(e.length>1){if(Es(e,t))return!0;for(let n=0;n<t.length;n++)if(Ms(t[n],e,r))return!0}for(let n=0;n<e.length;n++)if(Ms(e[n],t,r))return!0;return!1}function Es(e,t){if(e.length===0||t.length===0)return!1;for(let r=0;r<e.length-1;r++){let n=e[r],i=e[r+1];for(let o=0;o<t.length-1;o++){let a=t[o],s=t[o+1];if(md(n,i,a,s))return!0}}return!1}function md(e,t,r,n){return ot(e,r,n)!==ot(t,r,n)&&ot(e,t,r)!==ot(e,t,n)}function Ms(e,t,r){let n=r*r;if(t.length===1)return e.distSqr(t[0])<n;for(let i=1;i<t.length;i++){let o=t[i-1],a=t[i];if(Fs(e,o,a)<n)return!0}return!1}function Fs(e,t,r){let n=t.distSqr(r);if(n===0)return e.distSqr(t);let i=((e.x-t.x)*(r.x-t.x)+(e.y-t.y)*(r.y-t.y))/n;return i<0?e.distSqr(t):i>1?e.distSqr(r):e.distSqr(r.sub(t)._mult(i)._add(t))}function Ec(e,t){let r=!1,n,i,o;for(let a=0;a<e.length;a++){n=e[a];for(let s=0,l=n.length-1;s<n.length;l=s++)i=n[s],o=n[l],i.y>t.y!=o.y>t.y&&t.x<(o.x-i.x)*(t.y-i.y)/(o.y-i.y)+i.x&&(r=!r)}return r}function wr(e,t){let r=!1;for(let n=0,i=e.length-1;n<e.length;i=n++){let o=e[n],a=e[i];o.y>t.y!=a.y>t.y&&t.x<(a.x-o.x)*(t.y-o.y)/(a.y-o.y)+o.x&&(r=!r)}return r}function Vc(e,t,r,n,i){for(let a of e)if(t<=a.x&&r<=a.y&&n>=a.x&&i>=a.y)return!0;let o=[new Gn.default(t,r),new Gn.default(t,i),new Gn.default(n,i),new Gn.default(n,r)];if(e.length>2){for(let a of o)if(wr(e,a))return!0}for(let a=0;a<e.length-1;a++){let s=e[a],l=e[a+1];if(hd(s,l,o))return!0}return!1}function hd(e,t,r){let n=r[0],i=r[2];if(e.x<n.x&&t.x<n.x||e.x>i.x&&t.x>i.x||e.y<n.y&&t.y<n.y||e.y>i.y&&t.y>i.y)return!1;let o=ot(e,t,r[0]);return o!==ot(e,t,r[1])||o!==ot(e,t,r[2])||o!==ot(e,t,r[3])}var zo=Z(he(),1);function Xt(e,t,r){let n=t.paint.get(e).value;return n.kind==="constant"?n.value:r.programConfigurations.get(t.id).getMaxValue(e)}function _t(e){return Math.sqrt(e[0]*e[0]+e[1]*e[1])}function It(e,t,r,n,i){if(!t[0]&&!t[1])return e;let o=zo.default.convert(t)._mult(i);r==="viewport"&&o._rotate(-n);let a=[];for(let s=0;s<e.length;s++){let l=e[s];a.push(l.sub(o))}return a}function Bc(e,t){let r=[];for(let n=0;n<e.length;n++){let i=e[n],o=[];for(let a=0;a<i.length;a++){let s=i[a-1],l=i[a],u=i[a+1],c=a===0?new zo.default(0,0):l.sub(s)._unit()._perp(),p=a===i.length-1?new zo.default(0,0):u.sub(l)._unit()._perp(),f=c._add(p)._unit(),y=f.x*p.x+f.y*p.y;y!==0&&f._mult(1/y),o.push(f._mult(t)._add(l))}r.push(o)}return r}var zc,dd=()=>zc=zc||new re({"circle-sort-key":new R(S.layout_circle["circle-sort-key"])}),Rc,gd=()=>Rc=Rc||new re({"circle-radius":new R(S.paint_circle["circle-radius"]),"circle-color":new R(S.paint_circle["circle-color"]),"circle-blur":new R(S.paint_circle["circle-blur"]),"circle-opacity":new R(S.paint_circle["circle-opacity"]),"circle-translate":new B(S.paint_circle["circle-translate"]),"circle-translate-anchor":new B(S.paint_circle["circle-translate-anchor"]),"circle-pitch-scale":new B(S.paint_circle["circle-pitch-scale"]),"circle-pitch-alignment":new B(S.paint_circle["circle-pitch-alignment"]),"circle-stroke-width":new R(S.paint_circle["circle-stroke-width"]),"circle-stroke-color":new R(S.paint_circle["circle-stroke-color"]),"circle-stroke-opacity":new R(S.paint_circle["circle-stroke-opacity"])}),Oc={get paint(){return gd()},get layout(){return dd()}};var Q=1e-6,Ge=typeof Float32Array<"u"?Float32Array:Array,qn=Math.random;var N1=Math.PI/180;Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)});var jn={};Ll(jn,{add:()=>tg,adjoint:()=>_d,clone:()=>bd,copy:()=>vd,create:()=>xd,determinant:()=>Id,equals:()=>og,exactEquals:()=>ig,frob:()=>eg,fromQuat:()=>qd,fromQuat2:()=>Od,fromRotation:()=>Vd,fromRotationTranslation:()=>Gc,fromRotationTranslationScale:()=>$d,fromRotationTranslationScaleOrigin:()=>Gd,fromScaling:()=>Dd,fromTranslation:()=>Ld,fromValues:()=>Pd,fromXRotation:()=>Bd,fromYRotation:()=>zd,fromZRotation:()=>Rd,frustum:()=>jd,getRotation:()=>Ud,getScaling:()=>qc,getTranslation:()=>Nd,identity:()=>Uc,invert:()=>Ad,lookAt:()=>Kd,mul:()=>ag,multiply:()=>$c,multiplyScalar:()=>rg,multiplyScalarAndAdd:()=>ng,ortho:()=>Hd,orthoNO:()=>Jc,orthoZO:()=>Xd,perspective:()=>Jd,perspectiveFromFieldOfView:()=>Wd,perspectiveNO:()=>jc,perspectiveZO:()=>Zd,rotate:()=>kd,rotateX:()=>Md,rotateY:()=>Ed,rotateZ:()=>Fd,scale:()=>Cd,set:()=>Sd,str:()=>Qd,sub:()=>sg,subtract:()=>Zc,targetTo:()=>Yd,translate:()=>Td,transpose:()=>wd});function xd(){var e=new Ge(16);return Ge!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function bd(e){var t=new Ge(16);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}function vd(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function Pd(e,t,r,n,i,o,a,s,l,u,c,p,f,y,m,h){var d=new Ge(16);return d[0]=e,d[1]=t,d[2]=r,d[3]=n,d[4]=i,d[5]=o,d[6]=a,d[7]=s,d[8]=l,d[9]=u,d[10]=c,d[11]=p,d[12]=f,d[13]=y,d[14]=m,d[15]=h,d}function Sd(e,t,r,n,i,o,a,s,l,u,c,p,f,y,m,h,d){return e[0]=t,e[1]=r,e[2]=n,e[3]=i,e[4]=o,e[5]=a,e[6]=s,e[7]=l,e[8]=u,e[9]=c,e[10]=p,e[11]=f,e[12]=y,e[13]=m,e[14]=h,e[15]=d,e}function Uc(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function wd(e,t){if(e===t){var r=t[1],n=t[2],i=t[3],o=t[6],a=t[7],s=t[11];e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=r,e[6]=t[9],e[7]=t[13],e[8]=n,e[9]=o,e[11]=t[14],e[12]=i,e[13]=a,e[14]=s}else e[0]=t[0],e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=t[1],e[5]=t[5],e[6]=t[9],e[7]=t[13],e[8]=t[2],e[9]=t[6],e[10]=t[10],e[11]=t[14],e[12]=t[3],e[13]=t[7],e[14]=t[11],e[15]=t[15];return e}function Ad(e,t){var r=t[0],n=t[1],i=t[2],o=t[3],a=t[4],s=t[5],l=t[6],u=t[7],c=t[8],p=t[9],f=t[10],y=t[11],m=t[12],h=t[13],d=t[14],g=t[15],b=r*s-n*a,x=r*l-i*a,v=r*u-o*a,P=n*l-i*s,w=n*u-o*s,T=i*u-o*l,F=c*h-p*m,E=c*d-f*m,_=c*g-y*m,I=p*d-f*h,k=p*g-y*h,V=f*g-y*d,A=b*V-x*k+v*I+P*_-w*E+T*F;return A?(A=1/A,e[0]=(s*V-l*k+u*I)*A,e[1]=(i*k-n*V-o*I)*A,e[2]=(h*T-d*w+g*P)*A,e[3]=(f*w-p*T-y*P)*A,e[4]=(l*_-a*V-u*E)*A,e[5]=(r*V-i*_+o*E)*A,e[6]=(d*v-m*T-g*x)*A,e[7]=(c*T-f*v+y*x)*A,e[8]=(a*k-s*_+u*F)*A,e[9]=(n*_-r*k-o*F)*A,e[10]=(m*w-h*v+g*b)*A,e[11]=(p*v-c*w-y*b)*A,e[12]=(s*E-a*I-l*F)*A,e[13]=(r*I-n*E+i*F)*A,e[14]=(h*x-m*P-d*b)*A,e[15]=(c*P-p*x+f*b)*A,e):null}function _d(e,t){var r=t[0],n=t[1],i=t[2],o=t[3],a=t[4],s=t[5],l=t[6],u=t[7],c=t[8],p=t[9],f=t[10],y=t[11],m=t[12],h=t[13],d=t[14],g=t[15];return e[0]=s*(f*g-y*d)-p*(l*g-u*d)+h*(l*y-u*f),e[1]=-(n*(f*g-y*d)-p*(i*g-o*d)+h*(i*y-o*f)),e[2]=n*(l*g-u*d)-s*(i*g-o*d)+h*(i*u-o*l),e[3]=-(n*(l*y-u*f)-s*(i*y-o*f)+p*(i*u-o*l)),e[4]=-(a*(f*g-y*d)-c*(l*g-u*d)+m*(l*y-u*f)),e[5]=r*(f*g-y*d)-c*(i*g-o*d)+m*(i*y-o*f),e[6]=-(r*(l*g-u*d)-a*(i*g-o*d)+m*(i*u-o*l)),e[7]=r*(l*y-u*f)-a*(i*y-o*f)+c*(i*u-o*l),e[8]=a*(p*g-y*h)-c*(s*g-u*h)+m*(s*y-u*p),e[9]=-(r*(p*g-y*h)-c*(n*g-o*h)+m*(n*y-o*p)),e[10]=r*(s*g-u*h)-a*(n*g-o*h)+m*(n*u-o*s),e[11]=-(r*(s*y-u*p)-a*(n*y-o*p)+c*(n*u-o*s)),e[12]=-(a*(p*d-f*h)-c*(s*d-l*h)+m*(s*f-l*p)),e[13]=r*(p*d-f*h)-c*(n*d-i*h)+m*(n*f-i*p),e[14]=-(r*(s*d-l*h)-a*(n*d-i*h)+m*(n*l-i*s)),e[15]=r*(s*f-l*p)-a*(n*f-i*p)+c*(n*l-i*s),e}function Id(e){var t=e[0],r=e[1],n=e[2],i=e[3],o=e[4],a=e[5],s=e[6],l=e[7],u=e[8],c=e[9],p=e[10],f=e[11],y=e[12],m=e[13],h=e[14],d=e[15],g=t*a-r*o,b=t*s-n*o,x=t*l-i*o,v=r*s-n*a,P=r*l-i*a,w=n*l-i*s,T=u*m-c*y,F=u*h-p*y,E=u*d-f*y,_=c*h-p*m,I=c*d-f*m,k=p*d-f*h;return g*k-b*I+x*_+v*E-P*F+w*T}function $c(e,t,r){var n=t[0],i=t[1],o=t[2],a=t[3],s=t[4],l=t[5],u=t[6],c=t[7],p=t[8],f=t[9],y=t[10],m=t[11],h=t[12],d=t[13],g=t[14],b=t[15],x=r[0],v=r[1],P=r[2],w=r[3];return e[0]=x*n+v*s+P*p+w*h,e[1]=x*i+v*l+P*f+w*d,e[2]=x*o+v*u+P*y+w*g,e[3]=x*a+v*c+P*m+w*b,x=r[4],v=r[5],P=r[6],w=r[7],e[4]=x*n+v*s+P*p+w*h,e[5]=x*i+v*l+P*f+w*d,e[6]=x*o+v*u+P*y+w*g,e[7]=x*a+v*c+P*m+w*b,x=r[8],v=r[9],P=r[10],w=r[11],e[8]=x*n+v*s+P*p+w*h,e[9]=x*i+v*l+P*f+w*d,e[10]=x*o+v*u+P*y+w*g,e[11]=x*a+v*c+P*m+w*b,x=r[12],v=r[13],P=r[14],w=r[15],e[12]=x*n+v*s+P*p+w*h,e[13]=x*i+v*l+P*f+w*d,e[14]=x*o+v*u+P*y+w*g,e[15]=x*a+v*c+P*m+w*b,e}function Td(e,t,r){var n=r[0],i=r[1],o=r[2],a,s,l,u,c,p,f,y,m,h,d,g;return t===e?(e[12]=t[0]*n+t[4]*i+t[8]*o+t[12],e[13]=t[1]*n+t[5]*i+t[9]*o+t[13],e[14]=t[2]*n+t[6]*i+t[10]*o+t[14],e[15]=t[3]*n+t[7]*i+t[11]*o+t[15]):(a=t[0],s=t[1],l=t[2],u=t[3],c=t[4],p=t[5],f=t[6],y=t[7],m=t[8],h=t[9],d=t[10],g=t[11],e[0]=a,e[1]=s,e[2]=l,e[3]=u,e[4]=c,e[5]=p,e[6]=f,e[7]=y,e[8]=m,e[9]=h,e[10]=d,e[11]=g,e[12]=a*n+c*i+m*o+t[12],e[13]=s*n+p*i+h*o+t[13],e[14]=l*n+f*i+d*o+t[14],e[15]=u*n+y*i+g*o+t[15]),e}function Cd(e,t,r){var n=r[0],i=r[1],o=r[2];return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*i,e[5]=t[5]*i,e[6]=t[6]*i,e[7]=t[7]*i,e[8]=t[8]*o,e[9]=t[9]*o,e[10]=t[10]*o,e[11]=t[11]*o,e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function kd(e,t,r,n){var i=n[0],o=n[1],a=n[2],s=Math.hypot(i,o,a),l,u,c,p,f,y,m,h,d,g,b,x,v,P,w,T,F,E,_,I,k,V,A,z;return s<Q?null:(s=1/s,i*=s,o*=s,a*=s,l=Math.sin(r),u=Math.cos(r),c=1-u,p=t[0],f=t[1],y=t[2],m=t[3],h=t[4],d=t[5],g=t[6],b=t[7],x=t[8],v=t[9],P=t[10],w=t[11],T=i*i*c+u,F=o*i*c+a*l,E=a*i*c-o*l,_=i*o*c-a*l,I=o*o*c+u,k=a*o*c+i*l,V=i*a*c+o*l,A=o*a*c-i*l,z=a*a*c+u,e[0]=p*T+h*F+x*E,e[1]=f*T+d*F+v*E,e[2]=y*T+g*F+P*E,e[3]=m*T+b*F+w*E,e[4]=p*_+h*I+x*k,e[5]=f*_+d*I+v*k,e[6]=y*_+g*I+P*k,e[7]=m*_+b*I+w*k,e[8]=p*V+h*A+x*z,e[9]=f*V+d*A+v*z,e[10]=y*V+g*A+P*z,e[11]=m*V+b*A+w*z,t!==e&&(e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e)}function Md(e,t,r){var n=Math.sin(r),i=Math.cos(r),o=t[4],a=t[5],s=t[6],l=t[7],u=t[8],c=t[9],p=t[10],f=t[11];return t!==e&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[4]=o*i+u*n,e[5]=a*i+c*n,e[6]=s*i+p*n,e[7]=l*i+f*n,e[8]=u*i-o*n,e[9]=c*i-a*n,e[10]=p*i-s*n,e[11]=f*i-l*n,e}function Ed(e,t,r){var n=Math.sin(r),i=Math.cos(r),o=t[0],a=t[1],s=t[2],l=t[3],u=t[8],c=t[9],p=t[10],f=t[11];return t!==e&&(e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=o*i-u*n,e[1]=a*i-c*n,e[2]=s*i-p*n,e[3]=l*i-f*n,e[8]=o*n+u*i,e[9]=a*n+c*i,e[10]=s*n+p*i,e[11]=l*n+f*i,e}function Fd(e,t,r){var n=Math.sin(r),i=Math.cos(r),o=t[0],a=t[1],s=t[2],l=t[3],u=t[4],c=t[5],p=t[6],f=t[7];return t!==e&&(e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=o*i+u*n,e[1]=a*i+c*n,e[2]=s*i+p*n,e[3]=l*i+f*n,e[4]=u*i-o*n,e[5]=c*i-a*n,e[6]=p*i-s*n,e[7]=f*i-l*n,e}function Ld(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=t[0],e[13]=t[1],e[14]=t[2],e[15]=1,e}function Dd(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=t[1],e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=t[2],e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function Vd(e,t,r){var n=r[0],i=r[1],o=r[2],a=Math.hypot(n,i,o),s,l,u;return a<Q?null:(a=1/a,n*=a,i*=a,o*=a,s=Math.sin(t),l=Math.cos(t),u=1-l,e[0]=n*n*u+l,e[1]=i*n*u+o*s,e[2]=o*n*u-i*s,e[3]=0,e[4]=n*i*u-o*s,e[5]=i*i*u+l,e[6]=o*i*u+n*s,e[7]=0,e[8]=n*o*u+i*s,e[9]=i*o*u-n*s,e[10]=o*o*u+l,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e)}function Bd(e,t){var r=Math.sin(t),n=Math.cos(t);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=n,e[6]=r,e[7]=0,e[8]=0,e[9]=-r,e[10]=n,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function zd(e,t){var r=Math.sin(t),n=Math.cos(t);return e[0]=n,e[1]=0,e[2]=-r,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=r,e[9]=0,e[10]=n,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function Rd(e,t){var r=Math.sin(t),n=Math.cos(t);return e[0]=n,e[1]=r,e[2]=0,e[3]=0,e[4]=-r,e[5]=n,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function Gc(e,t,r){var n=t[0],i=t[1],o=t[2],a=t[3],s=n+n,l=i+i,u=o+o,c=n*s,p=n*l,f=n*u,y=i*l,m=i*u,h=o*u,d=a*s,g=a*l,b=a*u;return e[0]=1-(y+h),e[1]=p+b,e[2]=f-g,e[3]=0,e[4]=p-b,e[5]=1-(c+h),e[6]=m+d,e[7]=0,e[8]=f+g,e[9]=m-d,e[10]=1-(c+y),e[11]=0,e[12]=r[0],e[13]=r[1],e[14]=r[2],e[15]=1,e}function Od(e,t){var r=new Ge(3),n=-t[0],i=-t[1],o=-t[2],a=t[3],s=t[4],l=t[5],u=t[6],c=t[7],p=n*n+i*i+o*o+a*a;return p>0?(r[0]=(s*a+c*n+l*o-u*i)*2/p,r[1]=(l*a+c*i+u*n-s*o)*2/p,r[2]=(u*a+c*o+s*i-l*n)*2/p):(r[0]=(s*a+c*n+l*o-u*i)*2,r[1]=(l*a+c*i+u*n-s*o)*2,r[2]=(u*a+c*o+s*i-l*n)*2),Gc(e,t,r),e}function Nd(e,t){return e[0]=t[12],e[1]=t[13],e[2]=t[14],e}function qc(e,t){var r=t[0],n=t[1],i=t[2],o=t[4],a=t[5],s=t[6],l=t[8],u=t[9],c=t[10];return e[0]=Math.hypot(r,n,i),e[1]=Math.hypot(o,a,s),e[2]=Math.hypot(l,u,c),e}function Ud(e,t){var r=new Ge(3);qc(r,t);var n=1/r[0],i=1/r[1],o=1/r[2],a=t[0]*n,s=t[1]*i,l=t[2]*o,u=t[4]*n,c=t[5]*i,p=t[6]*o,f=t[8]*n,y=t[9]*i,m=t[10]*o,h=a+c+m,d=0;return h>0?(d=Math.sqrt(h+1)*2,e[3]=.25*d,e[0]=(p-y)/d,e[1]=(f-l)/d,e[2]=(s-u)/d):a>c&&a>m?(d=Math.sqrt(1+a-c-m)*2,e[3]=(p-y)/d,e[0]=.25*d,e[1]=(s+u)/d,e[2]=(f+l)/d):c>m?(d=Math.sqrt(1+c-a-m)*2,e[3]=(f-l)/d,e[0]=(s+u)/d,e[1]=.25*d,e[2]=(p+y)/d):(d=Math.sqrt(1+m-a-c)*2,e[3]=(s-u)/d,e[0]=(f+l)/d,e[1]=(p+y)/d,e[2]=.25*d),e}function $d(e,t,r,n){var i=t[0],o=t[1],a=t[2],s=t[3],l=i+i,u=o+o,c=a+a,p=i*l,f=i*u,y=i*c,m=o*u,h=o*c,d=a*c,g=s*l,b=s*u,x=s*c,v=n[0],P=n[1],w=n[2];return e[0]=(1-(m+d))*v,e[1]=(f+x)*v,e[2]=(y-b)*v,e[3]=0,e[4]=(f-x)*P,e[5]=(1-(p+d))*P,e[6]=(h+g)*P,e[7]=0,e[8]=(y+b)*w,e[9]=(h-g)*w,e[10]=(1-(p+m))*w,e[11]=0,e[12]=r[0],e[13]=r[1],e[14]=r[2],e[15]=1,e}function Gd(e,t,r,n,i){var o=t[0],a=t[1],s=t[2],l=t[3],u=o+o,c=a+a,p=s+s,f=o*u,y=o*c,m=o*p,h=a*c,d=a*p,g=s*p,b=l*u,x=l*c,v=l*p,P=n[0],w=n[1],T=n[2],F=i[0],E=i[1],_=i[2],I=(1-(h+g))*P,k=(y+v)*P,V=(m-x)*P,A=(y-v)*w,z=(1-(f+g))*w,O=(d+b)*w,N=(m+x)*T,K=(d-b)*T,xe=(1-(f+h))*T;return e[0]=I,e[1]=k,e[2]=V,e[3]=0,e[4]=A,e[5]=z,e[6]=O,e[7]=0,e[8]=N,e[9]=K,e[10]=xe,e[11]=0,e[12]=r[0]+F-(I*F+A*E+N*_),e[13]=r[1]+E-(k*F+z*E+K*_),e[14]=r[2]+_-(V*F+O*E+xe*_),e[15]=1,e}function qd(e,t){var r=t[0],n=t[1],i=t[2],o=t[3],a=r+r,s=n+n,l=i+i,u=r*a,c=n*a,p=n*s,f=i*a,y=i*s,m=i*l,h=o*a,d=o*s,g=o*l;return e[0]=1-p-m,e[1]=c+g,e[2]=f-d,e[3]=0,e[4]=c-g,e[5]=1-u-m,e[6]=y+h,e[7]=0,e[8]=f+d,e[9]=y-h,e[10]=1-u-p,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function jd(e,t,r,n,i,o,a){var s=1/(r-t),l=1/(i-n),u=1/(o-a);return e[0]=o*2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=o*2*l,e[6]=0,e[7]=0,e[8]=(r+t)*s,e[9]=(i+n)*l,e[10]=(a+o)*u,e[11]=-1,e[12]=0,e[13]=0,e[14]=a*o*2*u,e[15]=0,e}function jc(e,t,r,n,i){var o=1/Math.tan(t/2),a;return e[0]=o/r,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=o,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,i!=null&&i!==1/0?(a=1/(n-i),e[10]=(i+n)*a,e[14]=2*i*n*a):(e[10]=-1,e[14]=-2*n),e}var Jd=jc;function Zd(e,t,r,n,i){var o=1/Math.tan(t/2),a;return e[0]=o/r,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=o,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,i!=null&&i!==1/0?(a=1/(n-i),e[10]=i*a,e[14]=i*n*a):(e[10]=-1,e[14]=-n),e}function Wd(e,t,r,n){var i=Math.tan(t.upDegrees*Math.PI/180),o=Math.tan(t.downDegrees*Math.PI/180),a=Math.tan(t.leftDegrees*Math.PI/180),s=Math.tan(t.rightDegrees*Math.PI/180),l=2/(a+s),u=2/(i+o);return e[0]=l,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=u,e[6]=0,e[7]=0,e[8]=-((a-s)*l*.5),e[9]=(i-o)*u*.5,e[10]=n/(r-n),e[11]=-1,e[12]=0,e[13]=0,e[14]=n*r/(r-n),e[15]=0,e}function Jc(e,t,r,n,i,o,a){var s=1/(t-r),l=1/(n-i),u=1/(o-a);return e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=2*u,e[11]=0,e[12]=(t+r)*s,e[13]=(i+n)*l,e[14]=(a+o)*u,e[15]=1,e}var Hd=Jc;function Xd(e,t,r,n,i,o,a){var s=1/(t-r),l=1/(n-i),u=1/(o-a);return e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=u,e[11]=0,e[12]=(t+r)*s,e[13]=(i+n)*l,e[14]=o*u,e[15]=1,e}function Kd(e,t,r,n){var i,o,a,s,l,u,c,p,f,y,m=t[0],h=t[1],d=t[2],g=n[0],b=n[1],x=n[2],v=r[0],P=r[1],w=r[2];return Math.abs(m-v)<Q&&Math.abs(h-P)<Q&&Math.abs(d-w)<Q?Uc(e):(c=m-v,p=h-P,f=d-w,y=1/Math.hypot(c,p,f),c*=y,p*=y,f*=y,i=b*f-x*p,o=x*c-g*f,a=g*p-b*c,y=Math.hypot(i,o,a),y?(y=1/y,i*=y,o*=y,a*=y):(i=0,o=0,a=0),s=p*a-f*o,l=f*i-c*a,u=c*o-p*i,y=Math.hypot(s,l,u),y?(y=1/y,s*=y,l*=y,u*=y):(s=0,l=0,u=0),e[0]=i,e[1]=s,e[2]=c,e[3]=0,e[4]=o,e[5]=l,e[6]=p,e[7]=0,e[8]=a,e[9]=u,e[10]=f,e[11]=0,e[12]=-(i*m+o*h+a*d),e[13]=-(s*m+l*h+u*d),e[14]=-(c*m+p*h+f*d),e[15]=1,e)}function Yd(e,t,r,n){var i=t[0],o=t[1],a=t[2],s=n[0],l=n[1],u=n[2],c=i-r[0],p=o-r[1],f=a-r[2],y=c*c+p*p+f*f;y>0&&(y=1/Math.sqrt(y),c*=y,p*=y,f*=y);var m=l*f-u*p,h=u*c-s*f,d=s*p-l*c;return y=m*m+h*h+d*d,y>0&&(y=1/Math.sqrt(y),m*=y,h*=y,d*=y),e[0]=m,e[1]=h,e[2]=d,e[3]=0,e[4]=p*d-f*h,e[5]=f*m-c*d,e[6]=c*h-p*m,e[7]=0,e[8]=c,e[9]=p,e[10]=f,e[11]=0,e[12]=i,e[13]=o,e[14]=a,e[15]=1,e}function Qd(e){return"mat4("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+", "+e[6]+", "+e[7]+", "+e[8]+", "+e[9]+", "+e[10]+", "+e[11]+", "+e[12]+", "+e[13]+", "+e[14]+", "+e[15]+")"}function eg(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8],e[9],e[10],e[11],e[12],e[13],e[14],e[15])}function tg(e,t,r){return e[0]=t[0]+r[0],e[1]=t[1]+r[1],e[2]=t[2]+r[2],e[3]=t[3]+r[3],e[4]=t[4]+r[4],e[5]=t[5]+r[5],e[6]=t[6]+r[6],e[7]=t[7]+r[7],e[8]=t[8]+r[8],e[9]=t[9]+r[9],e[10]=t[10]+r[10],e[11]=t[11]+r[11],e[12]=t[12]+r[12],e[13]=t[13]+r[13],e[14]=t[14]+r[14],e[15]=t[15]+r[15],e}function Zc(e,t,r){return e[0]=t[0]-r[0],e[1]=t[1]-r[1],e[2]=t[2]-r[2],e[3]=t[3]-r[3],e[4]=t[4]-r[4],e[5]=t[5]-r[5],e[6]=t[6]-r[6],e[7]=t[7]-r[7],e[8]=t[8]-r[8],e[9]=t[9]-r[9],e[10]=t[10]-r[10],e[11]=t[11]-r[11],e[12]=t[12]-r[12],e[13]=t[13]-r[13],e[14]=t[14]-r[14],e[15]=t[15]-r[15],e}function rg(e,t,r){return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e[4]=t[4]*r,e[5]=t[5]*r,e[6]=t[6]*r,e[7]=t[7]*r,e[8]=t[8]*r,e[9]=t[9]*r,e[10]=t[10]*r,e[11]=t[11]*r,e[12]=t[12]*r,e[13]=t[13]*r,e[14]=t[14]*r,e[15]=t[15]*r,e}function ng(e,t,r,n){return e[0]=t[0]+r[0]*n,e[1]=t[1]+r[1]*n,e[2]=t[2]+r[2]*n,e[3]=t[3]+r[3]*n,e[4]=t[4]+r[4]*n,e[5]=t[5]+r[5]*n,e[6]=t[6]+r[6]*n,e[7]=t[7]+r[7]*n,e[8]=t[8]+r[8]*n,e[9]=t[9]+r[9]*n,e[10]=t[10]+r[10]*n,e[11]=t[11]+r[11]*n,e[12]=t[12]+r[12]*n,e[13]=t[13]+r[13]*n,e[14]=t[14]+r[14]*n,e[15]=t[15]+r[15]*n,e}function ig(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]&&e[9]===t[9]&&e[10]===t[10]&&e[11]===t[11]&&e[12]===t[12]&&e[13]===t[13]&&e[14]===t[14]&&e[15]===t[15]}function og(e,t){var r=e[0],n=e[1],i=e[2],o=e[3],a=e[4],s=e[5],l=e[6],u=e[7],c=e[8],p=e[9],f=e[10],y=e[11],m=e[12],h=e[13],d=e[14],g=e[15],b=t[0],x=t[1],v=t[2],P=t[3],w=t[4],T=t[5],F=t[6],E=t[7],_=t[8],I=t[9],k=t[10],V=t[11],A=t[12],z=t[13],O=t[14],N=t[15];return Math.abs(r-b)<=Q*Math.max(1,Math.abs(r),Math.abs(b))&&Math.abs(n-x)<=Q*Math.max(1,Math.abs(n),Math.abs(x))&&Math.abs(i-v)<=Q*Math.max(1,Math.abs(i),Math.abs(v))&&Math.abs(o-P)<=Q*Math.max(1,Math.abs(o),Math.abs(P))&&Math.abs(a-w)<=Q*Math.max(1,Math.abs(a),Math.abs(w))&&Math.abs(s-T)<=Q*Math.max(1,Math.abs(s),Math.abs(T))&&Math.abs(l-F)<=Q*Math.max(1,Math.abs(l),Math.abs(F))&&Math.abs(u-E)<=Q*Math.max(1,Math.abs(u),Math.abs(E))&&Math.abs(c-_)<=Q*Math.max(1,Math.abs(c),Math.abs(_))&&Math.abs(p-I)<=Q*Math.max(1,Math.abs(p),Math.abs(I))&&Math.abs(f-k)<=Q*Math.max(1,Math.abs(f),Math.abs(k))&&Math.abs(y-V)<=Q*Math.max(1,Math.abs(y),Math.abs(V))&&Math.abs(m-A)<=Q*Math.max(1,Math.abs(m),Math.abs(A))&&Math.abs(h-z)<=Q*Math.max(1,Math.abs(h),Math.abs(z))&&Math.abs(d-O)<=Q*Math.max(1,Math.abs(d),Math.abs(O))&&Math.abs(g-N)<=Q*Math.max(1,Math.abs(g),Math.abs(N))}var ag=$c,sg=Zc;var Kt={};Ll(Kt,{add:()=>fg,ceil:()=>yg,clone:()=>lg,copy:()=>cg,create:()=>Wc,cross:()=>Ag,dist:()=>Bg,distance:()=>Yc,div:()=>Vg,divide:()=>Kc,dot:()=>wg,equals:()=>Fg,exactEquals:()=>Eg,floor:()=>mg,forEach:()=>Ng,fromValues:()=>ug,inverse:()=>Pg,len:()=>Rg,length:()=>ep,lerp:()=>_g,max:()=>dg,min:()=>hg,mul:()=>Dg,multiply:()=>Xc,negate:()=>vg,normalize:()=>Sg,random:()=>Ig,round:()=>gg,scale:()=>xg,scaleAndAdd:()=>bg,set:()=>pg,sqrDist:()=>zg,sqrLen:()=>Og,squaredDistance:()=>Qc,squaredLength:()=>tp,str:()=>Mg,sub:()=>Lg,subtract:()=>Hc,transformMat4:()=>Tg,transformQuat:()=>Cg,zero:()=>kg});function Wc(){var e=new Ge(4);return Ge!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0,e[3]=0),e}function lg(e){var t=new Ge(4);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t}function ug(e,t,r,n){var i=new Ge(4);return i[0]=e,i[1]=t,i[2]=r,i[3]=n,i}function cg(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e}function pg(e,t,r,n,i){return e[0]=t,e[1]=r,e[2]=n,e[3]=i,e}function fg(e,t,r){return e[0]=t[0]+r[0],e[1]=t[1]+r[1],e[2]=t[2]+r[2],e[3]=t[3]+r[3],e}function Hc(e,t,r){return e[0]=t[0]-r[0],e[1]=t[1]-r[1],e[2]=t[2]-r[2],e[3]=t[3]-r[3],e}function Xc(e,t,r){return e[0]=t[0]*r[0],e[1]=t[1]*r[1],e[2]=t[2]*r[2],e[3]=t[3]*r[3],e}function Kc(e,t,r){return e[0]=t[0]/r[0],e[1]=t[1]/r[1],e[2]=t[2]/r[2],e[3]=t[3]/r[3],e}function yg(e,t){return e[0]=Math.ceil(t[0]),e[1]=Math.ceil(t[1]),e[2]=Math.ceil(t[2]),e[3]=Math.ceil(t[3]),e}function mg(e,t){return e[0]=Math.floor(t[0]),e[1]=Math.floor(t[1]),e[2]=Math.floor(t[2]),e[3]=Math.floor(t[3]),e}function hg(e,t,r){return e[0]=Math.min(t[0],r[0]),e[1]=Math.min(t[1],r[1]),e[2]=Math.min(t[2],r[2]),e[3]=Math.min(t[3],r[3]),e}function dg(e,t,r){return e[0]=Math.max(t[0],r[0]),e[1]=Math.max(t[1],r[1]),e[2]=Math.max(t[2],r[2]),e[3]=Math.max(t[3],r[3]),e}function gg(e,t){return e[0]=Math.round(t[0]),e[1]=Math.round(t[1]),e[2]=Math.round(t[2]),e[3]=Math.round(t[3]),e}function xg(e,t,r){return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e}function bg(e,t,r,n){return e[0]=t[0]+r[0]*n,e[1]=t[1]+r[1]*n,e[2]=t[2]+r[2]*n,e[3]=t[3]+r[3]*n,e}function Yc(e,t){var r=t[0]-e[0],n=t[1]-e[1],i=t[2]-e[2],o=t[3]-e[3];return Math.hypot(r,n,i,o)}function Qc(e,t){var r=t[0]-e[0],n=t[1]-e[1],i=t[2]-e[2],o=t[3]-e[3];return r*r+n*n+i*i+o*o}function ep(e){var t=e[0],r=e[1],n=e[2],i=e[3];return Math.hypot(t,r,n,i)}function tp(e){var t=e[0],r=e[1],n=e[2],i=e[3];return t*t+r*r+n*n+i*i}function vg(e,t){return e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e[3]=-t[3],e}function Pg(e,t){return e[0]=1/t[0],e[1]=1/t[1],e[2]=1/t[2],e[3]=1/t[3],e}function Sg(e,t){var r=t[0],n=t[1],i=t[2],o=t[3],a=r*r+n*n+i*i+o*o;return a>0&&(a=1/Math.sqrt(a)),e[0]=r*a,e[1]=n*a,e[2]=i*a,e[3]=o*a,e}function wg(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]+e[3]*t[3]}function Ag(e,t,r,n){var i=r[0]*n[1]-r[1]*n[0],o=r[0]*n[2]-r[2]*n[0],a=r[0]*n[3]-r[3]*n[0],s=r[1]*n[2]-r[2]*n[1],l=r[1]*n[3]-r[3]*n[1],u=r[2]*n[3]-r[3]*n[2],c=t[0],p=t[1],f=t[2],y=t[3];return e[0]=p*u-f*l+y*s,e[1]=-(c*u)+f*a-y*o,e[2]=c*l-p*a+y*i,e[3]=-(c*s)+p*o-f*i,e}function _g(e,t,r,n){var i=t[0],o=t[1],a=t[2],s=t[3];return e[0]=i+n*(r[0]-i),e[1]=o+n*(r[1]-o),e[2]=a+n*(r[2]-a),e[3]=s+n*(r[3]-s),e}function Ig(e,t){t=t||1;var r,n,i,o,a,s;do r=qn()*2-1,n=qn()*2-1,a=r*r+n*n;while(a>=1);do i=qn()*2-1,o=qn()*2-1,s=i*i+o*o;while(s>=1);var l=Math.sqrt((1-a)/s);return e[0]=t*r,e[1]=t*n,e[2]=t*i*l,e[3]=t*o*l,e}function Tg(e,t,r){var n=t[0],i=t[1],o=t[2],a=t[3];return e[0]=r[0]*n+r[4]*i+r[8]*o+r[12]*a,e[1]=r[1]*n+r[5]*i+r[9]*o+r[13]*a,e[2]=r[2]*n+r[6]*i+r[10]*o+r[14]*a,e[3]=r[3]*n+r[7]*i+r[11]*o+r[15]*a,e}function Cg(e,t,r){var n=t[0],i=t[1],o=t[2],a=r[0],s=r[1],l=r[2],u=r[3],c=u*n+s*o-l*i,p=u*i+l*n-a*o,f=u*o+a*i-s*n,y=-a*n-s*i-l*o;return e[0]=c*u+y*-a+p*-l-f*-s,e[1]=p*u+y*-s+f*-a-c*-l,e[2]=f*u+y*-l+c*-s-p*-a,e[3]=t[3],e}function kg(e){return e[0]=0,e[1]=0,e[2]=0,e[3]=0,e}function Mg(e){return"vec4("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+")"}function Eg(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]}function Fg(e,t){var r=e[0],n=e[1],i=e[2],o=e[3],a=t[0],s=t[1],l=t[2],u=t[3];return Math.abs(r-a)<=Q*Math.max(1,Math.abs(r),Math.abs(a))&&Math.abs(n-s)<=Q*Math.max(1,Math.abs(n),Math.abs(s))&&Math.abs(i-l)<=Q*Math.max(1,Math.abs(i),Math.abs(l))&&Math.abs(o-u)<=Q*Math.max(1,Math.abs(o),Math.abs(u))}var Lg=Hc,Dg=Xc,Vg=Kc,Bg=Yc,zg=Qc,Rg=ep,Og=tp,Ng=function(){var e=Wc();return function(t,r,n,i,o,a){var s,l;for(r||(r=4),n||(n=0),i?l=Math.min(i*r+n,t.length):l=t.length,s=n;s<l;s+=r)e[0]=t[s],e[1]=t[s+1],e[2]=t[s+2],e[3]=t[s+3],o(e,e,a),t[s]=e[0],t[s+1]=e[1],t[s+2]=e[2],t[s+3]=e[3];return t}}();var rp=Z(he(),1),Ro=class extends se{constructor(t){super(t,Oc)}createBucket(t){return new Ht(t)}queryRadius(t){let r=t;return Xt("circle-radius",this,r)+Xt("circle-stroke-width",this,r)+_t(this.paint.get("circle-translate"))}queryIntersectsFeature(t,r,n,i,o,a,s,l){let u=It(t,this.paint.get("circle-translate"),this.paint.get("circle-translate-anchor"),a.angle,s),c=this.paint.get("circle-radius").evaluate(r,n),p=this.paint.get("circle-stroke-width").evaluate(r,n),f=c+p,y=this.paint.get("circle-pitch-alignment")==="map",m=y?u:Ug(u,l),h=y?f*s:f;for(let d of i)for(let g of d){let b=y?g:np(g,l),x=h,v=Kt.transformMat4([],[g.x,g.y,0,1],l);if(this.paint.get("circle-pitch-scale")==="viewport"&&this.paint.get("circle-pitch-alignment")==="map"?x*=v[3]/a.cameraToCenterDistance:this.paint.get("circle-pitch-scale")==="map"&&this.paint.get("circle-pitch-alignment")==="viewport"&&(x*=a.cameraToCenterDistance/v[3]),Lc(m,b,x))return!0}return!1}};function np(e,t){let r=Kt.transformMat4([],[e.x,e.y,0,1],t);return new rp.default(r[0]/r[3],r[1]/r[3])}function Ug(e,t){return e.map(r=>np(r,t))}var Jn=class extends Ht{};C("HeatmapBucket",Jn,{omit:["layers"]});var ip,$g=()=>ip=ip||new re({"heatmap-radius":new R(S.paint_heatmap["heatmap-radius"]),"heatmap-weight":new R(S.paint_heatmap["heatmap-weight"]),"heatmap-intensity":new B(S.paint_heatmap["heatmap-intensity"]),"heatmap-color":new jt(S.paint_heatmap["heatmap-color"]),"heatmap-opacity":new B(S.paint_heatmap["heatmap-opacity"])}),op={get paint(){return $g()}};function Ls(e,{width:t,height:r},n,i){if(!i)i=new Uint8Array(t*r*n);else if(i instanceof Uint8ClampedArray)i=new Uint8Array(i.buffer);else if(i.length!==t*r*n)throw new RangeError("mismatched image size. expected: ".concat(i.length," but got: ").concat(t*r*n));return e.width=t,e.height=r,e.data=i,e}function ap(e,{width:t,height:r},n){if(t===e.width&&r===e.height)return;let i=Ls({},{width:t,height:r},n);Ds(e,i,{x:0,y:0},{x:0,y:0},{width:Math.min(e.width,t),height:Math.min(e.height,r)},n),e.width=t,e.height=r,e.data=i.data}function Ds(e,t,r,n,i,o){if(i.width===0||i.height===0)return t;if(i.width>e.width||i.height>e.height||r.x>e.width-i.width||r.y>e.height-i.height)throw new RangeError("out of range source coordinates for image copy");if(i.width>t.width||i.height>t.height||n.x>t.width-i.width||n.y>t.height-i.height)throw new RangeError("out of range destination coordinates for image copy");let a=e.data,s=t.data;if(a===s)throw new Error("srcData equals dstData, so image is already copied");for(let l=0;l<i.height;l++){let u=((r.y+l)*e.width+r.x)*o,c=((n.y+l)*t.width+n.x)*o;for(let p=0;p<i.width*o;p++)s[c+p]=a[u+p]}return t}var Yt=class e{constructor(t,r){Ls(this,t,1,r)}resize(t){ap(this,t,1)}clone(){return new e({width:this.width,height:this.height},new Uint8Array(this.data))}static copy(t,r,n,i,o){Ds(t,r,n,i,o,1)}},de=class e{constructor(t,r){Ls(this,t,4,r)}resize(t){ap(this,t,4)}replace(t,r){r?this.data.set(t):t instanceof Uint8ClampedArray?this.data=new Uint8Array(t.buffer):this.data=t}clone(){return new e({width:this.width,height:this.height},new Uint8Array(this.data))}static copy(t,r,n,i,o){Ds(t,r,n,i,o,4)}};C("AlphaImage",Yt);C("RGBAImage",de);function sp(e){let t={},r=e.resolution||256,n=e.clips?e.clips.length:1,i=e.image||new de({width:r,height:n});if(!ql(r))throw new Error("width is not a power of 2 - ".concat(r));let o=(a,s,l)=>{t[e.evaluationKey]=l;let u=e.expression.evaluate(t);i.data[a+s+0]=Math.floor(u.r*255/u.a),i.data[a+s+1]=Math.floor(u.g*255/u.a),i.data[a+s+2]=Math.floor(u.b*255/u.a),i.data[a+s+3]=Math.floor(u.a*255)};if(e.clips)for(let a=0,s=0;a<n;++a,s+=r*4)for(let l=0,u=0;l<r;l++,u+=4){let c=l/(r-1),{start:p,end:f}=e.clips[a],y=p*(1-c)+f*c;o(s,u,y)}else for(let a=0,s=0;a<r;a++,s+=4){let l=a/(r-1);o(0,s,l)}return i}var Oo=class extends se{createBucket(t){return new Jn(t)}constructor(t){super(t,op),this._updateColorRamp()}_handleSpecialPaintPropertyUpdate(t){t==="heatmap-color"&&this._updateColorRamp()}_updateColorRamp(){let t=this._transitionablePaint._values["heatmap-color"].value.expression;this.colorRamp=sp({expression:t,evaluationKey:"heatmapDensity",image:this.colorRamp}),this.colorRampTexture=null}resize(){this.heatmapFbo&&(this.heatmapFbo.destroy(),this.heatmapFbo=null)}queryRadius(){return 0}queryIntersectsFeature(){return!1}hasOffscreenPass(){return this.paint.get("heatmap-opacity")!==0&&this.visibility!=="none"}};var lp,Gg=()=>lp=lp||new re({"hillshade-illumination-direction":new B(S.paint_hillshade["hillshade-illumination-direction"]),"hillshade-illumination-anchor":new B(S.paint_hillshade["hillshade-illumination-anchor"]),"hillshade-exaggeration":new B(S.paint_hillshade["hillshade-exaggeration"]),"hillshade-shadow-color":new B(S.paint_hillshade["hillshade-shadow-color"]),"hillshade-highlight-color":new B(S.paint_hillshade["hillshade-highlight-color"]),"hillshade-accent-color":new B(S.paint_hillshade["hillshade-accent-color"])}),up={get paint(){return Gg()}};var No=class extends se{constructor(t){super(t,up)}hasOffscreenPass(){return this.paint.get("hillshade-exaggeration")!==0&&this.visibility!=="none"}};var qg=Y([{name:"a_pos",components:2,type:"Int16"}],4);var{members:cp,size:LP,alignment:DP}=qg;var dp=Z(Os(),1);function Ns(e,t,r,n,i){hp(e,t,r||0,n||e.length-1,i||ax)}function hp(e,t,r,n,i){for(;n>r;){if(n-r>600){var o=n-r+1,a=t-r+1,s=Math.log(o),l=.5*Math.exp(2*s/3),u=.5*Math.sqrt(s*l*(o-l)/o)*(a-o/2<0?-1:1),c=Math.max(r,Math.floor(t-a*l/o+u)),p=Math.min(n,Math.floor(t+(o-a)*l/o+u));hp(e,t,c,p,i)}var f=e[t],y=r,m=n;for(Xn(e,r,t),i(e[n],f)>0&&Xn(e,r,n);y<m;){for(Xn(e,y,m),y++,m--;i(e[y],f)<0;)y++;for(;i(e[m],f)>0;)m--}i(e[r],f)===0?Xn(e,r,m):(m++,Xn(e,m,n)),m<=t&&(r=m+1),t<=m&&(n=m-1)}}function Xn(e,t,r){var n=e[t];e[t]=e[r],e[r]=n}function ax(e,t){return e<t?-1:e>t?1:0}function _r(e,t){let r=e.length;if(r<=1)return[e];let n=[],i,o;for(let a=0;a<r;a++){let s=Zl(e[a]);s!==0&&(e[a].area=Math.abs(s),o===void 0&&(o=s<0),o===s<0?(i&&n.push(i),i=[e[a]]):i.push(e[a]))}if(i&&n.push(i),t>1)for(let a=0;a<n.length;a++)n[a].length<=t||(Ns(n[a],t,1,n[a].length-1,sx),n[a]=n[a].slice(0,t));return n}function sx(e,t){return t.area-e.area}function Ir(e,t,r){let n=r.patternDependencies,i=!1;for(let o of t){let a=o.paint.get("".concat(e,"-pattern"));a.isConstant()||(i=!0);let s=a.constantOr(null);s&&(i=!0,n[s.to]=!0,n[s.from]=!0)}return i}function Tr(e,t,r,n,i){let o=i.patternDependencies;for(let a of t){let l=a.paint.get("".concat(e,"-pattern")).value;if(l.kind!=="constant"){let u=l.evaluate({zoom:n-1},r,{},i.availableImages),c=l.evaluate({zoom:n},r,{},i.availableImages),p=l.evaluate({zoom:n+1},r,{},i.availableImages);u=u&&u.name?u.name:u,c=c&&c.name?c.name:c,p=p&&p.name?p.name:p,o[u]=!0,o[c]=!0,o[p]=!0,r.patterns[a.id]={min:u,mid:c,max:p}}}return r}var lx=500,er=class{constructor(t){this.zoom=t.zoom,this.overscaling=t.overscaling,this.layers=t.layers,this.layerIds=this.layers.map(r=>r.id),this.index=t.index,this.hasPattern=!1,this.patternFeatures=[],this.layoutVertexArray=new So,this.indexArray=new Le,this.indexArray2=new wt,this.programConfigurations=new Ce(t.layers,t.zoom),this.segments=new me,this.segments2=new me,this.stateDependentLayerIds=this.layers.filter(r=>r.isStateDependent()).map(r=>r.id)}populate(t,r,n){this.hasPattern=Ir("fill",this.layers,r);let i=this.layers[0].layout.get("fill-sort-key"),o=!i.isConstant(),a=[];for(let{feature:s,id:l,index:u,sourceLayerIndex:c}of t){let p=this.layers[0]._featureFilter.needGeometry,f=$e(s,p);if(!this.layers[0]._featureFilter.filter(new q(this.zoom),f,n))continue;let y=o?i.evaluate(f,{},n,r.availableImages):void 0,m={id:l,properties:s.properties,type:s.type,sourceLayerIndex:c,index:u,geometry:p?f.geometry:ke(s),patterns:{},sortKey:y};a.push(m)}o&&a.sort((s,l)=>s.sortKey-l.sortKey);for(let s of a){let{geometry:l,index:u,sourceLayerIndex:c}=s;if(this.hasPattern){let f=Tr("fill",this.layers,s,this.zoom,r);this.patternFeatures.push(f)}else this.addFeature(s,l,u,n,{});let p=t[u].feature;r.featureIndex.insert(p,l,u,c,this.index)}}update(t,r,n){this.stateDependentLayers.length&&this.programConfigurations.updatePaintArrays(t,r,this.stateDependentLayers,n)}addFeatures(t,r,n){for(let i of this.patternFeatures)this.addFeature(i,i.geometry,i.index,r,n)}isEmpty(){return this.layoutVertexArray.length===0}uploadPending(){return!this.uploaded||this.programConfigurations.needsUpload}upload(t){this.uploaded||(this.layoutVertexBuffer=t.createVertexBuffer(this.layoutVertexArray,cp),this.indexBuffer=t.createIndexBuffer(this.indexArray),this.indexBuffer2=t.createIndexBuffer(this.indexArray2)),this.programConfigurations.upload(t),this.uploaded=!0}destroy(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.indexBuffer2.destroy(),this.programConfigurations.destroy(),this.segments.destroy(),this.segments2.destroy())}addFeature(t,r,n,i,o){for(let a of _r(r,lx)){let s=0;for(let y of a)s+=y.length;let l=this.segments.prepareSegment(s,this.layoutVertexArray,this.indexArray),u=l.vertexLength,c=[],p=[];for(let y of a){if(y.length===0)continue;y!==a[0]&&p.push(c.length/2);let m=this.segments2.prepareSegment(y.length,this.layoutVertexArray,this.indexArray2),h=m.vertexLength;this.layoutVertexArray.emplaceBack(y[0].x,y[0].y),this.indexArray2.emplaceBack(h+y.length-1,h),c.push(y[0].x),c.push(y[0].y);for(let d=1;d<y.length;d++)this.layoutVertexArray.emplaceBack(y[d].x,y[d].y),this.indexArray2.emplaceBack(h+d-1,h+d),c.push(y[d].x),c.push(y[d].y);m.vertexLength+=y.length,m.primitiveLength+=y.length}let f=(0,dp.default)(c,p);for(let y=0;y<f.length;y+=3)this.indexArray.emplaceBack(u+f[y],u+f[y+1],u+f[y+2]);l.vertexLength+=s,l.primitiveLength+=f.length/3}this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length,t,n,o,i)}};C("FillBucket",er,{omit:["layers","patternFeatures"]});var gp,ux=()=>gp=gp||new re({"fill-sort-key":new R(S.layout_fill["fill-sort-key"])}),xp,cx=()=>xp=xp||new re({"fill-antialias":new B(S.paint_fill["fill-antialias"]),"fill-opacity":new R(S.paint_fill["fill-opacity"]),"fill-color":new R(S.paint_fill["fill-color"]),"fill-outline-color":new R(S.paint_fill["fill-outline-color"]),"fill-translate":new B(S.paint_fill["fill-translate"]),"fill-translate-anchor":new B(S.paint_fill["fill-translate-anchor"]),"fill-pattern":new lt(S.paint_fill["fill-pattern"])}),bp={get paint(){return cx()},get layout(){return ux()}};var jo=class extends se{constructor(t){super(t,bp)}recalculate(t,r){super.recalculate(t,r);let n=this.paint._values["fill-outline-color"];n.value.kind==="constant"&&n.value.value===void 0&&(this.paint._values["fill-outline-color"]=this.paint._values["fill-color"])}createBucket(t){return new er(t)}queryRadius(){return _t(this.paint.get("fill-translate"))}queryIntersectsFeature(t,r,n,i,o,a,s){let l=It(t,this.paint.get("fill-translate"),this.paint.get("fill-translate-anchor"),a.angle,s);return Bo(l,i)}isTileClipped(){return!0}};var px=Y([{name:"a_pos",components:2,type:"Int16"},{name:"a_normal_ed",components:4,type:"Int16"}],4),vp=Y([{name:"a_centroid",components:2,type:"Int16"}],4);var{members:Pp,size:dS,alignment:gS}=px;var Tp=Z(Os(),1),Cp=Z(Tt(),1);var wx=Cp.default.VectorTileFeature.types,Ax=500,Gs=Math.pow(2,13);function Kn(e,t,r,n,i,o,a,s){e.emplaceBack(t,r,Math.floor(n*Gs)*2+a,i*Gs*2,o*Gs*2,Math.round(s))}var tr=class{constructor(t){this.zoom=t.zoom,this.overscaling=t.overscaling,this.layers=t.layers,this.layerIds=this.layers.map(r=>r.id),this.index=t.index,this.hasPattern=!1,this.layoutVertexArray=new wo,this.centroidVertexArray=new vo,this.indexArray=new Le,this.programConfigurations=new Ce(t.layers,t.zoom),this.segments=new me,this.stateDependentLayerIds=this.layers.filter(r=>r.isStateDependent()).map(r=>r.id)}populate(t,r,n){this.features=[],this.hasPattern=Ir("fill-extrusion",this.layers,r);for(let{feature:i,id:o,index:a,sourceLayerIndex:s}of t){let l=this.layers[0]._featureFilter.needGeometry,u=$e(i,l);if(!this.layers[0]._featureFilter.filter(new q(this.zoom),u,n))continue;let c={id:o,sourceLayerIndex:s,index:a,geometry:l?u.geometry:ke(i),properties:i.properties,type:i.type,patterns:{}};this.hasPattern?this.features.push(Tr("fill-extrusion",this.layers,c,this.zoom,r)):this.addFeature(c,c.geometry,a,n,{}),r.featureIndex.insert(i,c.geometry,a,s,this.index,!0)}}addFeatures(t,r,n){for(let i of this.features){let{geometry:o}=i;this.addFeature(i,o,i.index,r,n)}}update(t,r,n){this.stateDependentLayers.length&&this.programConfigurations.updatePaintArrays(t,r,this.stateDependentLayers,n)}isEmpty(){return this.layoutVertexArray.length===0&&this.centroidVertexArray.length===0}uploadPending(){return!this.uploaded||this.programConfigurations.needsUpload}upload(t){this.uploaded||(this.layoutVertexBuffer=t.createVertexBuffer(this.layoutVertexArray,Pp),this.centroidVertexBuffer=t.createVertexBuffer(this.centroidVertexArray,vp.members,!0),this.indexBuffer=t.createIndexBuffer(this.indexArray)),this.programConfigurations.upload(t),this.uploaded=!0}destroy(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.programConfigurations.destroy(),this.segments.destroy(),this.centroidVertexBuffer.destroy())}addFeature(t,r,n,i,o){let a={x:0,y:0,vertexCount:0};for(let s of _r(r,Ax)){let l=0;for(let m of s)l+=m.length;let u=this.segments.prepareSegment(4,this.layoutVertexArray,this.indexArray);for(let m of s){if(m.length===0||Ix(m))continue;let h=0;for(let d=0;d<m.length;d++){let g=m[d];if(d>=1){let b=m[d-1];if(!_x(g,b)){u.vertexLength+4>me.MAX_VERTEX_ARRAY_LENGTH&&(u=this.segments.prepareSegment(4,this.layoutVertexArray,this.indexArray));let x=g.sub(b)._perp()._unit(),v=b.dist(g);h+v>32768&&(h=0),Kn(this.layoutVertexArray,g.x,g.y,x.x,x.y,0,0,h),Kn(this.layoutVertexArray,g.x,g.y,x.x,x.y,0,1,h),a.x+=2*g.x,a.y+=2*g.y,a.vertexCount+=2,h+=v,Kn(this.layoutVertexArray,b.x,b.y,x.x,x.y,0,0,h),Kn(this.layoutVertexArray,b.x,b.y,x.x,x.y,0,1,h),a.x+=2*b.x,a.y+=2*b.y,a.vertexCount+=2;let P=u.vertexLength;this.indexArray.emplaceBack(P,P+2,P+1),this.indexArray.emplaceBack(P+1,P+2,P+3),u.vertexLength+=4,u.primitiveLength+=2}}}}if(u.vertexLength+l>me.MAX_VERTEX_ARRAY_LENGTH&&(u=this.segments.prepareSegment(l,this.layoutVertexArray,this.indexArray)),wx[t.type]!=="Polygon")continue;let c=[],p=[],f=u.vertexLength;for(let m of s)if(m.length!==0){m!==s[0]&&p.push(c.length/2);for(let h=0;h<m.length;h++){let d=m[h];Kn(this.layoutVertexArray,d.x,d.y,0,0,1,1,0),a.x+=d.x,a.y+=d.y,a.vertexCount+=1,c.push(d.x),c.push(d.y)}}let y=(0,Tp.default)(c,p);for(let m=0;m<y.length;m+=3)this.indexArray.emplaceBack(f+y[m],f+y[m+2],f+y[m+1]);u.primitiveLength+=y.length/3,u.vertexLength+=l}for(let s=0;s<a.vertexCount;s++)this.centroidVertexArray.emplaceBack(Math.floor(a.x/a.vertexCount),Math.floor(a.y/a.vertexCount));this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length,t,n,o,i)}};C("FillExtrusionBucket",tr,{omit:["layers","features"]});function _x(e,t){return e.x===t.x&&(e.x<0||e.x>8192)||e.y===t.y&&(e.y<0||e.y>8192)}function Ix(e){return e.every(t=>t.x<0)||e.every(t=>t.x>8192)||e.every(t=>t.y<0)||e.every(t=>t.y>8192)}var kp,Tx=()=>kp=kp||new re({"fill-extrusion-opacity":new B(S["paint_fill-extrusion"]["fill-extrusion-opacity"]),"fill-extrusion-color":new R(S["paint_fill-extrusion"]["fill-extrusion-color"]),"fill-extrusion-translate":new B(S["paint_fill-extrusion"]["fill-extrusion-translate"]),"fill-extrusion-translate-anchor":new B(S["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),"fill-extrusion-pattern":new lt(S["paint_fill-extrusion"]["fill-extrusion-pattern"]),"fill-extrusion-height":new R(S["paint_fill-extrusion"]["fill-extrusion-height"]),"fill-extrusion-base":new R(S["paint_fill-extrusion"]["fill-extrusion-base"]),"fill-extrusion-vertical-gradient":new B(S["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"])}),Mp={get paint(){return Tx()}};var Zo=Z(he(),1);var Wo=class extends se{constructor(t){super(t,Mp)}createBucket(t){return new tr(t)}queryRadius(){return _t(this.paint.get("fill-extrusion-translate"))}is3D(){return!0}queryIntersectsFeature(t,r,n,i,o,a,s,l){let u=It(t,this.paint.get("fill-extrusion-translate"),this.paint.get("fill-extrusion-translate-anchor"),a.angle,s),c=this.paint.get("fill-extrusion-height").evaluate(r,n),p=this.paint.get("fill-extrusion-base").evaluate(r,n),f=Mx(u,l,a,0),y=kx(i,p,c,l),m=y[0],h=y[1];return Cx(m,h,f)}};function Yn(e,t){return e.x*t.x+e.y*t.y}function Ep(e,t){if(e.length===1){let r=0,n=t[r++],i;for(;!i||n.equals(i);)if(i=t[r++],!i)return 1/0;for(;r<t.length;r++){let o=t[r],a=e[0],s=i.sub(n),l=o.sub(n),u=a.sub(n),c=Yn(s,s),p=Yn(s,l),f=Yn(l,l),y=Yn(u,s),m=Yn(u,l),h=c*f-p*p,d=(f*y-p*m)/h,g=(c*m-p*y)/h,b=1-d-g,x=n.z*b+i.z*d+o.z*g;if(isFinite(x))return x}return 1/0}else{let r=1/0;for(let n of t)r=Math.min(r,n.z);return r}}function Cx(e,t,r){let n=1/0;Bo(r,t)&&(n=Ep(r,t[0]));for(let i=0;i<t.length;i++){let o=t[i],a=e[i];for(let s=0;s<o.length-1;s++){let l=o[s],u=o[s+1],c=a[s],p=a[s+1],f=[l,u,p,c,l];Fc(r,f)&&(n=Math.min(n,Ep(r,f)))}}return n===1/0?!1:n}function kx(e,t,r,n){let i=[],o=[],a=n[8]*t,s=n[9]*t,l=n[10]*t,u=n[11]*t,c=n[8]*r,p=n[9]*r,f=n[10]*r,y=n[11]*r;for(let m of e){let h=[],d=[];for(let g of m){let b=g.x,x=g.y,v=n[0]*b+n[4]*x+n[12],P=n[1]*b+n[5]*x+n[13],w=n[2]*b+n[6]*x+n[14],T=n[3]*b+n[7]*x+n[15],F=v+a,E=P+s,_=w+l,I=T+u,k=v+c,V=P+p,A=w+f,z=T+y,O=new Zo.default(F/I,E/I);O.z=_/I,h.push(O);let N=new Zo.default(k/z,V/z);N.z=A/z,d.push(N)}i.push(h),o.push(d)}return[i,o]}function Mx(e,t,r,n){let i=[];for(let o of e){let a=[o.x,o.y,n,1];Kt.transformMat4(a,a,t),i.push(new Zo.default(a[0]/a[3],a[1]/a[3]))}return i}var Ex=Y([{name:"a_pos_normal",components:2,type:"Int16"},{name:"a_data",components:4,type:"Uint8"}],4),{members:Fp,size:QS,alignment:ew}=Ex;var Fx=Y([{name:"a_uv_x",components:1,type:"Float32"},{name:"a_split_index",components:1,type:"Float32"}]),{members:Lp,size:nw,alignment:iw}=Fx;var Bp=Z(Tt(),1);var Lx=Bp.default.VectorTileFeature.types,Dp=63,Dx=Math.cos(75/2*(Math.PI/180)),Vx=15,Bx=20,zx=15,zp=1/2,Vp=Math.pow(2,zx-1)/zp,rr=class{constructor(t){this.zoom=t.zoom,this.overscaling=t.overscaling,this.layers=t.layers,this.layerIds=this.layers.map(r=>r.id),this.index=t.index,this.hasPattern=!1,this.patternFeatures=[],this.lineClipsArray=[],this.gradients={},this.layers.forEach(r=>{this.gradients[r.id]={}}),this.layoutVertexArray=new Ao,this.layoutVertexArray2=new _o,this.indexArray=new Le,this.programConfigurations=new Ce(t.layers,t.zoom),this.segments=new me,this.maxLineLength=0,this.stateDependentLayerIds=this.layers.filter(r=>r.isStateDependent()).map(r=>r.id)}populate(t,r,n){this.hasPattern=Ir("line",this.layers,r);let i=this.layers[0].layout.get("line-sort-key"),o=!i.isConstant(),a=[];for(let{feature:s,id:l,index:u,sourceLayerIndex:c}of t){let p=this.layers[0]._featureFilter.needGeometry,f=$e(s,p);if(!this.layers[0]._featureFilter.filter(new q(this.zoom),f,n))continue;let y=o?i.evaluate(f,{},n):void 0,m={id:l,properties:s.properties,type:s.type,sourceLayerIndex:c,index:u,geometry:p?f.geometry:ke(s),patterns:{},sortKey:y};a.push(m)}o&&a.sort((s,l)=>s.sortKey-l.sortKey);for(let s of a){let{geometry:l,index:u,sourceLayerIndex:c}=s;if(this.hasPattern){let f=Tr("line",this.layers,s,this.zoom,r);this.patternFeatures.push(f)}else this.addFeature(s,l,u,n,{});let p=t[u].feature;r.featureIndex.insert(p,l,u,c,this.index)}}update(t,r,n){this.stateDependentLayers.length&&this.programConfigurations.updatePaintArrays(t,r,this.stateDependentLayers,n)}addFeatures(t,r,n){for(let i of this.patternFeatures)this.addFeature(i,i.geometry,i.index,r,n)}isEmpty(){return this.layoutVertexArray.length===0}uploadPending(){return!this.uploaded||this.programConfigurations.needsUpload}upload(t){this.uploaded||(this.layoutVertexArray2.length!==0&&(this.layoutVertexBuffer2=t.createVertexBuffer(this.layoutVertexArray2,Lp)),this.layoutVertexBuffer=t.createVertexBuffer(this.layoutVertexArray,Fp),this.indexBuffer=t.createIndexBuffer(this.indexArray)),this.programConfigurations.upload(t),this.uploaded=!0}destroy(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.programConfigurations.destroy(),this.segments.destroy())}lineFeatureClips(t){if(t.properties&&Object.prototype.hasOwnProperty.call(t.properties,"mapbox_clip_start")&&Object.prototype.hasOwnProperty.call(t.properties,"mapbox_clip_end")){let r=+t.properties.mapbox_clip_start,n=+t.properties.mapbox_clip_end;return{start:r,end:n}}}addFeature(t,r,n,i,o){let a=this.layers[0].layout,s=a.get("line-join").evaluate(t,{}),l=a.get("line-cap"),u=a.get("line-miter-limit"),c=a.get("line-round-limit");this.lineClips=this.lineFeatureClips(t);for(let p of r)this.addLine(p,t,s,l,u,c);this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length,t,n,o,i)}addLine(t,r,n,i,o,a){if(this.distance=0,this.scaledDistance=0,this.totalDistance=0,this.lineClips){this.lineClipsArray.push(this.lineClips);for(let g=0;g<t.length-1;g++)this.totalDistance+=t[g].dist(t[g+1]);this.updateScaledDistance(),this.maxLineLength=Math.max(this.maxLineLength,this.totalDistance)}let s=Lx[r.type]==="Polygon",l=t.length;for(;l>=2&&t[l-1].equals(t[l-2]);)l--;let u=0;for(;u<l-1&&t[u].equals(t[u+1]);)u++;if(l<(s?3:2))return;n==="bevel"&&(o=1.05);let c=this.overscaling<=16?Vx*8192/(512*this.overscaling):0,p=this.segments.prepareSegment(l*10,this.layoutVertexArray,this.indexArray),f,y,m,h,d;this.e1=this.e2=-1,s&&(f=t[l-2],d=t[u].sub(f)._unit()._perp());for(let g=u;g<l;g++){if(m=g===l-1?s?t[u+1]:void 0:t[g+1],m&&t[g].equals(m))continue;d&&(h=d),f&&(y=f),f=t[g],d=m?m.sub(f)._unit()._perp():h,h=h||d;let b=h.add(d);(b.x!==0||b.y!==0)&&b._unit();let x=h.x*d.x+h.y*d.y,v=b.x*d.x+b.y*d.y,P=v!==0?1/v:1/0,w=2*Math.sqrt(2-2*v),T=v<Dx&&y&&m,F=h.x*d.y-h.y*d.x>0;if(T&&g>u){let I=f.dist(y);if(I>2*c){let k=f.sub(f.sub(y)._mult(c/I)._round());this.updateDistance(y,k),this.addCurrentVertex(k,h,0,0,p),y=k}}let E=y&&m,_=E?n:s?"butt":i;if(E&&_==="round"&&(P<a?_="miter":P<=2&&(_="fakeround")),_==="miter"&&P>o&&(_="bevel"),_==="bevel"&&(P>2&&(_="flipbevel"),P<o&&(_="miter")),y&&this.updateDistance(y,f),_==="miter")b._mult(P),this.addCurrentVertex(f,b,0,0,p);else if(_==="flipbevel"){if(P>100)b=d.mult(-1);else{let I=P*h.add(d).mag()/h.sub(d).mag();b._perp()._mult(I*(F?-1:1))}this.addCurrentVertex(f,b,0,0,p),this.addCurrentVertex(f,b.mult(-1),0,0,p)}else if(_==="bevel"||_==="fakeround"){let I=-Math.sqrt(P*P-1),k=F?I:0,V=F?0:I;if(y&&this.addCurrentVertex(f,h,k,V,p),_==="fakeround"){let A=Math.round(w*180/Math.PI/Bx);for(let z=1;z<A;z++){let O=z/A;if(O!==.5){let K=O-.5,xe=1.0904+x*(-3.2452+x*(3.55645-x*1.43519)),X=.848013+x*(-1.06021+x*.215638);O=O+O*K*(O-1)*(xe*K*K+X)}let N=d.sub(h)._mult(O)._add(h)._unit()._mult(F?-1:1);this.addHalfVertex(f,N.x,N.y,!1,F,0,p)}}m&&this.addCurrentVertex(f,d,-k,-V,p)}else if(_==="butt")this.addCurrentVertex(f,b,0,0,p);else if(_==="square"){let I=y?1:-1;this.addCurrentVertex(f,b,I,I,p)}else _==="round"&&(y&&(this.addCurrentVertex(f,h,0,0,p),this.addCurrentVertex(f,h,1,1,p,!0)),m&&(this.addCurrentVertex(f,d,-1,-1,p,!0),this.addCurrentVertex(f,d,0,0,p)));if(T&&g<l-1){let I=f.dist(m);if(I>2*c){let k=f.add(m.sub(f)._mult(c/I)._round());this.updateDistance(f,k),this.addCurrentVertex(k,d,0,0,p),f=k}}}}addCurrentVertex(t,r,n,i,o,a=!1){let s=r.x+r.y*n,l=r.y-r.x*n,u=-r.x+r.y*i,c=-r.y-r.x*i;this.addHalfVertex(t,s,l,a,!1,n,o),this.addHalfVertex(t,u,c,a,!0,-i,o),this.distance>Vp/2&&this.totalDistance===0&&(this.distance=0,this.updateScaledDistance(),this.addCurrentVertex(t,r,n,i,o,a))}addHalfVertex({x:t,y:r},n,i,o,a,s,l){let c=(this.lineClips?this.scaledDistance*(Vp-1):this.scaledDistance)*zp;if(this.layoutVertexArray.emplaceBack((t<<1)+(o?1:0),(r<<1)+(a?1:0),Math.round(Dp*n)+128,Math.round(Dp*i)+128,(s===0?0:s<0?-1:1)+1|(c&63)<<2,c>>6),this.lineClips){let f=this.scaledDistance-this.lineClips.start,y=this.lineClips.end-this.lineClips.start,m=f/y;this.layoutVertexArray2.emplaceBack(m,this.lineClipsArray.length)}let p=l.vertexLength++;this.e1>=0&&this.e2>=0&&(this.indexArray.emplaceBack(this.e1,this.e2,p),l.primitiveLength++),a?this.e2=p:this.e1=p}updateScaledDistance(){this.scaledDistance=this.lineClips?this.lineClips.start+(this.lineClips.end-this.lineClips.start)*this.distance/this.totalDistance:this.distance}updateDistance(t,r){this.distance+=t.dist(r),this.updateScaledDistance()}};C("LineBucket",rr,{omit:["layers","patternFeatures"]});var Rp,Rx=()=>Rp=Rp||new re({"line-cap":new B(S.layout_line["line-cap"]),"line-join":new R(S.layout_line["line-join"]),"line-miter-limit":new B(S.layout_line["line-miter-limit"]),"line-round-limit":new B(S.layout_line["line-round-limit"]),"line-sort-key":new R(S.layout_line["line-sort-key"])}),Op,Ox=()=>Op=Op||new re({"line-opacity":new R(S.paint_line["line-opacity"]),"line-color":new R(S.paint_line["line-color"]),"line-translate":new B(S.paint_line["line-translate"]),"line-translate-anchor":new B(S.paint_line["line-translate-anchor"]),"line-width":new R(S.paint_line["line-width"]),"line-gap-width":new R(S.paint_line["line-gap-width"]),"line-offset":new R(S.paint_line["line-offset"]),"line-blur":new R(S.paint_line["line-blur"]),"line-dasharray":new qt(S.paint_line["line-dasharray"]),"line-pattern":new lt(S.paint_line["line-pattern"]),"line-gradient":new jt(S.paint_line["line-gradient"])}),qs={get paint(){return Ox()},get layout(){return Rx()}};var js=class extends R{possiblyEvaluate(t,r){return r=new q(Math.floor(r.zoom),{now:r.now,fadeDuration:r.fadeDuration,zoomHistory:r.zoomHistory,transition:r.transition}),super.possiblyEvaluate(t,r)}evaluate(t,r,n,i){return r=Pe({},r,{zoom:Math.floor(r.zoom)}),super.evaluate(t,r,n,i)}},Ho,Xo=class extends se{constructor(t){super(t,qs),this.gradientVersion=0,Ho||(Ho=new js(qs.paint.properties["line-width"].specification),Ho.useIntegerZoom=!0)}_handleSpecialPaintPropertyUpdate(t){if(t==="line-gradient"){let r=this.gradientExpression();$t(r)?this.stepInterpolant=r._styleExpression.expression instanceof pr:this.stepInterpolant=!1,this.gradientVersion=(this.gradientVersion+1)%Number.MAX_SAFE_INTEGER}}gradientExpression(){return this._transitionablePaint._values["line-gradient"].value.expression}recalculate(t,r){super.recalculate(t,r),this.paint._values["line-floorwidth"]=Ho.possiblyEvaluate(this._transitioningPaint._values["line-width"].value,t)}createBucket(t){return new rr(t)}queryRadius(t){let r=t,n=Np(Xt("line-width",this,r),Xt("line-gap-width",this,r)),i=Xt("line-offset",this,r);return n/2+Math.abs(i)+_t(this.paint.get("line-translate"))}queryIntersectsFeature(t,r,n,i,o,a,s){let l=It(t,this.paint.get("line-translate"),this.paint.get("line-translate-anchor"),a.angle,s),u=s/2*Np(this.paint.get("line-width").evaluate(r,n),this.paint.get("line-gap-width").evaluate(r,n)),c=this.paint.get("line-offset").evaluate(r,n);return c&&(i=Bc(i,c*s)),Dc(l,i,u)}isTileClipped(){return!0}};function Np(e,t){return t>0?t+2*e:e}var Up=Y([{name:"a_pos_offset",components:4,type:"Int16"},{name:"a_data",components:4,type:"Uint16"},{name:"a_pixeloffset",components:4,type:"Int16"}],4),$p=Y([{name:"a_projected_pos",components:3,type:"Float32"}],4),Uw=Y([{name:"a_fade_opacity",components:1,type:"Uint32"}],4),Gp=Y([{name:"a_placed",components:2,type:"Uint8"},{name:"a_shift",components:2,type:"Float32"}]),$w=Y([{type:"Int16",name:"anchorPointX"},{type:"Int16",name:"anchorPointY"},{type:"Int16",name:"x1"},{type:"Int16",name:"y1"},{type:"Int16",name:"x2"},{type:"Int16",name:"y2"},{type:"Uint32",name:"featureIndex"},{type:"Uint16",name:"sourceLayerIndex"},{type:"Uint16",name:"bucketIndex"}]),Js=Y([{name:"a_pos",components:2,type:"Int16"},{name:"a_anchor_pos",components:2,type:"Int16"},{name:"a_extrude",components:2,type:"Int16"}],4),Gw=Y([{name:"a_pos",components:2,type:"Float32"},{name:"a_radius",components:1,type:"Float32"},{name:"a_flags",components:2,type:"Int16"}],4),qw=Y([{name:"triangle",components:3,type:"Uint16"}]),jw=Y([{type:"Int16",name:"anchorX"},{type:"Int16",name:"anchorY"},{type:"Uint16",name:"glyphStartIndex"},{type:"Uint16",name:"numGlyphs"},{type:"Uint32",name:"vertexStartIndex"},{type:"Uint32",name:"lineStartIndex"},{type:"Uint32",name:"lineLength"},{type:"Uint16",name:"segment"},{type:"Uint16",name:"lowerSize"},{type:"Uint16",name:"upperSize"},{type:"Float32",name:"lineOffsetX"},{type:"Float32",name:"lineOffsetY"},{type:"Uint8",name:"writingMode"},{type:"Uint8",name:"placedOrientation"},{type:"Uint8",name:"hidden"},{type:"Uint32",name:"crossTileID"},{type:"Int16",name:"associatedIconIndex"}]),Jw=Y([{type:"Int16",name:"anchorX"},{type:"Int16",name:"anchorY"},{type:"Int16",name:"rightJustifiedTextSymbolIndex"},{type:"Int16",name:"centerJustifiedTextSymbolIndex"},{type:"Int16",name:"leftJustifiedTextSymbolIndex"},{type:"Int16",name:"verticalPlacedTextSymbolIndex"},{type:"Int16",name:"placedIconSymbolIndex"},{type:"Int16",name:"verticalPlacedIconSymbolIndex"},{type:"Uint16",name:"key"},{type:"Uint16",name:"textBoxStartIndex"},{type:"Uint16",name:"textBoxEndIndex"},{type:"Uint16",name:"verticalTextBoxStartIndex"},{type:"Uint16",name:"verticalTextBoxEndIndex"},{type:"Uint16",name:"iconBoxStartIndex"},{type:"Uint16",name:"iconBoxEndIndex"},{type:"Uint16",name:"verticalIconBoxStartIndex"},{type:"Uint16",name:"verticalIconBoxEndIndex"},{type:"Uint16",name:"featureIndex"},{type:"Uint16",name:"numHorizontalGlyphVertices"},{type:"Uint16",name:"numVerticalGlyphVertices"},{type:"Uint16",name:"numIconVertices"},{type:"Uint16",name:"numVerticalIconVertices"},{type:"Uint16",name:"useRuntimeCollisionCircles"},{type:"Uint32",name:"crossTileID"},{type:"Float32",name:"textBoxScale"},{type:"Float32",name:"collisionCircleDiameter"},{type:"Uint16",name:"textAnchorOffsetStartIndex"},{type:"Uint16",name:"textAnchorOffsetEndIndex"}]),Zw=Y([{type:"Float32",name:"offsetX"}]),Ww=Y([{type:"Int16",name:"x"},{type:"Int16",name:"y"},{type:"Int16",name:"tileUnitDistanceFromAnchor"}]),Hw=Y([{type:"Uint16",name:"textAnchor"},{type:"Float32",components:2,name:"textOffset"}]);var ii=Z(he(),1);function Nx(e,t,r){let n=t.layout.get("text-transform").evaluate(r,{});return n==="uppercase"?e=e.toLocaleUpperCase():n==="lowercase"&&(e=e.toLocaleLowerCase()),ye.applyArabicShaping&&(e=ye.applyArabicShaping(e)),e}function qp(e,t,r){return e.sections.forEach(n=>{n.text=Nx(n.text,t,r)}),e}function jp(e){let t={},r={},n=[],i=0;function o(u){n.push(e[u]),i++}function a(u,c,p){let f=r[u];return delete r[u],r[c]=f,n[f].geometry[0].pop(),n[f].geometry[0]=n[f].geometry[0].concat(p[0]),f}function s(u,c,p){let f=t[c];return delete t[c],t[u]=f,n[f].geometry[0].shift(),n[f].geometry[0]=p[0].concat(n[f].geometry[0]),f}function l(u,c,p){let f=p?c[0][c[0].length-1]:c[0][0];return"".concat(u,":").concat(f.x,":").concat(f.y)}for(let u=0;u<e.length;u++){let c=e[u],p=c.geometry,f=c.text?c.text.toString():null;if(!f){o(u);continue}let y=l(f,p),m=l(f,p,!0);if(y in r&&m in t&&r[y]!==t[m]){let h=s(y,m,p),d=a(y,m,n[h].geometry);delete t[y],delete r[m],r[l(f,n[d].geometry,!0)]=d,n[h].geometry=null}else y in r?a(y,m,p):m in t?s(y,m,p):(o(u),t[y]=i-1,r[m]=i-1)}return n.filter(u=>u.geometry)}var kr={"!":"\\uFE15","#":"\\uFF03",$:"\\uFF04","%":"\\uFF05","&":"\\uFF06","(":"\\uFE35",")":"\\uFE36","*":"\\uFF0A","+":"\\uFF0B",",":"\\uFE10","-":"\\uFE32",".":"\\u30FB","/":"\\uFF0F",":":"\\uFE13",";":"\\uFE14","<":"\\uFE3F","=":"\\uFF1D",">":"\\uFE40","?":"\\uFE16","@":"\\uFF20","[":"\\uFE47","\\\\":"\\uFF3C","]":"\\uFE48","^":"\\uFF3E",_:"\\uFE33","\`":"\\uFF40","{":"\\uFE37","|":"\\u2015","}":"\\uFE38","~":"\\uFF5E","\\xA2":"\\uFFE0","\\xA3":"\\uFFE1","\\xA5":"\\uFFE5","\\xA6":"\\uFFE4","\\xAC":"\\uFFE2","\\xAF":"\\uFFE3","\\u2013":"\\uFE32","\\u2014":"\\uFE31","\\u2018":"\\uFE43","\\u2019":"\\uFE44","\\u201C":"\\uFE41","\\u201D":"\\uFE42","\\u2026":"\\uFE19","\\u2027":"\\u30FB","\\u20A9":"\\uFFE6","\\u3001":"\\uFE11","\\u3002":"\\uFE12","\\u3008":"\\uFE3F","\\u3009":"\\uFE40","\\u300A":"\\uFE3D","\\u300B":"\\uFE3E","\\u300C":"\\uFE41","\\u300D":"\\uFE42","\\u300E":"\\uFE43","\\u300F":"\\uFE44","\\u3010":"\\uFE3B","\\u3011":"\\uFE3C","\\u3014":"\\uFE39","\\u3015":"\\uFE3A","\\u3016":"\\uFE17","\\u3017":"\\uFE18","\\uFF01":"\\uFE15","\\uFF08":"\\uFE35","\\uFF09":"\\uFE36","\\uFF0C":"\\uFE10","\\uFF0D":"\\uFE32","\\uFF0E":"\\u30FB","\\uFF1A":"\\uFE13","\\uFF1B":"\\uFE14","\\uFF1C":"\\uFE3F","\\uFF1E":"\\uFE40","\\uFF1F":"\\uFE16","\\uFF3B":"\\uFE47","\\uFF3D":"\\uFE48","\\uFF3F":"\\uFE33","\\uFF5B":"\\uFE37","\\uFF5C":"\\u2015","\\uFF5D":"\\uFE38","\\uFF5F":"\\uFE35","\\uFF60":"\\uFE36","\\uFF61":"\\uFE12","\\uFF62":"\\uFE41","\\uFF63":"\\uFE42"};function Jp(e){let t="";for(let r=0;r<e.length;r++){let n=e.charCodeAt(r+1)||null,i=e.charCodeAt(r-1)||null;(!n||!Ps(n)||kr[e[r+1]])&&(!i||!Ps(i)||kr[e[r-1]])&&kr[e[r]]?t+=kr[e[r]]:t+=e[r]}return t}var ne=24;var ib=Z(Qn(),1),ob=3;var Qo=ob;function ei(e){let t=0,r=0;for(let s of e)t+=s.w*s.h,r=Math.max(r,s.w);e.sort((s,l)=>l.h-s.h);let i=[{x:0,y:0,w:Math.max(Math.ceil(Math.sqrt(t/.95)),r),h:1/0}],o=0,a=0;for(let s of e)for(let l=i.length-1;l>=0;l--){let u=i[l];if(!(s.w>u.w||s.h>u.h)){if(s.x=u.x,s.y=u.y,a=Math.max(a,s.y+s.h),o=Math.max(o,s.x+s.w),s.w===u.w&&s.h===u.h){let c=i.pop();l<i.length&&(i[l]=c)}else s.h===u.h?(u.x+=s.w,u.w-=s.w):s.w===u.w?(u.y+=s.h,u.h-=s.h):(i.push({x:u.x+s.w,y:u.y,w:u.w-s.w,h:s.h}),u.y+=s.h,u.h-=s.h);break}}return{w:o,h:a,fill:t/(o*a)||0}}var ge=1;var ea=class{constructor(t,{pixelRatio:r,version:n,stretchX:i,stretchY:o,content:a}){this.paddedRect=t,this.pixelRatio=r,this.stretchX=i,this.stretchY=o,this.content=a,this.version=n}get tl(){return[this.paddedRect.x+ge,this.paddedRect.y+ge]}get br(){return[this.paddedRect.x+this.paddedRect.w-ge,this.paddedRect.y+this.paddedRect.h-ge]}get tlbr(){return this.tl.concat(this.br)}get displaySize(){return[(this.paddedRect.w-ge*2)/this.pixelRatio,(this.paddedRect.h-ge*2)/this.pixelRatio]}},ti=class{constructor(t,r){let n={},i={};this.haveRenderCallbacks=[];let o=[];this.addImages(t,n,o),this.addImages(r,i,o);let{w:a,h:s}=ei(o),l=new de({width:a||1,height:s||1});for(let u in t){let c=t[u],p=n[u].paddedRect;de.copy(c.data,l,{x:0,y:0},{x:p.x+ge,y:p.y+ge},c.data)}for(let u in r){let c=r[u],p=i[u].paddedRect,f=p.x+ge,y=p.y+ge,m=c.data.width,h=c.data.height;de.copy(c.data,l,{x:0,y:0},{x:f,y},c.data),de.copy(c.data,l,{x:0,y:h-1},{x:f,y:y-1},{width:m,height:1}),de.copy(c.data,l,{x:0,y:0},{x:f,y:y+h},{width:m,height:1}),de.copy(c.data,l,{x:m-1,y:0},{x:f-1,y},{width:1,height:h}),de.copy(c.data,l,{x:0,y:0},{x:f+m,y},{width:1,height:h})}this.image=l,this.iconPositions=n,this.patternPositions=i}addImages(t,r,n){for(let i in t){let o=t[i],a={x:0,y:0,w:o.data.width+2*ge,h:o.data.height+2*ge};n.push(a),r[i]=new ea(a,o),o.hasRenderCallback&&this.haveRenderCallbacks.push(i)}}patchUpdatedImages(t,r){t.dispatchRenderCallbacks(this.haveRenderCallbacks);for(let n in t.updatedImages)this.patchUpdatedImage(this.iconPositions[n],t.getImage(n),r),this.patchUpdatedImage(this.patternPositions[n],t.getImage(n),r)}patchUpdatedImage(t,r,n){if(!t||!r||t.version===r.version)return;t.version=r.version;let[i,o]=t.tl;n.update(r.data,void 0,{x:i,y:o})}};C("ImagePosition",ea);C("ImageAtlas",ti);var na=(i=>(i[i.none=0]="none",i[i.horizontal=1]="horizontal",i[i.vertical=2]="vertical",i[i.horizontalOnly=3]="horizontalOnly",i))(na||{}),Fr=-17;function ab(e){for(let t of e)if(t.positionedGlyphs.length!==0)return!1;return!0}var Qp=57344,ef=63743,ta=class e{constructor(){this.scale=1,this.fontStack="",this.imageName=null}static forText(t,r){let n=new e;return n.scale=t||1,n.fontStack=r,n}static forImage(t){let r=new e;return r.imageName=t,r}},ri=class e{constructor(){this.text="",this.sectionIndex=[],this.sections=[],this.imageSectionID=null}static fromFeature(t,r){let n=new e;for(let i=0;i<t.sections.length;i++){let o=t.sections[i];o.image?n.addImageSection(o):n.addTextSection(o,r)}return n}length(){return this.text.length}getSection(t){return this.sections[this.sectionIndex[t]]}getSectionIndex(t){return this.sectionIndex[t]}getCharCode(t){return this.text.charCodeAt(t)}verticalizePunctuation(){this.text=Jp(this.text)}trim(){let t=0;for(let n=0;n<this.text.length&&ra[this.text.charCodeAt(n)];n++)t++;let r=this.text.length;for(let n=this.text.length-1;n>=0&&n>=t&&ra[this.text.charCodeAt(n)];n--)r--;this.text=this.text.substring(t,r),this.sectionIndex=this.sectionIndex.slice(t,r)}substring(t,r){let n=new e;return n.text=this.text.substring(t,r),n.sectionIndex=this.sectionIndex.slice(t,r),n.sections=this.sections,n}toString(){return this.text}getMaxScale(){return this.sectionIndex.reduce((t,r)=>Math.max(t,this.sections[r].scale),0)}addTextSection(t,r){this.text+=t.text,this.sections.push(ta.forText(t.scale,t.fontStack||r));let n=this.sections.length-1;for(let i=0;i<t.text.length;++i)this.sectionIndex.push(n)}addImageSection(t){let r=t.image?t.image.name:"";if(r.length===0){fe("Can't add FormattedSection with an empty image.");return}let n=this.getNextImageSectionCharCode();if(!n){fe("Reached maximum number of images ".concat(ef-Qp+2));return}this.text+=String.fromCharCode(n),this.sections.push(ta.forImage(r)),this.sectionIndex.push(this.sections.length-1)}getNextImageSectionCharCode(){return this.imageSectionID?this.imageSectionID>=ef?null:++this.imageSectionID:(this.imageSectionID=Qp,this.imageSectionID)}};function sb(e,t){let r=[],n=e.text,i=0;for(let o of t)r.push(e.substring(i,o)),i=o;return i<n.length&&r.push(e.substring(i,n.length)),r}function ni(e,t,r,n,i,o,a,s,l,u,c,p,f,y,m,h){let d=ri.fromFeature(e,i);p===2&&d.verticalizePunctuation();let g,{processBidirectionalText:b,processStyledBidirectionalText:x}=ye;if(b&&d.sections.length===1){g=[];let w=b(d.toString(),Hs(d,u,o,t,n,y,m));for(let T of w){let F=new ri;F.text=T,F.sections=d.sections;for(let E=0;E<T.length;E++)F.sectionIndex.push(0);g.push(F)}}else if(x){g=[];let w=x(d.text,d.sectionIndex,Hs(d,u,o,t,n,y,m));for(let T of w){let F=new ri;F.text=T[0],F.sectionIndex=T[1],F.sections=d.sections,g.push(F)}}else g=sb(d,Hs(d,u,o,t,n,y,m));let v=[],P={positionedLines:v,text:d.toString(),top:c[1],bottom:c[1],left:c[0],right:c[0],writingMode:p,iconsInText:!1,verticalizable:!1};return pb(P,t,r,n,g,a,s,l,p,u,f,h),ab(v)?!1:P}var ra={9:!0,10:!0,11:!0,12:!0,13:!0,32:!0},lb={10:!0,32:!0,38:!0,40:!0,41:!0,43:!0,45:!0,47:!0,173:!0,183:!0,8203:!0,8208:!0,8211:!0,8231:!0};function nf(e,t,r,n,i,o){if(t.imageName){let a=n[t.imageName];return a?a.displaySize[0]*t.scale*ne/o+i:0}else{let a=r[t.fontStack],s=a&&a[e];return s?s.metrics.advance*t.scale+i:0}}function ub(e,t,r,n,i,o){let a=0;for(let l=0;l<e.length();l++){let u=e.getSection(l);a+=nf(e.getCharCode(l),u,n,i,t,o)}let s=Math.max(1,Math.ceil(a/r));return a/s}function tf(e,t,r,n){let i=Math.pow(e-t,2);return n?e<t?i/2:i*2:i+Math.abs(r)*r}function cb(e,t,r){let n=0;return e===10&&(n-=1e4),r&&(n+=150),(e===40||e===65288)&&(n+=50),(t===41||t===65289)&&(n+=50),n}function rf(e,t,r,n,i,o){let a=null,s=tf(t,r,i,o);for(let l of n){let u=t-l.x,c=tf(u,r,i,o)+l.badness;c<=s&&(a=l,s=c)}return{index:e,x:t,priorBreak:a,badness:s}}function of(e){return e?of(e.priorBreak).concat(e.index):[]}function Hs(e,t,r,n,i,o,a){if(o!=="point")return[];if(!e)return[];let s=[],l=ub(e,t,r,n,i,a),u=e.text.indexOf("\\u200B")>=0,c=0;for(let p=0;p<e.length();p++){let f=e.getSection(p),y=e.getCharCode(p);if(ra[y]||(c+=nf(y,f,n,i,t,a)),p<e.length()-1){let m=dc(y);(lb[y]||m||f.imageName)&&s.push(rf(p+1,c,l,s,cb(y,e.getCharCode(p+1),m&&u),!1))}}return of(rf(e.length(),c,l,s,0,!0))}function af(e){let t=.5,r=.5;switch(e){case"right":case"top-right":case"bottom-right":t=1;break;case"left":case"top-left":case"bottom-left":t=0;break}switch(e){case"bottom":case"bottom-right":case"bottom-left":r=1;break;case"top":case"top-right":case"top-left":r=0;break}return{horizontalAlign:t,verticalAlign:r}}function pb(e,t,r,n,i,o,a,s,l,u,c,p){let f=0,y=Fr,m=0,h=0,d=s==="right"?1:s==="left"?0:.5,g=0;for(let P of i){P.trim();let w=P.getMaxScale(),T=(w-1)*ne,F={positionedGlyphs:[],lineOffset:0};e.positionedLines[g]=F;let E=F.positionedGlyphs,_=0;if(!P.length()){y+=o,++g;continue}for(let k=0;k<P.length();k++){let V=P.getSection(k),A=P.getSectionIndex(k),z=P.getCharCode(k),O=0,N=null,K=null,xe=null,X=ne,le=!(l===1||!c&&!oo(z)||c&&(ra[z]||gc(z)));if(V.imageName){let ce=n[V.imageName];if(!ce)continue;xe=V.imageName,e.iconsInText=e.iconsInText||!0,K=ce.paddedRect;let pe=ce.displaySize;V.scale=V.scale*ne/p,N={width:pe[0],height:pe[1],left:ge,top:-Qo,advance:le?pe[1]:pe[0]};let _e=ne-pe[1]*V.scale;O=T+_e,X=N.advance;let be=le?pe[0]*V.scale-ne*w:pe[1]*V.scale-ne*w;be>0&&be>_&&(_=be)}else{let ce=r[V.fontStack],pe=ce&&ce[z];if(pe&&pe.rect)K=pe.rect,N=pe.metrics;else{let _e=t[V.fontStack],be=_e&&_e[z];if(!be)continue;N=be.metrics}O=(w-V.scale)*ne}le?(e.verticalizable=!0,E.push({glyph:z,imageName:xe,x:f,y:y+O,vertical:le,scale:V.scale,fontStack:V.fontStack,sectionIndex:A,metrics:N,rect:K}),f+=X*V.scale+u):(E.push({glyph:z,imageName:xe,x:f,y:y+O,vertical:le,scale:V.scale,fontStack:V.fontStack,sectionIndex:A,metrics:N,rect:K}),f+=N.advance*V.scale+u)}if(E.length!==0){let k=f-u;m=Math.max(k,m),fb(E,0,E.length-1,d,_)}f=0;let I=o*w+_;F.lineOffset=Math.max(_,T),y+=I,h=Math.max(I,h),++g}let b=y-Fr,{horizontalAlign:x,verticalAlign:v}=af(a);yb(e.positionedLines,d,x,v,m,h,o,b,i.length),e.top+=-v*b,e.bottom=e.top+b,e.left+=-x*m,e.right=e.left+m}function fb(e,t,r,n,i){if(!n&&!i)return;let o=e[r],a=o.metrics.advance*o.scale,s=(e[r].x+a)*n;for(let l=t;l<=r;l++)e[l].x-=s,e[l].y+=i}function yb(e,t,r,n,i,o,a,s,l){let u=(t-r)*i,c=0;o!==a?c=-s*n-Fr:c=(-n*l+.5)*a;for(let p of e)for(let f of p.positionedGlyphs)f.x+=u,f.y+=c}function sf(e,t,r){let{horizontalAlign:n,verticalAlign:i}=af(r),o=t[0],a=t[1],s=o-e.displaySize[0]*n,l=s+e.displaySize[0],u=a-e.displaySize[1]*i,c=u+e.displaySize[1];return{image:e,top:u,bottom:c,left:s,right:l}}function Xs(e,t,r,n,i,o){let a=e.image,s;if(a.content){let d=a.content,g=a.pixelRatio||1;s=[d[0]/g,d[1]/g,a.displaySize[0]-d[2]/g,a.displaySize[1]-d[3]/g]}let l=t.left*o,u=t.right*o,c,p,f,y;r==="width"||r==="both"?(y=i[0]+l-n[3],p=i[0]+u+n[1]):(y=i[0]+(l+u-a.displaySize[0])/2,p=y+a.displaySize[0]);let m=t.top*o,h=t.bottom*o;return r==="height"||r==="both"?(c=i[1]+m-n[0],f=i[1]+h+n[2]):(c=i[1]+(m+h-a.displaySize[1])/2,f=c+a.displaySize[1]),{image:a,top:c,right:p,bottom:f,left:y,collisionPadding:s}}var lf=Z(Tt(),1);var Lr=255,Ct=128,tt=Lr*Ct;function Ks(e,t){let{expression:r}=t;if(r.kind==="constant")return{kind:"constant",layoutSize:r.evaluate(new q(e+1))};if(r.kind==="source")return{kind:"source"};{let{zoomStops:n,interpolationType:i}=r,o=0;for(;o<n.length&&n[o]<=e;)o++;o=Math.max(0,o-1);let a=o;for(;a<n.length&&n[a]<e+1;)a++;a=Math.min(n.length-1,a);let s=n[o],l=n[a];if(r.kind==="composite")return{kind:"composite",minZoom:s,maxZoom:l,interpolationType:i};let u=r.evaluate(new q(s)),c=r.evaluate(new q(l));return{kind:"camera",minZoom:s,maxZoom:l,minSize:u,maxSize:c,interpolationType:i}}}function Ys(e,t,r){let n="never",i=e.get(t);return i?n=i:e.get(r)&&(n="always"),n}var mb=lf.default.VectorTileFeature.types,hb=[{name:"a_fade_opacity",components:1,type:"Uint8",offset:0}];function ia(e,t,r,n,i,o,a,s,l,u,c,p,f){let y=s?Math.min(tt,Math.round(s[0])):0,m=s?Math.min(tt,Math.round(s[1])):0;e.emplaceBack(t,r,Math.round(n*32),Math.round(i*32),o,a,(y<<1)+(l?1:0),m,u*16,c*16,p*256,f*256)}function uf(e,t,r){e.emplaceBack(t.x,t.y,r),e.emplaceBack(t.x,t.y,r),e.emplaceBack(t.x,t.y,r),e.emplaceBack(t.x,t.y,r)}function db(e){for(let t of e.sections)if(bc(t.text))return!0;return!1}var oi=class{constructor(t){this.layoutVertexArray=new Io,this.indexArray=new Le,this.programConfigurations=t,this.segments=new me,this.dynamicLayoutVertexArray=new To,this.opacityVertexArray=new Co,this.hasVisibleVertices=!1,this.placedSymbolArray=new Ln}isEmpty(){return this.layoutVertexArray.length===0&&this.indexArray.length===0&&this.dynamicLayoutVertexArray.length===0&&this.opacityVertexArray.length===0}upload(t,r,n,i){this.isEmpty()||(n&&(this.layoutVertexBuffer=t.createVertexBuffer(this.layoutVertexArray,Up.members),this.indexBuffer=t.createIndexBuffer(this.indexArray,r),this.dynamicLayoutVertexBuffer=t.createVertexBuffer(this.dynamicLayoutVertexArray,$p.members,!0),this.opacityVertexBuffer=t.createVertexBuffer(this.opacityVertexArray,hb,!0),this.opacityVertexBuffer.itemSize=1),(n||i)&&this.programConfigurations.upload(t))}destroy(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.programConfigurations.destroy(),this.segments.destroy(),this.dynamicLayoutVertexBuffer.destroy(),this.opacityVertexBuffer.destroy())}};C("SymbolBuffers",oi);var ai=class{constructor(t,r,n){this.layoutVertexArray=new t,this.layoutAttributes=r,this.indexArray=new n,this.segments=new me,this.collisionVertexArray=new ko}upload(t){this.layoutVertexBuffer=t.createVertexBuffer(this.layoutVertexArray,this.layoutAttributes),this.indexBuffer=t.createIndexBuffer(this.indexArray),this.collisionVertexBuffer=t.createVertexBuffer(this.collisionVertexArray,Gp.members,!0)}destroy(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.segments.destroy(),this.collisionVertexBuffer.destroy())}};C("CollisionBuffers",ai);var He=class{constructor(t){this.collisionBoxArray=t.collisionBoxArray,this.zoom=t.zoom,this.overscaling=t.overscaling,this.layers=t.layers,this.layerIds=this.layers.map(l=>l.id),this.index=t.index,this.pixelRatio=t.pixelRatio,this.sourceLayerIndex=t.sourceLayerIndex,this.hasPattern=!1,this.hasRTLText=!1,this.sortKeyRanges=[],this.collisionCircleArray=[],this.placementInvProjMatrix=jn.identity([]),this.placementViewportMatrix=jn.identity([]);let n=this.layers[0]._unevaluatedLayout._values;this.textSizeData=Ks(this.zoom,n["text-size"]),this.iconSizeData=Ks(this.zoom,n["icon-size"]);let i=this.layers[0].layout,o=i.get("symbol-sort-key"),a=i.get("symbol-z-order");this.canOverlap=Ys(i,"text-overlap","text-allow-overlap")!=="never"||Ys(i,"icon-overlap","icon-allow-overlap")!=="never"||i.get("text-ignore-placement")||i.get("icon-ignore-placement"),this.sortFeaturesByKey=a!=="viewport-y"&&!o.isConstant();let s=a==="viewport-y"||a==="auto"&&!this.sortFeaturesByKey;this.sortFeaturesByY=s&&this.canOverlap,i.get("symbol-placement")==="point"&&(this.writingModes=i.get("text-writing-mode").map(l=>na[l])),this.stateDependentLayerIds=this.layers.filter(l=>l.isStateDependent()).map(l=>l.id),this.sourceID=t.sourceID}createArrays(){this.text=new oi(new Ce(this.layers,this.zoom,t=>/^text/.test(t))),this.icon=new oi(new Ce(this.layers,this.zoom,t=>/^icon/.test(t))),this.glyphOffsetArray=new Vn,this.lineVertexArray=new Bn,this.symbolInstances=new Dn,this.textAnchorOffsets=new zn}calculateGlyphDependencies(t,r,n,i,o){for(let a=0;a<t.length;a++)if(r[t.charCodeAt(a)]=!0,(n||i)&&o){let s=kr[t.charAt(a)];s&&(r[s.charCodeAt(0)]=!0)}}populate(t,r,n){let i=this.layers[0],o=i.layout,a=o.get("text-font"),s=o.get("text-field"),l=o.get("icon-image"),u=(s.value.kind!=="constant"||s.value.value instanceof Fe&&!s.value.value.isEmpty()||s.value.value.toString().length>0)&&(a.value.kind!=="constant"||a.value.value.length>0),c=l.value.kind!=="constant"||!!l.value.value||Object.keys(l.parameters).length>0,p=o.get("symbol-sort-key");if(this.features=[],!u&&!c)return;let f=r.iconDependencies,y=r.glyphDependencies,m=r.availableImages,h=new q(this.zoom);for(let{feature:d,id:g,index:b,sourceLayerIndex:x}of t){let v=i._featureFilter.needGeometry,P=$e(d,v);if(!i._featureFilter.filter(h,P,n))continue;v||(P.geometry=ke(d));let w;if(u){let _=i.getValueAndResolveTokens("text-field",P,n,m),I=Fe.factory(_),k=this.hasRTLText=this.hasRTLText||db(I);(!k||ye.getRTLTextPluginStatus()==="unavailable"||k&&ye.isParsed())&&(w=qp(I,i,P))}let T;if(c){let _=i.getValueAndResolveTokens("icon-image",P,n,m);_ instanceof Te?T=_:T=Te.fromString(_)}if(!w&&!T)continue;let F=this.sortFeaturesByKey?p.evaluate(P,{},n):void 0,E={id:g,text:w,icon:T,index:b,sourceLayerIndex:x,geometry:P.geometry,properties:d.properties,type:mb[d.type],sortKey:F};if(this.features.push(E),T&&(f[T.name]=!0),w){let _=a.evaluate(P,{},n).join(","),I=o.get("text-rotation-alignment")!=="viewport"&&o.get("symbol-placement")!=="point";this.allowVerticalPlacement=this.writingModes&&this.writingModes.indexOf(2)>=0;for(let k of w.sections)if(k.image)f[k.image.name]=!0;else{let V=mn(w.toString()),A=k.fontStack||_,z=y[A]=y[A]||{};this.calculateGlyphDependencies(k.text,z,I,this.allowVerticalPlacement,V)}}}o.get("symbol-placement")==="line"&&(this.features=jp(this.features)),this.sortFeaturesByKey&&this.features.sort((d,g)=>d.sortKey-g.sortKey)}update(t,r,n){this.stateDependentLayers.length&&(this.text.programConfigurations.updatePaintArrays(t,r,this.layers,n),this.icon.programConfigurations.updatePaintArrays(t,r,this.layers,n))}isEmpty(){return this.symbolInstances.length===0&&!this.hasRTLText}uploadPending(){return!this.uploaded||this.text.programConfigurations.needsUpload||this.icon.programConfigurations.needsUpload}upload(t){!this.uploaded&&this.hasDebugData()&&(this.textCollisionBox.upload(t),this.iconCollisionBox.upload(t)),this.text.upload(t,this.sortFeaturesByY,!this.uploaded,this.text.programConfigurations.needsUpload),this.icon.upload(t,this.sortFeaturesByY,!this.uploaded,this.icon.programConfigurations.needsUpload),this.uploaded=!0}destroyDebugData(){this.textCollisionBox.destroy(),this.iconCollisionBox.destroy()}destroy(){this.text.destroy(),this.icon.destroy(),this.hasDebugData()&&this.destroyDebugData()}addToLineVertexArray(t,r){let n=this.lineVertexArray.length;if(t.segment!==void 0){let i=t.dist(r[t.segment+1]),o=t.dist(r[t.segment]),a={};for(let s=t.segment+1;s<r.length;s++)a[s]={x:r[s].x,y:r[s].y,tileUnitDistanceFromAnchor:i},s<r.length-1&&(i+=r[s+1].dist(r[s]));for(let s=t.segment||0;s>=0;s--)a[s]={x:r[s].x,y:r[s].y,tileUnitDistanceFromAnchor:o},s>0&&(o+=r[s-1].dist(r[s]));for(let s=0;s<r.length;s++){let l=a[s];this.lineVertexArray.emplaceBack(l.x,l.y,l.tileUnitDistanceFromAnchor)}}return{lineStartIndex:n,lineLength:this.lineVertexArray.length-n}}addSymbols(t,r,n,i,o,a,s,l,u,c,p,f){let y=t.indexArray,m=t.layoutVertexArray,h=t.segments.prepareSegment(4*r.length,m,y,this.canOverlap?a.sortKey:void 0),d=this.glyphOffsetArray.length,g=h.vertexLength,b=this.allowVerticalPlacement&&s===2?Math.PI/2:0,x=a.text&&a.text.sections;for(let v=0;v<r.length;v++){let{tl:P,tr:w,bl:T,br:F,tex:E,pixelOffsetTL:_,pixelOffsetBR:I,minFontScaleX:k,minFontScaleY:V,glyphOffset:A,isSDF:z,sectionIndex:O}=r[v],N=h.vertexLength,K=A[1];ia(m,l.x,l.y,P.x,K+P.y,E.x,E.y,n,z,_.x,_.y,k,V),ia(m,l.x,l.y,w.x,K+w.y,E.x+E.w,E.y,n,z,I.x,_.y,k,V),ia(m,l.x,l.y,T.x,K+T.y,E.x,E.y+E.h,n,z,_.x,I.y,k,V),ia(m,l.x,l.y,F.x,K+F.y,E.x+E.w,E.y+E.h,n,z,I.x,I.y,k,V),uf(t.dynamicLayoutVertexArray,l,b),y.emplaceBack(N,N+1,N+2),y.emplaceBack(N+1,N+2,N+3),h.vertexLength+=4,h.primitiveLength+=2,this.glyphOffsetArray.emplaceBack(A[0]),(v===r.length-1||O!==r[v+1].sectionIndex)&&t.programConfigurations.populatePaintArrays(m.length,a,a.index,{},f,x&&x[O])}t.placedSymbolArray.emplaceBack(l.x,l.y,d,this.glyphOffsetArray.length-d,g,u,c,l.segment,n?n[0]:0,n?n[1]:0,i[0],i[1],s,0,!1,0,p)}_addCollisionDebugVertex(t,r,n,i,o,a){return r.emplaceBack(0,0),t.emplaceBack(n.x,n.y,i,o,Math.round(a.x),Math.round(a.y))}addCollisionDebugVertices(t,r,n,i,o,a,s){let l=o.segments.prepareSegment(4,o.layoutVertexArray,o.indexArray),u=l.vertexLength,c=o.layoutVertexArray,p=o.collisionVertexArray,f=s.anchorX,y=s.anchorY;this._addCollisionDebugVertex(c,p,a,f,y,new ii.default(t,r)),this._addCollisionDebugVertex(c,p,a,f,y,new ii.default(n,r)),this._addCollisionDebugVertex(c,p,a,f,y,new ii.default(n,i)),this._addCollisionDebugVertex(c,p,a,f,y,new ii.default(t,i)),l.vertexLength+=4;let m=o.indexArray;m.emplaceBack(u,u+1),m.emplaceBack(u+1,u+2),m.emplaceBack(u+2,u+3),m.emplaceBack(u+3,u),l.primitiveLength+=4}addDebugCollisionBoxes(t,r,n,i){for(let o=t;o<r;o++){let a=this.collisionBoxArray.get(o),s=a.x1,l=a.y1,u=a.x2,c=a.y2;this.addCollisionDebugVertices(s,l,u,c,i?this.textCollisionBox:this.iconCollisionBox,a.anchorPoint,n)}}generateCollisionDebugBuffers(){this.hasDebugData()&&this.destroyDebugData(),this.textCollisionBox=new ai(On,Js.members,wt),this.iconCollisionBox=new ai(On,Js.members,wt);for(let t=0;t<this.symbolInstances.length;t++){let r=this.symbolInstances.get(t);this.addDebugCollisionBoxes(r.textBoxStartIndex,r.textBoxEndIndex,r,!0),this.addDebugCollisionBoxes(r.verticalTextBoxStartIndex,r.verticalTextBoxEndIndex,r,!0),this.addDebugCollisionBoxes(r.iconBoxStartIndex,r.iconBoxEndIndex,r,!1),this.addDebugCollisionBoxes(r.verticalIconBoxStartIndex,r.verticalIconBoxEndIndex,r,!1)}}_deserializeCollisionBoxesForSymbol(t,r,n,i,o,a,s,l,u){let c={};for(let p=r;p<n;p++){let f=t.get(p);c.textBox={x1:f.x1,y1:f.y1,x2:f.x2,y2:f.y2,anchorPointX:f.anchorPointX,anchorPointY:f.anchorPointY},c.textFeatureIndex=f.featureIndex;break}for(let p=i;p<o;p++){let f=t.get(p);c.verticalTextBox={x1:f.x1,y1:f.y1,x2:f.x2,y2:f.y2,anchorPointX:f.anchorPointX,anchorPointY:f.anchorPointY},c.verticalTextFeatureIndex=f.featureIndex;break}for(let p=a;p<s;p++){let f=t.get(p);c.iconBox={x1:f.x1,y1:f.y1,x2:f.x2,y2:f.y2,anchorPointX:f.anchorPointX,anchorPointY:f.anchorPointY},c.iconFeatureIndex=f.featureIndex;break}for(let p=l;p<u;p++){let f=t.get(p);c.verticalIconBox={x1:f.x1,y1:f.y1,x2:f.x2,y2:f.y2,anchorPointX:f.anchorPointX,anchorPointY:f.anchorPointY},c.verticalIconFeatureIndex=f.featureIndex;break}return c}deserializeCollisionBoxes(t){this.collisionArrays=[];for(let r=0;r<this.symbolInstances.length;r++){let n=this.symbolInstances.get(r);this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t,n.textBoxStartIndex,n.textBoxEndIndex,n.verticalTextBoxStartIndex,n.verticalTextBoxEndIndex,n.iconBoxStartIndex,n.iconBoxEndIndex,n.verticalIconBoxStartIndex,n.verticalIconBoxEndIndex))}}hasTextData(){return this.text.segments.get().length>0}hasIconData(){return this.icon.segments.get().length>0}hasDebugData(){return this.textCollisionBox&&this.iconCollisionBox}hasTextCollisionBoxData(){return this.hasDebugData()&&this.textCollisionBox.segments.get().length>0}hasIconCollisionBoxData(){return this.hasDebugData()&&this.iconCollisionBox.segments.get().length>0}addIndicesForPlacedSymbol(t,r){let n=t.placedSymbolArray.get(r),i=n.vertexStartIndex+n.numGlyphs*4;for(let o=n.vertexStartIndex;o<i;o+=4)t.indexArray.emplaceBack(o,o+1,o+2),t.indexArray.emplaceBack(o+1,o+2,o+3)}getSortedSymbolIndexes(t){if(this.sortedAngle===t&&this.symbolInstanceIndexes!==void 0)return this.symbolInstanceIndexes;let r=Math.sin(t),n=Math.cos(t),i=[],o=[],a=[];for(let s=0;s<this.symbolInstances.length;++s){a.push(s);let l=this.symbolInstances.get(s);i.push(Math.round(r*l.anchorX+n*l.anchorY)|0),o.push(l.featureIndex)}return a.sort((s,l)=>i[s]-i[l]||o[l]-o[s]),a}addToSortKeyRanges(t,r){let n=this.sortKeyRanges[this.sortKeyRanges.length-1];n&&n.sortKey===r?n.symbolInstanceEnd=t+1:this.sortKeyRanges.push({sortKey:r,symbolInstanceStart:t,symbolInstanceEnd:t+1})}sortFeatures(t){if(this.sortFeaturesByY&&this.sortedAngle!==t&&!(this.text.segments.get().length>1||this.icon.segments.get().length>1)){this.symbolInstanceIndexes=this.getSortedSymbolIndexes(t),this.sortedAngle=t,this.text.indexArray.clear(),this.icon.indexArray.clear(),this.featureSortOrder=[];for(let r of this.symbolInstanceIndexes){let n=this.symbolInstances.get(r);this.featureSortOrder.push(n.featureIndex),[n.rightJustifiedTextSymbolIndex,n.centerJustifiedTextSymbolIndex,n.leftJustifiedTextSymbolIndex].forEach((i,o,a)=>{i>=0&&a.indexOf(i)===o&&this.addIndicesForPlacedSymbol(this.text,i)}),n.verticalPlacedTextSymbolIndex>=0&&this.addIndicesForPlacedSymbol(this.text,n.verticalPlacedTextSymbolIndex),n.placedIconSymbolIndex>=0&&this.addIndicesForPlacedSymbol(this.icon,n.placedIconSymbolIndex),n.verticalPlacedIconSymbolIndex>=0&&this.addIndicesForPlacedSymbol(this.icon,n.verticalPlacedIconSymbolIndex)}this.text.indexBuffer&&this.text.indexBuffer.updateData(this.text.indexArray),this.icon.indexBuffer&&this.icon.indexBuffer.updateData(this.icon.indexArray)}}};C("SymbolBucket",He,{omit:["layers","collisionBoxArray","features","compareText"]});He.MAX_GLYPHS=65535;He.addDynamicAttributes=uf;function cf(e,t){return t.replace(/{([^{}]+)}/g,(r,n)=>e&&n in e?String(e[n]):"")}var pf,gb=()=>pf=pf||new re({"symbol-placement":new B(S.layout_symbol["symbol-placement"]),"symbol-spacing":new B(S.layout_symbol["symbol-spacing"]),"symbol-avoid-edges":new B(S.layout_symbol["symbol-avoid-edges"]),"symbol-sort-key":new R(S.layout_symbol["symbol-sort-key"]),"symbol-z-order":new B(S.layout_symbol["symbol-z-order"]),"icon-allow-overlap":new B(S.layout_symbol["icon-allow-overlap"]),"icon-overlap":new B(S.layout_symbol["icon-overlap"]),"icon-ignore-placement":new B(S.layout_symbol["icon-ignore-placement"]),"icon-optional":new B(S.layout_symbol["icon-optional"]),"icon-rotation-alignment":new B(S.layout_symbol["icon-rotation-alignment"]),"icon-size":new R(S.layout_symbol["icon-size"]),"icon-text-fit":new B(S.layout_symbol["icon-text-fit"]),"icon-text-fit-padding":new B(S.layout_symbol["icon-text-fit-padding"]),"icon-image":new R(S.layout_symbol["icon-image"]),"icon-rotate":new R(S.layout_symbol["icon-rotate"]),"icon-padding":new R(S.layout_symbol["icon-padding"]),"icon-keep-upright":new B(S.layout_symbol["icon-keep-upright"]),"icon-offset":new R(S.layout_symbol["icon-offset"]),"icon-anchor":new R(S.layout_symbol["icon-anchor"]),"icon-pitch-alignment":new B(S.layout_symbol["icon-pitch-alignment"]),"text-pitch-alignment":new B(S.layout_symbol["text-pitch-alignment"]),"text-rotation-alignment":new B(S.layout_symbol["text-rotation-alignment"]),"text-field":new R(S.layout_symbol["text-field"]),"text-font":new R(S.layout_symbol["text-font"]),"text-size":new R(S.layout_symbol["text-size"]),"text-max-width":new R(S.layout_symbol["text-max-width"]),"text-line-height":new B(S.layout_symbol["text-line-height"]),"text-letter-spacing":new R(S.layout_symbol["text-letter-spacing"]),"text-justify":new R(S.layout_symbol["text-justify"]),"text-radial-offset":new R(S.layout_symbol["text-radial-offset"]),"text-variable-anchor":new B(S.layout_symbol["text-variable-anchor"]),"text-variable-anchor-offset":new R(S.layout_symbol["text-variable-anchor-offset"]),"text-anchor":new R(S.layout_symbol["text-anchor"]),"text-max-angle":new B(S.layout_symbol["text-max-angle"]),"text-writing-mode":new B(S.layout_symbol["text-writing-mode"]),"text-rotate":new R(S.layout_symbol["text-rotate"]),"text-padding":new B(S.layout_symbol["text-padding"]),"text-keep-upright":new B(S.layout_symbol["text-keep-upright"]),"text-transform":new R(S.layout_symbol["text-transform"]),"text-offset":new R(S.layout_symbol["text-offset"]),"text-allow-overlap":new B(S.layout_symbol["text-allow-overlap"]),"text-overlap":new B(S.layout_symbol["text-overlap"]),"text-ignore-placement":new B(S.layout_symbol["text-ignore-placement"]),"text-optional":new B(S.layout_symbol["text-optional"])}),ff,xb=()=>ff=ff||new re({"icon-opacity":new R(S.paint_symbol["icon-opacity"]),"icon-color":new R(S.paint_symbol["icon-color"]),"icon-halo-color":new R(S.paint_symbol["icon-halo-color"]),"icon-halo-width":new R(S.paint_symbol["icon-halo-width"]),"icon-halo-blur":new R(S.paint_symbol["icon-halo-blur"]),"icon-translate":new B(S.paint_symbol["icon-translate"]),"icon-translate-anchor":new B(S.paint_symbol["icon-translate-anchor"]),"text-opacity":new R(S.paint_symbol["text-opacity"]),"text-color":new R(S.paint_symbol["text-color"],{runtimeType:Re,getOverride:e=>e.textColor,hasOverride:e=>!!e.textColor}),"text-halo-color":new R(S.paint_symbol["text-halo-color"]),"text-halo-width":new R(S.paint_symbol["text-halo-width"]),"text-halo-blur":new R(S.paint_symbol["text-halo-blur"]),"text-translate":new B(S.paint_symbol["text-translate"]),"text-translate-anchor":new B(S.paint_symbol["text-translate-anchor"])}),oa={get paint(){return xb()},get layout(){return gb()}};var si=class{constructor(t){if(t.property.overrides===void 0)throw new Error("overrides must be provided to instantiate FormatSectionOverride class");this.type=t.property.overrides?t.property.overrides.runtimeType:yr,this.defaultValue=t}evaluate(t){if(t.formattedSection){let r=this.defaultValue.property.overrides;if(r&&r.hasOverride(t.formattedSection))return r.getOverride(t.formattedSection)}return t.feature&&t.featureState?this.defaultValue.evaluate(t.feature,t.featureState):this.defaultValue.property.specification.default}eachChild(t){if(!this.defaultValue.isConstant()){let r=this.defaultValue.value;t(r._styleExpression.expression)}}outputDefined(){return!1}serialize(){return null}};C("FormatSectionOverride",si,{omit:["defaultValue"]});var aa=class e extends se{constructor(t){super(t,oa)}recalculate(t,r){if(super.recalculate(t,r),this.layout.get("icon-rotation-alignment")==="auto"&&(this.layout.get("symbol-placement")!=="point"?this.layout._values["icon-rotation-alignment"]="map":this.layout._values["icon-rotation-alignment"]="viewport"),this.layout.get("text-rotation-alignment")==="auto"&&(this.layout.get("symbol-placement")!=="point"?this.layout._values["text-rotation-alignment"]="map":this.layout._values["text-rotation-alignment"]="viewport"),this.layout.get("text-pitch-alignment")==="auto"&&(this.layout._values["text-pitch-alignment"]=this.layout.get("text-rotation-alignment")==="map"?"map":"viewport"),this.layout.get("icon-pitch-alignment")==="auto"&&(this.layout._values["icon-pitch-alignment"]=this.layout.get("icon-rotation-alignment")),this.layout.get("symbol-placement")==="point"){let n=this.layout.get("text-writing-mode");if(n){let i=[];for(let o of n)i.indexOf(o)<0&&i.push(o);this.layout._values["text-writing-mode"]=i}else this.layout._values["text-writing-mode"]=["horizontal"]}this._setPaintOverrides()}getValueAndResolveTokens(t,r,n,i){let o=this.layout.get(t).evaluate(r,{},n,i),a=this._unevaluatedLayout._values[t];return!a.isDataDriven()&&!$t(a.value)&&o?cf(r.properties,o):o}createBucket(t){return new He(t)}queryRadius(){return 0}queryIntersectsFeature(){throw new Error("Should take a different path in FeatureIndex")}_setPaintOverrides(){for(let t of oa.paint.overridableProperties){if(!e.hasPaintOverride(this.layout,t))continue;let r=this.paint.get(t),n=new si(r),i=new Rt(n,r.property.specification),o=null;r.value.kind==="constant"||r.value.kind==="source"?o=new dt("source",i):o=new gt("composite",i,r.value.zoomStops),this.paint._values[t]=new Se(r.property,o,r.parameters)}}_handleOverridablePaintPropertyUpdate(t,r,n){return!this.layout||r.isDataDriven()||n.isDataDriven()?!1:e.hasPaintOverride(this.layout,t)}static hasPaintOverride(t,r){let n=t.get("text-field"),i=oa.paint.properties[r],o=!1,a=s=>{for(let l of s)if(i.overrides&&i.overrides.hasOverride(l)){o=!0;return}};if(n.value.kind==="constant"&&n.value.value instanceof Fe)a(n.value.value.sections);else if(n.value.kind==="source"){let s=u=>{if(!o)if(u instanceof mt&&ue(u.value)===mr){let c=u.value;a(c.sections)}else u instanceof en?a(u.sections):u.eachChild(s)},l=n.value;l._styleExpression&&s(l._styleExpression.expression)}return o}};function yf(e,t,r,n=1){let i=e.get("icon-padding").evaluate(t,{},r),o=i&&i.values;return[o[0]*n,o[1]*n,o[2]*n,o[3]*n]}var mf,bb=()=>mf=mf||new re({"background-color":new B(S.paint_background["background-color"]),"background-pattern":new qt(S.paint_background["background-pattern"]),"background-opacity":new B(S.paint_background["background-opacity"])}),hf={get paint(){return bb()}};var sa=class extends se{constructor(t){super(t,hf)}};var df,vb=()=>df=df||new re({"raster-opacity":new B(S.paint_raster["raster-opacity"]),"raster-hue-rotate":new B(S.paint_raster["raster-hue-rotate"]),"raster-brightness-min":new B(S.paint_raster["raster-brightness-min"]),"raster-brightness-max":new B(S.paint_raster["raster-brightness-max"]),"raster-saturation":new B(S.paint_raster["raster-saturation"]),"raster-contrast":new B(S.paint_raster["raster-contrast"]),"raster-resampling":new B(S.paint_raster["raster-resampling"]),"raster-fade-duration":new B(S.paint_raster["raster-fade-duration"])}),gf={get paint(){return vb()}};var la=class extends se{constructor(t){super(t,gf)}};var ua=class extends se{constructor(r){super(r,{});this.onAdd=r=>{this.implementation.onAdd&&this.implementation.onAdd(r,r.painter.context.gl)};this.onRemove=r=>{this.implementation.onRemove&&this.implementation.onRemove(r,r.painter.context.gl)};this.implementation=r}is3D(){return this.implementation.renderingMode==="3d"}hasOffscreenPass(){return this.implementation.prerender!==void 0}recalculate(){}updateTransitions(){}hasTransition(){return!1}serialize(){throw new Error("Custom layers cannot be serialized")}};function xf(e){if(e.type==="custom")return new ua(e);switch(e.type){case"background":return new sa(e);case"circle":return new Ro(e);case"fill":return new jo(e);case"fill-extrusion":return new Wo(e);case"heatmap":return new Oo(e);case"hillshade":return new No(e);case"line":return new Xo(e);case"raster":return new la(e);case"symbol":return new aa(e)}}var ca=class{constructor(t){this.keyCache={},t&&this.replace(t)}replace(t){this._layerConfigs={},this._layers={},this.update(t,[])}update(t,r){for(let i of t){this._layerConfigs[i.id]=i;let o=this._layers[i.id]=xf(i);o._featureFilter=fn(o.filter),this.keyCache[i.id]&&delete this.keyCache[i.id]}for(let i of r)delete this.keyCache[i],delete this._layerConfigs[i],delete this._layers[i];this.familiesBySource={};let n=Ru(Object.values(this._layerConfigs),this.keyCache);for(let i of n){let o=i.map(p=>this._layers[p.id]),a=o[0];if(a.visibility==="none")continue;let s=a.source||"",l=this.familiesBySource[s];l||(l=this.familiesBySource[s]={});let u=a.sourceLayer||"_geojsonTileLayer",c=l[u];c||(c=l[u]=[]),c.push(o)}}};var Gf=Z(Tt(),1),qf=Z(Qn(),1);var Dr=class{constructor(t){this._stringToNumber={},this._numberToString=[];for(let r=0;r<t.length;r++){let n=t[r];this._stringToNumber[n]=r,this._numberToString[r]=n}}encode(t){return this._stringToNumber[t]}decode(t){if(t>=this._numberToString.length)throw new Error("Out of bounds. Index requested n=".concat(t," can't be >= this._numberToString.length ").concat(this._numberToString.length));return this._numberToString[t]}};var Pf=Z(Tt(),1),Sf=Z(Qn(),1);var pa=class{constructor(t,r,n,i,o){this.type="Feature",this._vectorTileFeature=t,t._z=r,t._x=n,t._y=i,this.properties=t.properties,this.id=o}get geometry(){return this._geometry===void 0&&(this._geometry=this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x,this._vectorTileFeature._y,this._vectorTileFeature._z).geometry),this._geometry}set geometry(t){this._geometry=t}toJSON(){let t={geometry:this.geometry};for(let r in this)r==="_geometry"||r==="_vectorTileFeature"||(t[r]=this[r]);return t}};var li=class{constructor(t,r){this.tileID=t,this.x=t.canonical.x,this.y=t.canonical.y,this.z=t.canonical.z,this.grid=new Dt(8192,16,0),this.grid3D=new Dt(8192,16,0),this.featureIndexArray=new Rn,this.promoteId=r}insert(t,r,n,i,o,a){let s=this.featureIndexArray.length;this.featureIndexArray.emplaceBack(n,i,o);let l=a?this.grid3D:this.grid;for(let u=0;u<r.length;u++){let c=r[u],p=[1/0,1/0,-1/0,-1/0];for(let f=0;f<c.length;f++){let y=c[f];p[0]=Math.min(p[0],y.x),p[1]=Math.min(p[1],y.y),p[2]=Math.max(p[2],y.x),p[3]=Math.max(p[3],y.y)}p[0]<8192&&p[1]<8192&&p[2]>=0&&p[3]>=0&&l.insert(s,p[0],p[1],p[2],p[3])}}loadVTLayers(){return this.vtLayers||(this.vtLayers=new Pf.default.VectorTile(new Sf.default(this.rawTileData)).layers,this.sourceLayerCoder=new Dr(this.vtLayers?Object.keys(this.vtLayers).sort():["_geojsonTileLayer"])),this.vtLayers}query(t,r,n,i){this.loadVTLayers();let o=t.params||{},a=8192/t.tileSize/t.scale,s=fn(o.filter),l=t.queryGeometry,u=t.queryPadding*a,c=vf(l),p=this.grid.query(c.minX-u,c.minY-u,c.maxX+u,c.maxY+u),f=vf(t.cameraQueryGeometry),y=this.grid3D.query(f.minX-u,f.minY-u,f.maxX+u,f.maxY+u,(d,g,b,x)=>Vc(t.cameraQueryGeometry,d-u,g-u,b+u,x+u));for(let d of y)p.push(d);p.sort(Pb);let m={},h;for(let d=0;d<p.length;d++){let g=p[d];if(g===h)continue;h=g;let b=this.featureIndexArray.get(g),x=null;this.loadMatchingFeature(m,b.bucketIndex,b.sourceLayerIndex,b.featureIndex,s,o.layers,o.availableImages,r,n,i,(v,P,w)=>(x||(x=ke(v)),P.queryIntersectsFeature(l,v,w,x,this.z,t.transform,a,t.pixelPosMatrix)))}return m}loadMatchingFeature(t,r,n,i,o,a,s,l,u,c,p){let f=this.bucketLayerIDs[r];if(a&&!Jl(a,f))return;let y=this.sourceLayerCoder.decode(n),h=this.vtLayers[y].feature(i);if(o.needGeometry){let g=$e(h,!0);if(!o.filter(new q(this.tileID.overscaledZ),g,this.tileID.canonical))return}else if(!o.filter(new q(this.tileID.overscaledZ),h))return;let d=this.getId(h,y);for(let g=0;g<f.length;g++){let b=f[g];if(a&&a.indexOf(b)<0)continue;let x=l[b];if(!x)continue;let v={};d&&c&&(v=c.getState(x.sourceLayer||"_geojsonTileLayer",d));let P=Pe({},u[b]);P.paint=bf(P.paint,x.paint,h,v,s),P.layout=bf(P.layout,x.layout,h,v,s);let w=!p||p(h,x,v);if(!w)continue;let T=new pa(h,this.z,this.x,this.y,d);T.layer=P;let F=t[b];F===void 0&&(F=t[b]=[]),F.push({featureIndex:i,feature:T,intersectionZ:w})}}lookupSymbolFeatures(t,r,n,i,o,a,s,l){let u={};this.loadVTLayers();let c=fn(o);for(let p of t)this.loadMatchingFeature(u,n,i,p,c,a,s,l,r);return u}hasLayer(t){for(let r of this.bucketLayerIDs)for(let n of r)if(t===n)return!0;return!1}getId(t,r){let n=t.id;if(this.promoteId){let i=typeof this.promoteId=="string"?this.promoteId:this.promoteId[r];n=t.properties[i],typeof n=="boolean"&&(n=Number(n))}return n}};C("FeatureIndex",li,{omit:["rawTileData","sourceLayerCoder"]});function bf(e,t,r,n,i){return Gr(e,(o,a)=>{let s=t instanceof vt?t.get(a):null;return s&&s.evaluate?s.evaluate(r,n,i):s})}function vf(e){let t=1/0,r=1/0,n=-1/0,i=-1/0;for(let o of e)t=Math.min(t,o.x),r=Math.min(r,o.y),n=Math.max(n,o.x),i=Math.max(i,o.y);return{minX:t,minY:r,maxX:n,maxY:i}}function Pb(e,t){return t-e}var wf=Z(he(),1);var rt=class e extends wf.default{constructor(t,r,n,i){super(t,r),this.angle=n,i!==void 0&&(this.segment=i)}clone(){return new e(this.x,this.y,this.angle,this.segment)}};C("Anchor",rt);function Qs(e,t,r,n,i){if(t.segment===void 0||r===0)return!0;let o=t,a=t.segment+1,s=0;for(;s>-r/2;){if(a--,a<0)return!1;s-=e[a].dist(o),o=e[a]}s+=e[a].dist(e[a+1]),a++;let l=[],u=0;for(;s<r/2;){let c=e[a-1],p=e[a],f=e[a+1];if(!f)return!1;let y=c.angleTo(p)-p.angleTo(f);for(y=Math.abs((y+3*Math.PI)%(Math.PI*2)-Math.PI),l.push({distance:s,angleDelta:y}),u+=y;s-l[0].distance>n;)u-=l.shift().angleDelta;if(u>i)return!1;a++,s+=p.dist(f)}return!0}function Af(e){let t=0;for(let r=0;r<e.length-1;r++)t+=e[r].dist(e[r+1]);return t}function _f(e,t,r){return e?3/5*t*r:0}function If(e,t){return Math.max(e?e.right-e.left:0,t?t.right-t.left:0)}function Tf(e,t,r,n,i,o){let a=_f(r,i,o),s=If(r,n)*o,l=0,u=Af(e)/2;for(let c=0;c<e.length-1;c++){let p=e[c],f=e[c+1],y=p.dist(f);if(l+y>u){let m=(u-l)/y,h=Oe.number(p.x,f.x,m),d=Oe.number(p.y,f.y,m),g=new rt(h,d,f.angleTo(p),c);return g._round(),!a||Qs(e,g,s,a,t)?g:void 0}l+=y}}function Cf(e,t,r,n,i,o,a,s,l){let u=_f(n,o,a),c=If(n,i),p=c*a,f=e[0].x===0||e[0].x===l||e[0].y===0||e[0].y===l;t-p<t/4&&(t=p+t/4);let y=o*2,m=f?t/2*s%t:(c/2+y)*a*s%t;return kf(e,m,t,u,r,p,f,!1,l)}function kf(e,t,r,n,i,o,a,s,l){let u=o/2,c=Af(e),p=0,f=t-r,y=[];for(let m=0;m<e.length-1;m++){let h=e[m],d=e[m+1],g=h.dist(d),b=d.angleTo(h);for(;f+r<p+g;){f+=r;let x=(f-p)/g,v=Oe.number(h.x,d.x,x),P=Oe.number(h.y,d.y,x);if(v>=0&&v<l&&P>=0&&P<l&&f-u>=0&&f+u<=c){let w=new rt(v,P,b,m);w._round(),(!n||Qs(e,w,o,n,i))&&y.push(w)}}p+=g}return!s&&!y.length&&!a&&(y=kf(e,p/2,r,n,i,o,a,!0,l)),y}var pt=Z(he(),1);function Mf(e,t,r,n,i){let o=[];for(let a=0;a<e.length;a++){let s=e[a],l;for(let u=0;u<s.length-1;u++){let c=s[u],p=s[u+1];c.x<t&&p.x<t||(c.x<t?c=new pt.default(t,c.y+(p.y-c.y)*((t-c.x)/(p.x-c.x)))._round():p.x<t&&(p=new pt.default(t,c.y+(p.y-c.y)*((t-c.x)/(p.x-c.x)))._round()),!(c.y<r&&p.y<r)&&(c.y<r?c=new pt.default(c.x+(p.x-c.x)*((r-c.y)/(p.y-c.y)),r)._round():p.y<r&&(p=new pt.default(c.x+(p.x-c.x)*((r-c.y)/(p.y-c.y)),r)._round()),!(c.x>=n&&p.x>=n)&&(c.x>=n?c=new pt.default(n,c.y+(p.y-c.y)*((n-c.x)/(p.x-c.x)))._round():p.x>=n&&(p=new pt.default(n,c.y+(p.y-c.y)*((n-c.x)/(p.x-c.x)))._round()),!(c.y>=i&&p.y>=i)&&(c.y>=i?c=new pt.default(c.x+(p.x-c.x)*((i-c.y)/(p.y-c.y)),i)._round():p.y>=i&&(p=new pt.default(c.x+(p.x-c.x)*((i-c.y)/(p.y-c.y)),i)._round()),(!l||!c.equals(l[l.length-1]))&&(l=[c],o.push(l)),l.push(p)))))}}return o}var we=Z(he(),1);var Vr=ge;function el(e,t,r,n){let i=[],o=e.image,a=o.pixelRatio,s=o.paddedRect.w-2*Vr,l=o.paddedRect.h-2*Vr,u=e.right-e.left,c=e.bottom-e.top,p=o.stretchX||[[0,s]],f=o.stretchY||[[0,l]],y=(I,k)=>I+k[1]-k[0],m=p.reduce(y,0),h=f.reduce(y,0),d=s-m,g=l-h,b=0,x=m,v=0,P=h,w=0,T=d,F=0,E=g;if(o.content&&n){let I=o.content;b=fa(p,0,I[0]),v=fa(f,0,I[1]),x=fa(p,I[0],I[2]),P=fa(f,I[1],I[3]),w=I[0]-b,F=I[1]-v,T=I[2]-I[0]-x,E=I[3]-I[1]-P}let _=(I,k,V,A)=>{let z=ya(I.stretch-b,x,u,e.left),O=ma(I.fixed-w,T,I.stretch,m),N=ya(k.stretch-v,P,c,e.top),K=ma(k.fixed-F,E,k.stretch,h),xe=ya(V.stretch-b,x,u,e.left),X=ma(V.fixed-w,T,V.stretch,m),le=ya(A.stretch-v,P,c,e.top),ce=ma(A.fixed-F,E,A.stretch,h),pe=new we.default(z,N),_e=new we.default(xe,N),be=new we.default(xe,le),wi=new we.default(z,le),Ea=new we.default(O/a,K/a),Fa=new we.default(X/a,ce/a),Or=t*Math.PI/180;if(Or){let Ie=Math.sin(Or),ve=Math.cos(Or),Ve=[ve,-Ie,Ie,ve];pe._matMult(Ve),_e._matMult(Ve),wi._matMult(Ve),be._matMult(Ve)}let Ai=I.stretch+I.fixed,Me=V.stretch+V.fixed,Ft=k.stretch+k.fixed,_i=A.stretch+A.fixed,La={x:o.paddedRect.x+Vr+Ai,y:o.paddedRect.y+Vr+Ft,w:Me-Ai,h:_i-Ft},Da=T/a/u,Va=E/a/c;return{tl:pe,tr:_e,bl:wi,br:be,tex:La,writingMode:void 0,glyphOffset:[0,0],sectionIndex:0,pixelOffsetTL:Ea,pixelOffsetBR:Fa,minFontScaleX:Da,minFontScaleY:Va,isSDF:r}};if(!n||!o.stretchX&&!o.stretchY)i.push(_({fixed:0,stretch:-1},{fixed:0,stretch:-1},{fixed:0,stretch:s+1},{fixed:0,stretch:l+1}));else{let I=Ef(p,d,m),k=Ef(f,g,h);for(let V=0;V<I.length-1;V++){let A=I[V],z=I[V+1];for(let O=0;O<k.length-1;O++){let N=k[O],K=k[O+1];i.push(_(A,N,z,K))}}}return i}function fa(e,t,r){let n=0;for(let i of e)n+=Math.max(t,Math.min(r,i[1]))-Math.max(t,Math.min(r,i[0]));return n}function Ef(e,t,r){let n=[{fixed:-Vr,stretch:0}];for(let[i,o]of e){let a=n[n.length-1];n.push({fixed:i-a.stretch,stretch:a.stretch}),n.push({fixed:i-a.stretch,stretch:a.stretch+(o-i)})}return n.push({fixed:t+Vr,stretch:r}),n}function ya(e,t,r,n){return e/t*r+n}function ma(e,t,r,n){return e-t*r/n}function Ff(e,t,r,n,i,o,a,s){let l=n.layout.get("text-rotate").evaluate(o,{})*Math.PI/180,u=[];for(let c of t.positionedLines)for(let p of c.positionedGlyphs){if(!p.rect)continue;let f=p.rect||{},m=Qo+1,h=!0,d=1,g=0,b=(i||s)&&p.vertical,x=p.metrics.advance*p.scale/2;if(s&&t.verticalizable){let X=(p.scale-1)*ne,le=(ne-p.metrics.width*p.scale)/2;g=c.lineOffset/2-(p.imageName?-le:X)}if(p.imageName){let X=a[p.imageName];h=X.sdf,d=X.pixelRatio,m=ge/d}let v=i?[p.x+x,p.y]:[0,0],P=i?[0,0]:[p.x+x+r[0],p.y+r[1]-g],w=[0,0];b&&(w=P,P=[0,0]);let T=p.metrics.isDoubleResolution?2:1,F=(p.metrics.left-m)*p.scale-x+P[0],E=(-p.metrics.top-m)*p.scale+P[1],_=F+f.w/T*p.scale/d,I=E+f.h/T*p.scale/d,k=new we.default(F,E),V=new we.default(_,E),A=new we.default(F,I),z=new we.default(_,I);if(b){let X=new we.default(-x,x-Fr),le=-Math.PI/2,ce=ne/2-x,pe=p.imageName?ce:0,_e=new we.default(5-Fr-ce,-pe),be=new we.default(...w);k._rotateAround(le,X)._add(_e)._add(be),V._rotateAround(le,X)._add(_e)._add(be),A._rotateAround(le,X)._add(_e)._add(be),z._rotateAround(le,X)._add(_e)._add(be)}if(l){let X=Math.sin(l),le=Math.cos(l),ce=[le,-X,X,le];k._matMult(ce),V._matMult(ce),A._matMult(ce),z._matMult(ce)}let O=new we.default(0,0),N=new we.default(0,0);u.push({tl:k,tr:V,bl:A,br:z,tex:f,writingMode:t.writingMode,glyphOffset:v,sectionIndex:p.sectionIndex,isSDF:h,pixelOffsetTL:O,pixelOffsetBR:N,minFontScaleX:0,minFontScaleY:0})}return u}var ui=Z(he(),1),nr=class{constructor(t,r,n,i,o,a,s,l,u,c){if(this.boxStartIndex=t.length,u){let p=a.top,f=a.bottom,y=a.collisionPadding;y&&(p-=y[1],f+=y[3]);let m=f-p;m>0&&(m=Math.max(10,m),this.circleDiameter=m)}else{let p=a.top*s-l[0],f=a.bottom*s+l[2],y=a.left*s-l[3],m=a.right*s+l[1],h=a.collisionPadding;if(h&&(y-=h[0]*s,p-=h[1]*s,m+=h[2]*s,f+=h[3]*s),c){let d=new ui.default(y,p),g=new ui.default(m,p),b=new ui.default(y,f),x=new ui.default(m,f),v=c*Math.PI/180;d._rotate(v),g._rotate(v),b._rotate(v),x._rotate(v),y=Math.min(d.x,g.x,b.x,x.x),m=Math.max(d.x,g.x,b.x,x.x),p=Math.min(d.y,g.y,b.y,x.y),f=Math.max(d.y,g.y,b.y,x.y)}t.emplaceBack(r.x,r.y,y,p,m,f,n,i,o)}this.boxEndIndex=t.length}};var ci=class{constructor(t=[],r=Sb){if(this.data=t,this.length=this.data.length,this.compare=r,this.length>0)for(let n=(this.length>>1)-1;n>=0;n--)this._down(n)}push(t){this.data.push(t),this.length++,this._up(this.length-1)}pop(){if(this.length===0)return;let t=this.data[0],r=this.data.pop();return this.length--,this.length>0&&(this.data[0]=r,this._down(0)),t}peek(){return this.data[0]}_up(t){let{data:r,compare:n}=this,i=r[t];for(;t>0;){let o=t-1>>1,a=r[o];if(n(i,a)>=0)break;r[t]=a,t=o}r[t]=i}_down(t){let{data:r,compare:n}=this,i=this.length>>1,o=r[t];for(;t<i;){let a=(t<<1)+1,s=r[a],l=a+1;if(l<this.length&&n(r[l],s)<0&&(a=l,s=r[l]),n(s,o)>=0)break;r[t]=s,t=a}r[t]=o}};function Sb(e,t){return e<t?-1:e>t?1:0}var tl=Z(he(),1);function Lf(e,t=1,r=!1){let n=1/0,i=1/0,o=-1/0,a=-1/0,s=e[0];for(let h=0;h<s.length;h++){let d=s[h];(!h||d.x<n)&&(n=d.x),(!h||d.y<i)&&(i=d.y),(!h||d.x>o)&&(o=d.x),(!h||d.y>a)&&(a=d.y)}let l=o-n,u=a-i,c=Math.min(l,u),p=c/2,f=new ci([],wb);if(c===0)return new tl.default(n,i);for(let h=n;h<o;h+=c)for(let d=i;d<a;d+=c)f.push(new Br(h+p,d+p,p,e));let y=_b(e),m=f.length;for(;f.length;){let h=f.pop();(h.d>y.d||!y.d)&&(y=h,r&&console.log("found best %d after %d probes",Math.round(1e4*h.d)/1e4,m)),!(h.max-y.d<=t)&&(p=h.h/2,f.push(new Br(h.p.x-p,h.p.y-p,p,e)),f.push(new Br(h.p.x+p,h.p.y-p,p,e)),f.push(new Br(h.p.x-p,h.p.y+p,p,e)),f.push(new Br(h.p.x+p,h.p.y+p,p,e)),m+=4)}return r&&(console.log("num probes: ".concat(m)),console.log("best distance: ".concat(y.d))),y.p}function wb(e,t){return t.max-e.max}function Br(e,t,r,n){this.p=new tl.default(e,t),this.h=r,this.d=Ab(this.p,n),this.max=this.d+this.h*Math.SQRT2}function Ab(e,t){let r=!1,n=1/0;for(let i=0;i<t.length;i++){let o=t[i];for(let a=0,s=o.length,l=s-1;a<s;l=a++){let u=o[a],c=o[l];u.y>e.y!=c.y>e.y&&e.x<(c.x-u.x)*(e.y-u.y)/(c.y-u.y)+u.x&&(r=!r),n=Math.min(n,Fs(e,u,c))}}return(r?1:-1)*Math.sqrt(n)}function _b(e){let t=0,r=0,n=0,i=e[0];for(let o=0,a=i.length,s=a-1;o<a;s=o++){let l=i[o],u=i[s],c=l.x*u.y-u.x*l.y;r+=(l.x+u.x)*c,n+=(l.y+u.y)*c,t+=c*3}return new Br(r/t,n/t,0,e)}var ol=Z(Is(),1);var rl=(o=>(o[o.center=1]="center",o[o.left=2]="left",o[o.right=3]="right",o[o.top=4]="top",o[o.bottom=5]="bottom",o[o["top-left"]=6]="top-left",o[o["top-right"]=7]="top-right",o[o["bottom-left"]=8]="bottom-left",o[o["bottom-right"]=9]="bottom-right",o))(rl||{}),kt=7,ha=Number.POSITIVE_INFINITY;function nl(e,t){function r(i,o){let a=0,s=0;o<0&&(o=0);let l=o/Math.SQRT2;switch(i){case"top-right":case"top-left":s=l-kt;break;case"bottom-right":case"bottom-left":s=-l+kt;break;case"bottom":s=-o+kt;break;case"top":s=o-kt;break}switch(i){case"top-right":case"bottom-right":a=-l;break;case"top-left":case"bottom-left":a=l;break;case"left":a=o;break;case"right":a=-o;break}return[a,s]}function n(i,o,a){let s=0,l=0;switch(o=Math.abs(o),a=Math.abs(a),i){case"top-right":case"top-left":case"top":l=a-kt;break;case"bottom-right":case"bottom-left":case"bottom":l=-a+kt;break}switch(i){case"top-right":case"bottom-right":case"right":s=-o;break;case"top-left":case"bottom-left":case"left":s=o;break}return[s,l]}return t[1]!==ha?n(e,t[0],t[1]):r(e,t[0])}function il(e,t,r){var a;let n=e.layout,i=(a=n.get("text-variable-anchor-offset"))==null?void 0:a.evaluate(t,{},r);if(i){let s=i.values,l=[];for(let u=0;u<s.length;u+=2){let c=l[u]=s[u],p=s[u+1].map(f=>f*ne);c.startsWith("top")?p[1]-=kt:c.startsWith("bottom")&&(p[1]+=kt),l[u+1]=p}return new Ne(l)}let o=n.get("text-variable-anchor");if(o){let s;e._unevaluatedLayout.getValue("text-radial-offset")!==void 0?s=[n.get("text-radial-offset").evaluate(t,{},r)*ne,ha]:s=n.get("text-offset").evaluate(t,{},r).map(c=>c*ne);let u=[];for(let c of o)u.push(c,nl(c,s));return new Ne(u)}return null}function Bf(e){e.bucket.createArrays();let t=512*e.bucket.overscaling;e.bucket.tilePixelRatio=8192/t,e.bucket.compareText={},e.bucket.iconsNeedLinear=!1;let r=e.bucket.layers[0],n=r.layout,i=r._unevaluatedLayout._values,o={layoutIconSize:i["icon-size"].possiblyEvaluate(new q(e.bucket.zoom+1),e.canonical),layoutTextSize:i["text-size"].possiblyEvaluate(new q(e.bucket.zoom+1),e.canonical),textMaxSize:i["text-size"].possiblyEvaluate(new q(18))};if(e.bucket.textSizeData.kind==="composite"){let{minZoom:c,maxZoom:p}=e.bucket.textSizeData;o.compositeTextSizes=[i["text-size"].possiblyEvaluate(new q(c),e.canonical),i["text-size"].possiblyEvaluate(new q(p),e.canonical)]}if(e.bucket.iconSizeData.kind==="composite"){let{minZoom:c,maxZoom:p}=e.bucket.iconSizeData;o.compositeIconSizes=[i["icon-size"].possiblyEvaluate(new q(c),e.canonical),i["icon-size"].possiblyEvaluate(new q(p),e.canonical)]}let a=n.get("text-line-height")*ne,s=n.get("text-rotation-alignment")!=="viewport"&&n.get("symbol-placement")!=="point",l=n.get("text-keep-upright"),u=n.get("text-size");for(let c of e.bucket.features){let p=n.get("text-font").evaluate(c,{},e.canonical).join(","),f=u.evaluate(c,{},e.canonical),y=o.layoutTextSize.evaluate(c,{},e.canonical),m=o.layoutIconSize.evaluate(c,{},e.canonical),h={horizontal:{},vertical:void 0},d=c.text,g=[0,0];if(d){let P=d.toString(),w=n.get("text-letter-spacing").evaluate(c,{},e.canonical)*ne,T=hc(P)?w:0,F=n.get("text-anchor").evaluate(c,{},e.canonical),E=il(r,c,e.canonical);if(!E){let A=n.get("text-radial-offset").evaluate(c,{},e.canonical);A?g=nl(F,[A*ne,ha]):g=n.get("text-offset").evaluate(c,{},e.canonical).map(z=>z*ne)}let _=s?"center":n.get("text-justify").evaluate(c,{},e.canonical),I=n.get("symbol-placement"),k=I==="point"?n.get("text-max-width").evaluate(c,{},e.canonical)*ne:0,V=()=>{e.bucket.allowVerticalPlacement&&mn(P)&&(h.vertical=ni(d,e.glyphMap,e.glyphPositions,e.imagePositions,p,k,a,F,"left",T,g,2,!0,I,y,f))};if(!s&&E){let A=new Set;if(_==="auto")for(let O=0;O<E.values.length;O+=2)A.add(Df(E.values[O]));else A.add(_);let z=!1;for(let O of A)if(!h.horizontal[O])if(z)h.horizontal[O]=h.horizontal[0];else{let N=ni(d,e.glyphMap,e.glyphPositions,e.imagePositions,p,k,a,"center",O,T,g,1,!1,I,y,f);N&&(h.horizontal[O]=N,z=N.positionedLines.length===1)}V()}else{_==="auto"&&(_=Df(F));let A=ni(d,e.glyphMap,e.glyphPositions,e.imagePositions,p,k,a,F,_,T,g,1,!1,I,y,f);A&&(h.horizontal[_]=A),V(),mn(P)&&s&&l&&(h.vertical=ni(d,e.glyphMap,e.glyphPositions,e.imagePositions,p,k,a,F,_,T,g,2,!1,I,y,f))}}let b,x=!1;if(c.icon&&c.icon.name){let P=e.imageMap[c.icon.name];P&&(b=sf(e.imagePositions[c.icon.name],n.get("icon-offset").evaluate(c,{},e.canonical),n.get("icon-anchor").evaluate(c,{},e.canonical)),x=!!P.sdf,e.bucket.sdfIcons===void 0?e.bucket.sdfIcons=x:e.bucket.sdfIcons!==x&&fe("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"),(P.pixelRatio!==e.bucket.pixelRatio||n.get("icon-rotate").constantOr(1)!==0)&&(e.bucket.iconsNeedLinear=!0))}let v=zf(h.horizontal)||h.vertical;e.bucket.iconsInText=v?v.iconsInText:!1,(v||b)&&Ib(e.bucket,c,h,b,e.imageMap,o,y,m,g,x,e.canonical)}e.showCollisionBoxes&&e.bucket.generateCollisionDebugBuffers()}function Df(e){switch(e){case"right":case"top-right":case"bottom-right":return"right";case"left":case"top-left":case"bottom-left":return"left"}return"center"}function Ib(e,t,r,n,i,o,a,s,l,u,c){let p=o.textMaxSize.evaluate(t,{});p===void 0&&(p=a);let f=e.layers[0].layout,y=f.get("icon-offset").evaluate(t,{},c),m=zf(r.horizontal),h=24,d=a/h,g=e.tilePixelRatio*d,b=e.tilePixelRatio*p/h,x=e.tilePixelRatio*s,v=e.tilePixelRatio*f.get("symbol-spacing"),P=f.get("text-padding")*e.tilePixelRatio,w=yf(f,t,c,e.tilePixelRatio),T=f.get("text-max-angle")/180*Math.PI,F=f.get("text-rotation-alignment")!=="viewport"&&f.get("symbol-placement")!=="point",E=f.get("icon-rotation-alignment")==="map"&&f.get("symbol-placement")!=="point",_=f.get("symbol-placement"),I=v/2,k=f.get("icon-text-fit"),V;n&&k!=="none"&&(e.allowVerticalPlacement&&r.vertical&&(V=Xs(n,r.vertical,k,f.get("icon-text-fit-padding"),y,d)),m&&(n=Xs(n,m,k,f.get("icon-text-fit-padding"),y,d)));let A=(z,O)=>{O.x<0||O.x>=8192||O.y<0||O.y>=8192||Cb(e,O,z,r,n,i,V,e.layers[0],e.collisionBoxArray,t.index,t.sourceLayerIndex,e.index,g,[P,P,P,P],F,l,x,w,E,y,t,o,u,c,a)};if(_==="line")for(let z of Mf(t.geometry,0,0,8192,8192)){let O=Cf(z,v,T,r.vertical||m,n,h,b,e.overscaling,8192);for(let N of O){let K=m;(!K||!kb(e,K.text,I,N))&&A(z,N)}}else if(_==="line-center"){for(let z of t.geometry)if(z.length>1){let O=Tf(z,T,r.vertical||m,n,h,b);O&&A(z,O)}}else if(t.type==="Polygon")for(let z of _r(t.geometry,0)){let O=Lf(z,16);A(z[0],new rt(O.x,O.y,0))}else if(t.type==="LineString")for(let z of t.geometry)A(z,new rt(z[0].x,z[0].y,0));else if(t.type==="Point")for(let z of t.geometry)for(let O of z)A([O],new rt(O.x,O.y,0))}function Tb(e,t){let r=e.length,n=t==null?void 0:t.values;if((n==null?void 0:n.length)>0)for(let i=0;i<n.length;i+=2){let o=rl[n[i]],a=n[i+1];e.emplaceBack(o,a[0],a[1])}return[r,e.length]}function Vf(e,t,r,n,i,o,a,s,l,u,c,p,f,y,m){let h=Ff(t,r,s,i,o,a,n,e.allowVerticalPlacement),d=e.textSizeData,g=null;d.kind==="source"?(g=[Ct*i.layout.get("text-size").evaluate(a,{})],g[0]>tt&&fe("".concat(e.layerIds[0],': Value for "text-size" is >= ').concat(Lr,'. Reduce your "text-size".'))):d.kind==="composite"&&(g=[Ct*y.compositeTextSizes[0].evaluate(a,{},m),Ct*y.compositeTextSizes[1].evaluate(a,{},m)],(g[0]>tt||g[1]>tt)&&fe("".concat(e.layerIds[0],': Value for "text-size" is >= ').concat(Lr,'. Reduce your "text-size".'))),e.addSymbols(e.text,h,g,s,o,a,u,t,l.lineStartIndex,l.lineLength,f,m);for(let b of c)p[b]=e.text.placedSymbolArray.length-1;return h.length*4}function zf(e){for(let t in e)return e[t];return null}function Cb(e,t,r,n,i,o,a,s,l,u,c,p,f,y,m,h,d,g,b,x,v,P,w,T,F){let E=e.addToLineVertexArray(t,r),_,I,k,V,A=0,z=0,O=0,N=0,K=-1,xe=-1,X={},le=(0,ol.default)("");if(e.allowVerticalPlacement&&n.vertical){let ve=s.layout.get("text-rotate").evaluate(v,{},T)+90,Ve=n.vertical;k=new nr(l,t,u,c,p,Ve,f,y,m,ve),a&&(V=new nr(l,t,u,c,p,a,d,g,m,ve))}if(i){let Ie=s.layout.get("icon-rotate").evaluate(v,{}),ve=s.layout.get("icon-text-fit")!=="none",Ve=el(i,Ie,w,ve),Nr=a?el(a,Ie,w,ve):void 0;I=new nr(l,t,u,c,p,i,d,g,!1,Ie),A=Ve.length*4;let Fl=e.iconSizeData,Lt=null;Fl.kind==="source"?(Lt=[Ct*s.layout.get("icon-size").evaluate(v,{})],Lt[0]>tt&&fe("".concat(e.layerIds[0],': Value for "icon-size" is >= ').concat(Lr,'. Reduce your "icon-size".'))):Fl.kind==="composite"&&(Lt=[Ct*P.compositeIconSizes[0].evaluate(v,{},T),Ct*P.compositeIconSizes[1].evaluate(v,{},T)],(Lt[0]>tt||Lt[1]>tt)&&fe("".concat(e.layerIds[0],': Value for "icon-size" is >= ').concat(Lr,'. Reduce your "icon-size".'))),e.addSymbols(e.icon,Ve,Lt,x,b,v,0,t,E.lineStartIndex,E.lineLength,-1,T),K=e.icon.placedSymbolArray.length-1,Nr&&(z=Nr.length*4,e.addSymbols(e.icon,Nr,Lt,x,b,v,2,t,E.lineStartIndex,E.lineLength,-1,T),xe=e.icon.placedSymbolArray.length-1)}let ce=Object.keys(n.horizontal);for(let Ie of ce){let ve=n.horizontal[Ie];if(!_){le=(0,ol.default)(ve.text);let Nr=s.layout.get("text-rotate").evaluate(v,{},T);_=new nr(l,t,u,c,p,ve,f,y,m,Nr)}let Ve=ve.positionedLines.length===1;if(O+=Vf(e,t,ve,o,s,m,v,h,E,n.vertical?1:3,Ve?ce:[Ie],X,K,P,T),Ve)break}n.vertical&&(N+=Vf(e,t,n.vertical,o,s,m,v,h,E,2,["vertical"],X,xe,P,T));let pe=_?_.boxStartIndex:e.collisionBoxArray.length,_e=_?_.boxEndIndex:e.collisionBoxArray.length,be=k?k.boxStartIndex:e.collisionBoxArray.length,wi=k?k.boxEndIndex:e.collisionBoxArray.length,Ea=I?I.boxStartIndex:e.collisionBoxArray.length,Fa=I?I.boxEndIndex:e.collisionBoxArray.length,Or=V?V.boxStartIndex:e.collisionBoxArray.length,Ai=V?V.boxEndIndex:e.collisionBoxArray.length,Me=-1,Ft=(Ie,ve)=>Ie&&Ie.circleDiameter?Math.max(Ie.circleDiameter,ve):ve;Me=Ft(_,Me),Me=Ft(k,Me),Me=Ft(I,Me),Me=Ft(V,Me);let _i=Me>-1?1:0;_i&&(Me*=F/ne),e.glyphOffsetArray.length>=He.MAX_GLYPHS&&fe("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"),v.sortKey!==void 0&&e.addToSortKeyRanges(e.symbolInstances.length,v.sortKey);let La=il(s,v,T),[Da,Va]=Tb(e.textAnchorOffsets,La);e.symbolInstances.emplaceBack(t.x,t.y,X.right>=0?X.right:-1,X.center>=0?X.center:-1,X.left>=0?X.left:-1,X.vertical||-1,K,xe,le,pe,_e,be,wi,Ea,Fa,Or,Ai,u,O,N,A,z,_i,0,f,Me,Da,Va)}function kb(e,t,r,n){let i=e.compareText;if(!(t in i))i[t]=[];else{let o=i[t];for(let a=o.length-1;a>=0;a--)if(n.dist(o[a])<r)return!0}return i[t].push(n),!1}var da=1,pi=class{constructor(t){let r={},n=[];for(let s in t){let l=t[s],u=r[s]={};for(let c in l){let p=l[+c];if(!p||p.bitmap.width===0||p.bitmap.height===0)continue;let f={x:0,y:0,w:p.bitmap.width+2*da,h:p.bitmap.height+2*da};n.push(f),u[c]={rect:f,metrics:p.metrics}}}let{w:i,h:o}=ei(n),a=new Yt({width:i||1,height:o||1});for(let s in t){let l=t[s];for(let u in l){let c=l[+u];if(!c||c.bitmap.width===0||c.bitmap.height===0)continue;let p=r[s][u].rect;Yt.copy(c.bitmap,a,{x:0,y:0},{x:p.x+da,y:p.y+da},c.bitmap)}}this.image=a,this.positions=r}};C("GlyphAtlas",pi);function Of(e,t,r){t=Math.pow(2,r)-t-1;var n=Rf(e*256,t*256,r),i=Rf((e+1)*256,(t+1)*256,r);return n[0]+","+n[1]+","+i[0]+","+i[1]}function Rf(e,t,r){var n=2*Math.PI*6378137/256/Math.pow(2,r),i=e*n-2*Math.PI*6378137/2,o=t*n-2*Math.PI*6378137/2;return[i,o]}var $f=Z(he(),1);var al=63710088e-1,fi=class e{constructor(t,r){if(isNaN(t)||isNaN(r))throw new Error("Invalid LngLat object: (".concat(t,", ").concat(r,")"));if(this.lng=+t,this.lat=+r,this.lat>90||this.lat<-90)throw new Error("Invalid LngLat latitude value: must be between -90 and 90")}wrap(){return new e(Gl(this.lng,-180,180),this.lat)}toArray(){return[this.lng,this.lat]}toString(){return"LngLat(".concat(this.lng,", ").concat(this.lat,")")}distanceTo(t){let r=Math.PI/180,n=this.lat*r,i=t.lat*r,o=Math.sin(n)*Math.sin(i)+Math.cos(n)*Math.cos(i)*Math.cos((t.lng-this.lng)*r);return al*Math.acos(Math.min(o,1))}static convert(t){if(t instanceof e)return t;if(Array.isArray(t)&&(t.length===2||t.length===3))return new e(Number(t[0]),Number(t[1]));if(!Array.isArray(t)&&typeof t=="object"&&t!==null)return new e(Number("lng"in t?t.lng:t.lon),Number(t.lat));throw new Error("\`LngLatLike\` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]")}};var Nf=2*Math.PI*al;function Uf(e){return Nf*Math.cos(e*Math.PI/180)}function Mb(e){return(180+e)/360}function Eb(e){return(180-180/Math.PI*Math.log(Math.tan(Math.PI/4+e*Math.PI/360)))/360}function Fb(e,t){return e/Uf(t)}function Lb(e){return e*360-180}function sl(e){let t=180-e*360;return 360/Math.PI*Math.atan(Math.exp(t*Math.PI/180))-90}function Db(e,t){return e*Uf(sl(t))}function Vb(e){return 1/Math.cos(e*Math.PI/180)}var ga=class e{constructor(t,r,n=0){this.x=+t,this.y=+r,this.z=+n}static fromLngLat(t,r=0){let n=fi.convert(t);return new e(Mb(n.lng),Eb(n.lat),Fb(r,n.lat))}toLngLat(){return new fi(Lb(this.x),sl(this.y))}toAltitude(){return Db(this.z,this.y)}meterInMercatorCoordinateUnits(){return 1/Nf*Vb(sl(this.y))}};var xa=class{constructor(t,r,n){if(t<0||t>25||n<0||n>=Math.pow(2,t)||r<0||r>=Math.pow(2,t))throw new Error("x=".concat(r,", y=").concat(n,", z=").concat(t," outside of bounds. 0<=x<").concat(Math.pow(2,t),", 0<=y<").concat(Math.pow(2,t)," 0<=z<=25 "));this.z=t,this.x=r,this.y=n,this.key=yi(0,t,t,r,n)}equals(t){return this.z===t.z&&this.x===t.x&&this.y===t.y}url(t,r,n){let i=Of(this.x,this.y,this.z),o=Bb(this.z,this.x,this.y);return t[(this.x+this.y)%t.length].replace(/{prefix}/g,(this.x%16).toString(16)+(this.y%16).toString(16)).replace(/{z}/g,String(this.z)).replace(/{x}/g,String(this.x)).replace(/{y}/g,String(n==="tms"?Math.pow(2,this.z)-this.y-1:this.y)).replace(/{ratio}/g,r>1?"@2x":"").replace(/{quadkey}/g,o).replace(/{bbox-epsg-3857}/g,i)}isChildOf(t){let r=this.z-t.z;return r>0&&t.x===this.x>>r&&t.y===this.y>>r}getTilePoint(t){let r=Math.pow(2,this.z);return new $f.default((t.x*r-this.x)*8192,(t.y*r-this.y)*8192)}toString(){return"".concat(this.z,"/").concat(this.x,"/").concat(this.y)}},ll=class{constructor(t,r){this.wrap=t,this.canonical=r,this.key=yi(t,r.z,r.z,r.x,r.y)}},mi=class e{constructor(t,r,n,i,o){if(t<n)throw new Error("overscaledZ should be >= z; overscaledZ = ".concat(t,"; z = ").concat(n));this.overscaledZ=t,this.wrap=r,this.canonical=new xa(n,+i,+o),this.key=yi(r,t,n,i,o)}clone(){return new e(this.overscaledZ,this.wrap,this.canonical.z,this.canonical.x,this.canonical.y)}equals(t){return this.overscaledZ===t.overscaledZ&&this.wrap===t.wrap&&this.canonical.equals(t.canonical)}scaledTo(t){if(t>this.overscaledZ)throw new Error("targetZ > this.overscaledZ; targetZ = ".concat(t,"; overscaledZ = ").concat(this.overscaledZ));let r=this.canonical.z-t;return t>this.canonical.z?new e(t,this.wrap,this.canonical.z,this.canonical.x,this.canonical.y):new e(t,this.wrap,t,this.canonical.x>>r,this.canonical.y>>r)}calculateScaledKey(t,r){if(t>this.overscaledZ)throw new Error("targetZ > this.overscaledZ; targetZ = ".concat(t,"; overscaledZ = ").concat(this.overscaledZ));let n=this.canonical.z-t;return t>this.canonical.z?yi(this.wrap*+r,t,this.canonical.z,this.canonical.x,this.canonical.y):yi(this.wrap*+r,t,t,this.canonical.x>>n,this.canonical.y>>n)}isChildOf(t){if(t.wrap!==this.wrap)return!1;let r=this.canonical.z-t.canonical.z;return t.overscaledZ===0||t.overscaledZ<this.overscaledZ&&t.canonical.x===this.canonical.x>>r&&t.canonical.y===this.canonical.y>>r}children(t){if(this.overscaledZ>=t)return[new e(this.overscaledZ+1,this.wrap,this.canonical.z,this.canonical.x,this.canonical.y)];let r=this.canonical.z+1,n=this.canonical.x*2,i=this.canonical.y*2;return[new e(r,this.wrap,r,n,i),new e(r,this.wrap,r,n+1,i),new e(r,this.wrap,r,n,i+1),new e(r,this.wrap,r,n+1,i+1)]}isLessThan(t){return this.wrap<t.wrap?!0:this.wrap>t.wrap?!1:this.overscaledZ<t.overscaledZ?!0:this.overscaledZ>t.overscaledZ?!1:this.canonical.x<t.canonical.x?!0:this.canonical.x>t.canonical.x?!1:this.canonical.y<t.canonical.y}wrapped(){return new e(this.overscaledZ,0,this.canonical.z,this.canonical.x,this.canonical.y)}unwrapTo(t){return new e(this.overscaledZ,t,this.canonical.z,this.canonical.x,this.canonical.y)}overscaleFactor(){return Math.pow(2,this.overscaledZ-this.canonical.z)}toUnwrapped(){return new ll(this.wrap,this.canonical)}toString(){return"".concat(this.overscaledZ,"/").concat(this.canonical.x,"/").concat(this.canonical.y)}getTilePoint(t){return this.canonical.getTilePoint(new ga(t.x-this.wrap,t.y))}};function yi(e,t,r,n,i){e*=2,e<0&&(e=e*-1-1);let o=1<<r;return(o*o*e+o*i+n).toString(36)+r.toString(36)+t.toString(36)}function Bb(e,t,r){let n="",i;for(let o=e;o>0;o--)i=1<<o-1,n+=(t&i?1:0)+(r&i?2:0);return n}C("CanonicalTileID",xa);C("OverscaledTileID",mi,{omit:["posMatrix"]});var ba=class{constructor(t){this.tileID=new mi(t.tileID.overscaledZ,t.tileID.wrap,t.tileID.canonical.z,t.tileID.canonical.x,t.tileID.canonical.y),this.uid=t.uid,this.zoom=t.zoom,this.pixelRatio=t.pixelRatio,this.tileSize=t.tileSize,this.source=t.source,this.overscaling=this.tileID.overscaleFactor(),this.showCollisionBoxes=t.showCollisionBoxes,this.collectResourceTiming=!!t.collectResourceTiming,this.returnDependencies=!!t.returnDependencies,this.promoteId=t.promoteId,this.inFlightDependencies=[]}async parse(t,r,n,i){this.status="parsing",this.data=t,this.collisionBoxArray=new Fn;let o=new Dr(Object.keys(t.layers).sort()),a=new li(this.tileID,this.promoteId);a.bucketLayerIDs=[];let s={},l={featureIndex:a,iconDependencies:{},patternDependencies:{},glyphDependencies:{},availableImages:n},u=r.familiesBySource[this.source];for(let P in u){let w=t.layers[P];if(!w)continue;w.version===1&&fe('Vector tile source "'.concat(this.source,'" layer "').concat(P,'" ')+"does not use vector tile spec v2 and therefore may have some rendering errors.");let T=o.encode(P),F=[];for(let E=0;E<w.length;E++){let _=w.feature(E),I=a.getId(_,P);F.push({feature:_,id:I,index:E,sourceLayerIndex:T})}for(let E of u[P]){let _=E[0];if(_.source!==this.source&&fe("layer.source = ".concat(_.source," does not equal this.source = ").concat(this.source)),_.minzoom&&this.zoom<Math.floor(_.minzoom)||_.maxzoom&&this.zoom>=_.maxzoom||_.visibility==="none")continue;ul(E,this.zoom,n),(s[_.id]=_.createBucket({index:a.bucketLayerIDs.length,layers:E,zoom:this.zoom,pixelRatio:this.pixelRatio,overscaling:this.overscaling,collisionBoxArray:this.collisionBoxArray,sourceLayerIndex:T,sourceID:this.source})).populate(F,l,this.tileID.canonical),a.bucketLayerIDs.push(E.map(k=>k.id))}}let c=Gr(l.glyphDependencies,P=>Object.keys(P).map(Number));this.inFlightDependencies.forEach(P=>P==null?void 0:P.abort()),this.inFlightDependencies=[];let p=Promise.resolve({});if(Object.keys(c).length){let P=new AbortController;this.inFlightDependencies.push(P),p=i.sendAsync({type:"GG",data:{stacks:c,source:this.source,tileID:this.tileID,type:"glyphs"}},P)}let f=Object.keys(l.iconDependencies),y=Promise.resolve({});if(f.length){let P=new AbortController;this.inFlightDependencies.push(P),y=i.sendAsync({type:"GI",data:{icons:f,source:this.source,tileID:this.tileID,type:"icons"}},P)}let m=Object.keys(l.patternDependencies),h=Promise.resolve({});if(m.length){let P=new AbortController;this.inFlightDependencies.push(P),h=i.sendAsync({type:"GI",data:{icons:m,source:this.source,tileID:this.tileID,type:"patterns"}},P)}let[d,g,b]=await Promise.all([p,y,h]),x=new pi(d),v=new ti(g,b);for(let P in s){let w=s[P];w instanceof He?(ul(w.layers,this.zoom,n),Bf({bucket:w,glyphMap:d,glyphPositions:x.positions,imageMap:g,imagePositions:v.iconPositions,showCollisionBoxes:this.showCollisionBoxes,canonical:this.tileID.canonical})):w.hasPattern&&(w instanceof rr||w instanceof er||w instanceof tr)&&(ul(w.layers,this.zoom,n),w.addFeatures(l,this.tileID.canonical,v.patternPositions))}return this.status="done",{buckets:Object.values(s).filter(P=>!P.isEmpty()),featureIndex:a,collisionBoxArray:this.collisionBoxArray,glyphAtlasImage:x.image,imageAtlas:v,glyphMap:this.returnDependencies?d:null,iconMap:this.returnDependencies?g:null,glyphPositions:this.returnDependencies?x.positions:null}}};function ul(e,t,r){let n=new q(t);for(let i of e)i.recalculate(n,r)}var zb=60,OI=1e3/zb;var zr=class{constructor(t){this._marks={start:[t.url,"start"].join("#"),end:[t.url,"end"].join("#"),measure:t.url.toString()},performance.mark(this._marks.start)}finish(){performance.mark(this._marks.end);let t=performance.getEntriesByName(this._marks.measure);return t.length===0&&(performance.measure(this._marks.measure,this._marks.start,this._marks.end),t=performance.getEntriesByName(this._marks.measure),performance.clearMarks(this._marks.start),performance.clearMarks(this._marks.end),performance.clearMeasures(this._marks.measure)),t}};var Rr=class{constructor(t,r,n){this.actor=t,this.layerIndex=r,this.availableImages=n,this.fetching={},this.loading={},this.loaded={}}async loadVectorTile(t,r){let n=await uc(t.request,r);try{return{vectorTile:new Gf.default.VectorTile(new qf.default(n.data)),rawData:n.data,cacheControl:n.cacheControl,expires:n.expires}}catch(i){let o=new Uint8Array(n.data),a=o[0]===31&&o[1]===139,s="Unable to parse the tile at ".concat(t.request.url,", ");throw a?s+="please make sure the data is not gzipped and that you have configured the relevant header in the server":s+="got error: ".concat(i.messge),new Error(s)}}async loadTile(t){let r=t.uid,n=t&&t.request&&t.request.collectResourceTiming?new zr(t.request):!1,i=new ba(t);this.loading[r]=i;let o=new AbortController;i.abort=o;try{let a=await this.loadVectorTile(t,o);if(delete this.loading[r],!a)return null;let s=a.rawData,l={};a.expires&&(l.expires=a.expires),a.cacheControl&&(l.cacheControl=a.cacheControl);let u={};if(n){let p=n.finish();p&&(u.resourceTiming=JSON.parse(JSON.stringify(p)))}i.vectorTile=a.vectorTile;let c=i.parse(a.vectorTile,this.layerIndex,this.availableImages,this.actor);this.loaded[r]=i,this.fetching[r]={rawTileData:s,cacheControl:l,resourceTiming:u};try{let p=await c;return Pe({rawTileData:s.slice(0)},p,l,u)}finally{delete this.fetching[r]}}catch(a){throw delete this.loading[r],i.status="done",this.loaded[r]=i,a}}async reloadTile(t){let r=t.uid;if(!this.loaded||!this.loaded[r])throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");let n=this.loaded[r];if(n.showCollisionBoxes=t.showCollisionBoxes,n.status==="parsing"){let i=await n.parse(n.vectorTile,this.layerIndex,this.availableImages,this.actor),o;if(this.fetching[r]){let{rawTileData:a,cacheControl:s,resourceTiming:l}=this.fetching[r];delete this.fetching[r],o=Pe({rawTileData:a.slice(0)},i,s,l)}else o=i;return o}if(n.status==="done"&&n.vectorTile)return n.parse(n.vectorTile,this.layerIndex,this.availableImages,this.actor)}async abortTile(t){let r=this.loading,n=t.uid;r&&r[n]&&r[n].abort&&(r[n].abort.abort(),delete r[n])}async removeTile(t){this.loaded&&this.loaded[t.uid]&&delete this.loaded[t.uid]}};var hi=class{constructor(t,r,n,i=1,o=1,a=1,s=0){if(this.uid=t,r.height!==r.width)throw new RangeError("DEM tiles must be square");if(n&&!["mapbox","terrarium","custom"].includes(n)){fe('"'.concat(n,'" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".'));return}this.stride=r.height;let l=this.dim=r.height-2;switch(this.data=new Uint32Array(r.data.buffer),n){case"terrarium":this.redFactor=256,this.greenFactor=1,this.blueFactor=1/256,this.baseShift=32768;break;case"custom":this.redFactor=i,this.greenFactor=o,this.blueFactor=a,this.baseShift=s;break;case"mapbox":default:this.redFactor=6553.6,this.greenFactor=25.6,this.blueFactor=.1,this.baseShift=1e4;break}for(let u=0;u<l;u++)this.data[this._idx(-1,u)]=this.data[this._idx(0,u)],this.data[this._idx(l,u)]=this.data[this._idx(l-1,u)],this.data[this._idx(u,-1)]=this.data[this._idx(u,0)],this.data[this._idx(u,l)]=this.data[this._idx(u,l-1)];this.data[this._idx(-1,-1)]=this.data[this._idx(0,0)],this.data[this._idx(l,-1)]=this.data[this._idx(l-1,0)],this.data[this._idx(-1,l)]=this.data[this._idx(0,l-1)],this.data[this._idx(l,l)]=this.data[this._idx(l-1,l-1)],this.min=Number.MAX_SAFE_INTEGER,this.max=Number.MIN_SAFE_INTEGER;for(let u=0;u<l;u++)for(let c=0;c<l;c++){let p=this.get(u,c);p>this.max&&(this.max=p),p<this.min&&(this.min=p)}}get(t,r){let n=new Uint8Array(this.data.buffer),i=this._idx(t,r)*4;return this.unpack(n[i],n[i+1],n[i+2])}getUnpackVector(){return[this.redFactor,this.greenFactor,this.blueFactor,this.baseShift]}_idx(t,r){if(t<-1||t>=this.dim+1||r<-1||r>=this.dim+1)throw new RangeError("out of range source coordinates for DEM data");return(r+1)*this.stride+(t+1)}unpack(t,r,n){return t*this.redFactor+r*this.greenFactor+n*this.blueFactor-this.baseShift}getPixels(){return new de({width:this.stride,height:this.stride},new Uint8Array(this.data.buffer))}backfillBorder(t,r,n){if(this.dim!==t.dim)throw new Error("dem dimension mismatch");let i=r*this.dim,o=r*this.dim+this.dim,a=n*this.dim,s=n*this.dim+this.dim;switch(r){case-1:i=o-1;break;case 1:o=i+1;break}switch(n){case-1:a=s-1;break;case 1:s=a+1;break}let l=-r*this.dim,u=-n*this.dim;for(let c=a;c<s;c++)for(let p=i;p<o;p++)this.data[this._idx(p,c)]=t.data[this._idx(p+l,c+u)]}};C("DEMData",hi);var va=class{constructor(){this.loaded={}}async loadTile(t){let{uid:r,encoding:n,rawImageData:i,redFactor:o,greenFactor:a,blueFactor:s,baseShift:l}=t,u=i.width+2,c=i.height+2,p=qr(i)?new de({width:u,height:c},await Wl(i,-1,-1,u,c)):i,f=new hi(r,p,n,o,a,s,l);return this.loaded=this.loaded||{},this.loaded[r]=f,f}removeTile(t){let r=this.loaded,n=t.uid;r&&r[n]&&delete r[n]}};var gy=Z(Wf(),1);var cl=Z(he(),1),Hf=Z(Tt(),1);var Rb=Hf.default.VectorTileFeature.prototype.toGeoJSON,pl=class{constructor(t){this._feature=t,this.extent=8192,this.type=t.type,this.properties=t.tags,"id"in t&&!isNaN(t.id)&&(this.id=parseInt(t.id,10))}loadGeometry(){if(this._feature.type===1){let t=[];for(let r of this._feature.geometry)t.push([new cl.default(r[0],r[1])]);return t}else{let t=[];for(let r of this._feature.geometry){let n=[];for(let i of r)n.push(new cl.default(i[0],i[1]));t.push(n)}return t}}toGeoJSON(t,r,n){return Rb.call(this,t,r,n)}},Sa=class{constructor(t){this.layers={_geojsonTileLayer:this},this.name="_geojsonTileLayer",this.extent=8192,this.length=t.length,this._features=t}feature(t){return new pl(this._features[t])}};var xy=Z(ty(),1);var ry=[Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array],ml=1,gi=8,bi=class e{static from(t){if(!(t instanceof ArrayBuffer))throw new Error("Data must be an instance of ArrayBuffer.");let[r,n]=new Uint8Array(t,0,2);if(r!==219)throw new Error("Data does not appear to be in a KDBush format.");let i=n>>4;if(i!==ml)throw new Error("Got v".concat(i," data when expected v").concat(ml,"."));let o=ry[n&15];if(!o)throw new Error("Unrecognized array type.");let[a]=new Uint16Array(t,2,1),[s]=new Uint32Array(t,4,1);return new e(s,a,o,t)}constructor(t,r=64,n=Float64Array,i){if(isNaN(t)||t<0)throw new Error("Unpexpected numItems value: ".concat(t,"."));this.numItems=+t,this.nodeSize=Math.min(Math.max(+r,2),65535),this.ArrayType=n,this.IndexArrayType=t<65536?Uint16Array:Uint32Array;let o=ry.indexOf(this.ArrayType),a=t*2*this.ArrayType.BYTES_PER_ELEMENT,s=t*this.IndexArrayType.BYTES_PER_ELEMENT,l=(8-s%8)%8;if(o<0)throw new Error("Unexpected typed array class: ".concat(n,"."));i&&i instanceof ArrayBuffer?(this.data=i,this.ids=new this.IndexArrayType(this.data,gi,t),this.coords=new this.ArrayType(this.data,gi+s+l,t*2),this._pos=t*2,this._finished=!0):(this.data=new ArrayBuffer(gi+a+s+l),this.ids=new this.IndexArrayType(this.data,gi,t),this.coords=new this.ArrayType(this.data,gi+s+l,t*2),this._pos=0,this._finished=!1,new Uint8Array(this.data,0,2).set([219,(ml<<4)+o]),new Uint16Array(this.data,2,1)[0]=r,new Uint32Array(this.data,4,1)[0]=t)}add(t,r){let n=this._pos>>1;return this.ids[n]=n,this.coords[this._pos++]=t,this.coords[this._pos++]=r,n}finish(){let t=this._pos>>1;if(t!==this.numItems)throw new Error("Added ".concat(t," items when expected ").concat(this.numItems,"."));return dl(this.ids,this.coords,this.nodeSize,0,this.numItems-1,0),this._finished=!0,this}range(t,r,n,i){if(!this._finished)throw new Error("Data not yet indexed - call index.finish().");let{ids:o,coords:a,nodeSize:s}=this,l=[0,o.length-1,0],u=[];for(;l.length;){let c=l.pop()||0,p=l.pop()||0,f=l.pop()||0;if(p-f<=s){for(let d=f;d<=p;d++){let g=a[2*d],b=a[2*d+1];g>=t&&g<=n&&b>=r&&b<=i&&u.push(o[d])}continue}let y=f+p>>1,m=a[2*y],h=a[2*y+1];m>=t&&m<=n&&h>=r&&h<=i&&u.push(o[y]),(c===0?t<=m:r<=h)&&(l.push(f),l.push(y-1),l.push(1-c)),(c===0?n>=m:i>=h)&&(l.push(y+1),l.push(p),l.push(1-c))}return u}within(t,r,n){if(!this._finished)throw new Error("Data not yet indexed - call index.finish().");let{ids:i,coords:o,nodeSize:a}=this,s=[0,i.length-1,0],l=[],u=n*n;for(;s.length;){let c=s.pop()||0,p=s.pop()||0,f=s.pop()||0;if(p-f<=a){for(let d=f;d<=p;d++)ny(o[2*d],o[2*d+1],t,r)<=u&&l.push(i[d]);continue}let y=f+p>>1,m=o[2*y],h=o[2*y+1];ny(m,h,t,r)<=u&&l.push(i[y]),(c===0?t-n<=m:r-n<=h)&&(s.push(f),s.push(y-1),s.push(1-c)),(c===0?t+n>=m:r+n>=h)&&(s.push(y+1),s.push(p),s.push(1-c))}return l}};function dl(e,t,r,n,i,o){if(i-n<=r)return;let a=n+i>>1;iy(e,t,a,n,i,o),dl(e,t,r,n,a-1,1-o),dl(e,t,r,a+1,i,1-o)}function iy(e,t,r,n,i,o){for(;i>n;){if(i-n>600){let u=i-n+1,c=r-n+1,p=Math.log(u),f=.5*Math.exp(2*p/3),y=.5*Math.sqrt(p*f*(u-f)/u)*(c-u/2<0?-1:1),m=Math.max(n,Math.floor(r-c*f/u+y)),h=Math.min(i,Math.floor(r+(u-c)*f/u+y));iy(e,t,r,m,h,o)}let a=t[2*r+o],s=n,l=i;for(xi(e,t,n,r),t[2*i+o]>a&&xi(e,t,n,i);s<l;){for(xi(e,t,s,l),s++,l--;t[2*s+o]<a;)s++;for(;t[2*l+o]>a;)l--}t[2*n+o]===a?xi(e,t,n,l):(l++,xi(e,t,l,i)),l<=r&&(n=l+1),r<=l&&(i=l-1)}}function xi(e,t,r,n){hl(e,r,n),hl(t,2*r,2*n),hl(t,2*r+1,2*n+1)}function hl(e,t,r){let n=e[t];e[t]=e[r],e[r]=n}function ny(e,t,r,n){let i=e-r,o=t-n;return i*i+o*o}var Hb={minZoom:0,maxZoom:16,minPoints:2,radius:40,extent:512,nodeSize:64,log:!1,generateId:!1,reduce:null,map:e=>e},oy=Math.fround||(e=>t=>(e[0]=+t,e[0]))(new Float32Array(1)),ir=2,Et=3,gl=4,Mt=5,sy=6,vi=class{constructor(t){this.options=Object.assign(Object.create(Hb),t),this.trees=new Array(this.options.maxZoom+1),this.stride=this.options.reduce?7:6,this.clusterProps=[]}load(t){let{log:r,minZoom:n,maxZoom:i}=this.options;r&&console.time("total time");let o="prepare ".concat(t.length," points");r&&console.time(o),this.points=t;let a=[];for(let l=0;l<t.length;l++){let u=t[l];if(!u.geometry)continue;let[c,p]=u.geometry.coordinates,f=oy(Aa(c)),y=oy(_a(p));a.push(f,y,1/0,l,-1,1),this.options.reduce&&a.push(0)}let s=this.trees[i+1]=this._createTree(a);r&&console.timeEnd(o);for(let l=i;l>=n;l--){let u=+Date.now();s=this.trees[l]=this._createTree(this._cluster(s,l)),r&&console.log("z%d: %d clusters in %dms",l,s.numItems,+Date.now()-u)}return r&&console.timeEnd("total time"),this}getClusters(t,r){let n=((t[0]+180)%360+360)%360-180,i=Math.max(-90,Math.min(90,t[1])),o=t[2]===180?180:((t[2]+180)%360+360)%360-180,a=Math.max(-90,Math.min(90,t[3]));if(t[2]-t[0]>=360)n=-180,o=180;else if(n>o){let p=this.getClusters([n,i,180,a],r),f=this.getClusters([-180,i,o,a],r);return p.concat(f)}let s=this.trees[this._limitZoom(r)],l=s.range(Aa(n),_a(a),Aa(o),_a(i)),u=s.data,c=[];for(let p of l){let f=this.stride*p;c.push(u[f+Mt]>1?ay(u,f,this.clusterProps):this.points[u[f+Et]])}return c}getChildren(t){let r=this._getOriginId(t),n=this._getOriginZoom(t),i="No cluster with the specified id.",o=this.trees[n];if(!o)throw new Error(i);let a=o.data;if(r*this.stride>=a.length)throw new Error(i);let s=this.options.radius/(this.options.extent*Math.pow(2,n-1)),l=a[r*this.stride],u=a[r*this.stride+1],c=o.within(l,u,s),p=[];for(let f of c){let y=f*this.stride;a[y+gl]===t&&p.push(a[y+Mt]>1?ay(a,y,this.clusterProps):this.points[a[y+Et]])}if(p.length===0)throw new Error(i);return p}getLeaves(t,r,n){r=r||10,n=n||0;let i=[];return this._appendLeaves(i,t,r,n,0),i}getTile(t,r,n){let i=this.trees[this._limitZoom(t)],o=Math.pow(2,t),{extent:a,radius:s}=this.options,l=s/a,u=(n-l)/o,c=(n+1+l)/o,p={features:[]};return this._addTileFeatures(i.range((r-l)/o,u,(r+1+l)/o,c),i.data,r,n,o,p),r===0&&this._addTileFeatures(i.range(1-l/o,u,1,c),i.data,o,n,o,p),r===o-1&&this._addTileFeatures(i.range(0,u,l/o,c),i.data,-1,n,o,p),p.features.length?p:null}getClusterExpansionZoom(t){let r=this._getOriginZoom(t)-1;for(;r<=this.options.maxZoom;){let n=this.getChildren(t);if(r++,n.length!==1)break;t=n[0].properties.cluster_id}return r}_appendLeaves(t,r,n,i,o){let a=this.getChildren(r);for(let s of a){let l=s.properties;if(l&&l.cluster?o+l.point_count<=i?o+=l.point_count:o=this._appendLeaves(t,l.cluster_id,n,i,o):o<i?o++:t.push(s),t.length===n)break}return o}_createTree(t){let r=new bi(t.length/this.stride|0,this.options.nodeSize,Float32Array);for(let n=0;n<t.length;n+=this.stride)r.add(t[n],t[n+1]);return r.finish(),r.data=t,r}_addTileFeatures(t,r,n,i,o,a){for(let s of t){let l=s*this.stride,u=r[l+Mt]>1,c,p,f;if(u)c=ly(r,l,this.clusterProps),p=r[l],f=r[l+1];else{let h=this.points[r[l+Et]];c=h.properties;let[d,g]=h.geometry.coordinates;p=Aa(d),f=_a(g)}let y={type:1,geometry:[[Math.round(this.options.extent*(p*o-n)),Math.round(this.options.extent*(f*o-i))]],tags:c},m;u||this.options.generateId?m=r[l+Et]:m=this.points[r[l+Et]].id,m!==void 0&&(y.id=m),a.features.push(y)}}_limitZoom(t){return Math.max(this.options.minZoom,Math.min(Math.floor(+t),this.options.maxZoom+1))}_cluster(t,r){let{radius:n,extent:i,reduce:o,minPoints:a}=this.options,s=n/(i*Math.pow(2,r)),l=t.data,u=[],c=this.stride;for(let p=0;p<l.length;p+=c){if(l[p+ir]<=r)continue;l[p+ir]=r;let f=l[p],y=l[p+1],m=t.within(l[p],l[p+1],s),h=l[p+Mt],d=h;for(let g of m){let b=g*c;l[b+ir]>r&&(d+=l[b+Mt])}if(d>h&&d>=a){let g=f*h,b=y*h,x,v=-1,P=((p/c|0)<<5)+(r+1)+this.points.length;for(let w of m){let T=w*c;if(l[T+ir]<=r)continue;l[T+ir]=r;let F=l[T+Mt];g+=l[T]*F,b+=l[T+1]*F,l[T+gl]=P,o&&(x||(x=this._map(l,p,!0),v=this.clusterProps.length,this.clusterProps.push(x)),o(x,this._map(l,T)))}l[p+gl]=P,u.push(g/d,b/d,1/0,P,-1,d),o&&u.push(v)}else{for(let g=0;g<c;g++)u.push(l[p+g]);if(d>1)for(let g of m){let b=g*c;if(!(l[b+ir]<=r)){l[b+ir]=r;for(let x=0;x<c;x++)u.push(l[b+x])}}}}return u}_getOriginId(t){return t-this.points.length>>5}_getOriginZoom(t){return(t-this.points.length)%32}_map(t,r,n){if(t[r+Mt]>1){let a=this.clusterProps[t[r+sy]];return n?Object.assign({},a):a}let i=this.points[t[r+Et]].properties,o=this.options.map(i);return n&&o===i?Object.assign({},o):o}};function ay(e,t,r){return{type:"Feature",id:e[t+Et],properties:ly(e,t,r),geometry:{type:"Point",coordinates:[Xb(e[t]),Kb(e[t+1])]}}}function ly(e,t,r){let n=e[t+Mt],i=n>=1e4?"".concat(Math.round(n/1e3),"k"):n>=1e3?"".concat(Math.round(n/100)/10,"k"):n,o=e[t+sy],a=o===-1?{}:Object.assign({},r[o]);return Object.assign(a,{cluster:!0,cluster_id:e[t+Et],point_count:n,point_count_abbreviated:i})}function Aa(e){return e/360+.5}function _a(e){let t=Math.sin(e*Math.PI/180),r=.5-.25*Math.log((1+t)/(1-t))/Math.PI;return r<0?0:r>1?1:r}function Xb(e){return(e-.5)*360}function Kb(e){let t=(180-e*360)*Math.PI/180;return 360*Math.atan(Math.exp(t))/Math.PI-90}function Pi(e,t,r,n){for(var i=n,o=r-t>>1,a=r-t,s,l=e[t],u=e[t+1],c=e[r],p=e[r+1],f=t+3;f<r;f+=3){var y=Yb(e[f],e[f+1],l,u,c,p);if(y>i)s=f,i=y;else if(y===i){var m=Math.abs(f-o);m<a&&(s=f,a=m)}}i>n&&(s-t>3&&Pi(e,t,s,n),e[s+2]=i,r-s>3&&Pi(e,s,r,n))}function Yb(e,t,r,n,i,o){var a=i-r,s=o-n;if(a!==0||s!==0){var l=((e-r)*a+(t-n)*s)/(a*a+s*s);l>1?(r=i,n=o):l>0&&(r+=a*l,n+=s*l)}return a=e-r,s=t-n,a*a+s*s}function ft(e,t,r,n){var i={id:typeof e>"u"?null:e,type:t,geometry:r,tags:n,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0};return Qb(i),i}function Qb(e){var t=e.geometry,r=e.type;if(r==="Point"||r==="MultiPoint"||r==="LineString")xl(e,t);else if(r==="Polygon"||r==="MultiLineString")for(var n=0;n<t.length;n++)xl(e,t[n]);else if(r==="MultiPolygon")for(n=0;n<t.length;n++)for(var i=0;i<t[n].length;i++)xl(e,t[n][i])}function xl(e,t){for(var r=0;r<t.length;r+=3)e.minX=Math.min(e.minX,t[r]),e.minY=Math.min(e.minY,t[r+1]),e.maxX=Math.max(e.maxX,t[r]),e.maxY=Math.max(e.maxY,t[r+1])}function Pl(e,t){var r=[];if(e.type==="FeatureCollection")for(var n=0;n<e.features.length;n++)Ia(r,e.features[n],t,n);else e.type==="Feature"?Ia(r,e,t):Ia(r,{geometry:e},t);return r}function Ia(e,t,r,n){if(t.geometry){var i=t.geometry.coordinates,o=t.geometry.type,a=Math.pow(r.tolerance/((1<<r.maxZoom)*r.extent),2),s=[],l=t.id;if(r.promoteId?l=t.properties[r.promoteId]:r.generateId&&(l=n||0),o==="Point")uy(i,s);else if(o==="MultiPoint")for(var u=0;u<i.length;u++)uy(i[u],s);else if(o==="LineString")vl(i,s,a,!1);else if(o==="MultiLineString")if(r.lineMetrics){for(u=0;u<i.length;u++)s=[],vl(i[u],s,a,!1),e.push(ft(l,"LineString",s,t.properties));return}else bl(i,s,a,!1);else if(o==="Polygon")bl(i,s,a,!0);else if(o==="MultiPolygon")for(u=0;u<i.length;u++){var c=[];bl(i[u],c,a,!0),s.push(c)}else if(o==="GeometryCollection"){for(u=0;u<t.geometry.geometries.length;u++)Ia(e,{id:l,geometry:t.geometry.geometries[u],properties:t.properties},r,n);return}else throw new Error("Input data is not a valid GeoJSON object.");e.push(ft(l,o,s,t.properties))}}function uy(e,t){t.push(cy(e[0])),t.push(py(e[1])),t.push(0)}function vl(e,t,r,n){for(var i,o,a=0,s=0;s<e.length;s++){var l=cy(e[s][0]),u=py(e[s][1]);t.push(l),t.push(u),t.push(0),s>0&&(n?a+=(i*u-l*o)/2:a+=Math.sqrt(Math.pow(l-i,2)+Math.pow(u-o,2))),i=l,o=u}var c=t.length-3;t[2]=1,Pi(t,0,c,r),t[c+2]=1,t.size=Math.abs(a),t.start=0,t.end=t.size}function bl(e,t,r,n){for(var i=0;i<e.length;i++){var o=[];vl(e[i],o,r,n),t.push(o)}}function cy(e){return e/360+.5}function py(e){var t=Math.sin(e*Math.PI/180),r=.5-.25*Math.log((1+t)/(1-t))/Math.PI;return r<0?0:r>1?1:r}function qe(e,t,r,n,i,o,a,s){if(r/=t,n/=t,o>=r&&a<n)return e;if(a<r||o>=n)return null;for(var l=[],u=0;u<e.length;u++){var c=e[u],p=c.geometry,f=c.type,y=i===0?c.minX:c.minY,m=i===0?c.maxX:c.maxY;if(y>=r&&m<n){l.push(c);continue}else if(m<r||y>=n)continue;var h=[];if(f==="Point"||f==="MultiPoint")e0(p,h,r,n,i);else if(f==="LineString")yy(p,h,r,n,i,!1,s.lineMetrics);else if(f==="MultiLineString")Sl(p,h,r,n,i,!1);else if(f==="Polygon")Sl(p,h,r,n,i,!0);else if(f==="MultiPolygon")for(var d=0;d<p.length;d++){var g=[];Sl(p[d],g,r,n,i,!0),g.length&&h.push(g)}if(h.length){if(s.lineMetrics&&f==="LineString"){for(d=0;d<h.length;d++)l.push(ft(c.id,f,h[d],c.tags));continue}(f==="LineString"||f==="MultiLineString")&&(h.length===1?(f="LineString",h=h[0]):f="MultiLineString"),(f==="Point"||f==="MultiPoint")&&(f=h.length===3?"Point":"MultiPoint"),l.push(ft(c.id,f,h,c.tags))}}return l.length?l:null}function e0(e,t,r,n,i){for(var o=0;o<e.length;o+=3){var a=e[o+i];a>=r&&a<=n&&(t.push(e[o]),t.push(e[o+1]),t.push(e[o+2]))}}function yy(e,t,r,n,i,o,a){for(var s=fy(e),l=i===0?t0:r0,u=e.start,c,p,f=0;f<e.length-3;f+=3){var y=e[f],m=e[f+1],h=e[f+2],d=e[f+3],g=e[f+4],b=i===0?y:m,x=i===0?d:g,v=!1;a&&(c=Math.sqrt(Math.pow(y-d,2)+Math.pow(m-g,2))),b<r?x>r&&(p=l(s,y,m,d,g,r),a&&(s.start=u+c*p)):b>n?x<n&&(p=l(s,y,m,d,g,n),a&&(s.start=u+c*p)):wl(s,y,m,h),x<r&&b>=r&&(p=l(s,y,m,d,g,r),v=!0),x>n&&b<=n&&(p=l(s,y,m,d,g,n),v=!0),!o&&v&&(a&&(s.end=u+c*p),t.push(s),s=fy(e)),a&&(u+=c)}var P=e.length-3;y=e[P],m=e[P+1],h=e[P+2],b=i===0?y:m,b>=r&&b<=n&&wl(s,y,m,h),P=s.length-3,o&&P>=3&&(s[P]!==s[0]||s[P+1]!==s[1])&&wl(s,s[0],s[1],s[2]),s.length&&t.push(s)}function fy(e){var t=[];return t.size=e.size,t.start=e.start,t.end=e.end,t}function Sl(e,t,r,n,i,o){for(var a=0;a<e.length;a++)yy(e[a],t,r,n,i,o,!1)}function wl(e,t,r,n){e.push(t),e.push(r),e.push(n)}function t0(e,t,r,n,i,o){var a=(o-t)/(n-t);return e.push(o),e.push(r+(i-r)*a),e.push(1),a}function r0(e,t,r,n,i,o){var a=(o-r)/(i-r);return e.push(t+(n-t)*a),e.push(o),e.push(1),a}function _l(e,t){var r=t.buffer/t.extent,n=e,i=qe(e,1,-1-r,r,0,-1,2,t),o=qe(e,1,1-r,2+r,0,-1,2,t);return(i||o)&&(n=qe(e,1,-r,1+r,0,-1,2,t)||[],i&&(n=my(i,1).concat(n)),o&&(n=n.concat(my(o,-1)))),n}function my(e,t){for(var r=[],n=0;n<e.length;n++){var i=e[n],o=i.type,a;if(o==="Point"||o==="MultiPoint"||o==="LineString")a=Al(i.geometry,t);else if(o==="MultiLineString"||o==="Polygon"){a=[];for(var s=0;s<i.geometry.length;s++)a.push(Al(i.geometry[s],t))}else if(o==="MultiPolygon")for(a=[],s=0;s<i.geometry.length;s++){for(var l=[],u=0;u<i.geometry[s].length;u++)l.push(Al(i.geometry[s][u],t));a.push(l)}r.push(ft(i.id,o,a,i.tags))}return r}function Al(e,t){var r=[];r.size=e.size,e.start!==void 0&&(r.start=e.start,r.end=e.end);for(var n=0;n<e.length;n+=3)r.push(e[n]+t,e[n+1],e[n+2]);return r}function Ta(e,t){if(e.transformed)return e;var r=1<<e.z,n=e.x,i=e.y,o,a,s;for(o=0;o<e.features.length;o++){var l=e.features[o],u=l.geometry,c=l.type;if(l.geometry=[],c===1)for(a=0;a<u.length;a+=2)l.geometry.push(hy(u[a],u[a+1],t,r,n,i));else for(a=0;a<u.length;a++){var p=[];for(s=0;s<u[a].length;s+=2)p.push(hy(u[a][s],u[a][s+1],t,r,n,i));l.geometry.push(p)}}return e.transformed=!0,e}function hy(e,t,r,n,i,o){return[Math.round(r*(e*n-i)),Math.round(r*(t*n-o))]}function Tl(e,t,r,n,i){for(var o=t===i.maxZoom?0:i.tolerance/((1<<t)*i.extent),a={features:[],numPoints:0,numSimplified:0,numFeatures:0,source:null,x:r,y:n,z:t,transformed:!1,minX:2,minY:1,maxX:-1,maxY:0},s=0;s<e.length;s++){a.numFeatures++,n0(a,e[s],o,i);var l=e[s].minX,u=e[s].minY,c=e[s].maxX,p=e[s].maxY;l<a.minX&&(a.minX=l),u<a.minY&&(a.minY=u),c>a.maxX&&(a.maxX=c),p>a.maxY&&(a.maxY=p)}return a}function n0(e,t,r,n){var i=t.geometry,o=t.type,a=[];if(o==="Point"||o==="MultiPoint")for(var s=0;s<i.length;s+=3)a.push(i[s]),a.push(i[s+1]),e.numPoints++,e.numSimplified++;else if(o==="LineString")Il(a,i,e,r,!1,!1);else if(o==="MultiLineString"||o==="Polygon")for(s=0;s<i.length;s++)Il(a,i[s],e,r,o==="Polygon",s===0);else if(o==="MultiPolygon")for(var l=0;l<i.length;l++){var u=i[l];for(s=0;s<u.length;s++)Il(a,u[s],e,r,!0,s===0)}if(a.length){var c=t.tags||null;if(o==="LineString"&&n.lineMetrics){c={};for(var p in t.tags)c[p]=t.tags[p];c.mapbox_clip_start=i.start/i.size,c.mapbox_clip_end=i.end/i.size}var f={geometry:a,type:o==="Polygon"||o==="MultiPolygon"?3:o==="LineString"||o==="MultiLineString"?2:1,tags:c};t.id!==null&&(f.id=t.id),e.features.push(f)}}function Il(e,t,r,n,i,o){var a=n*n;if(n>0&&t.size<(i?a:n)){r.numPoints+=t.length/3;return}for(var s=[],l=0;l<t.length;l+=3)(n===0||t[l+2]>a)&&(r.numSimplified++,s.push(t[l]),s.push(t[l+1])),r.numPoints++;i&&i0(s,o),e.push(s)}function i0(e,t){for(var r=0,n=0,i=e.length,o=i-2;n<i;o=n,n+=2)r+=(e[n]-e[o])*(e[n+1]+e[o+1]);if(r>0===t)for(n=0,i=e.length;n<i/2;n+=2){var a=e[n],s=e[n+1];e[n]=e[i-2-n],e[n+1]=e[i-1-n],e[i-2-n]=a,e[i-1-n]=s}}function kl(e,t){return new Ca(e,t)}function Ca(e,t){t=this.options=o0(Object.create(this.options),t);var r=t.debug;if(r&&console.time("preprocess data"),t.maxZoom<0||t.maxZoom>24)throw new Error("maxZoom should be in the 0-24 range");if(t.promoteId&&t.generateId)throw new Error("promoteId and generateId cannot be used together.");var n=Pl(e,t);this.tiles={},this.tileCoords=[],r&&(console.timeEnd("preprocess data"),console.log("index: maxZoom: %d, maxPoints: %d",t.indexMaxZoom,t.indexMaxPoints),console.time("generate tiles"),this.stats={},this.total=0),n=_l(n,t),n.length&&this.splitTile(n,0,0,0),r&&(n.length&&console.log("features: %d, points: %d",this.tiles[0].numFeatures,this.tiles[0].numPoints),console.timeEnd("generate tiles"),console.log("tiles generated:",this.total,JSON.stringify(this.stats)))}Ca.prototype.options={maxZoom:14,indexMaxZoom:5,indexMaxPoints:1e5,tolerance:3,extent:4096,buffer:64,lineMetrics:!1,promoteId:null,generateId:!1,debug:0};Ca.prototype.splitTile=function(e,t,r,n,i,o,a){for(var s=[e,t,r,n],l=this.options,u=l.debug;s.length;){n=s.pop(),r=s.pop(),t=s.pop(),e=s.pop();var c=1<<t,p=Cl(t,r,n),f=this.tiles[p];if(!f&&(u>1&&console.time("creation"),f=this.tiles[p]=Tl(e,t,r,n,l),this.tileCoords.push({z:t,x:r,y:n}),u)){u>1&&(console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)",t,r,n,f.numFeatures,f.numPoints,f.numSimplified),console.timeEnd("creation"));var y="z"+t;this.stats[y]=(this.stats[y]||0)+1,this.total++}if(f.source=e,i){if(t===l.maxZoom||t===i)continue;var m=1<<i-t;if(r!==Math.floor(o/m)||n!==Math.floor(a/m))continue}else if(t===l.indexMaxZoom||f.numPoints<=l.indexMaxPoints)continue;if(f.source=null,e.length!==0){u>1&&console.time("clipping");var h=.5*l.buffer/l.extent,d=.5-h,g=.5+h,b=1+h,x,v,P,w,T,F;x=v=P=w=null,T=qe(e,c,r-h,r+g,0,f.minX,f.maxX,l),F=qe(e,c,r+d,r+b,0,f.minX,f.maxX,l),e=null,T&&(x=qe(T,c,n-h,n+g,1,f.minY,f.maxY,l),v=qe(T,c,n+d,n+b,1,f.minY,f.maxY,l),T=null),F&&(P=qe(F,c,n-h,n+g,1,f.minY,f.maxY,l),w=qe(F,c,n+d,n+b,1,f.minY,f.maxY,l),F=null),u>1&&console.timeEnd("clipping"),s.push(x||[],t+1,r*2,n*2),s.push(v||[],t+1,r*2,n*2+1),s.push(P||[],t+1,r*2+1,n*2),s.push(w||[],t+1,r*2+1,n*2+1)}}};Ca.prototype.getTile=function(e,t,r){var n=this.options,i=n.extent,o=n.debug;if(e<0||e>24)return null;var a=1<<e;t=(t%a+a)%a;var s=Cl(e,t,r);if(this.tiles[s])return Ta(this.tiles[s],i);o>1&&console.log("drilling down to z%d-%d-%d",e,t,r);for(var l=e,u=t,c=r,p;!p&&l>0;)l--,u=Math.floor(u/2),c=Math.floor(c/2),p=this.tiles[Cl(l,u,c)];return!p||!p.source?null:(o>1&&console.log("found parent tile z%d-%d-%d",l,u,c),o>1&&console.time("drilling down"),this.splitTile(p.source,l,u,c,e,t,r),o>1&&console.timeEnd("drilling down"),this.tiles[s]?Ta(this.tiles[s],i):null)};function Cl(e,t,r){return((1<<e)*r+t)*32+e}function o0(e,t){for(var r in t)e[r]=t[r];return e}function Si(e,t){return t?e.properties[t]:e.id}function Ml(e,t){if(e==null)return!0;if(e.type==="Feature")return Si(e,t)!=null;if(e.type==="FeatureCollection"){let r=new Set;for(let n of e.features){let i=Si(n,t);if(i==null||r.has(i))return!1;r.add(i)}return!0}return!1}function El(e,t){let r=new Map;if(e!=null)if(e.type==="Feature")r.set(Si(e,t),e);else for(let n of e.features)r.set(Si(n,t),n);return r}function dy(e,t,r){var n,i,o,a;if(t.removeAll&&e.clear(),t.remove)for(let s of t.remove)e.delete(s);if(t.add)for(let s of t.add){let l=Si(s,r);l!=null&&e.set(l,s)}if(t.update)for(let s of t.update){let l=e.get(s.id);if(l==null)continue;let u=s.newGeometry||s.removeAllProperties,c=!s.removeAllProperties&&(((n=s.removeProperties)==null?void 0:n.length)>0||((i=s.addOrUpdateProperties)==null?void 0:i.length)>0);if((u||c)&&(l={...l},e.set(s.id,l),c&&(l.properties={...l.properties})),s.newGeometry&&(l.geometry=s.newGeometry),s.removeAllProperties)l.properties={};else if(((o=s.removeProperties)==null?void 0:o.length)>0)for(let p of s.removeProperties)Object.prototype.hasOwnProperty.call(l.properties,p)&&delete l.properties[p];if(((a=s.addOrUpdateProperties)==null?void 0:a.length)>0)for(let{key:p,value:f}of s.addOrUpdateProperties)l.properties[p]=f}}var ka=class extends Rr{constructor(){super(...arguments);this._dataUpdateable=new Map}async loadVectorTile(r,n){let i=r.tileID.canonical;if(!this._geoJSONIndex)throw new Error("Unable to parse the data into a cluster or geojson");let o=this._geoJSONIndex.getTile(i.z,i.x,i.y);if(!o)return null;let a=new Sa(o.features),s=(0,xy.default)(a);return(s.byteOffset!==0||s.byteLength!==s.buffer.byteLength)&&(s=new Uint8Array(s)),{vectorTile:a,rawData:s.buffer}}async loadData(r){var i;(i=this._pendingRequest)==null||i.abort();let n=r&&r.request&&r.request.collectResourceTiming?new zr(r.request):!1;this._pendingRequest=new AbortController;try{let o=await this.loadGeoJSON(r,this._pendingRequest);if(delete this._pendingRequest,typeof o!="object")throw new Error("Input data given to '".concat(r.source,"' is not a valid GeoJSON object."));if((0,gy.default)(o,!0),r.filter){let s=Gt(r.filter,{type:"boolean","property-type":"data-driven",overridable:!1,transition:!1});if(s.result==="error")throw new Error(s.value.map(u=>"".concat(u.key,": ").concat(u.message)).join(", "));o={type:"FeatureCollection",features:o.features.filter(u=>s.value.evaluate({zoom:0},u))}}this._geoJSONIndex=r.cluster?new vi(a0(r)).load(o.features):kl(o,r.geojsonVtOptions),this.loaded={};let a={};if(n){let s=n.finish();s&&(a.resourceTiming={},a.resourceTiming[r.source]=JSON.parse(JSON.stringify(s)))}return a}catch(o){if(delete this._pendingRequest,ec(o))return{abandoned:!0};throw o}}reloadTile(r){let n=this.loaded,i=r.uid;return n&&n[i]?super.reloadTile(r):this.loadTile(r)}async loadGeoJSON(r,n){let{promoteId:i}=r;if(r.request){let o=await lc(r.request,n);return this._dataUpdateable=Ml(o.data,i)?El(o.data,i):void 0,o.data}if(typeof r.data=="string")try{let o=JSON.parse(r.data);return this._dataUpdateable=Ml(o,i)?El(o,i):void 0,o}catch{throw new Error("Input data given to '".concat(r.source,"' is not a valid GeoJSON object."))}if(!r.dataDiff)throw new Error("Input data given to '".concat(r.source,"' is not a valid GeoJSON object."));if(!this._dataUpdateable)throw new Error("Cannot update existing geojson data in ".concat(r.source));return dy(this._dataUpdateable,r.dataDiff,i),{type:"FeatureCollection",features:Array.from(this._dataUpdateable.values())}}async removeSource(r){this._pendingRequest&&this._pendingRequest.abort()}getClusterExpansionZoom(r){return this._geoJSONIndex.getClusterExpansionZoom(r.clusterId)}getClusterChildren(r){return this._geoJSONIndex.getChildren(r.clusterId)}getClusterLeaves(r){return this._geoJSONIndex.getLeaves(r.clusterId,r.limit,r.offset)}};function a0({superclusterOptions:e,clusterProperties:t}){if(!t||!e)return e;let r={},n={},i={accumulated:null,zoom:0},o={properties:null},a=Object.keys(t);for(let s of a){let[l,u]=t[s],c=Gt(u),p=Gt(typeof l=="string"?[l,["accumulated"],["get",s]]:l);r[s]=c.value,n[s]=p.value}return e.map=s=>{o.properties=s;let l={};for(let u of a)l[u]=r[u].evaluate(i,o);return l},e.reduce=(s,l)=>{o.properties=l;for(let u of a)i.accumulated=s[u],s[u]=n[u].evaluate(i,o)},e}var Ma=class{constructor(t){this.self=t,this.actor=new to(t),this.layerIndexes={},this.availableImages={},this.workerSources={},this.demWorkerSources={},this.externalWorkerSourceTypes={},this.self.registerWorkerSource=(r,n)=>{if(this.externalWorkerSourceTypes[r])throw new Error('Worker source with name "'.concat(r,'" already registered.'));this.externalWorkerSourceTypes[r]=n},this.self.addProtocol=rc,this.self.removeProtocol=nc,this.self.registerRTLTextPlugin=r=>{if(ye.isParsed())throw new Error("RTL text plugin already registered.");ye.setMethods(r)},this.actor.registerMessageHandler("LDT",(r,n)=>this._getDEMWorkerSource(r,n.source).loadTile(n)),this.actor.registerMessageHandler("RDT",async(r,n)=>{this._getDEMWorkerSource(r,n.source).removeTile(n)}),this.actor.registerMessageHandler("GCEZ",async(r,n)=>this._getWorkerSource(r,n.type,n.source).getClusterExpansionZoom(n)),this.actor.registerMessageHandler("GCC",async(r,n)=>this._getWorkerSource(r,n.type,n.source).getClusterChildren(n)),this.actor.registerMessageHandler("GCL",async(r,n)=>this._getWorkerSource(r,n.type,n.source).getClusterLeaves(n)),this.actor.registerMessageHandler("LD",(r,n)=>this._getWorkerSource(r,n.type,n.source).loadData(n)),this.actor.registerMessageHandler("LT",(r,n)=>this._getWorkerSource(r,n.type,n.source).loadTile(n)),this.actor.registerMessageHandler("RT",(r,n)=>this._getWorkerSource(r,n.type,n.source).reloadTile(n)),this.actor.registerMessageHandler("AT",(r,n)=>this._getWorkerSource(r,n.type,n.source).abortTile(n)),this.actor.registerMessageHandler("RMT",(r,n)=>this._getWorkerSource(r,n.type,n.source).removeTile(n)),this.actor.registerMessageHandler("RS",async(r,n)=>{if(!this.workerSources[r]||!this.workerSources[r][n.type]||!this.workerSources[r][n.type][n.source])return;let i=this.workerSources[r][n.type][n.source];delete this.workerSources[r][n.type][n.source],i.removeSource!==void 0&&i.removeSource(n)}),this.actor.registerMessageHandler("RM",async r=>{delete this.layerIndexes[r],delete this.availableImages[r],delete this.workerSources[r],delete this.demWorkerSources[r]}),this.actor.registerMessageHandler("SR",async(r,n)=>{this.referrer=n}),this.actor.registerMessageHandler("SRPS",(r,n)=>this._syncRTLPluginState(r,n)),this.actor.registerMessageHandler("IS",async(r,n)=>{this.self.importScripts(n)}),this.actor.registerMessageHandler("SI",(r,n)=>this._setImages(r,n)),this.actor.registerMessageHandler("UL",async(r,n)=>{this._getLayerIndex(r).update(n.layers,n.removedIds)}),this.actor.registerMessageHandler("SL",async(r,n)=>{this._getLayerIndex(r).replace(n)})}async _setImages(t,r){this.availableImages[t]=r;for(let n in this.workerSources[t]){let i=this.workerSources[t][n];for(let o in i)i[o].availableImages=r}}async _syncRTLPluginState(t,r){if(ye.isParsed())return ye.getState();if(r.pluginStatus!=="loading")return ye.setState(r),r;let n=r.pluginURL;if(this.self.importScripts(n),ye.isParsed()){let o={pluginStatus:"loaded",pluginURL:n};return ye.setState(o),o}throw ye.setState({pluginStatus:"error",pluginURL:""}),new Error("RTL Text Plugin failed to import scripts from ".concat(n))}_getAvailableImages(t){let r=this.availableImages[t];return r||(r=[]),r}_getLayerIndex(t){let r=this.layerIndexes[t];return r||(r=this.layerIndexes[t]=new ca),r}_getWorkerSource(t,r,n){if(this.workerSources[t]||(this.workerSources[t]={}),this.workerSources[t][r]||(this.workerSources[t][r]={}),!this.workerSources[t][r][n]){let i={sendAsync:(o,a)=>(o.targetMapId=t,this.actor.sendAsync(o,a))};switch(r){case"vector":this.workerSources[t][r][n]=new Rr(i,this._getLayerIndex(t),this._getAvailableImages(t));break;case"geojson":this.workerSources[t][r][n]=new ka(i,this._getLayerIndex(t),this._getAvailableImages(t));break;default:this.workerSources[t][r][n]=new this.externalWorkerSourceTypes[r](i,this._getLayerIndex(t),this._getAvailableImages(t));break}}return this.workerSources[t][r][n]}_getDEMWorkerSource(t,r){return this.demWorkerSources[t]||(this.demWorkerSources[t]={}),this.demWorkerSources[t][r]||(this.demWorkerSources[t][r]=new va),this.demWorkerSources[t][r]}};at(self)&&(self.worker=new Ma(self));})();
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
`;
var JT = () => URL.createObjectURL(new Blob([ig], { type: "text/javascript" }));
function ng() {
  return new Worker(JT());
}
var Pl = "maplibre_preloaded_worker_pool";
var kr = class r38 {
  constructor() {
    this.active = {};
  }
  acquire(e) {
    if (!this.workers) for (this.workers = []; this.workers.length < r38.workerCount; ) this.workers.push(ng());
    return this.active[e] = true, this.workers.slice();
  }
  release(e) {
    delete this.active[e], this.numActive() === 0 && (this.workers.forEach((t) => {
      t.terminate();
    }), this.workers = null);
  }
  isPreloaded() {
    return !!this.active[Pl];
  }
  numActive() {
    return Object.keys(this.active).length;
  }
};
var YT = Math.floor(J.hardwareConcurrency / 2);
kr.workerCount = hf(globalThis) ? Math.max(Math.min(YT, 3), 1) : 1;
var No;
function Go() {
  return No || (No = new kr()), No;
}
function QT() {
  Go().acquire(Pl);
}
function eA() {
  let r50 = No;
  r50 && (r50.isPreloaded() && r50.numActive() === 1 ? (r50.release(Pl), No = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
}
var qo = class {
  constructor(e, t) {
    this.workerPool = e, this.actors = [], this.currentActor = 0, this.id = t;
    let i = this.workerPool.acquire(t);
    for (let n = 0; n < i.length; n++) {
      let o = i[n], a = new Sl(o, t);
      a.name = "Worker ".concat(n), this.actors.push(a);
    }
    if (!this.actors.length) throw new Error("No actors found");
  }
  broadcast(e, t) {
    let i = [];
    for (let n of this.actors) i.push(n.sendAsync({ type: e, data: t }));
    return Promise.all(i);
  }
  getActor() {
    return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
  }
  remove(e = true) {
    this.actors.forEach((t) => {
      t.remove();
    }), this.actors = [], e && this.workerPool.release(this.id);
  }
  registerMessageHandler(e, t) {
    for (let i of this.actors) i.registerMessageHandler(e, t);
  }
};
var Tl;
function Al() {
  return Tl || (Tl = new qo(Go(), Ga), Tl.registerMessageHandler("GR", (r50, e, t) => _i(e, t))), Tl;
}
c();
function tA(r50, e) {
  let t = G.create();
  return G.translate(t, t, [1, 1, 0]), G.scale(t, t, [r50.width * 0.5, r50.height * 0.5, 1]), G.multiply(t, t, r50.calculatePosMatrix(e.toUnwrapped()));
}
function rA(r50, e, t) {
  if (r50) for (let i of r50) {
    let n = e[i];
    if (n && n.source === t && n.type === "fill-extrusion") return true;
  }
  else for (let i in e) {
    let n = e[i];
    if (n.source === t && n.type === "fill-extrusion") return true;
  }
  return false;
}
function og(r50, e, t, i, n, o) {
  let a = rA(n && n.layers, e, r50.id), s3 = o.maxPitchScaleFactor(), l = r50.tilesIn(i, s3, a);
  l.sort(lg);
  let u = [];
  for (let p of l) u.push({ wrappedTileID: p.tileID.wrapped().key, queryResults: p.tile.queryRenderedFeatures(e, t, r50._state, p.queryGeometry, p.cameraQueryGeometry, p.scale, n, o, s3, tA(r50.transform, p.tileID)) });
  let c3 = iA(u);
  for (let p in c3) c3[p].forEach((h) => {
    let f = h.feature, d = r50.getFeatureState(f.layer["source-layer"], f.id);
    f.source = f.layer.source, f.layer["source-layer"] && (f.sourceLayer = f.layer["source-layer"]), f.state = d;
  });
  return c3;
}
function ag(r50, e, t, i, n, o, a) {
  let s3 = {}, l = o.queryRenderedSymbols(i), u = [];
  for (let c3 of Object.keys(l).map(Number)) u.push(a[c3]);
  u.sort(lg);
  for (let c3 of u) {
    let p = c3.featureIndex.lookupSymbolFeatures(l[c3.bucketInstanceId], e, c3.bucketIndex, c3.sourceLayerIndex, n.filter, n.layers, n.availableImages, r50);
    for (let h in p) {
      let f = s3[h] = s3[h] || [], d = p[h];
      d.sort((y, g) => {
        let x = c3.featureSortOrder;
        if (x) {
          let v = x.indexOf(y.featureIndex);
          return x.indexOf(g.featureIndex) - v;
        } else return g.featureIndex - y.featureIndex;
      });
      for (let y of d) f.push(y);
    }
  }
  for (let c3 in s3) s3[c3].forEach((p) => {
    let h = p.feature, f = r50[c3], y = t[f.source].getFeatureState(h.layer["source-layer"], h.id);
    h.source = h.layer.source, h.layer["source-layer"] && (h.sourceLayer = h.layer["source-layer"]), h.state = y;
  });
  return s3;
}
function sg(r50, e) {
  let t = r50.getRenderableIds().map((o) => r50.getTileByID(o)), i = [], n = {};
  for (let o = 0; o < t.length; o++) {
    let a = t[o], s3 = a.tileID.canonical.key;
    n[s3] || (n[s3] = true, a.querySourceFeatures(i, e));
  }
  return i;
}
function lg(r50, e) {
  let t = r50.tileID, i = e.tileID;
  return t.overscaledZ - i.overscaledZ || t.canonical.y - i.canonical.y || t.wrap - i.wrap || t.canonical.x - i.canonical.x;
}
function iA(r50) {
  let e = {}, t = {};
  for (let i of r50) {
    let n = i.queryResults, o = i.wrappedTileID, a = t[o] = t[o] || {};
    for (let s3 in n) {
      let l = n[s3], u = a[s3] = a[s3] || {}, c3 = e[s3] = e[s3] || [];
      for (let p of l) u[p.featureIndex] || (u[p.featureIndex] = true, c3.push(p));
    }
  }
  return e;
}
c();
c();
c();
c();
async function Ml(r50, e, t) {
  let i = r50;
  if (r50.url ? i = (await mr(e.transformRequest(r50.url, "Source"), t)).data : await J.frameAsync(t), !i) return null;
  let n = fr(O(i, r50), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
  return "vector_layers" in i && i.vector_layers && (n.vectorLayerIds = i.vector_layers.map((o) => o.id)), n;
}
c();
c();
c();
var jo = 63710088e-1;
var re = class r39 {
  constructor(e, t) {
    if (isNaN(e) || isNaN(t)) throw new Error("Invalid LngLat object: (".concat(e, ", ").concat(t, ")"));
    if (this.lng = +e, this.lat = +t, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
  }
  wrap() {
    return new r39(Jt(this.lng, -180, 180), this.lat);
  }
  toArray() {
    return [this.lng, this.lat];
  }
  toString() {
    return "LngLat(".concat(this.lng, ", ").concat(this.lat, ")");
  }
  distanceTo(e) {
    let t = Math.PI / 180, i = this.lat * t, n = e.lat * t, o = Math.sin(i) * Math.sin(n) + Math.cos(i) * Math.cos(n) * Math.cos((e.lng - this.lng) * t);
    return jo * Math.acos(Math.min(o, 1));
  }
  static convert(e) {
    if (e instanceof r39) return e;
    if (Array.isArray(e) && (e.length === 2 || e.length === 3)) return new r39(Number(e[0]), Number(e[1]));
    if (!Array.isArray(e) && typeof e == "object" && e !== null) return new r39(Number("lng" in e ? e.lng : e.lon), Number(e.lat));
    throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
  }
};
var lt = class r40 {
  constructor(e, t) {
    e && (t ? this.setSouthWest(e).setNorthEast(t) : Array.isArray(e) && (e.length === 4 ? this.setSouthWest([e[0], e[1]]).setNorthEast([e[2], e[3]]) : this.setSouthWest(e[0]).setNorthEast(e[1])));
  }
  setNorthEast(e) {
    return this._ne = e instanceof re ? new re(e.lng, e.lat) : re.convert(e), this;
  }
  setSouthWest(e) {
    return this._sw = e instanceof re ? new re(e.lng, e.lat) : re.convert(e), this;
  }
  extend(e) {
    let t = this._sw, i = this._ne, n, o;
    if (e instanceof re) n = e, o = e;
    else if (e instanceof r40) {
      if (n = e._sw, o = e._ne, !n || !o) return this;
    } else {
      if (Array.isArray(e)) if (e.length === 4 || e.every(Array.isArray)) {
        let a = e;
        return this.extend(r40.convert(a));
      } else {
        let a = e;
        return this.extend(re.convert(a));
      }
      else if (e && ("lng" in e || "lon" in e) && "lat" in e) return this.extend(re.convert(e));
      return this;
    }
    return !t && !i ? (this._sw = new re(n.lng, n.lat), this._ne = new re(o.lng, o.lat)) : (t.lng = Math.min(n.lng, t.lng), t.lat = Math.min(n.lat, t.lat), i.lng = Math.max(o.lng, i.lng), i.lat = Math.max(o.lat, i.lat)), this;
  }
  getCenter() {
    return new re((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
  }
  getSouthWest() {
    return this._sw;
  }
  getNorthEast() {
    return this._ne;
  }
  getNorthWest() {
    return new re(this.getWest(), this.getNorth());
  }
  getSouthEast() {
    return new re(this.getEast(), this.getSouth());
  }
  getWest() {
    return this._sw.lng;
  }
  getSouth() {
    return this._sw.lat;
  }
  getEast() {
    return this._ne.lng;
  }
  getNorth() {
    return this._ne.lat;
  }
  toArray() {
    return [this._sw.toArray(), this._ne.toArray()];
  }
  toString() {
    return "LngLatBounds(".concat(this._sw.toString(), ", ").concat(this._ne.toString(), ")");
  }
  isEmpty() {
    return !(this._sw && this._ne);
  }
  contains(e) {
    let { lng: t, lat: i } = re.convert(e), n = this._sw.lat <= i && i <= this._ne.lat, o = this._sw.lng <= t && t <= this._ne.lng;
    return this._sw.lng > this._ne.lng && (o = this._sw.lng >= t && t >= this._ne.lng), n && o;
  }
  static convert(e) {
    return e instanceof r40 || !e ? e : new r40(e);
  }
  static fromLngLat(e, t = 0) {
    let n = 360 * t / 40075017, o = n / Math.cos(Math.PI / 180 * e.lat);
    return new r40(new re(e.lng - o, e.lat - n), new re(e.lng + o, e.lat + n));
  }
};
c();
var ug = 2 * Math.PI * jo;
function cg(r50) {
  return ug * Math.cos(r50 * Math.PI / 180);
}
function Lr(r50) {
  return (180 + r50) / 360;
}
function Dr(r50) {
  return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + r50 * Math.PI / 360))) / 360;
}
function Il(r50, e) {
  return r50 / cg(e);
}
function nA(r50) {
  return r50 * 360 - 180;
}
function jp(r50) {
  let e = 180 - r50 * 360;
  return 360 / Math.PI * Math.atan(Math.exp(e * Math.PI / 180)) - 90;
}
function oA(r50, e) {
  return r50 * cg(jp(e));
}
function aA(r50) {
  return 1 / Math.cos(r50 * Math.PI / 180);
}
var ze = class r41 {
  constructor(e, t, i = 0) {
    this.x = +e, this.y = +t, this.z = +i;
  }
  static fromLngLat(e, t = 0) {
    let i = re.convert(e);
    return new r41(Lr(i.lng), Dr(i.lat), Il(t, i.lat));
  }
  toLngLat() {
    return new re(nA(this.x), jp(this.y));
  }
  toAltitude() {
    return oA(this.z, this.y);
  }
  meterInMercatorCoordinateUnits() {
    return 1 / ug * aA(jp(this.y));
  }
};
var nn = class {
  constructor(e, t, i) {
    this.bounds = lt.convert(this.validateBounds(e)), this.minzoom = t || 0, this.maxzoom = i || 24;
  }
  validateBounds(e) {
    return !Array.isArray(e) || e.length !== 4 ? [-180, -90, 180, 90] : [Math.max(-180, e[0]), Math.max(-90, e[1]), Math.min(180, e[2]), Math.min(90, e[3])];
  }
  contains(e) {
    let t = Math.pow(2, e.z), i = { minX: Math.floor(Lr(this.bounds.getWest()) * t), minY: Math.floor(Dr(this.bounds.getNorth()) * t), maxX: Math.ceil(Lr(this.bounds.getEast()) * t), maxY: Math.ceil(Dr(this.bounds.getSouth()) * t) };
    return e.x >= i.minX && e.x < i.maxX && e.y >= i.minY && e.y < i.maxY;
  }
};
var Zo = class extends me {
  constructor(e, t, i, n) {
    if (super(), this.id = e, this.dispatcher = i, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, O(this, fr(t, ["url", "scheme", "tileSize", "promoteId"])), this._options = O({ type: "vector" }, t), this._collectResourceTiming = t.collectResourceTiming, this.tileSize !== 512) throw new Error("vector tile sources must have a tileSize of 512");
    this.setEventedParent(n);
  }
  async load() {
    this._loaded = false, this.fire(new z("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
    try {
      let e = await Ml(this._options, this.map._requestManager, this._tileJSONRequest);
      this._tileJSONRequest = null, this._loaded = true, this.map.style.sourceCaches[this.id].clearTiles(), e && (O(this, e), e.bounds && (this.tileBounds = new nn(e.bounds, this.minzoom, this.maxzoom)), this.fire(new z("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new z("data", { dataType: "source", sourceDataType: "content" })));
    } catch (e) {
      this._tileJSONRequest = null, this.fire(new Z(e));
    }
  }
  loaded() {
    return this._loaded;
  }
  hasTile(e) {
    return !this.tileBounds || this.tileBounds.contains(e.canonical);
  }
  onAdd(e) {
    this.map = e, this.load();
  }
  setSourceProperty(e) {
    this._tileJSONRequest && this._tileJSONRequest.abort(), e(), this.load();
  }
  setTiles(e) {
    return this.setSourceProperty(() => {
      this._options.tiles = e;
    }), this;
  }
  setUrl(e) {
    return this.setSourceProperty(() => {
      this.url = e, this._options.url = e;
    }), this;
  }
  onRemove() {
    this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
  }
  serialize() {
    return O({}, this._options);
  }
  async loadTile(e) {
    let t = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), i = { request: this.map._requestManager.transformRequest(t, "Tile"), uid: e.uid, tileID: e.tileID, zoom: e.tileID.overscaledZ, tileSize: this.tileSize * e.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
    i.request.collectResourceTiming = this._collectResourceTiming;
    let n = "RT";
    if (!e.actor || e.state === "expired") e.actor = this.dispatcher.getActor(), n = "LT";
    else if (e.state === "loading") return new Promise((o, a) => {
      e.reloadPromise = { resolve: o, reject: a };
    });
    e.abortController = new AbortController();
    try {
      let o = await e.actor.sendAsync({ type: n, data: i }, e.abortController);
      if (delete e.abortController, e.aborted) return;
      this._afterTileLoadWorkerResponse(e, o);
    } catch (o) {
      if (delete e.abortController, e.aborted) return;
      if (o && o.status !== 404) throw o;
      this._afterTileLoadWorkerResponse(e, null);
    }
  }
  _afterTileLoadWorkerResponse(e, t) {
    if (t && t.resourceTiming && (e.resourceTiming = t.resourceTiming), t && this.map._refreshExpiredTiles && e.setExpiryData(t), e.loadVectorData(t, this.map.painter), e.reloadPromise) {
      let i = e.reloadPromise;
      e.reloadPromise = null, this.loadTile(e).then(i.resolve).catch(i.reject);
    }
  }
  async abortTile(e) {
    e.abortController && (e.abortController.abort(), delete e.abortController), e.actor && await e.actor.sendAsync({ type: "AT", data: { uid: e.uid, type: this.type, source: this.id } });
  }
  async unloadTile(e) {
    e.unloadVectorData(), e.actor && await e.actor.sendAsync({ type: "RMT", data: { uid: e.uid, type: this.type, source: this.id } });
  }
  hasTransition() {
    return false;
  }
};
c();
var pi = class extends me {
  constructor(e, t, i, n) {
    super(), this.id = e, this.dispatcher = i, this.setEventedParent(n), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = O({ type: "raster" }, t), O(this, fr(t, ["url", "scheme", "tileSize"]));
  }
  async load() {
    this._loaded = false, this.fire(new z("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
    try {
      let e = await Ml(this._options, this.map._requestManager, this._tileJSONRequest);
      this._tileJSONRequest = null, this._loaded = true, e && (O(this, e), e.bounds && (this.tileBounds = new nn(e.bounds, this.minzoom, this.maxzoom)), this.fire(new z("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new z("data", { dataType: "source", sourceDataType: "content" })));
    } catch (e) {
      this._tileJSONRequest = null, this.fire(new Z(e));
    }
  }
  loaded() {
    return this._loaded;
  }
  onAdd(e) {
    this.map = e, this.load();
  }
  onRemove() {
    this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
  }
  setSourceProperty(e) {
    this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), e(), this.load();
  }
  setTiles(e) {
    return this.setSourceProperty(() => {
      this._options.tiles = e;
    }), this;
  }
  setUrl(e) {
    return this.setSourceProperty(() => {
      this.url = e, this._options.url = e;
    }), this;
  }
  serialize() {
    return O({}, this._options);
  }
  hasTile(e) {
    return !this.tileBounds || this.tileBounds.contains(e.canonical);
  }
  async loadTile(e) {
    let t = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
    e.abortController = new AbortController();
    try {
      let i = await at.getImage(this.map._requestManager.transformRequest(t, "Tile"), e.abortController, this.map._refreshExpiredTiles);
      if (delete e.abortController, e.aborted) {
        e.state = "unloaded";
        return;
      }
      if (i && i.data) {
        this.map._refreshExpiredTiles && i.cacheControl && i.expires && e.setExpiryData({ cacheControl: i.cacheControl, expires: i.expires });
        let n = this.map.painter.context, o = n.gl, a = i.data;
        e.texture = this.map.painter.getTileTexture(a.width), e.texture ? e.texture.update(a, { useMipmap: true }) : (e.texture = new _e(n, a, o.RGBA, { useMipmap: true }), e.texture.bind(o.LINEAR, o.CLAMP_TO_EDGE, o.LINEAR_MIPMAP_NEAREST), n.extTextureFilterAnisotropic && o.texParameterf(o.TEXTURE_2D, n.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, n.extTextureFilterAnisotropicMax)), e.state = "loaded";
      }
    } catch (i) {
      if (delete e.abortController, e.aborted) e.state = "unloaded";
      else if (i) throw e.state = "errored", i;
    }
  }
  async abortTile(e) {
    e.abortController && (e.abortController.abort(), delete e.abortController);
  }
  async unloadTile(e) {
    e.texture && this.map.painter.saveTileTexture(e.texture);
  }
  hasTransition() {
    return false;
  }
};
c();
c();
c();
function hg(r50, e, t) {
  e = Math.pow(2, t) - e - 1;
  var i = pg(r50 * 256, e * 256, t), n = pg((r50 + 1) * 256, (e + 1) * 256, t);
  return i[0] + "," + i[1] + "," + n[0] + "," + n[1];
}
function pg(r50, e, t) {
  var i = 2 * Math.PI * 6378137 / 256 / Math.pow(2, t), n = r50 * i - 2 * Math.PI * 6378137 / 2, o = e * i - 2 * Math.PI * 6378137 / 2;
  return [n, o];
}
var fg = s(ye(), 1);
var on = class {
  constructor(e, t, i) {
    if (e < 0 || e > 25 || i < 0 || i >= Math.pow(2, e) || t < 0 || t >= Math.pow(2, e)) throw new Error("x=".concat(t, ", y=").concat(i, ", z=").concat(e, " outside of bounds. 0<=x<").concat(Math.pow(2, e), ", 0<=y<").concat(Math.pow(2, e), " 0<=z<=25 "));
    this.z = e, this.x = t, this.y = i, this.key = Ho(0, e, e, t, i);
  }
  equals(e) {
    return this.z === e.z && this.x === e.x && this.y === e.y;
  }
  url(e, t, i) {
    let n = hg(this.x, this.y, this.z), o = sA(this.z, this.x, this.y);
    return e[(this.x + this.y) % e.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(i === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, t > 1 ? "@2x" : "").replace(/{quadkey}/g, o).replace(/{bbox-epsg-3857}/g, n);
  }
  isChildOf(e) {
    let t = this.z - e.z;
    return t > 0 && e.x === this.x >> t && e.y === this.y >> t;
  }
  getTilePoint(e) {
    let t = Math.pow(2, this.z);
    return new fg.default((e.x * t - this.x) * 8192, (e.y * t - this.y) * 8192);
  }
  toString() {
    return "".concat(this.z, "/").concat(this.x, "/").concat(this.y);
  }
};
var an = class {
  constructor(e, t) {
    this.wrap = e, this.canonical = t, this.key = Ho(e, t.z, t.z, t.x, t.y);
  }
};
var Xe = class r42 {
  constructor(e, t, i, n, o) {
    if (e < i) throw new Error("overscaledZ should be >= z; overscaledZ = ".concat(e, "; z = ").concat(i));
    this.overscaledZ = e, this.wrap = t, this.canonical = new on(i, +n, +o), this.key = Ho(t, e, i, n, o);
  }
  clone() {
    return new r42(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
  }
  equals(e) {
    return this.overscaledZ === e.overscaledZ && this.wrap === e.wrap && this.canonical.equals(e.canonical);
  }
  scaledTo(e) {
    if (e > this.overscaledZ) throw new Error("targetZ > this.overscaledZ; targetZ = ".concat(e, "; overscaledZ = ").concat(this.overscaledZ));
    let t = this.canonical.z - e;
    return e > this.canonical.z ? new r42(e, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new r42(e, this.wrap, e, this.canonical.x >> t, this.canonical.y >> t);
  }
  calculateScaledKey(e, t) {
    if (e > this.overscaledZ) throw new Error("targetZ > this.overscaledZ; targetZ = ".concat(e, "; overscaledZ = ").concat(this.overscaledZ));
    let i = this.canonical.z - e;
    return e > this.canonical.z ? Ho(this.wrap * +t, e, this.canonical.z, this.canonical.x, this.canonical.y) : Ho(this.wrap * +t, e, e, this.canonical.x >> i, this.canonical.y >> i);
  }
  isChildOf(e) {
    if (e.wrap !== this.wrap) return false;
    let t = this.canonical.z - e.canonical.z;
    return e.overscaledZ === 0 || e.overscaledZ < this.overscaledZ && e.canonical.x === this.canonical.x >> t && e.canonical.y === this.canonical.y >> t;
  }
  children(e) {
    if (this.overscaledZ >= e) return [new r42(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
    let t = this.canonical.z + 1, i = this.canonical.x * 2, n = this.canonical.y * 2;
    return [new r42(t, this.wrap, t, i, n), new r42(t, this.wrap, t, i + 1, n), new r42(t, this.wrap, t, i, n + 1), new r42(t, this.wrap, t, i + 1, n + 1)];
  }
  isLessThan(e) {
    return this.wrap < e.wrap ? true : this.wrap > e.wrap ? false : this.overscaledZ < e.overscaledZ ? true : this.overscaledZ > e.overscaledZ ? false : this.canonical.x < e.canonical.x ? true : this.canonical.x > e.canonical.x ? false : this.canonical.y < e.canonical.y;
  }
  wrapped() {
    return new r42(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
  }
  unwrapTo(e) {
    return new r42(this.overscaledZ, e, this.canonical.z, this.canonical.x, this.canonical.y);
  }
  overscaleFactor() {
    return Math.pow(2, this.overscaledZ - this.canonical.z);
  }
  toUnwrapped() {
    return new an(this.wrap, this.canonical);
  }
  toString() {
    return "".concat(this.overscaledZ, "/").concat(this.canonical.x, "/").concat(this.canonical.y);
  }
  getTilePoint(e) {
    return this.canonical.getTilePoint(new ze(e.x - this.wrap, e.y));
  }
};
function Ho(r50, e, t, i, n) {
  r50 *= 2, r50 < 0 && (r50 = r50 * -1 - 1);
  let o = 1 << t;
  return (o * o * r50 + o * n + i).toString(36) + t.toString(36) + e.toString(36);
}
function sA(r50, e, t) {
  let i = "", n;
  for (let o = r50; o > 0; o--) n = 1 << o - 1, i += (e & n ? 1 : 0) + (t & n ? 2 : 0);
  return i;
}
U("CanonicalTileID", on);
U("OverscaledTileID", Xe, { omit: ["posMatrix"] });
c();
var Zp = class {
  constructor(e, t, i, n = 1, o = 1, a = 1, s3 = 0) {
    if (this.uid = e, t.height !== t.width) throw new RangeError("DEM tiles must be square");
    if (i && !["mapbox", "terrarium", "custom"].includes(i)) {
      Ee('"'.concat(i, '" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".'));
      return;
    }
    this.stride = t.height;
    let l = this.dim = t.height - 2;
    switch (this.data = new Uint32Array(t.data.buffer), i) {
      case "terrarium":
        this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
        break;
      case "custom":
        this.redFactor = n, this.greenFactor = o, this.blueFactor = a, this.baseShift = s3;
        break;
      case "mapbox":
      default:
        this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = 0.1, this.baseShift = 1e4;
        break;
    }
    for (let u = 0; u < l; u++) this.data[this._idx(-1, u)] = this.data[this._idx(0, u)], this.data[this._idx(l, u)] = this.data[this._idx(l - 1, u)], this.data[this._idx(u, -1)] = this.data[this._idx(u, 0)], this.data[this._idx(u, l)] = this.data[this._idx(u, l - 1)];
    this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(l, -1)] = this.data[this._idx(l - 1, 0)], this.data[this._idx(-1, l)] = this.data[this._idx(0, l - 1)], this.data[this._idx(l, l)] = this.data[this._idx(l - 1, l - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
    for (let u = 0; u < l; u++) for (let c3 = 0; c3 < l; c3++) {
      let p = this.get(u, c3);
      p > this.max && (this.max = p), p < this.min && (this.min = p);
    }
  }
  get(e, t) {
    let i = new Uint8Array(this.data.buffer), n = this._idx(e, t) * 4;
    return this.unpack(i[n], i[n + 1], i[n + 2]);
  }
  getUnpackVector() {
    return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift];
  }
  _idx(e, t) {
    if (e < -1 || e >= this.dim + 1 || t < -1 || t >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
    return (t + 1) * this.stride + (e + 1);
  }
  unpack(e, t, i) {
    return e * this.redFactor + t * this.greenFactor + i * this.blueFactor - this.baseShift;
  }
  getPixels() {
    return new we({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
  }
  backfillBorder(e, t, i) {
    if (this.dim !== e.dim) throw new Error("dem dimension mismatch");
    let n = t * this.dim, o = t * this.dim + this.dim, a = i * this.dim, s3 = i * this.dim + this.dim;
    switch (t) {
      case -1:
        n = o - 1;
        break;
      case 1:
        o = n + 1;
        break;
    }
    switch (i) {
      case -1:
        a = s3 - 1;
        break;
      case 1:
        s3 = a + 1;
        break;
    }
    let l = -t * this.dim, u = -i * this.dim;
    for (let c3 = a; c3 < s3; c3++) for (let p = n; p < o; p++) this.data[this._idx(p, c3)] = e.data[this._idx(p + l, c3 + u)];
  }
};
U("DEMData", Zp);
var $o = class extends pi {
  constructor(e, t, i, n) {
    super(e, t, i, n), this.type = "raster-dem", this.maxzoom = 22, this._options = O({ type: "raster-dem" }, t), this.encoding = t.encoding || "mapbox", this.redFactor = t.redFactor, this.greenFactor = t.greenFactor, this.blueFactor = t.blueFactor, this.baseShift = t.baseShift;
  }
  async loadTile(e) {
    let t = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), i = this.map._requestManager.transformRequest(t, "Tile");
    e.neighboringTiles = this._getNeighboringTiles(e.tileID), e.abortController = new AbortController();
    try {
      let n = await at.getImage(i, e.abortController, this.map._refreshExpiredTiles);
      if (delete e.abortController, e.aborted) {
        e.state = "unloaded";
        return;
      }
      if (n && n.data) {
        let o = n.data;
        this.map._refreshExpiredTiles && n.cacheControl && n.expires && e.setExpiryData({ cacheControl: n.cacheControl, expires: n.expires });
        let s3 = pt(o) && Ra() ? o : await this.readImageNow(o), l = { type: this.type, uid: e.uid, source: this.id, rawImageData: s3, encoding: this.encoding, redFactor: this.redFactor, greenFactor: this.greenFactor, blueFactor: this.blueFactor, baseShift: this.baseShift };
        if (!e.actor || e.state === "expired") {
          e.actor = this.dispatcher.getActor();
          let u = await e.actor.sendAsync({ type: "LDT", data: l });
          e.dem = u, e.needsHillshadePrepare = true, e.needsTerrainPrepare = true, e.state = "loaded";
        }
      }
    } catch (n) {
      if (delete e.abortController, e.aborted) e.state = "unloaded";
      else if (n) throw e.state = "errored", n;
    }
  }
  async readImageNow(e) {
    if (typeof VideoFrame < "u" && Sc()) {
      let t = e.width + 2, i = e.height + 2;
      try {
        return new we({ width: t, height: i }, await df(e, -1, -1, t, i));
      } catch {
      }
    }
    return J.getImageData(e, 1);
  }
  _getNeighboringTiles(e) {
    let t = e.canonical, i = Math.pow(2, t.z), n = (t.x - 1 + i) % i, o = t.x === 0 ? e.wrap - 1 : e.wrap, a = (t.x + 1 + i) % i, s3 = t.x + 1 === i ? e.wrap + 1 : e.wrap, l = {};
    return l[new Xe(e.overscaledZ, o, t.z, n, t.y).key] = { backfilled: false }, l[new Xe(e.overscaledZ, s3, t.z, a, t.y).key] = { backfilled: false }, t.y > 0 && (l[new Xe(e.overscaledZ, o, t.z, n, t.y - 1).key] = { backfilled: false }, l[new Xe(e.overscaledZ, e.wrap, t.z, t.x, t.y - 1).key] = { backfilled: false }, l[new Xe(e.overscaledZ, s3, t.z, a, t.y - 1).key] = { backfilled: false }), t.y + 1 < i && (l[new Xe(e.overscaledZ, o, t.z, n, t.y + 1).key] = { backfilled: false }, l[new Xe(e.overscaledZ, e.wrap, t.z, t.x, t.y + 1).key] = { backfilled: false }, l[new Xe(e.overscaledZ, s3, t.z, a, t.y + 1).key] = { backfilled: false }), l;
  }
  async unloadTile(e) {
    e.demTexture && this.map.painter.saveTileTexture(e.demTexture), e.fbo && (e.fbo.destroy(), delete e.fbo), e.dem && delete e.dem, delete e.neighboringTiles, e.state = "unloaded", e.actor && await e.actor.sendAsync({ type: "RDT", data: { type: this.type, uid: e.uid, source: this.id } });
  }
};
c();
var Wo = class extends me {
  constructor(e, t, i, n) {
    super(), this.id = e, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._removed = false, this._pendingLoads = 0, this.actor = i.getActor(), this.setEventedParent(n), this._data = t.data, this._options = O({}, t), this._collectResourceTiming = t.collectResourceTiming, t.maxzoom !== void 0 && (this.maxzoom = t.maxzoom), t.type && (this.type = t.type), t.attribution && (this.attribution = t.attribution), this.promoteId = t.promoteId;
    let o = 8192 / this.tileSize;
    this.workerOptions = O({ source: this.id, cluster: t.cluster || false, geojsonVtOptions: { buffer: (t.buffer !== void 0 ? t.buffer : 128) * o, tolerance: (t.tolerance !== void 0 ? t.tolerance : 0.375) * o, extent: 8192, maxZoom: this.maxzoom, lineMetrics: t.lineMetrics || false, generateId: t.generateId || false }, superclusterOptions: { maxZoom: t.clusterMaxZoom !== void 0 ? t.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, t.clusterMinPoints || 2), extent: 8192, radius: (t.clusterRadius || 50) * o, log: false, generateId: t.generateId || false }, clusterProperties: t.clusterProperties, filter: t.filter }, t.workerOptions), typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId);
  }
  async load() {
    await this._updateWorkerData();
  }
  onAdd(e) {
    this.map = e, this.load();
  }
  setData(e) {
    return this._data = e, this._updateWorkerData(), this;
  }
  updateData(e) {
    return this._updateWorkerData(e), this;
  }
  setClusterOptions(e) {
    return this.workerOptions.cluster = e.cluster, e && (e.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = e.clusterRadius), e.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = e.clusterMaxZoom)), this._updateWorkerData(), this;
  }
  getClusterExpansionZoom(e) {
    return this.actor.sendAsync({ type: "GCEZ", data: { type: this.type, clusterId: e, source: this.id } });
  }
  getClusterChildren(e) {
    return this.actor.sendAsync({ type: "GCC", data: { type: this.type, clusterId: e, source: this.id } });
  }
  getClusterLeaves(e, t, i) {
    return this.actor.sendAsync({ type: "GCL", data: { type: this.type, source: this.id, clusterId: e, limit: t, offset: i } });
  }
  async _updateWorkerData(e) {
    let t = O({ type: this.type }, this.workerOptions);
    e ? t.dataDiff = e : typeof this._data == "string" ? (t.request = this.map._requestManager.transformRequest(J.resolveURL(this._data), "Source"), t.request.collectResourceTiming = this._collectResourceTiming) : t.data = JSON.stringify(this._data), this._pendingLoads++, this.fire(new z("dataloading", { dataType: "source" }));
    try {
      let i = await this.actor.sendAsync({ type: "LD", data: t });
      if (this._pendingLoads--, this._removed || i.abandoned) {
        this.fire(new z("dataabort", { dataType: "source" }));
        return;
      }
      let n = null;
      i.resourceTiming && i.resourceTiming[this.id] && (n = i.resourceTiming[this.id].slice(0));
      let o = { dataType: "source" };
      this._collectResourceTiming && n && n.length > 0 && O(o, { resourceTiming: n }), this.fire(new z("data", { ...o, sourceDataType: "metadata" })), this.fire(new z("data", { ...o, sourceDataType: "content" }));
    } catch (i) {
      if (this._pendingLoads--, this._removed) {
        this.fire(new z("dataabort", { dataType: "source" }));
        return;
      }
      this.fire(new Z(i));
    }
  }
  loaded() {
    return this._pendingLoads === 0;
  }
  async loadTile(e) {
    let t = e.actor ? "RT" : "LT";
    e.actor = this.actor;
    let i = { type: this.type, uid: e.uid, tileID: e.tileID, zoom: e.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
    e.abortController = new AbortController();
    let n = await this.actor.sendAsync({ type: t, data: i }, e.abortController);
    delete e.abortController, e.unloadVectorData(), e.aborted || e.loadVectorData(n, this.map.painter, t === "RT");
  }
  async abortTile(e) {
    e.abortController && (e.abortController.abort(), delete e.abortController), e.aborted = true;
  }
  async unloadTile(e) {
    e.unloadVectorData(), await this.actor.sendAsync({ type: "RMT", data: { uid: e.uid, type: this.type, source: this.id } });
  }
  onRemove() {
    this._removed = true, this.actor.sendAsync({ type: "RS", data: { type: this.type, source: this.id } });
  }
  serialize() {
    return O({}, this._options, { type: this.type, data: this._data });
  }
  hasTransition() {
    return false;
  }
};
c();
c();
c();
var zr = be([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
var Et = class extends me {
  constructor(e, t, i, n) {
    super(), this.id = e, this.dispatcher = i, this.coordinates = t.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.setEventedParent(n), this.options = t;
  }
  async load(e) {
    this._loaded = false, this.fire(new z("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = new AbortController();
    try {
      let t = await at.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
      this._request = null, this._loaded = true, t && t.data && (this.image = t.data, e && (this.coordinates = e), this._finishLoading());
    } catch (t) {
      this._request = null, this._loaded = true, this.fire(new Z(t));
    }
  }
  loaded() {
    return this._loaded;
  }
  updateImage(e) {
    return e.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = e.url, this.load(e.coordinates).finally(() => {
      this.texture = null;
    }), this) : this;
  }
  _finishLoading() {
    this.map && (this.setCoordinates(this.coordinates), this.fire(new z("data", { dataType: "source", sourceDataType: "metadata" })));
  }
  onAdd(e) {
    this.map = e, this.load();
  }
  onRemove() {
    this._request && (this._request.abort(), this._request = null);
  }
  setCoordinates(e) {
    this.coordinates = e;
    let t = e.map(ze.fromLngLat);
    this.tileID = lA(t), this.minzoom = this.maxzoom = this.tileID.z;
    let i = t.map((n) => this.tileID.getTilePoint(n)._round());
    return this._boundsArray = new Gi(), this._boundsArray.emplaceBack(i[0].x, i[0].y, 0, 0), this._boundsArray.emplaceBack(i[1].x, i[1].y, 8192, 0), this._boundsArray.emplaceBack(i[3].x, i[3].y, 0, 8192), this._boundsArray.emplaceBack(i[2].x, i[2].y, 8192, 8192), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this.fire(new z("data", { dataType: "source", sourceDataType: "content" })), this;
  }
  prepare() {
    if (Object.keys(this.tiles).length === 0 || !this.image) return;
    let e = this.map.painter.context, t = e.gl;
    this.boundsBuffer || (this.boundsBuffer = e.createVertexBuffer(this._boundsArray, zr.members)), this.boundsSegments || (this.boundsSegments = fe.simpleSegment(0, 0, 4, 2)), this.texture || (this.texture = new _e(e, this.image, t.RGBA), this.texture.bind(t.LINEAR, t.CLAMP_TO_EDGE));
    let i = false;
    for (let n in this.tiles) {
      let o = this.tiles[n];
      o.state !== "loaded" && (o.state = "loaded", o.texture = this.texture, i = true);
    }
    i && this.fire(new z("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
  }
  async loadTile(e) {
    this.tileID && this.tileID.equals(e.tileID.canonical) ? (this.tiles[String(e.tileID.wrap)] = e, e.buckets = {}) : e.state = "errored";
  }
  serialize() {
    return { type: "image", url: this.options.url, coordinates: this.coordinates };
  }
  hasTransition() {
    return false;
  }
};
function lA(r50) {
  let e = 1 / 0, t = 1 / 0, i = -1 / 0, n = -1 / 0;
  for (let c3 of r50) e = Math.min(e, c3.x), t = Math.min(t, c3.y), i = Math.max(i, c3.x), n = Math.max(n, c3.y);
  let o = i - e, a = n - t, s3 = Math.max(o, a), l = Math.max(0, Math.floor(-Math.log(s3) / Math.LN2)), u = Math.pow(2, l);
  return new on(l, Math.floor((e + i) / 2 * u), Math.floor((t + n) / 2 * u));
}
var Xo = class extends Et {
  constructor(e, t, i, n) {
    super(e, t, i, n), this.roundZoom = true, this.type = "video", this.options = t;
  }
  async load() {
    this._loaded = false;
    let e = this.options;
    this.urls = [];
    for (let t of e.urls) this.urls.push(this.map._requestManager.transformRequest(t, "Source").url);
    try {
      let t = await bf(this.urls);
      if (this._loaded = true, !t) return;
      this.video = t, this.video.loop = true, this.video.addEventListener("playing", () => {
        this.map.triggerRepaint();
      }), this.map && this.video.play(), this._finishLoading();
    } catch (t) {
      this.fire(new Z(t));
    }
  }
  pause() {
    this.video && this.video.pause();
  }
  play() {
    this.video && this.video.play();
  }
  seek(e) {
    if (this.video) {
      let t = this.video.seekable;
      e < t.start(0) || e > t.end(0) ? this.fire(new Z(new R("sources.".concat(this.id), null, "Playback for this video can be set only between the ".concat(t.start(0), " and ").concat(t.end(0), "-second mark.")))) : this.video.currentTime = e;
    }
  }
  getVideo() {
    return this.video;
  }
  onAdd(e) {
    this.map || (this.map = e, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
  }
  prepare() {
    if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return;
    let e = this.map.painter.context, t = e.gl;
    this.boundsBuffer || (this.boundsBuffer = e.createVertexBuffer(this._boundsArray, zr.members)), this.boundsSegments || (this.boundsSegments = fe.simpleSegment(0, 0, 4, 2)), this.texture ? this.video.paused || (this.texture.bind(t.LINEAR, t.CLAMP_TO_EDGE), t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, t.RGBA, t.UNSIGNED_BYTE, this.video)) : (this.texture = new _e(e, this.video, t.RGBA), this.texture.bind(t.LINEAR, t.CLAMP_TO_EDGE));
    let i = false;
    for (let n in this.tiles) {
      let o = this.tiles[n];
      o.state !== "loaded" && (o.state = "loaded", o.texture = this.texture, i = true);
    }
    i && this.fire(new z("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
  }
  serialize() {
    return { type: "video", urls: this.urls, coordinates: this.coordinates };
  }
  hasTransition() {
    return this.video && !this.video.paused;
  }
};
c();
var Ko = class extends Et {
  constructor(e, t, i, n) {
    super(e, t, i, n), t.coordinates ? (!Array.isArray(t.coordinates) || t.coordinates.length !== 4 || t.coordinates.some((o) => !Array.isArray(o) || o.length !== 2 || o.some((a) => typeof a != "number"))) && this.fire(new Z(new R("sources.".concat(e), null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new Z(new R("sources.".concat(e), null, 'missing required property "coordinates"'))), t.animate && typeof t.animate != "boolean" && this.fire(new Z(new R("sources.".concat(e), null, 'optional "animate" property must be a boolean value'))), t.canvas ? typeof t.canvas != "string" && !(t.canvas instanceof HTMLCanvasElement) && this.fire(new Z(new R("sources.".concat(e), null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new Z(new R("sources.".concat(e), null, 'missing required property "canvas"'))), this.options = t, this.animate = t.animate !== void 0 ? t.animate : true;
  }
  async load() {
    if (this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions()) {
      this.fire(new Z(new Error("Canvas dimensions cannot be less than or equal to zero.")));
      return;
    }
    this.play = function() {
      this._playing = true, this.map.triggerRepaint();
    }, this.pause = function() {
      this._playing && (this.prepare(), this._playing = false);
    }, this._finishLoading();
  }
  getCanvas() {
    return this.canvas;
  }
  onAdd(e) {
    this.map = e, this.load(), this.canvas && this.animate && this.play();
  }
  onRemove() {
    this.pause();
  }
  prepare() {
    let e = false;
    if (this.canvas.width !== this.width && (this.width = this.canvas.width, e = true), this.canvas.height !== this.height && (this.height = this.canvas.height, e = true), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0) return;
    let t = this.map.painter.context, i = t.gl;
    this.boundsBuffer || (this.boundsBuffer = t.createVertexBuffer(this._boundsArray, zr.members)), this.boundsSegments || (this.boundsSegments = fe.simpleSegment(0, 0, 4, 2)), this.texture ? (e || this._playing) && this.texture.update(this.canvas, { premultiply: true }) : this.texture = new _e(t, this.canvas, i.RGBA, { premultiply: true });
    let n = false;
    for (let o in this.tiles) {
      let a = this.tiles[o];
      a.state !== "loaded" && (a.state = "loaded", a.texture = this.texture, n = true);
    }
    n && this.fire(new z("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
  }
  serialize() {
    return { type: "canvas", coordinates: this.coordinates };
  }
  hasTransition() {
    return this._playing;
  }
  _hasInvalidDimensions() {
    for (let e of [this.canvas.width, this.canvas.height]) if (isNaN(e) || e <= 0) return true;
    return false;
  }
};
var mg = {};
var dg = (r50, e, t, i) => {
  let n = yg(e.type), o = new n(r50, e, t, i);
  if (o.id !== r50) throw new Error("Expected Source id to be ".concat(r50, " instead of ").concat(o.id));
  return o;
};
var yg = (r50) => {
  switch (r50) {
    case "geojson":
      return Wo;
    case "image":
      return Et;
    case "raster":
      return pi;
    case "raster-dem":
      return $o;
    case "vector":
      return Zo;
    case "video":
      return Xo;
    case "canvas":
      return Ko;
  }
  return mg[r50];
};
var uA = (r50, e) => {
  mg[r50] = e;
};
var cA = async (r50, e) => {
  if (yg(r50)) throw new Error('A source type called "'.concat(r50, '" already exists.'));
  uA(r50, e);
};
c();
c();
function gg(r50, e) {
  let t = {};
  if (!e) return t;
  for (let i of r50) {
    let n = i.layerIds.map((o) => e.getLayer(o)).filter(Boolean);
    if (n.length !== 0) {
      i.layers = n, i.stateDependentLayerIds && (i.stateDependentLayers = i.stateDependentLayerIds.map((o) => n.filter((a) => a.id === o)[0]));
      for (let o of n) t[o.id] = i;
    }
  }
  return t;
}
c();
c();
var Cl = class {
  constructor(e) {
    this._stringToNumber = {}, this._numberToString = [];
    for (let t = 0; t < e.length; t++) {
      let i = e[t];
      this._stringToNumber[i] = t, this._numberToString[t] = i;
    }
  }
  encode(e) {
    return this._stringToNumber[e];
  }
  decode(e) {
    if (e >= this._numberToString.length) throw new Error("Out of bounds. Index requested n=".concat(e, " can't be >= this._numberToString.length ").concat(this._numberToString.length));
    return this._numberToString[e];
  }
};
var _g = s(Co(), 1);
var vg = s(Vp(), 1);
c();
var sn = class {
  constructor(e, t, i, n, o) {
    this.type = "Feature", this._vectorTileFeature = e, e._z = t, e._x = i, e._y = n, this.properties = e.properties, this.id = o;
  }
  get geometry() {
    return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
  }
  set geometry(e) {
    this._geometry = e;
  }
  toJSON() {
    let e = { geometry: this.geometry };
    for (let t in this) t === "_geometry" || t === "_vectorTileFeature" || (e[t] = this[t]);
    return e;
  }
};
var Hp = class {
  constructor(e, t) {
    this.tileID = e, this.x = e.canonical.x, this.y = e.canonical.y, this.z = e.canonical.z, this.grid = new Yr(8192, 16, 0), this.grid3D = new Yr(8192, 16, 0), this.featureIndexArray = new fo(), this.promoteId = t;
  }
  insert(e, t, i, n, o, a) {
    let s3 = this.featureIndexArray.length;
    this.featureIndexArray.emplaceBack(i, n, o);
    let l = a ? this.grid3D : this.grid;
    for (let u = 0; u < t.length; u++) {
      let c3 = t[u], p = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
      for (let h = 0; h < c3.length; h++) {
        let f = c3[h];
        p[0] = Math.min(p[0], f.x), p[1] = Math.min(p[1], f.y), p[2] = Math.max(p[2], f.x), p[3] = Math.max(p[3], f.y);
      }
      p[0] < 8192 && p[1] < 8192 && p[2] >= 0 && p[3] >= 0 && l.insert(s3, p[0], p[1], p[2], p[3]);
    }
  }
  loadVTLayers() {
    return this.vtLayers || (this.vtLayers = new _g.default.VectorTile(new vg.default(this.rawTileData)).layers, this.sourceLayerCoder = new Cl(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
  }
  query(e, t, i, n) {
    this.loadVTLayers();
    let o = e.params || {}, a = 8192 / e.tileSize / e.scale, s3 = Gn(o.filter), l = e.queryGeometry, u = e.queryPadding * a, c3 = bg(l), p = this.grid.query(c3.minX - u, c3.minY - u, c3.maxX + u, c3.maxY + u), h = bg(e.cameraQueryGeometry), f = this.grid3D.query(h.minX - u, h.minY - u, h.maxX + u, h.maxY + u, (g, x, v, b) => Qm(e.cameraQueryGeometry, g - u, x - u, v + u, b + u));
    for (let g of f) p.push(g);
    p.sort(pA);
    let d = {}, y;
    for (let g = 0; g < p.length; g++) {
      let x = p[g];
      if (x === y) continue;
      y = x;
      let v = this.featureIndexArray.get(x), b = null;
      this.loadMatchingFeature(d, v.bucketIndex, v.sourceLayerIndex, v.featureIndex, s3, o.layers, o.availableImages, t, i, n, (w, S, P) => (b || (b = mt(w)), S.queryIntersectsFeature(l, w, P, b, this.z, e.transform, a, e.pixelPosMatrix)));
    }
    return d;
  }
  loadMatchingFeature(e, t, i, n, o, a, s3, l, u, c3, p) {
    let h = this.bucketLayerIDs[t];
    if (a && !sf(a, h)) return;
    let f = this.sourceLayerCoder.decode(i), y = this.vtLayers[f].feature(n);
    if (o.needGeometry) {
      let x = dt(y, true);
      if (!o.filter(new de(this.tileID.overscaledZ), x, this.tileID.canonical)) return;
    } else if (!o.filter(new de(this.tileID.overscaledZ), y)) return;
    let g = this.getId(y, f);
    for (let x = 0; x < h.length; x++) {
      let v = h[x];
      if (a && a.indexOf(v) < 0) continue;
      let b = l[v];
      if (!b) continue;
      let w = {};
      g && c3 && (w = c3.getState(b.sourceLayer || "_geojsonTileLayer", g));
      let S = O({}, u[v]);
      S.paint = xg(S.paint, b.paint, y, w, s3), S.layout = xg(S.layout, b.layout, y, w, s3);
      let P = !p || p(y, b, w);
      if (!P) continue;
      let k = new sn(y, this.z, this.x, this.y, g);
      k.layer = S;
      let I = e[v];
      I === void 0 && (I = e[v] = []), I.push({ featureIndex: n, feature: k, intersectionZ: P });
    }
  }
  lookupSymbolFeatures(e, t, i, n, o, a, s3, l) {
    let u = {};
    this.loadVTLayers();
    let c3 = Gn(o);
    for (let p of e) this.loadMatchingFeature(u, i, n, p, c3, a, s3, l, t);
    return u;
  }
  hasLayer(e) {
    for (let t of this.bucketLayerIDs) for (let i of t) if (e === i) return true;
    return false;
  }
  getId(e, t) {
    let i = e.id;
    if (this.promoteId) {
      let n = typeof this.promoteId == "string" ? this.promoteId : this.promoteId[t];
      i = e.properties[n], typeof i == "boolean" && (i = Number(i));
    }
    return i;
  }
};
U("FeatureIndex", Hp, { omit: ["rawTileData", "sourceLayerCoder"] });
function xg(r50, e, t, i, n) {
  return bn(r50, (o, a) => {
    let s3 = e instanceof vr ? e.get(a) : null;
    return s3 && s3.evaluate ? s3.evaluate(t, i, n) : s3;
  });
}
function bg(r50) {
  let e = 1 / 0, t = 1 / 0, i = -1 / 0, n = -1 / 0;
  for (let o of r50) e = Math.min(e, o.x), t = Math.min(t, o.y), i = Math.max(i, o.x), n = Math.max(n, o.y);
  return { minX: e, minY: t, maxX: i, maxY: n };
}
function pA(r50, e) {
  return e - r50;
}
c();
c();
var Jo = "RTLPluginLoaded";
var Wp = class extends me {
  constructor() {
    super(...arguments);
    this.status = "unavailable";
    this.url = null;
    this.dispatcher = Al();
  }
  _syncState(t) {
    return this.status = t, this.dispatcher.broadcast("SRPS", { pluginStatus: t, pluginURL: this.url }).catch((i) => {
      throw this.status = "error", i;
    });
  }
  getRTLTextPluginStatus() {
    return this.status;
  }
  clearRTLTextPlugin() {
    this.status = "unavailable", this.url = null;
  }
  async setRTLTextPlugin(t, i = false) {
    if (this.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
    if (this.url = J.resolveURL(t), !this.url) throw new Error("requested url ".concat(t, " is invalid"));
    if (this.status === "unavailable") if (i) this.status = "deferred", this._syncState(this.status);
    else return this._requestImport();
    else if (this.status === "requested") return this._requestImport();
  }
  async _requestImport() {
    await this._syncState("loading"), this.status = "loaded", this.fire(new z(Jo));
  }
  lazyLoad() {
    this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport();
  }
};
var $p = null;
function Fr() {
  return $p || ($p = new Wp()), $p;
}
var hA = 3e4;
var ln = class {
  constructor(e, t) {
    this.timeAdded = 0;
    this.fadeEndTime = 0;
    this.tileID = e, this.uid = Oa(), this.uses = 0, this.tileSize = t, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
  }
  registerFadeDuration(e) {
    let t = e + this.timeAdded;
    t < this.fadeEndTime || (this.fadeEndTime = t);
  }
  wasRequested() {
    return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
  }
  clearTextures(e) {
    this.demTexture && e.saveTileTexture(this.demTexture), this.demTexture = null;
  }
  loadVectorData(e, t, i) {
    if (this.hasData() && this.unloadVectorData(), this.state = "loaded", !e) {
      this.collisionBoxArray = new so();
      return;
    }
    e.featureIndex && (this.latestFeatureIndex = e.featureIndex, e.rawTileData ? (this.latestRawTileData = e.rawTileData, this.latestFeatureIndex.rawTileData = e.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e.collisionBoxArray, this.buckets = gg(e.buckets, t.style), this.hasSymbolBuckets = false;
    for (let n in this.buckets) {
      let o = this.buckets[n];
      if (o instanceof Rt) if (this.hasSymbolBuckets = true, i) o.justReloaded = true;
      else break;
    }
    if (this.hasRTLText = false, this.hasSymbolBuckets) for (let n in this.buckets) {
      let o = this.buckets[n];
      if (o instanceof Rt && o.hasRTLText) {
        this.hasRTLText = true, Fr().lazyLoad();
        break;
      }
    }
    this.queryPadding = 0;
    for (let n in this.buckets) {
      let o = this.buckets[n];
      this.queryPadding = Math.max(this.queryPadding, t.style.getLayer(n).queryRadius(o));
    }
    e.imageAtlas && (this.imageAtlas = e.imageAtlas), e.glyphAtlasImage && (this.glyphAtlasImage = e.glyphAtlasImage);
  }
  unloadVectorData() {
    for (let e in this.buckets) this.buckets[e].destroy();
    this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
  }
  getBucket(e) {
    return this.buckets[e.id];
  }
  upload(e) {
    for (let i in this.buckets) {
      let n = this.buckets[i];
      n.uploadPending() && n.upload(e);
    }
    let t = e.gl;
    this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new _e(e, this.imageAtlas.image, t.RGBA), this.imageAtlas.uploaded = true), this.glyphAtlasImage && (this.glyphAtlasTexture = new _e(e, this.glyphAtlasImage, t.ALPHA), this.glyphAtlasImage = null);
  }
  prepare(e) {
    this.imageAtlas && this.imageAtlas.patchUpdatedImages(e, this.imageAtlasTexture);
  }
  queryRenderedFeatures(e, t, i, n, o, a, s3, l, u, c3) {
    return !this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData ? {} : this.latestFeatureIndex.query({ queryGeometry: n, cameraQueryGeometry: o, scale: a, tileSize: this.tileSize, pixelPosMatrix: c3, transform: l, params: s3, queryPadding: this.queryPadding * u }, e, t, i);
  }
  querySourceFeatures(e, t) {
    let i = this.latestFeatureIndex;
    if (!i || !i.rawTileData) return;
    let n = i.loadVTLayers(), o = t && t.sourceLayer ? t.sourceLayer : "", a = n._geojsonTileLayer || n[o];
    if (!a) return;
    let s3 = Gn(t && t.filter), { z: l, x: u, y: c3 } = this.tileID.canonical, p = { z: l, x: u, y: c3 };
    for (let h = 0; h < a.length; h++) {
      let f = a.feature(h);
      if (s3.needGeometry) {
        let g = dt(f, true);
        if (!s3.filter(new de(this.tileID.overscaledZ), g, this.tileID.canonical)) continue;
      } else if (!s3.filter(new de(this.tileID.overscaledZ), f)) continue;
      let d = i.getId(f, o), y = new sn(f, l, u, c3, d);
      y.tile = p, e.push(y);
    }
  }
  hasData() {
    return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
  }
  patternsLoaded() {
    return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
  }
  setExpiryData(e) {
    let t = this.expirationTime;
    if (e.cacheControl) {
      let i = pf(e.cacheControl);
      i["max-age"] && (this.expirationTime = Date.now() + i["max-age"] * 1e3);
    } else e.expires && (this.expirationTime = new Date(e.expires).getTime());
    if (this.expirationTime) {
      let i = Date.now(), n = false;
      if (this.expirationTime > i) n = false;
      else if (!t) n = true;
      else if (this.expirationTime < t) n = true;
      else {
        let o = this.expirationTime - t;
        o ? this.expirationTime = i + Math.max(o, hA) : n = true;
      }
      n ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
    }
  }
  getExpiryTimeout() {
    if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
  }
  setFeatureState(e, t) {
    if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(e).length === 0) return;
    let i = this.latestFeatureIndex.loadVTLayers();
    for (let n in this.buckets) {
      if (!t.style.hasLayer(n)) continue;
      let o = this.buckets[n], a = o.layers[0].sourceLayer || "_geojsonTileLayer", s3 = i[a], l = e[a];
      if (!s3 || !l || Object.keys(l).length === 0) continue;
      o.update(l, s3, this.imageAtlas && this.imageAtlas.patternPositions || {});
      let u = t && t.style && t.style.getLayer(n);
      u && (this.queryPadding = Math.max(this.queryPadding, u.queryRadius(o)));
    }
  }
  holdingForFade() {
    return this.symbolFadeHoldUntil !== void 0;
  }
  symbolFadeFinished() {
    return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < J.now();
  }
  clearFadeHold() {
    this.symbolFadeHoldUntil = void 0;
  }
  setHoldDuration(e) {
    this.symbolFadeHoldUntil = J.now() + e;
  }
  setDependencies(e, t) {
    let i = {};
    for (let n of t) i[n] = true;
    this.dependencies[e] = i;
  }
  hasDependency(e, t) {
    for (let i of e) {
      let n = this.dependencies[i];
      if (n) {
        for (let o of t) if (n[o]) return true;
      }
    }
    return false;
  }
};
c();
var El = class {
  constructor(e, t) {
    this.max = e, this.onRemove = t, this.reset();
  }
  reset() {
    for (let e in this.data) for (let t of this.data[e]) t.timeout && clearTimeout(t.timeout), this.onRemove(t.value);
    return this.data = {}, this.order = [], this;
  }
  add(e, t, i) {
    let n = e.wrapped().key;
    this.data[n] === void 0 && (this.data[n] = []);
    let o = { value: t, timeout: void 0 };
    if (i !== void 0 && (o.timeout = setTimeout(() => {
      this.remove(e, o);
    }, i)), this.data[n].push(o), this.order.push(n), this.order.length > this.max) {
      let a = this._getAndRemoveByKey(this.order[0]);
      a && this.onRemove(a);
    }
    return this;
  }
  has(e) {
    return e.wrapped().key in this.data;
  }
  getAndRemove(e) {
    return this.has(e) ? this._getAndRemoveByKey(e.wrapped().key) : null;
  }
  _getAndRemoveByKey(e) {
    let t = this.data[e].shift();
    return t.timeout && clearTimeout(t.timeout), this.data[e].length === 0 && delete this.data[e], this.order.splice(this.order.indexOf(e), 1), t.value;
  }
  getByKey(e) {
    let t = this.data[e];
    return t ? t[0].value : null;
  }
  get(e) {
    return this.has(e) ? this.data[e.wrapped().key][0].value : null;
  }
  remove(e, t) {
    if (!this.has(e)) return this;
    let i = e.wrapped().key, n = t === void 0 ? 0 : this.data[i].indexOf(t), o = this.data[i][n];
    return this.data[i].splice(n, 1), o.timeout && clearTimeout(o.timeout), this.data[i].length === 0 && delete this.data[i], this.onRemove(o.value), this.order.splice(this.order.indexOf(i), 1), this;
  }
  setMaxSize(e) {
    for (this.max = e; this.order.length > this.max; ) {
      let t = this._getAndRemoveByKey(this.order[0]);
      t && this.onRemove(t);
    }
    return this;
  }
  filter(e) {
    let t = [];
    for (let i in this.data) for (let n of this.data[i]) e(n.value) || t.push(n);
    for (let i of t) this.remove(i.value.tileID, i);
  }
};
var Xp = s(ye(), 1);
c();
var kl = class {
  constructor() {
    this.state = {}, this.stateChanges = {}, this.deletedStates = {};
  }
  updateState(e, t, i) {
    let n = String(t);
    if (this.stateChanges[e] = this.stateChanges[e] || {}, this.stateChanges[e][n] = this.stateChanges[e][n] || {}, O(this.stateChanges[e][n], i), this.deletedStates[e] === null) {
      this.deletedStates[e] = {};
      for (let o in this.state[e]) o !== n && (this.deletedStates[e][o] = null);
    } else if (this.deletedStates[e] && this.deletedStates[e][n] === null) {
      this.deletedStates[e][n] = {};
      for (let a in this.state[e][n]) i[a] || (this.deletedStates[e][n][a] = null);
    } else for (let a in i) this.deletedStates[e] && this.deletedStates[e][n] && this.deletedStates[e][n][a] === null && delete this.deletedStates[e][n][a];
  }
  removeFeatureState(e, t, i) {
    if (this.deletedStates[e] === null) return;
    let o = String(t);
    if (this.deletedStates[e] = this.deletedStates[e] || {}, i && t !== void 0) this.deletedStates[e][o] !== null && (this.deletedStates[e][o] = this.deletedStates[e][o] || {}, this.deletedStates[e][o][i] = null);
    else if (t !== void 0) if (this.stateChanges[e] && this.stateChanges[e][o]) {
      this.deletedStates[e][o] = {};
      for (i in this.stateChanges[e][o]) this.deletedStates[e][o][i] = null;
    } else this.deletedStates[e][o] = null;
    else this.deletedStates[e] = null;
  }
  getState(e, t) {
    let i = String(t), n = this.state[e] || {}, o = this.stateChanges[e] || {}, a = O({}, n[i], o[i]);
    if (this.deletedStates[e] === null) return {};
    if (this.deletedStates[e]) {
      let s3 = this.deletedStates[e][t];
      if (s3 === null) return {};
      for (let l in s3) delete a[l];
    }
    return a;
  }
  initializeTileState(e, t) {
    e.setFeatureState(this.state, t);
  }
  coalesceChanges(e, t) {
    let i = {};
    for (let n in this.stateChanges) {
      this.state[n] = this.state[n] || {};
      let o = {};
      for (let a in this.stateChanges[n]) this.state[n][a] || (this.state[n][a] = {}), O(this.state[n][a], this.stateChanges[n][a]), o[a] = this.state[n][a];
      i[n] = o;
    }
    for (let n in this.deletedStates) {
      this.state[n] = this.state[n] || {};
      let o = {};
      if (this.deletedStates[n] === null) for (let a in this.state[n]) o[a] = {}, this.state[n][a] = {};
      else for (let a in this.deletedStates[n]) {
        if (this.deletedStates[n][a] === null) this.state[n][a] = {};
        else for (let l of Object.keys(this.deletedStates[n][a])) delete this.state[n][a][l];
        o[a] = this.state[n][a];
      }
      i[n] = i[n] || {}, O(i[n], o);
    }
    if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(i).length !== 0) for (let n in e) e[n].setFeatureState(i, t);
  }
};
var sr = class r43 extends me {
  constructor(e, t, i) {
    super(), this.id = e, this.dispatcher = i, this.on("data", (n) => this._dataHandler(n)), this.on("dataloading", () => {
      this._sourceErrored = false;
    }), this.on("error", () => {
      this._sourceErrored = this._source.loaded();
    }), this._source = dg(e, t, i, this), this._tiles = {}, this._cache = new El(0, (n) => this._unloadTile(n)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new kl(), this._didEmitContent = false, this._updated = false;
  }
  onAdd(e) {
    this.map = e, this._maxTileCacheSize = e ? e._maxTileCacheSize : null, this._maxTileCacheZoomLevels = e ? e._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(e);
  }
  onRemove(e) {
    this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(e);
  }
  loaded() {
    if (this._sourceErrored) return true;
    if (!this._sourceLoaded || !this._source.loaded()) return false;
    if ((this.used !== void 0 || this.usedForTerrain !== void 0) && !this.used && !this.usedForTerrain) return true;
    if (!this._updated) return false;
    for (let e in this._tiles) {
      let t = this._tiles[e];
      if (t.state !== "loaded" && t.state !== "errored") return false;
    }
    return true;
  }
  getSource() {
    return this._source;
  }
  pause() {
    this._paused = true;
  }
  resume() {
    if (!this._paused) return;
    let e = this._shouldReloadOnResume;
    this._paused = false, this._shouldReloadOnResume = false, e && this.reload(), this.transform && this.update(this.transform, this.terrain);
  }
  async _loadTile(e, t, i) {
    try {
      await this._source.loadTile(e), this._tileLoaded(e, t, i);
    } catch (n) {
      e.state = "errored", n.status !== 404 ? this._source.fire(new Z(n, { tile: e })) : this.update(this.transform, this.terrain);
    }
  }
  _unloadTile(e) {
    this._source.unloadTile && this._source.unloadTile(e);
  }
  _abortTile(e) {
    this._source.abortTile && this._source.abortTile(e), this._source.fire(new z("dataabort", { tile: e, coord: e.tileID, dataType: "source" }));
  }
  serialize() {
    return this._source.serialize();
  }
  prepare(e) {
    this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
    for (let t in this._tiles) {
      let i = this._tiles[t];
      i.upload(e), i.prepare(this.map.style.imageManager);
    }
  }
  getIds() {
    return Object.values(this._tiles).map((e) => e.tileID).sort(wg).map((e) => e.key);
  }
  getRenderableIds(e) {
    let t = [];
    for (let i in this._tiles) this._isIdRenderable(i, e) && t.push(this._tiles[i]);
    return e ? t.sort((i, n) => {
      let o = i.tileID, a = n.tileID, s3 = new Xp.default(o.canonical.x, o.canonical.y)._rotate(this.transform.angle), l = new Xp.default(a.canonical.x, a.canonical.y)._rotate(this.transform.angle);
      return o.overscaledZ - a.overscaledZ || l.y - s3.y || l.x - s3.x;
    }).map((i) => i.tileID.key) : t.map((i) => i.tileID).sort(wg).map((i) => i.key);
  }
  hasRenderableParent(e) {
    let t = this.findLoadedParent(e, 0);
    return t ? this._isIdRenderable(t.tileID.key) : false;
  }
  _isIdRenderable(e, t) {
    return this._tiles[e] && this._tiles[e].hasData() && !this._coveredTiles[e] && (t || !this._tiles[e].holdingForFade());
  }
  reload() {
    if (this._paused) {
      this._shouldReloadOnResume = true;
      return;
    }
    this._cache.reset();
    for (let e in this._tiles) this._tiles[e].state !== "errored" && this._reloadTile(e, "reloading");
  }
  async _reloadTile(e, t) {
    let i = this._tiles[e];
    i && (i.state !== "loading" && (i.state = t), await this._loadTile(i, e, t));
  }
  _tileLoaded(e, t, i) {
    e.timeAdded = J.now(), i === "expired" && (e.refreshedUponExpiration = true), this._setTileReloadTimer(t, e), this.getSource().type === "raster-dem" && e.dem && this._backfillDEM(e), this._state.initializeTileState(e, this.map ? this.map.painter : null), e.aborted || this._source.fire(new z("data", { dataType: "source", tile: e, coord: e.tileID }));
  }
  _backfillDEM(e) {
    let t = this.getRenderableIds();
    for (let n = 0; n < t.length; n++) {
      let o = t[n];
      if (e.neighboringTiles && e.neighboringTiles[o]) {
        let a = this.getTileByID(o);
        i(e, a), i(a, e);
      }
    }
    function i(n, o) {
      n.needsHillshadePrepare = true, n.needsTerrainPrepare = true;
      let a = o.tileID.canonical.x - n.tileID.canonical.x, s3 = o.tileID.canonical.y - n.tileID.canonical.y, l = Math.pow(2, n.tileID.canonical.z), u = o.tileID.key;
      a === 0 && s3 === 0 || Math.abs(s3) > 1 || (Math.abs(a) > 1 && (Math.abs(a + l) === 1 ? a += l : Math.abs(a - l) === 1 && (a -= l)), !(!o.dem || !n.dem) && (n.dem.backfillBorder(o.dem, a, s3), n.neighboringTiles && n.neighboringTiles[u] && (n.neighboringTiles[u].backfilled = true)));
    }
  }
  getTile(e) {
    return this.getTileByID(e.key);
  }
  getTileByID(e) {
    return this._tiles[e];
  }
  _retainLoadedChildren(e, t, i, n) {
    for (let o in this._tiles) {
      let a = this._tiles[o];
      if (n[o] || !a.hasData() || a.tileID.overscaledZ <= t || a.tileID.overscaledZ > i) continue;
      let s3 = a.tileID;
      for (; a && a.tileID.overscaledZ > t + 1; ) {
        let u = a.tileID.scaledTo(a.tileID.overscaledZ - 1);
        a = this._tiles[u.key], a && a.hasData() && (s3 = u);
      }
      let l = s3;
      for (; l.overscaledZ > t; ) if (l = l.scaledTo(l.overscaledZ - 1), e[l.key]) {
        n[s3.key] = s3;
        break;
      }
    }
  }
  findLoadedParent(e, t) {
    if (e.key in this._loadedParentTiles) {
      let i = this._loadedParentTiles[e.key];
      return i && i.tileID.overscaledZ >= t ? i : null;
    }
    for (let i = e.overscaledZ - 1; i >= t; i--) {
      let n = e.scaledTo(i), o = this._getLoadedTile(n);
      if (o) return o;
    }
  }
  _getLoadedTile(e) {
    let t = this._tiles[e.key];
    return t && t.hasData() ? t : this._cache.getByKey(e.wrapped().key);
  }
  updateCacheSize(e) {
    let t = Math.ceil(e.width / this._source.tileSize) + 1, i = Math.ceil(e.height / this._source.tileSize) + 1, n = t * i, o = this._maxTileCacheZoomLevels === null ? nt.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels, a = Math.floor(n * o), s3 = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, a) : a;
    this._cache.setMaxSize(s3);
  }
  handleWrapJump(e) {
    let t = this._prevLng === void 0 ? e : this._prevLng, n = (e - t) / 360, o = Math.round(n);
    if (this._prevLng = e, o) {
      let a = {};
      for (let s3 in this._tiles) {
        let l = this._tiles[s3];
        l.tileID = l.tileID.unwrapTo(l.tileID.wrap + o), a[l.tileID.key] = l;
      }
      this._tiles = a;
      for (let s3 in this._timers) clearTimeout(this._timers[s3]), delete this._timers[s3];
      for (let s3 in this._tiles) {
        let l = this._tiles[s3];
        this._setTileReloadTimer(s3, l);
      }
    }
  }
  update(e, t) {
    if (!this._sourceLoaded || this._paused) return;
    this.transform = e, this.terrain = t, this.updateCacheSize(e), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {};
    let i;
    !this.used && !this.usedForTerrain ? i = [] : this._source.tileID ? i = e.getVisibleUnwrappedCoordinates(this._source.tileID).map((c3) => new Xe(c3.canonical.z, c3.wrap, c3.canonical.z, c3.canonical.x, c3.canonical.y)) : (i = e.coveringTiles({ tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this.usedForTerrain ? false : this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: t }), this._source.hasTile && (i = i.filter((c3) => this._source.hasTile(c3))));
    let n = e.coveringZoomLevel(this._source), o = Math.max(n - r43.maxOverzooming, this._source.minzoom), a = Math.max(n + r43.maxUnderzooming, this._source.minzoom);
    if (this.usedForTerrain) {
      let c3 = {};
      for (let p of i) if (p.canonical.z > this._source.minzoom) {
        let h = p.scaledTo(p.canonical.z - 1);
        c3[h.key] = h;
        let f = p.scaledTo(Math.max(this._source.minzoom, Math.min(p.canonical.z, 5)));
        c3[f.key] = f;
      }
      i = i.concat(Object.values(c3));
    }
    let s3 = i.length === 0 && !this._updated && this._didEmitContent;
    this._updated = true, s3 && this.fire(new z("data", { sourceDataType: "idle", dataType: "source", sourceId: this.id }));
    let l = this._updateRetainedTiles(i, n);
    if (Sg(this._source.type)) {
      let c3 = {}, p = {}, h = Object.keys(l), f = J.now();
      for (let d of h) {
        let y = l[d], g = this._tiles[d];
        if (!g || g.fadeEndTime !== 0 && g.fadeEndTime <= f) continue;
        let x = this.findLoadedParent(y, o);
        x && (this._addTile(x.tileID), c3[x.tileID.key] = x.tileID), p[d] = y;
      }
      this._retainLoadedChildren(p, n, a, l);
      for (let d in c3) l[d] || (this._coveredTiles[d] = true, l[d] = c3[d]);
      if (t) {
        let d = {}, y = {};
        for (let g of i) this._tiles[g.key].hasData() ? d[g.key] = g : y[g.key] = g;
        for (let g in y) {
          let x = y[g].children(this._source.maxzoom);
          this._tiles[x[0].key] && this._tiles[x[1].key] && this._tiles[x[2].key] && this._tiles[x[3].key] && (d[x[0].key] = l[x[0].key] = x[0], d[x[1].key] = l[x[1].key] = x[1], d[x[2].key] = l[x[2].key] = x[2], d[x[3].key] = l[x[3].key] = x[3], delete y[g]);
        }
        for (let g in y) {
          let x = this.findLoadedParent(y[g], this._source.minzoom);
          if (x) {
            d[x.tileID.key] = l[x.tileID.key] = x.tileID;
            for (let v in d) d[v].isChildOf(x.tileID) && delete d[v];
          }
        }
        for (let g in this._tiles) d[g] || (this._coveredTiles[g] = true);
      }
    }
    for (let c3 in l) this._tiles[c3].clearFadeHold();
    let u = nf(this._tiles, l);
    for (let c3 of u) {
      let p = this._tiles[c3];
      p.hasSymbolBuckets && !p.holdingForFade() ? p.setHoldDuration(this.map._fadeDuration) : (!p.hasSymbolBuckets || p.symbolFadeFinished()) && this._removeTile(c3);
    }
    this._updateLoadedParentTileCache();
  }
  releaseSymbolFadeTiles() {
    for (let e in this._tiles) this._tiles[e].holdingForFade() && this._removeTile(e);
  }
  _updateRetainedTiles(e, t) {
    let i = {}, n = {}, o = Math.max(t - r43.maxOverzooming, this._source.minzoom), a = Math.max(t + r43.maxUnderzooming, this._source.minzoom), s3 = {};
    for (let l of e) {
      let u = this._addTile(l);
      i[l.key] = l, !u.hasData() && t < this._source.maxzoom && (s3[l.key] = l);
    }
    this._retainLoadedChildren(s3, t, a, i);
    for (let l of e) {
      let u = this._tiles[l.key];
      if (u.hasData()) continue;
      if (t + 1 > this._source.maxzoom) {
        let p = l.children(this._source.maxzoom)[0], h = this.getTile(p);
        if (h && h.hasData()) {
          i[p.key] = p;
          continue;
        }
      } else {
        let p = l.children(this._source.maxzoom);
        if (i[p[0].key] && i[p[1].key] && i[p[2].key] && i[p[3].key]) continue;
      }
      let c3 = u.wasRequested();
      for (let p = l.overscaledZ - 1; p >= o; --p) {
        let h = l.scaledTo(p);
        if (n[h.key]) break;
        if (n[h.key] = true, u = this.getTile(h), !u && c3 && (u = this._addTile(h)), u) {
          let f = u.hasData();
          if ((c3 || f) && (i[h.key] = h), c3 = u.wasRequested(), f) break;
        }
      }
    }
    return i;
  }
  _updateLoadedParentTileCache() {
    this._loadedParentTiles = {};
    for (let e in this._tiles) {
      let t = [], i, n = this._tiles[e].tileID;
      for (; n.overscaledZ > 0; ) {
        if (n.key in this._loadedParentTiles) {
          i = this._loadedParentTiles[n.key];
          break;
        }
        t.push(n.key);
        let o = n.scaledTo(n.overscaledZ - 1);
        if (i = this._getLoadedTile(o), i) break;
        n = o;
      }
      for (let o of t) this._loadedParentTiles[o] = i;
    }
  }
  _addTile(e) {
    let t = this._tiles[e.key];
    if (t) return t;
    t = this._cache.getAndRemove(e), t && (this._setTileReloadTimer(e.key, t), t.tileID = e, this._state.initializeTileState(t, this.map ? this.map.painter : null), this._cacheTimers[e.key] && (clearTimeout(this._cacheTimers[e.key]), delete this._cacheTimers[e.key], this._setTileReloadTimer(e.key, t)));
    let i = t;
    return t || (t = new ln(e, this._source.tileSize * e.overscaleFactor()), this._loadTile(t, e.key, t.state)), t.uses++, this._tiles[e.key] = t, i || this._source.fire(new z("dataloading", { tile: t, coord: t.tileID, dataType: "source" })), t;
  }
  _setTileReloadTimer(e, t) {
    e in this._timers && (clearTimeout(this._timers[e]), delete this._timers[e]);
    let i = t.getExpiryTimeout();
    i && (this._timers[e] = setTimeout(() => {
      this._reloadTile(e, "expired"), delete this._timers[e];
    }, i));
  }
  _removeTile(e) {
    let t = this._tiles[e];
    t && (t.uses--, delete this._tiles[e], this._timers[e] && (clearTimeout(this._timers[e]), delete this._timers[e]), !(t.uses > 0) && (t.hasData() && t.state !== "reloading" ? this._cache.add(t.tileID, t, t.getExpiryTimeout()) : (t.aborted = true, this._abortTile(t), this._unloadTile(t))));
  }
  _dataHandler(e) {
    let t = e.sourceDataType;
    e.dataType === "source" && t === "metadata" && (this._sourceLoaded = true), this._sourceLoaded && !this._paused && e.dataType === "source" && t === "content" && (this.reload(), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = true);
  }
  clearTiles() {
    this._shouldReloadOnResume = false, this._paused = false;
    for (let e in this._tiles) this._removeTile(e);
    this._cache.reset();
  }
  tilesIn(e, t, i) {
    let n = [], o = this.transform;
    if (!o) return n;
    let a = i ? o.getCameraQueryGeometry(e) : e, s3 = e.map((d) => o.pointCoordinate(d, this.terrain)), l = a.map((d) => o.pointCoordinate(d, this.terrain)), u = this.getIds(), c3 = 1 / 0, p = 1 / 0, h = -1 / 0, f = -1 / 0;
    for (let d of l) c3 = Math.min(c3, d.x), p = Math.min(p, d.y), h = Math.max(h, d.x), f = Math.max(f, d.y);
    for (let d = 0; d < u.length; d++) {
      let y = this._tiles[u[d]];
      if (y.holdingForFade()) continue;
      let g = y.tileID, x = Math.pow(2, o.zoom - y.tileID.overscaledZ), v = t * y.queryPadding * 8192 / y.tileSize / x, b = [g.getTilePoint(new ze(c3, p)), g.getTilePoint(new ze(h, f))];
      if (b[0].x - v < 8192 && b[0].y - v < 8192 && b[1].x + v >= 0 && b[1].y + v >= 0) {
        let w = s3.map((P) => g.getTilePoint(P)), S = l.map((P) => g.getTilePoint(P));
        n.push({ tile: y, tileID: g, queryGeometry: w, cameraQueryGeometry: S, scale: x });
      }
    }
    return n;
  }
  getVisibleCoordinates(e) {
    let t = this.getRenderableIds(e).map((i) => this._tiles[i].tileID);
    for (let i of t) i.posMatrix = this.transform.calculatePosMatrix(i.toUnwrapped());
    return t;
  }
  hasTransition() {
    if (this._source.hasTransition()) return true;
    if (Sg(this._source.type)) {
      let e = J.now();
      for (let t in this._tiles) if (this._tiles[t].fadeEndTime >= e) return true;
    }
    return false;
  }
  setFeatureState(e, t, i) {
    e = e || "_geojsonTileLayer", this._state.updateState(e, t, i);
  }
  removeFeatureState(e, t, i) {
    e = e || "_geojsonTileLayer", this._state.removeFeatureState(e, t, i);
  }
  getFeatureState(e, t) {
    return e = e || "_geojsonTileLayer", this._state.getState(e, t);
  }
  setDependencies(e, t, i) {
    let n = this._tiles[e];
    n && n.setDependencies(t, i);
  }
  reloadTilesForDependencies(e, t) {
    for (let i in this._tiles) this._tiles[i].hasDependency(e, t) && this._reloadTile(i, "reloading");
    this._cache.filter((i) => !i.hasDependency(e, t));
  }
};
sr.maxOverzooming = 10;
sr.maxUnderzooming = 3;
function wg(r50, e) {
  let t = Math.abs(r50.wrap * 2) - +(r50.wrap < 0), i = Math.abs(e.wrap * 2) - +(e.wrap < 0);
  return r50.overscaledZ - e.overscaledZ || i - t || e.canonical.y - r50.canonical.y || e.canonical.x - r50.canonical.x;
}
function Sg(r50) {
  return r50 === "raster" || r50 === "image" || r50 === "video";
}
c();
c();
c();
var jt = s(ye(), 1);
c();
var lr = s(ye(), 1);
function Kp(r50, e, t, i, n) {
  let o = [];
  for (let a = 0; a < r50.length; a++) {
    let s3 = r50[a], l;
    for (let u = 0; u < s3.length - 1; u++) {
      let c3 = s3[u], p = s3[u + 1];
      c3.x < e && p.x < e || (c3.x < e ? c3 = new lr.default(e, c3.y + (p.y - c3.y) * ((e - c3.x) / (p.x - c3.x)))._round() : p.x < e && (p = new lr.default(e, c3.y + (p.y - c3.y) * ((e - c3.x) / (p.x - c3.x)))._round()), !(c3.y < t && p.y < t) && (c3.y < t ? c3 = new lr.default(c3.x + (p.x - c3.x) * ((t - c3.y) / (p.y - c3.y)), t)._round() : p.y < t && (p = new lr.default(c3.x + (p.x - c3.x) * ((t - c3.y) / (p.y - c3.y)), t)._round()), !(c3.x >= i && p.x >= i) && (c3.x >= i ? c3 = new lr.default(i, c3.y + (p.y - c3.y) * ((i - c3.x) / (p.x - c3.x)))._round() : p.x >= i && (p = new lr.default(i, c3.y + (p.y - c3.y) * ((i - c3.x) / (p.x - c3.x)))._round()), !(c3.y >= n && p.y >= n) && (c3.y >= n ? c3 = new lr.default(c3.x + (p.x - c3.x) * ((n - c3.y) / (p.y - c3.y)), n)._round() : p.y >= n && (p = new lr.default(c3.x + (p.x - c3.x) * ((n - c3.y) / (p.y - c3.y)), n)._round()), (!l || !c3.equals(l[l.length - 1])) && (l = [c3], o.push(l)), l.push(p)))));
    }
  }
  return o;
}
c();
var Ll = class {
  constructor(e, t) {
    this.reset(e, t);
  }
  reset(e, t) {
    this.points = e || [], this._distances = [0];
    for (let i = 1; i < this.points.length; i++) this._distances[i] = this._distances[i - 1] + this.points[i].dist(this.points[i - 1]);
    this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t || 0, this.length * 0.5), this.paddedLength = this.length - this.padding * 2;
  }
  lerp(e) {
    if (this.points.length === 1) return this.points[0];
    e = Ae(e, 0, 1);
    let t = 1, i = this._distances[t], n = e * this.paddedLength + this.padding;
    for (; i < n && t < this._distances.length; ) i = this._distances[++t];
    let o = t - 1, a = this._distances[o], s3 = i - a, l = s3 > 0 ? (n - a) / s3 : 0;
    return this.points[o].mult(1 - l).add(this.points[t].mult(l));
  }
};
c();
function Dl(r50, e) {
  let t = true;
  return r50 === "always" || (r50 === "never" || e === "never") && (t = false), t;
}
var Yo = class {
  constructor(e, t, i) {
    let n = this.boxCells = [], o = this.circleCells = [];
    this.xCellCount = Math.ceil(e / i), this.yCellCount = Math.ceil(t / i);
    for (let a = 0; a < this.xCellCount * this.yCellCount; a++) n.push([]), o.push([]);
    this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e, this.height = t, this.xScale = this.xCellCount / e, this.yScale = this.yCellCount / t, this.boxUid = 0, this.circleUid = 0;
  }
  keysLength() {
    return this.boxKeys.length + this.circleKeys.length;
  }
  insert(e, t, i, n, o) {
    this._forEachCell(t, i, n, o, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e), this.bboxes.push(t), this.bboxes.push(i), this.bboxes.push(n), this.bboxes.push(o);
  }
  insertCircle(e, t, i, n) {
    this._forEachCell(t - n, i - n, t + n, i + n, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e), this.circles.push(t), this.circles.push(i), this.circles.push(n);
  }
  _insertBoxCell(e, t, i, n, o, a) {
    this.boxCells[o].push(a);
  }
  _insertCircleCell(e, t, i, n, o, a) {
    this.circleCells[o].push(a);
  }
  _query(e, t, i, n, o, a, s3) {
    if (i < 0 || e > this.width || n < 0 || t > this.height) return [];
    let l = [];
    if (e <= 0 && t <= 0 && this.width <= i && this.height <= n) {
      if (o) return [{ key: null, x1: e, y1: t, x2: i, y2: n }];
      for (let u = 0; u < this.boxKeys.length; u++) l.push({ key: this.boxKeys[u], x1: this.bboxes[u * 4], y1: this.bboxes[u * 4 + 1], x2: this.bboxes[u * 4 + 2], y2: this.bboxes[u * 4 + 3] });
      for (let u = 0; u < this.circleKeys.length; u++) {
        let c3 = this.circles[u * 3], p = this.circles[u * 3 + 1], h = this.circles[u * 3 + 2];
        l.push({ key: this.circleKeys[u], x1: c3 - h, y1: p - h, x2: c3 + h, y2: p + h });
      }
    } else {
      let u = { hitTest: o, overlapMode: a, seenUids: { box: {}, circle: {} } };
      this._forEachCell(e, t, i, n, this._queryCell, l, u, s3);
    }
    return l;
  }
  query(e, t, i, n) {
    return this._query(e, t, i, n, false, null);
  }
  hitTest(e, t, i, n, o, a) {
    return this._query(e, t, i, n, true, o, a).length > 0;
  }
  hitTestCircle(e, t, i, n, o) {
    let a = e - i, s3 = e + i, l = t - i, u = t + i;
    if (s3 < 0 || a > this.width || u < 0 || l > this.height) return false;
    let c3 = [], p = { hitTest: true, overlapMode: n, circle: { x: e, y: t, radius: i }, seenUids: { box: {}, circle: {} } };
    return this._forEachCell(a, l, s3, u, this._queryCellCircle, c3, p, o), c3.length > 0;
  }
  _queryCell(e, t, i, n, o, a, s3, l) {
    let { seenUids: u, hitTest: c3, overlapMode: p } = s3, h = this.boxCells[o];
    if (h !== null) {
      let d = this.bboxes;
      for (let y of h) if (!u.box[y]) {
        u.box[y] = true;
        let g = y * 4, x = this.boxKeys[y];
        if (e <= d[g + 2] && t <= d[g + 3] && i >= d[g + 0] && n >= d[g + 1] && (!l || l(x)) && (!c3 || !Dl(p, x.overlapMode)) && (a.push({ key: x, x1: d[g], y1: d[g + 1], x2: d[g + 2], y2: d[g + 3] }), c3)) return true;
      }
    }
    let f = this.circleCells[o];
    if (f !== null) {
      let d = this.circles;
      for (let y of f) if (!u.circle[y]) {
        u.circle[y] = true;
        let g = y * 3, x = this.circleKeys[y];
        if (this._circleAndRectCollide(d[g], d[g + 1], d[g + 2], e, t, i, n) && (!l || l(x)) && (!c3 || !Dl(p, x.overlapMode))) {
          let v = d[g], b = d[g + 1], w = d[g + 2];
          if (a.push({ key: x, x1: v - w, y1: b - w, x2: v + w, y2: b + w }), c3) return true;
        }
      }
    }
    return false;
  }
  _queryCellCircle(e, t, i, n, o, a, s3, l) {
    let { circle: u, seenUids: c3, overlapMode: p } = s3, h = this.boxCells[o];
    if (h !== null) {
      let d = this.bboxes;
      for (let y of h) if (!c3.box[y]) {
        c3.box[y] = true;
        let g = y * 4, x = this.boxKeys[y];
        if (this._circleAndRectCollide(u.x, u.y, u.radius, d[g + 0], d[g + 1], d[g + 2], d[g + 3]) && (!l || l(x)) && !Dl(p, x.overlapMode)) return a.push(true), true;
      }
    }
    let f = this.circleCells[o];
    if (f !== null) {
      let d = this.circles;
      for (let y of f) if (!c3.circle[y]) {
        c3.circle[y] = true;
        let g = y * 3, x = this.circleKeys[y];
        if (this._circlesCollide(d[g], d[g + 1], d[g + 2], u.x, u.y, u.radius) && (!l || l(x)) && !Dl(p, x.overlapMode)) return a.push(true), true;
      }
    }
  }
  _forEachCell(e, t, i, n, o, a, s3, l) {
    let u = this._convertToXCellCoord(e), c3 = this._convertToYCellCoord(t), p = this._convertToXCellCoord(i), h = this._convertToYCellCoord(n);
    for (let f = u; f <= p; f++) for (let d = c3; d <= h; d++) {
      let y = this.xCellCount * d + f;
      if (o.call(this, e, t, i, n, y, a, s3, l)) return;
    }
  }
  _convertToXCellCoord(e) {
    return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale)));
  }
  _convertToYCellCoord(e) {
    return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale)));
  }
  _circlesCollide(e, t, i, n, o, a) {
    let s3 = n - e, l = o - t, u = i + a;
    return u * u > s3 * s3 + l * l;
  }
  _circleAndRectCollide(e, t, i, n, o, a, s3) {
    let l = (a - n) / 2, u = Math.abs(e - (n + l));
    if (u > l + i) return false;
    let c3 = (s3 - o) / 2, p = Math.abs(t - (o + c3));
    if (p > c3 + i) return false;
    if (u <= l || p <= c3) return true;
    let h = u - l, f = p - c3;
    return h * h + f * f <= i * i;
  }
};
c();
var un = s(ye(), 1);
function Qo(r50, e, t, i, n) {
  let o = G.create();
  return e ? (G.scale(o, o, [1 / n, 1 / n, 1]), t || G.rotateZ(o, o, i.angle)) : G.multiply(o, i.labelPlaneMatrix, r50), o;
}
function Fl(r50, e, t, i, n) {
  if (e) {
    let o = G.clone(r50);
    return G.scale(o, o, [n, n, 1]), t || G.rotateZ(o, o, -i.angle), o;
  } else return i.glCoordMatrix;
}
function xt(r50, e, t) {
  let i;
  t ? (i = [r50.x, r50.y, t(r50.x, r50.y), 1], Ge.transformMat4(i, i, e)) : (i = [r50.x, r50.y, 0, 1], Rl(i, i, e));
  let n = i[3];
  return { point: new un.default(i[0] / n, i[1] / n), signedDistanceFromCamera: n };
}
function ea(r50, e) {
  return 0.5 + 0.5 * (r50 / e);
}
function fA(r50, e) {
  let t = r50[0] / r50[3], i = r50[1] / r50[3];
  return t >= -e[0] && t <= e[0] && i >= -e[1] && i <= e[1];
}
function Ag(r50, e, t, i, n, o, a, s3, l, u) {
  let c3 = i ? r50.textSizeData : r50.iconSizeData, p = ui(c3, t.transform.zoom), h = [256 / t.width * 2 + 1, 256 / t.height * 2 + 1], f = i ? r50.text.dynamicLayoutVertexArray : r50.icon.dynamicLayoutVertexArray;
  f.clear();
  let d = r50.lineVertexArray, y = i ? r50.text.placedSymbolArray : r50.icon.placedSymbolArray, g = t.transform.width / t.transform.height, x = false;
  for (let v = 0; v < y.length; v++) {
    let b = y.get(v);
    if (b.hidden || b.writingMode === 2 && !x) {
      hi(b.numGlyphs, f);
      continue;
    }
    x = false;
    let w;
    if (u ? (w = [b.anchorX, b.anchorY, u(b.anchorX, b.anchorY), 1], Ge.transformMat4(w, w, e)) : (w = [b.anchorX, b.anchorY, 0, 1], Rl(w, w, e)), !fA(w, h)) {
      hi(b.numGlyphs, f);
      continue;
    }
    let S = w[3], P = ea(t.transform.cameraToCenterDistance, S), k = Qi(c3, p, b), I = a ? k / P : k * P, C = new un.default(b.anchorX, b.anchorY), M = xt(C, n, u).point, F = { projections: {}, offsets: {} }, D = Tg(b, I, false, s3, e, n, o, r50.glyphOffsetArray, d, f, M, C, F, g, l, u);
    x = D.useVertical, (D.notEnoughRoom || x || D.needsFlipping && Tg(b, I, true, s3, e, n, o, r50.glyphOffsetArray, d, f, M, C, F, g, l, u).notEnoughRoom) && hi(b.numGlyphs, f);
  }
  i ? r50.text.dynamicLayoutVertexBuffer.updateData(f) : r50.icon.dynamicLayoutVertexBuffer.updateData(f);
}
function Qp(r50, e, t, i, n, o, a, s3, l, u, c3, p, h) {
  let f = s3.glyphStartIndex + s3.numGlyphs, d = s3.lineStartIndex, y = s3.lineStartIndex + s3.lineLength, g = e.getoffsetX(s3.glyphStartIndex), x = e.getoffsetX(f - 1), v = zl(r50 * g, t, i, n, o, a, s3.segment, d, y, l, u, c3, p, h);
  if (!v) return null;
  let b = zl(r50 * x, t, i, n, o, a, s3.segment, d, y, l, u, c3, p, h);
  return b ? { first: v, last: b } : null;
}
function Pg(r50, e, t, i) {
  if (r50 === 1) {
    let n = Math.abs(t.y - e.y), o = Math.abs(t.x - e.x) * i;
    if (n > o) return { useVertical: true };
  }
  return (r50 === 2 ? e.y < t.y : e.x > t.x) ? { needsFlipping: true } : null;
}
function Tg(r50, e, t, i, n, o, a, s3, l, u, c3, p, h, f, d, y) {
  let g = e / 24, x = r50.lineOffsetX * g, v = r50.lineOffsetY * g, b;
  if (r50.numGlyphs > 1) {
    let w = r50.glyphStartIndex + r50.numGlyphs, S = r50.lineStartIndex, P = r50.lineStartIndex + r50.lineLength, k = Qp(g, s3, x, v, t, c3, p, r50, l, o, h, d, y);
    if (!k) return { notEnoughRoom: true };
    let I = xt(k.first.point, a, y).point, C = xt(k.last.point, a, y).point;
    if (i && !t) {
      let M = Pg(r50.writingMode, I, C, f);
      if (M) return M;
    }
    b = [k.first];
    for (let M = r50.glyphStartIndex + 1; M < w - 1; M++) {
      let F = zl(g * s3.getoffsetX(M), x, v, t, c3, p, r50.segment, S, P, l, o, h, d, y);
      if (F == null) return { notEnoughRoom: true };
      b.push(F);
    }
    b.push(k.last);
  } else {
    if (i && !t) {
      let S = xt(p, n, y).point, P = r50.lineStartIndex + r50.segment + 1, k = new un.default(l.getx(P), l.gety(P)), I = xt(k, n, y), C = I.signedDistanceFromCamera > 0 ? I.point : Mg(p, k, S, 1, n, y), M = Pg(r50.writingMode, S, C, f);
      if (M) return M;
    }
    let w = zl(g * s3.getoffsetX(r50.glyphStartIndex), x, v, t, c3, p, r50.segment, r50.lineStartIndex, r50.lineStartIndex + r50.lineLength, l, o, h, d, y);
    if (!w) return { notEnoughRoom: true };
    b = [w];
  }
  for (let w of b) ci(u, w.point, w.angle);
  return {};
}
function Mg(r50, e, t, i, n, o) {
  let a = xt(r50.add(r50.sub(e)._unit()), n, o).point, s3 = t.sub(a);
  return t.add(s3._mult(i / s3.mag()));
}
function Jp(r50, e) {
  let { projectionCache: t, lineVertexArray: i, labelPlaneMatrix: n, tileAnchorPoint: o, distanceFromAnchor: a, getElevation: s3, previousVertex: l, direction: u, absOffsetX: c3 } = e;
  if (t.projections[r50]) return t.projections[r50];
  let p = new un.default(i.getx(r50), i.gety(r50)), h = xt(p, n, s3);
  if (h.signedDistanceFromCamera > 0) return t.projections[r50] = h.point, h.point;
  let f = r50 - u, d = a === 0 ? o : new un.default(i.getx(f), i.gety(f));
  return Mg(d, p, l, c3 - a + 1, n, s3);
}
function Yp(r50, e, t) {
  return r50._unit()._perp()._mult(e * t);
}
function mA(r50, e, t, i, n, o, a, s3) {
  let { projectionCache: l, direction: u } = s3;
  if (l.offsets[r50]) return l.offsets[r50];
  let c3 = t.add(e);
  if (r50 + u < i || r50 + u >= n) return l.offsets[r50] = c3, c3;
  let p = Jp(r50 + u, s3), h = Yp(p.sub(t), a, u), f = t.add(h), d = p.add(h);
  return l.offsets[r50] = lf(o, c3, f, d) || c3, l.offsets[r50];
}
function zl(r50, e, t, i, n, o, a, s3, l, u, c3, p, h, f) {
  let d = i ? r50 - e : r50 + e, y = d > 0 ? 1 : -1, g = 0;
  i && (y *= -1, g = Math.PI), y < 0 && (g += Math.PI);
  let x = y > 0 ? s3 + a : s3 + a + 1, v = n, b = n, w, S, P = 0, k = 0, I = Math.abs(d), C = [], M;
  for (; P + k <= I; ) {
    if (x += y, x < s3 || x >= l) return null;
    P += k, b = v, S = w;
    let T = { projectionCache: p, lineVertexArray: u, labelPlaneMatrix: c3, tileAnchorPoint: o, distanceFromAnchor: P, getElevation: f, previousVertex: b, direction: y, absOffsetX: I };
    if (v = Jp(x, T), t === 0) C.push(b), M = v.sub(b);
    else {
      let N, X = v.sub(b);
      if (X.mag() === 0) {
        let ie = Jp(x + y, T);
        N = Yp(ie.sub(v), t, y);
      } else N = Yp(X, t, y);
      S || (S = b.add(N)), w = mA(x, N, v, s3, l, S, t, T), C.push(S), M = w.sub(S);
    }
    k = M.mag();
  }
  let F = (I - P) / k, D = M._mult(F)._add(S || b), E = g + Math.atan2(v.y - b.y, v.x - b.x);
  return C.push(D), { point: D, angle: h ? E : 0, path: C };
}
var dA = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
function hi(r50, e) {
  for (let t = 0; t < r50; t++) {
    let i = e.length;
    e.resize(i + 4), e.float32.set(dA, i * 3);
  }
}
function Rl(r50, e, t) {
  let i = e[0], n = e[1];
  return r50[0] = t[0] * i + t[4] * n + t[12], r50[1] = t[1] * i + t[5] * n + t[13], r50[3] = t[3] * i + t[7] * n + t[15], r50;
}
var We = 100;
var Bl = class {
  constructor(e, t = new Yo(e.width + 2 * We, e.height + 2 * We, 25), i = new Yo(e.width + 2 * We, e.height + 2 * We, 25)) {
    this.transform = e, this.grid = t, this.ignoredGrid = i, this.pitchfactor = Math.cos(e._pitch) * e.cameraToCenterDistance, this.screenRightBoundary = e.width + We, this.screenBottomBoundary = e.height + We, this.gridRightBoundary = e.width + 2 * We, this.gridBottomBoundary = e.height + 2 * We, this.perspectiveRatioCutoff = 0.6;
  }
  placeCollisionBox(e, t, i, n, o, a) {
    let s3 = this.projectAndGetPerspectiveRatio(n, e.anchorPointX, e.anchorPointY, a), l = i * s3.perspectiveRatio, u = e.x1 * l + s3.point.x, c3 = e.y1 * l + s3.point.y, p = e.x2 * l + s3.point.x, h = e.y2 * l + s3.point.y;
    return !this.isInsideGrid(u, c3, p, h) || t !== "always" && this.grid.hitTest(u, c3, p, h, t, o) || s3.perspectiveRatio < this.perspectiveRatioCutoff ? { box: [], offscreen: false } : { box: [u, c3, p, h], offscreen: this.isOffscreen(u, c3, p, h) };
  }
  placeCollisionCircles(e, t, i, n, o, a, s3, l, u, c3, p, h, f, d) {
    let y = [], g = new jt.default(t.anchorX, t.anchorY), x = xt(g, a, d), v = ea(this.transform.cameraToCenterDistance, x.signedDistanceFromCamera), w = (c3 ? o / v : o * v) / Er, S = xt(g, s3, d).point, P = { projections: {}, offsets: {} }, k = t.lineOffsetX * w, I = t.lineOffsetY * w, C = Qp(w, n, k, I, false, S, g, t, i, s3, P, false, d), M = false, F = false, D = true;
    if (C) {
      let E = h * 0.5 * v + f, T = new jt.default(-We, -We), N = new jt.default(this.screenRightBoundary, this.screenBottomBoundary), X = new Ll(), ie = C.first, K = C.last, $ = [];
      for (let ue = ie.path.length - 1; ue >= 1; ue--) $.push(ie.path[ue]);
      for (let ue = 1; ue < K.path.length; ue++) $.push(K.path[ue]);
      let Ke = E * 2.5;
      if (l) {
        let ue = $.map((Te) => xt(Te, l, d));
        ue.some((Te) => Te.signedDistanceFromCamera <= 0) ? $ = [] : $ = ue.map((Te) => Te.point);
      }
      let Oe = [];
      if ($.length > 0) {
        let ue = $[0].clone(), Te = $[0].clone();
        for (let Je = 1; Je < $.length; Je++) ue.x = Math.min(ue.x, $[Je].x), ue.y = Math.min(ue.y, $[Je].y), Te.x = Math.max(Te.x, $[Je].x), Te.y = Math.max(Te.y, $[Je].y);
        ue.x >= T.x && Te.x <= N.x && ue.y >= T.y && Te.y <= N.y ? Oe = [$] : Te.x < T.x || ue.x > N.x || Te.y < T.y || ue.y > N.y ? Oe = [] : Oe = Kp([$], T.x, T.y, N.x, N.y);
      }
      for (let ue of Oe) {
        X.reset(ue, E * 0.25);
        let Te = 0;
        X.length <= 0.5 * E ? Te = 1 : Te = Math.ceil(X.paddedLength / Ke) + 1;
        for (let Je = 0; Je < Te; Je++) {
          let pr = Je / Math.max(Te - 1, 1), hr = X.lerp(pr), Lt = hr.x + We, Ht = hr.y + We;
          y.push(Lt, Ht, E, 0);
          let Or = Lt - E, $t = Ht - E, Wt = Lt + E, Ye = Ht + E;
          if (D = D && this.isOffscreen(Or, $t, Wt, Ye), F = F || this.isInsideGrid(Or, $t, Wt, Ye), e !== "always" && this.grid.hitTestCircle(Lt, Ht, E, e, p) && (M = true, !u)) return { circles: [], offscreen: false, collisionDetected: M };
        }
      }
    }
    return { circles: !u && M || !F || v < this.perspectiveRatioCutoff ? [] : y, offscreen: D, collisionDetected: M };
  }
  queryRenderedSymbols(e) {
    if (e.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {};
    let t = [], i = 1 / 0, n = 1 / 0, o = -1 / 0, a = -1 / 0;
    for (let c3 of e) {
      let p = new jt.default(c3.x + We, c3.y + We);
      i = Math.min(i, p.x), n = Math.min(n, p.y), o = Math.max(o, p.x), a = Math.max(a, p.y), t.push(p);
    }
    let s3 = this.grid.query(i, n, o, a).concat(this.ignoredGrid.query(i, n, o, a)), l = {}, u = {};
    for (let c3 of s3) {
      let p = c3.key;
      if (l[p.bucketInstanceId] === void 0 && (l[p.bucketInstanceId] = {}), l[p.bucketInstanceId][p.featureIndex]) continue;
      let h = [new jt.default(c3.x1, c3.y1), new jt.default(c3.x2, c3.y1), new jt.default(c3.x2, c3.y2), new jt.default(c3.x1, c3.y2)];
      qs(t, h) && (l[p.bucketInstanceId][p.featureIndex] = true, u[p.bucketInstanceId] === void 0 && (u[p.bucketInstanceId] = []), u[p.bucketInstanceId].push(p.featureIndex));
    }
    return u;
  }
  insertCollisionBox(e, t, i, n, o, a) {
    let s3 = i ? this.ignoredGrid : this.grid, l = { bucketInstanceId: n, featureIndex: o, collisionGroupID: a, overlapMode: t };
    s3.insert(l, e[0], e[1], e[2], e[3]);
  }
  insertCollisionCircles(e, t, i, n, o, a) {
    let s3 = i ? this.ignoredGrid : this.grid, l = { bucketInstanceId: n, featureIndex: o, collisionGroupID: a, overlapMode: t };
    for (let u = 0; u < e.length; u += 4) s3.insertCircle(l, e[u], e[u + 1], e[u + 2]);
  }
  projectAndGetPerspectiveRatio(e, t, i, n) {
    let o;
    return n ? (o = [t, i, n(t, i), 1], Ge.transformMat4(o, o, e)) : (o = [t, i, 0, 1], Rl(o, o, e)), { point: new jt.default((o[0] / o[3] + 1) / 2 * this.transform.width + We, (-o[1] / o[3] + 1) / 2 * this.transform.height + We), perspectiveRatio: 0.5 + 0.5 * (this.transform.cameraToCenterDistance / o[3]) };
  }
  isOffscreen(e, t, i, n) {
    return i < We || e >= this.screenRightBoundary || n < We || t > this.screenBottomBoundary;
  }
  isInsideGrid(e, t, i, n) {
    return i >= 0 && e < this.gridRightBoundary && n >= 0 && t < this.gridBottomBoundary;
  }
  getViewportMatrix() {
    let e = G.identity([]);
    return G.translate(e, e, [-We, -We, 0]), e;
  }
};
c();
c();
var Ig = s(ye(), 1);
var ta = class r44 extends Ig.default {
  constructor(e, t, i, n) {
    super(e, t), this.angle = i, n !== void 0 && (this.segment = n);
  }
  clone() {
    return new r44(this.x, this.y, this.angle, this.segment);
  }
};
U("Anchor", ta);
c();
c();
c();
var yA = s(ye(), 1);
c();
var gA = s(ye(), 1);
c();
c();
var xA = s(ye(), 1);
var _A = s(gp(), 1);
c();
var ra = ((o) => (o[o.center = 1] = "center", o[o.left = 2] = "left", o[o.right = 3] = "right", o[o.top = 4] = "top", o[o.bottom = 5] = "bottom", o[o["top-left"] = 6] = "top-left", o[o["top-right"] = 7] = "top-right", o[o["bottom-left"] = 8] = "bottom-left", o[o["bottom-right"] = 9] = "bottom-right", o))(ra || {});
var bA = Number.POSITIVE_INFINITY;
function Cg(r50) {
  switch (r50) {
    case "right":
    case "top-right":
    case "bottom-right":
      return "right";
    case "left":
    case "top-left":
    case "bottom-left":
      return "left";
  }
  return "center";
}
c();
function He(r50, e, t) {
  return e * (8192 / (r50.tileSize * Math.pow(2, t - r50.tileID.overscaledZ)));
}
var Gl = s(ye(), 1);
var Vl = class {
  constructor(e, t, i, n) {
    e ? this.opacity = Math.max(0, Math.min(1, e.opacity + (e.placed ? t : -t))) : this.opacity = n && i ? 1 : 0, this.placed = i;
  }
  isHidden() {
    return this.opacity === 0 && !this.placed;
  }
};
var fi = class {
  constructor(e, t, i, n, o) {
    this.text = new Vl(e ? e.text : null, t, i, o), this.icon = new Vl(e ? e.icon : null, t, n, o);
  }
  isHidden() {
    return this.text.isHidden() && this.icon.isHidden();
  }
};
var Ul = class {
  constructor(e, t, i) {
    this.text = e, this.icon = t, this.skipFade = i;
  }
};
var rh = class {
  constructor() {
    this.invProjMatrix = G.create(), this.viewportMatrix = G.create(), this.circles = [];
  }
};
var ih = class {
  constructor(e, t, i, n, o) {
    this.bucketInstanceId = e, this.featureIndex = t, this.sourceLayerIndex = i, this.bucketIndex = n, this.tileID = o;
  }
};
var nh = class {
  constructor(e) {
    this.crossSourceCollisions = e, this.maxGroupID = 0, this.collisionGroups = {};
  }
  get(e) {
    if (this.crossSourceCollisions) return { ID: 0, predicate: null };
    if (!this.collisionGroups[e]) {
      let t = ++this.maxGroupID;
      this.collisionGroups[e] = { ID: t, predicate: (i) => i.collisionGroupID === t };
    }
    return this.collisionGroups[e];
  }
};
function Eg(r50, e, t, i, n) {
  let { horizontalAlign: o, verticalAlign: a } = ll(r50), s3 = -(o - 0.5) * e, l = -(a - 0.5) * t;
  return new Gl.default(s3 + i[0] * n, l + i[1] * n);
}
function th(r50, e, t, i, n, o) {
  let { x1: a, x2: s3, y1: l, y2: u, anchorPointX: c3, anchorPointY: p } = r50, h = new Gl.default(e, t);
  return i && h._rotate(n ? o : -o), { x1: a + h.x, y1: l + h.y, x2: s3 + h.x, y2: u + h.y, anchorPointX: c3, anchorPointY: p };
}
var Nl = class {
  constructor(e, t, i, n, o) {
    this.transform = e.clone(), this.terrain = t, this.collisionIndex = new Bl(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = i, this.retainedQueryData = {}, this.collisionGroups = new nh(n), this.collisionCircleArrays = {}, this.prevPlacement = o, o && (o.prevPlacement = void 0), this.placedOrientations = {};
  }
  getBucketParts(e, t, i, n) {
    let o = i.getBucket(t), a = i.latestFeatureIndex;
    if (!o || !a || t.id !== o.layerIds[0]) return;
    let s3 = i.collisionBoxArray, l = o.layers[0].layout, u = Math.pow(2, this.transform.zoom - i.tileID.overscaledZ), c3 = i.tileSize / 8192, p = this.transform.calculatePosMatrix(i.tileID.toUnwrapped()), h = l.get("text-pitch-alignment") === "map", f = l.get("text-rotation-alignment") === "map", d = He(i, 1, this.transform.zoom), y = Qo(p, h, f, this.transform, d), g = null;
    if (h) {
      let v = Fl(p, h, f, this.transform, d);
      g = G.multiply([], this.transform.labelPlaneMatrix, v);
    }
    this.retainedQueryData[o.bucketInstanceId] = new ih(o.bucketInstanceId, a, o.sourceLayerIndex, o.index, i.tileID);
    let x = { bucket: o, layout: l, posMatrix: p, textLabelPlaneMatrix: y, labelToScreenMatrix: g, scale: u, textPixelRatio: c3, holdingForFade: i.holdingForFade(), collisionBoxArray: s3, partiallyEvaluatedTextSize: ui(o.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(o.sourceID) };
    if (n) for (let v of o.sortKeyRanges) {
      let { sortKey: b, symbolInstanceStart: w, symbolInstanceEnd: S } = v;
      e.push({ sortKey: b, symbolInstanceStart: w, symbolInstanceEnd: S, parameters: x });
    }
    else e.push({ symbolInstanceStart: 0, symbolInstanceEnd: o.symbolInstances.length, parameters: x });
  }
  attemptAnchorPlacement(e, t, i, n, o, a, s3, l, u, c3, p, h, f, d, y, g) {
    let x = ra[e.textAnchor], v = [e.textOffset0, e.textOffset1], b = Eg(x, i, n, v, o), w = this.collisionIndex.placeCollisionBox(th(t, b.x, b.y, a, s3, this.transform.angle), p, l, u, c3.predicate, g);
    if (!(y && this.collisionIndex.placeCollisionBox(th(y, b.x, b.y, a, s3, this.transform.angle), p, l, u, c3.predicate, g).box.length === 0) && w.box.length > 0) {
      let S;
      if (this.prevPlacement && this.prevPlacement.variableOffsets[h.crossTileID] && this.prevPlacement.placements[h.crossTileID] && this.prevPlacement.placements[h.crossTileID].text && (S = this.prevPlacement.variableOffsets[h.crossTileID].anchor), h.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
      return this.variableOffsets[h.crossTileID] = { textOffset: v, width: i, height: n, anchor: x, textBoxScale: o, prevAnchor: S }, this.markUsedJustification(f, x, h, d), f.allowVerticalPlacement && (this.markUsedOrientation(f, d, h), this.placedOrientations[h.crossTileID] = d), { shift: b, placedGlyphBoxes: w };
    }
  }
  placeLayerBucketPart(e, t, i) {
    let { bucket: n, layout: o, posMatrix: a, textLabelPlaneMatrix: s3, labelToScreenMatrix: l, textPixelRatio: u, holdingForFade: c3, collisionBoxArray: p, partiallyEvaluatedTextSize: h, collisionGroup: f } = e.parameters, d = o.get("text-optional"), y = o.get("icon-optional"), g = en(o, "text-overlap", "text-allow-overlap"), x = g === "always", v = en(o, "icon-overlap", "icon-allow-overlap"), b = v === "always", w = o.get("text-rotation-alignment") === "map", S = o.get("text-pitch-alignment") === "map", P = o.get("icon-text-fit") !== "none", k = o.get("symbol-z-order") === "viewport-y", I = x && (b || !n.hasIconData() || y), C = b && (x || !n.hasTextData() || d);
    !n.collisionArrays && p && n.deserializeCollisionBoxes(p);
    let M = this.retainedQueryData[n.bucketInstanceId].tileID, F = this.terrain ? (E, T) => this.terrain.getElevation(M, E, T) : null, D = (E, T) => {
      var $t, Wt;
      if (t[E.crossTileID]) return;
      if (c3) {
        this.placements[E.crossTileID] = new Ul(false, false, false);
        return;
      }
      let N = false, X = false, ie = true, K = null, $ = { box: null, offscreen: null }, Ke = { box: null, offscreen: null }, Oe = null, ue = null, Te = null, Je = 0, pr = 0, hr = 0;
      T.textFeatureIndex ? Je = T.textFeatureIndex : E.useRuntimeCollisionCircles && (Je = E.featureIndex), T.verticalTextFeatureIndex && (pr = T.verticalTextFeatureIndex);
      let Lt = T.textBox;
      if (Lt) {
        let Ye = (je) => {
          let ut = 1;
          if (n.allowVerticalPlacement && !je && this.prevPlacement) {
            let Xt = this.prevPlacement.placedOrientations[E.crossTileID];
            Xt && (this.placedOrientations[E.crossTileID] = Xt, ut = Xt, this.markUsedOrientation(n, ut, E));
          }
          return ut;
        }, it = (je, ut) => {
          if (n.allowVerticalPlacement && E.numVerticalGlyphVertices > 0 && T.verticalTextBox) {
            for (let Xt of n.writingModes) if (Xt === 2 ? ($ = ut(), Ke = $) : $ = je(), $ && $.box && $.box.length) break;
          } else $ = je();
        }, Qe = E.textAnchorOffsetStartIndex, Vr = E.textAnchorOffsetEndIndex;
        if (Vr === Qe) {
          let je = (Ur, za) => {
            let et = this.collisionIndex.placeCollisionBox(Ur, g, u, a, f.predicate, F);
            return et && et.box && et.box.length && (this.markUsedOrientation(n, za, E), this.placedOrientations[E.crossTileID] = za), et;
          };
          it(() => je(Lt, 1), () => {
            let Ur = T.verticalTextBox;
            return n.allowVerticalPlacement && E.numVerticalGlyphVertices > 0 && Ur ? je(Ur, 2) : { box: null, offscreen: null };
          }), Ye($ && $.box && $.box.length);
        } else {
          let je = ra[(Wt = ($t = this.prevPlacement) == null ? void 0 : $t.variableOffsets[E.crossTileID]) == null ? void 0 : Wt.anchor], ut = (et, bc, S_) => {
            let P_ = et.x2 - et.x1, T_ = et.y2 - et.y1, A_ = E.textBoxScale, M_ = P && v === "never" ? bc : null, gi = { box: [], offscreen: false }, jh = g === "never" ? 1 : 2, Zh = "never";
            je && jh++;
            for (let Hh = 0; Hh < jh; Hh++) {
              for (let _c = Qe; _c < Vr; _c++) {
                let $h = n.textAnchorOffsets.get(_c);
                if (je && $h.textAnchor !== je) continue;
                let vc = this.attemptAnchorPlacement($h, et, P_, T_, A_, w, S, u, a, f, Zh, E, n, S_, M_, F);
                if (vc && (gi = vc.placedGlyphBoxes, gi && gi.box && gi.box.length)) return N = true, K = vc.shift, gi;
              }
              je ? je = null : Zh = g;
            }
            return gi;
          };
          it(() => ut(Lt, T.iconBox, 1), () => {
            let et = T.verticalTextBox, bc = $ && $.box && $.box.length;
            return n.allowVerticalPlacement && !bc && E.numVerticalGlyphVertices > 0 && et ? ut(et, T.verticalIconBox, 2) : { box: null, offscreen: null };
          }), $ && (N = $.box, ie = $.offscreen);
          let za = Ye($ && $.box);
          if (!N && this.prevPlacement) {
            let et = this.prevPlacement.variableOffsets[E.crossTileID];
            et && (this.variableOffsets[E.crossTileID] = et, this.markUsedJustification(n, et.anchor, E, za));
          }
        }
      }
      if (Oe = $, N = Oe && Oe.box && Oe.box.length > 0, ie = Oe && Oe.offscreen, E.useRuntimeCollisionCircles) {
        let Ye = n.text.placedSymbolArray.get(E.centerJustifiedTextSymbolIndex), it = Qi(n.textSizeData, h, Ye), Qe = o.get("text-padding"), Vr = E.collisionCircleDiameter;
        ue = this.collisionIndex.placeCollisionCircles(g, Ye, n.lineVertexArray, n.glyphOffsetArray, it, a, s3, l, i, S, f.predicate, Vr, Qe, F), ue.circles.length && ue.collisionDetected && !i && Ee("Collisions detected, but collision boxes are not shown"), N = x || ue.circles.length > 0 && !ue.collisionDetected, ie = ie && ue.offscreen;
      }
      if (T.iconFeatureIndex && (hr = T.iconFeatureIndex), T.iconBox) {
        let Ye = (it) => {
          let Qe = P && K ? th(it, K.x, K.y, w, S, this.transform.angle) : it;
          return this.collisionIndex.placeCollisionBox(Qe, v, u, a, f.predicate, F);
        };
        Ke && Ke.box && Ke.box.length && T.verticalIconBox ? (Te = Ye(T.verticalIconBox), X = Te.box.length > 0) : (Te = Ye(T.iconBox), X = Te.box.length > 0), ie = ie && Te.offscreen;
      }
      let Ht = d || E.numHorizontalGlyphVertices === 0 && E.numVerticalGlyphVertices === 0, Or = y || E.numIconVertices === 0;
      if (!Ht && !Or ? X = N = X && N : Or ? Ht || (X = X && N) : N = X && N, N && Oe && Oe.box && (Ke && Ke.box && pr ? this.collisionIndex.insertCollisionBox(Oe.box, g, o.get("text-ignore-placement"), n.bucketInstanceId, pr, f.ID) : this.collisionIndex.insertCollisionBox(Oe.box, g, o.get("text-ignore-placement"), n.bucketInstanceId, Je, f.ID)), X && Te && this.collisionIndex.insertCollisionBox(Te.box, v, o.get("icon-ignore-placement"), n.bucketInstanceId, hr, f.ID), ue && (N && this.collisionIndex.insertCollisionCircles(ue.circles, g, o.get("text-ignore-placement"), n.bucketInstanceId, Je, f.ID), i)) {
        let Ye = n.bucketInstanceId, it = this.collisionCircleArrays[Ye];
        it === void 0 && (it = this.collisionCircleArrays[Ye] = new rh());
        for (let Qe = 0; Qe < ue.circles.length; Qe += 4) it.circles.push(ue.circles[Qe + 0]), it.circles.push(ue.circles[Qe + 1]), it.circles.push(ue.circles[Qe + 2]), it.circles.push(ue.collisionDetected ? 1 : 0);
      }
      if (E.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
      if (n.bucketInstanceId === 0) throw new Error("bucket.bucketInstanceId can't be 0");
      this.placements[E.crossTileID] = new Ul(N || I, X || C, ie || n.justReloaded), t[E.crossTileID] = true;
    };
    if (k) {
      if (e.symbolInstanceStart !== 0) throw new Error("bucket.bucketInstanceId should be 0");
      let E = n.getSortedSymbolIndexes(this.transform.angle);
      for (let T = E.length - 1; T >= 0; --T) {
        let N = E[T];
        D(n.symbolInstances.get(N), n.collisionArrays[N]);
      }
    } else for (let E = e.symbolInstanceStart; E < e.symbolInstanceEnd; E++) D(n.symbolInstances.get(E), n.collisionArrays[E]);
    if (i && n.bucketInstanceId in this.collisionCircleArrays) {
      let E = this.collisionCircleArrays[n.bucketInstanceId];
      G.invert(E.invProjMatrix, a), E.viewportMatrix = this.collisionIndex.getViewportMatrix();
    }
    n.justReloaded = false;
  }
  markUsedJustification(e, t, i, n) {
    let o = { left: i.leftJustifiedTextSymbolIndex, center: i.centerJustifiedTextSymbolIndex, right: i.rightJustifiedTextSymbolIndex }, a;
    n === 2 ? a = i.verticalPlacedTextSymbolIndex : a = o[Cg(t)];
    let s3 = [i.leftJustifiedTextSymbolIndex, i.centerJustifiedTextSymbolIndex, i.rightJustifiedTextSymbolIndex, i.verticalPlacedTextSymbolIndex];
    for (let l of s3) l >= 0 && (a >= 0 && l !== a ? e.text.placedSymbolArray.get(l).crossTileID = 0 : e.text.placedSymbolArray.get(l).crossTileID = i.crossTileID);
  }
  markUsedOrientation(e, t, i) {
    let n = t === 1 || t === 3 ? t : 0, o = t === 2 ? t : 0, a = [i.leftJustifiedTextSymbolIndex, i.centerJustifiedTextSymbolIndex, i.rightJustifiedTextSymbolIndex];
    for (let s3 of a) e.text.placedSymbolArray.get(s3).placedOrientation = n;
    i.verticalPlacedTextSymbolIndex && (e.text.placedSymbolArray.get(i.verticalPlacedTextSymbolIndex).placedOrientation = o);
  }
  commit(e) {
    this.commitTime = e, this.zoomAtLastRecencyCheck = this.transform.zoom;
    let t = this.prevPlacement, i = false;
    this.prevZoomAdjustment = t ? t.zoomAdjustment(this.transform.zoom) : 0;
    let n = t ? t.symbolFadeChange(e) : 1, o = t ? t.opacities : {}, a = t ? t.variableOffsets : {}, s3 = t ? t.placedOrientations : {};
    for (let l in this.placements) {
      let u = this.placements[l], c3 = o[l];
      c3 ? (this.opacities[l] = new fi(c3, n, u.text, u.icon), i = i || u.text !== c3.text.placed || u.icon !== c3.icon.placed) : (this.opacities[l] = new fi(null, n, u.text, u.icon, u.skipFade), i = i || u.text || u.icon);
    }
    for (let l in o) {
      let u = o[l];
      if (!this.opacities[l]) {
        let c3 = new fi(u, n, false, false);
        c3.isHidden() || (this.opacities[l] = c3, i = i || u.text.placed || u.icon.placed);
      }
    }
    for (let l in a) !this.variableOffsets[l] && this.opacities[l] && !this.opacities[l].isHidden() && (this.variableOffsets[l] = a[l]);
    for (let l in s3) !this.placedOrientations[l] && this.opacities[l] && !this.opacities[l].isHidden() && (this.placedOrientations[l] = s3[l]);
    if (t && t.lastPlacementChangeTime === void 0) throw new Error("Last placement time for previous placement is not defined");
    i ? this.lastPlacementChangeTime = e : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = t ? t.lastPlacementChangeTime : e);
  }
  updateLayerOpacities(e, t) {
    let i = {};
    for (let n of t) {
      let o = n.getBucket(e);
      o && n.latestFeatureIndex && e.id === o.layerIds[0] && this.updateBucketOpacities(o, i, n.collisionBoxArray);
    }
  }
  updateBucketOpacities(e, t, i) {
    e.hasTextData() && (e.text.opacityVertexArray.clear(), e.text.hasVisibleVertices = false), e.hasIconData() && (e.icon.opacityVertexArray.clear(), e.icon.hasVisibleVertices = false), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexArray.clear(), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexArray.clear();
    let n = e.layers[0], o = n.layout, a = new fi(null, 0, false, false, true), s3 = o.get("text-allow-overlap"), l = o.get("icon-allow-overlap"), u = n._unevaluatedLayout.hasValue("text-variable-anchor") || n._unevaluatedLayout.hasValue("text-variable-anchor-offset"), c3 = o.get("text-rotation-alignment") === "map", p = o.get("text-pitch-alignment") === "map", h = o.get("icon-text-fit") !== "none", f = new fi(null, 0, s3 && (l || !e.hasIconData() || o.get("icon-optional")), l && (s3 || !e.hasTextData() || o.get("text-optional")), true);
    !e.collisionArrays && i && (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) && e.deserializeCollisionBoxes(i);
    let d = (y, g, x) => {
      for (let v = 0; v < g / 4; v++) y.opacityVertexArray.emplaceBack(x);
      y.hasVisibleVertices = y.hasVisibleVertices || x !== ia;
    };
    for (let y = 0; y < e.symbolInstances.length; y++) {
      let g = e.symbolInstances.get(y), { numHorizontalGlyphVertices: x, numVerticalGlyphVertices: v, crossTileID: b } = g, w = t[b], S = this.opacities[b];
      w ? S = a : S || (S = f, this.opacities[b] = S), t[b] = true;
      let P = x > 0 || v > 0, k = g.numIconVertices > 0, I = this.placedOrientations[g.crossTileID], C = I === 2, M = I === 1 || I === 3;
      if (P) {
        let F = kg(S.text), D = C ? ia : F;
        d(e.text, x, D);
        let E = M ? ia : F;
        d(e.text, v, E);
        let T = S.text.isHidden();
        [g.rightJustifiedTextSymbolIndex, g.centerJustifiedTextSymbolIndex, g.leftJustifiedTextSymbolIndex].forEach((ie) => {
          ie >= 0 && (e.text.placedSymbolArray.get(ie).hidden = T || C ? 1 : 0);
        }), g.verticalPlacedTextSymbolIndex >= 0 && (e.text.placedSymbolArray.get(g.verticalPlacedTextSymbolIndex).hidden = T || M ? 1 : 0);
        let N = this.variableOffsets[g.crossTileID];
        N && this.markUsedJustification(e, N.anchor, g, I);
        let X = this.placedOrientations[g.crossTileID];
        X && (this.markUsedJustification(e, "left", g, X), this.markUsedOrientation(e, X, g));
      }
      if (k) {
        let F = kg(S.icon), D = !(h && g.verticalPlacedIconSymbolIndex && C);
        if (g.placedIconSymbolIndex >= 0) {
          let E = D ? F : ia;
          d(e.icon, g.numIconVertices, E), e.icon.placedSymbolArray.get(g.placedIconSymbolIndex).hidden = S.icon.isHidden();
        }
        if (g.verticalPlacedIconSymbolIndex >= 0) {
          let E = D ? ia : F;
          d(e.icon, g.numVerticalIconVertices, E), e.icon.placedSymbolArray.get(g.verticalPlacedIconSymbolIndex).hidden = S.icon.isHidden();
        }
      }
      if (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) {
        let F = e.collisionArrays[y];
        if (F) {
          let D = new Gl.default(0, 0);
          if (F.textBox || F.verticalTextBox) {
            let T = true;
            if (u) {
              let N = this.variableOffsets[b];
              N ? (D = Eg(N.anchor, N.width, N.height, N.textOffset, N.textBoxScale), c3 && D._rotate(p ? this.transform.angle : -this.transform.angle)) : T = false;
            }
            F.textBox && Ol(e.textCollisionBox.collisionVertexArray, S.text.placed, !T || C, D.x, D.y), F.verticalTextBox && Ol(e.textCollisionBox.collisionVertexArray, S.text.placed, !T || M, D.x, D.y);
          }
          let E = !!(!M && F.verticalIconBox);
          F.iconBox && Ol(e.iconCollisionBox.collisionVertexArray, S.icon.placed, E, h ? D.x : 0, h ? D.y : 0), F.verticalIconBox && Ol(e.iconCollisionBox.collisionVertexArray, S.icon.placed, !E, h ? D.x : 0, h ? D.y : 0);
        }
      }
    }
    if (e.sortFeatures(this.transform.angle), this.retainedQueryData[e.bucketInstanceId] && (this.retainedQueryData[e.bucketInstanceId].featureSortOrder = e.featureSortOrder), e.hasTextData() && e.text.opacityVertexBuffer && e.text.opacityVertexBuffer.updateData(e.text.opacityVertexArray), e.hasIconData() && e.icon.opacityVertexBuffer && e.icon.opacityVertexBuffer.updateData(e.icon.opacityVertexArray), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexBuffer && e.iconCollisionBox.collisionVertexBuffer.updateData(e.iconCollisionBox.collisionVertexArray), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexBuffer && e.textCollisionBox.collisionVertexBuffer.updateData(e.textCollisionBox.collisionVertexArray), e.text.opacityVertexArray.length !== e.text.layoutVertexArray.length / 4) throw new Error("bucket.text.opacityVertexArray.length (= ".concat(e.text.opacityVertexArray.length, ") !== bucket.text.layoutVertexArray.length (= ").concat(e.text.layoutVertexArray.length, ") / 4"));
    if (e.icon.opacityVertexArray.length !== e.icon.layoutVertexArray.length / 4) throw new Error("bucket.icon.opacityVertexArray.length (= ".concat(e.icon.opacityVertexArray.length, ") !== bucket.icon.layoutVertexArray.length (= ").concat(e.icon.layoutVertexArray.length, ") / 4"));
    if (e.bucketInstanceId in this.collisionCircleArrays) {
      let y = this.collisionCircleArrays[e.bucketInstanceId];
      e.placementInvProjMatrix = y.invProjMatrix, e.placementViewportMatrix = y.viewportMatrix, e.collisionCircleArray = y.circles, delete this.collisionCircleArrays[e.bucketInstanceId];
    }
  }
  symbolFadeChange(e) {
    return this.fadeDuration === 0 ? 1 : (e - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
  }
  zoomAdjustment(e) {
    return Math.max(0, (this.transform.zoom - e) / 1.5);
  }
  hasTransitions(e) {
    return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration;
  }
  stillRecent(e, t) {
    let i = this.zoomAtLastRecencyCheck === t ? 1 - this.zoomAdjustment(t) : 1;
    return this.zoomAtLastRecencyCheck = t, this.commitTime + this.fadeDuration * i > e;
  }
  setStale() {
    this.stale = true;
  }
};
function Ol(r50, e, t, i, n) {
  r50.emplaceBack(e ? 1 : 0, t ? 1 : 0, i || 0, n || 0), r50.emplaceBack(e ? 1 : 0, t ? 1 : 0, i || 0, n || 0), r50.emplaceBack(e ? 1 : 0, t ? 1 : 0, i || 0, n || 0), r50.emplaceBack(e ? 1 : 0, t ? 1 : 0, i || 0, n || 0);
}
var vA = Math.pow(2, 25);
var wA = Math.pow(2, 24);
var SA = Math.pow(2, 17);
var PA = Math.pow(2, 16);
var TA = Math.pow(2, 9);
var AA = Math.pow(2, 8);
var MA = Math.pow(2, 1);
function kg(r50) {
  if (r50.opacity === 0 && !r50.placed) return 0;
  if (r50.opacity === 1 && r50.placed) return 4294967295;
  let e = r50.placed ? 1 : 0, t = Math.floor(r50.opacity * 127);
  return t * vA + e * wA + t * SA + e * PA + t * TA + e * AA + t * MA + e;
}
var ia = 0;
var oh = class {
  constructor(e) {
    this._sortAcrossTiles = e.layout.get("symbol-z-order") !== "viewport-y" && !e.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
  }
  continuePlacement(e, t, i, n, o) {
    let a = this._bucketParts;
    for (; this._currentTileIndex < e.length; ) {
      let s3 = e[this._currentTileIndex];
      if (t.getBucketParts(a, n, s3, this._sortAcrossTiles), this._currentTileIndex++, o()) return true;
    }
    for (this._sortAcrossTiles && (this._sortAcrossTiles = false, a.sort((s3, l) => s3.sortKey - l.sortKey)); this._currentPartIndex < a.length; ) {
      let s3 = a[this._currentPartIndex];
      if (t.placeLayerBucketPart(s3, this._seenCrossTileIDs, i), this._currentPartIndex++, o()) return true;
    }
    return false;
  }
};
var ql = class {
  constructor(e, t, i, n, o, a, s3, l) {
    this.placement = new Nl(e, t, a, s3, l), this._currentPlacementIndex = i.length - 1, this._forceFullPlacement = n, this._showCollisionBoxes = o, this._done = false;
  }
  isDone() {
    return this._done;
  }
  continuePlacement(e, t, i) {
    let n = J.now(), o = () => this._forceFullPlacement ? false : J.now() - n > 2;
    for (; this._currentPlacementIndex >= 0; ) {
      let a = e[this._currentPlacementIndex], s3 = t[a], l = this.placement.collisionIndex.transform.zoom;
      if (s3.type === "symbol" && (!s3.minzoom || s3.minzoom <= l) && (!s3.maxzoom || s3.maxzoom > l)) {
        if (this._inProgressLayer || (this._inProgressLayer = new oh(s3)), this._inProgressLayer.continuePlacement(i[s3.source], this.placement, this._showCollisionBoxes, s3, o)) return;
        delete this._inProgressLayer;
      }
      this._currentPlacementIndex--;
    }
    this._done = true;
  }
  commit(e) {
    return this.placement.commit(e), this.placement;
  }
};
c();
c();
var Lg = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
var ah = 1;
var na = 8;
var aa = class r45 {
  static from(e) {
    if (!(e instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
    let [t, i] = new Uint8Array(e, 0, 2);
    if (t !== 219) throw new Error("Data does not appear to be in a KDBush format.");
    let n = i >> 4;
    if (n !== ah) throw new Error("Got v".concat(n, " data when expected v").concat(ah, "."));
    let o = Lg[i & 15];
    if (!o) throw new Error("Unrecognized array type.");
    let [a] = new Uint16Array(e, 2, 1), [s3] = new Uint32Array(e, 4, 1);
    return new r45(s3, a, o, e);
  }
  constructor(e, t = 64, i = Float64Array, n) {
    if (isNaN(e) || e < 0) throw new Error("Unpexpected numItems value: ".concat(e, "."));
    this.numItems = +e, this.nodeSize = Math.min(Math.max(+t, 2), 65535), this.ArrayType = i, this.IndexArrayType = e < 65536 ? Uint16Array : Uint32Array;
    let o = Lg.indexOf(this.ArrayType), a = e * 2 * this.ArrayType.BYTES_PER_ELEMENT, s3 = e * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s3 % 8) % 8;
    if (o < 0) throw new Error("Unexpected typed array class: ".concat(i, "."));
    n && n instanceof ArrayBuffer ? (this.data = n, this.ids = new this.IndexArrayType(this.data, na, e), this.coords = new this.ArrayType(this.data, na + s3 + l, e * 2), this._pos = e * 2, this._finished = true) : (this.data = new ArrayBuffer(na + a + s3 + l), this.ids = new this.IndexArrayType(this.data, na, e), this.coords = new this.ArrayType(this.data, na + s3 + l, e * 2), this._pos = 0, this._finished = false, new Uint8Array(this.data, 0, 2).set([219, (ah << 4) + o]), new Uint16Array(this.data, 2, 1)[0] = t, new Uint32Array(this.data, 4, 1)[0] = e);
  }
  add(e, t) {
    let i = this._pos >> 1;
    return this.ids[i] = i, this.coords[this._pos++] = e, this.coords[this._pos++] = t, i;
  }
  finish() {
    let e = this._pos >> 1;
    if (e !== this.numItems) throw new Error("Added ".concat(e, " items when expected ").concat(this.numItems, "."));
    return lh(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = true, this;
  }
  range(e, t, i, n) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    let { ids: o, coords: a, nodeSize: s3 } = this, l = [0, o.length - 1, 0], u = [];
    for (; l.length; ) {
      let c3 = l.pop() || 0, p = l.pop() || 0, h = l.pop() || 0;
      if (p - h <= s3) {
        for (let g = h; g <= p; g++) {
          let x = a[2 * g], v = a[2 * g + 1];
          x >= e && x <= i && v >= t && v <= n && u.push(o[g]);
        }
        continue;
      }
      let f = h + p >> 1, d = a[2 * f], y = a[2 * f + 1];
      d >= e && d <= i && y >= t && y <= n && u.push(o[f]), (c3 === 0 ? e <= d : t <= y) && (l.push(h), l.push(f - 1), l.push(1 - c3)), (c3 === 0 ? i >= d : n >= y) && (l.push(f + 1), l.push(p), l.push(1 - c3));
    }
    return u;
  }
  within(e, t, i) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    let { ids: n, coords: o, nodeSize: a } = this, s3 = [0, n.length - 1, 0], l = [], u = i * i;
    for (; s3.length; ) {
      let c3 = s3.pop() || 0, p = s3.pop() || 0, h = s3.pop() || 0;
      if (p - h <= a) {
        for (let g = h; g <= p; g++) Dg(o[2 * g], o[2 * g + 1], e, t) <= u && l.push(n[g]);
        continue;
      }
      let f = h + p >> 1, d = o[2 * f], y = o[2 * f + 1];
      Dg(d, y, e, t) <= u && l.push(n[f]), (c3 === 0 ? e - i <= d : t - i <= y) && (s3.push(h), s3.push(f - 1), s3.push(1 - c3)), (c3 === 0 ? e + i >= d : t + i >= y) && (s3.push(f + 1), s3.push(p), s3.push(1 - c3));
    }
    return l;
  }
};
function lh(r50, e, t, i, n, o) {
  if (n - i <= t) return;
  let a = i + n >> 1;
  zg(r50, e, a, i, n, o), lh(r50, e, t, i, a - 1, 1 - o), lh(r50, e, t, a + 1, n, 1 - o);
}
function zg(r50, e, t, i, n, o) {
  for (; n > i; ) {
    if (n - i > 600) {
      let u = n - i + 1, c3 = t - i + 1, p = Math.log(u), h = 0.5 * Math.exp(2 * p / 3), f = 0.5 * Math.sqrt(p * h * (u - h) / u) * (c3 - u / 2 < 0 ? -1 : 1), d = Math.max(i, Math.floor(t - c3 * h / u + f)), y = Math.min(n, Math.floor(t + (u - c3) * h / u + f));
      zg(r50, e, t, d, y, o);
    }
    let a = e[2 * t + o], s3 = i, l = n;
    for (oa(r50, e, i, t), e[2 * n + o] > a && oa(r50, e, i, n); s3 < l; ) {
      for (oa(r50, e, s3, l), s3++, l--; e[2 * s3 + o] < a; ) s3++;
      for (; e[2 * l + o] > a; ) l--;
    }
    e[2 * i + o] === a ? oa(r50, e, i, l) : (l++, oa(r50, e, l, n)), l <= t && (i = l + 1), t <= l && (n = l - 1);
  }
}
function oa(r50, e, t, i) {
  sh(r50, t, i), sh(e, 2 * t, 2 * i), sh(e, 2 * t + 1, 2 * i + 1);
}
function sh(r50, e, t) {
  let i = r50[e];
  r50[e] = r50[t], r50[t] = i;
}
function Dg(r50, e, t, i) {
  let n = r50 - t, o = e - i;
  return n * n + o * o;
}
var sa = 512 / 8192 / 2;
var IA = 128;
var uh = class {
  constructor(e, t, i) {
    this.tileID = e;
    this.bucketInstanceId = i;
    this._symbolsByKey = {};
    let n = /* @__PURE__ */ new Map();
    for (let o = 0; o < t.length; o++) {
      let a = t.get(o), s3 = a.key, l = n.get(s3);
      l ? l.push(a) : n.set(s3, [a]);
    }
    for (let [o, a] of n) {
      let s3 = a.map((c3) => ({ x: Math.floor(c3.anchorX * sa), y: Math.floor(c3.anchorY * sa) })), l = a.map((c3) => c3.crossTileID), u = { positions: s3, crossTileIDs: l };
      if (u.positions.length > IA) {
        let c3 = new aa(u.positions.length, 16, Uint16Array);
        for (let { x: p, y: h } of u.positions) c3.add(p, h);
        c3.finish(), delete u.positions, u.index = c3;
      }
      this._symbolsByKey[o] = u;
    }
  }
  getScaledCoordinates(e, t) {
    let { x: i, y: n, z: o } = this.tileID.canonical, { x: a, y: s3, z: l } = t.canonical, u = l - o, c3 = sa / Math.pow(2, u), p = (a * 8192 + e.anchorX) * c3, h = (s3 * 8192 + e.anchorY) * c3, f = i * 8192 * sa, d = n * 8192 * sa;
    return { x: Math.floor(p - f), y: Math.floor(h - d) };
  }
  findMatches(e, t, i) {
    let n = this.tileID.canonical.z < t.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - t.canonical.z);
    for (let o = 0; o < e.length; o++) {
      let a = e.get(o);
      if (a.crossTileID) continue;
      let s3 = this._symbolsByKey[a.key];
      if (!s3) continue;
      let l = this.getScaledCoordinates(a, t);
      if (s3.index) {
        let u = s3.index.range(l.x - n, l.y - n, l.x + n, l.y + n).sort();
        for (let c3 of u) {
          let p = s3.crossTileIDs[c3];
          if (!i[p]) {
            i[p] = true, a.crossTileID = p;
            break;
          }
        }
      } else if (s3.positions) for (let u = 0; u < s3.positions.length; u++) {
        let c3 = s3.positions[u], p = s3.crossTileIDs[u];
        if (Math.abs(c3.x - l.x) <= n && Math.abs(c3.y - l.y) <= n && !i[p]) {
          i[p] = true, a.crossTileID = p;
          break;
        }
      }
    }
  }
  getCrossTileIDsLists() {
    return Object.values(this._symbolsByKey).map(({ crossTileIDs: e }) => e);
  }
};
var ch = class {
  constructor() {
    this.maxCrossTileID = 0;
  }
  generate() {
    return ++this.maxCrossTileID;
  }
};
var ph = class {
  constructor() {
    this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
  }
  handleWrapJump(e) {
    let t = Math.round((e - this.lng) / 360);
    if (t !== 0) for (let i in this.indexes) {
      let n = this.indexes[i], o = {};
      for (let a in n) {
        let s3 = n[a];
        s3.tileID = s3.tileID.unwrapTo(s3.tileID.wrap + t), o[s3.tileID.key] = s3;
      }
      this.indexes[i] = o;
    }
    this.lng = e;
  }
  addBucket(e, t, i) {
    if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) {
      if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === t.bucketInstanceId) return false;
      this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key]);
    }
    for (let o = 0; o < t.symbolInstances.length; o++) {
      let a = t.symbolInstances.get(o);
      a.crossTileID = 0;
    }
    this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = {});
    let n = this.usedCrossTileIDs[e.overscaledZ];
    for (let o in this.indexes) {
      let a = this.indexes[o];
      if (Number(o) > e.overscaledZ) for (let s3 in a) {
        let l = a[s3];
        l.tileID.isChildOf(e) && l.findMatches(t.symbolInstances, e, n);
      }
      else {
        let s3 = e.scaledTo(Number(o)), l = a[s3.key];
        l && l.findMatches(t.symbolInstances, e, n);
      }
    }
    for (let o = 0; o < t.symbolInstances.length; o++) {
      let a = t.symbolInstances.get(o);
      a.crossTileID || (a.crossTileID = i.generate(), n[a.crossTileID] = true);
    }
    return this.indexes[e.overscaledZ] === void 0 && (this.indexes[e.overscaledZ] = {}), this.indexes[e.overscaledZ][e.key] = new uh(e, t.symbolInstances, t.bucketInstanceId), true;
  }
  removeBucketCrossTileIDs(e, t) {
    for (let i of t.getCrossTileIDsLists()) for (let n of i) delete this.usedCrossTileIDs[e][n];
  }
  removeStaleBuckets(e) {
    let t = false;
    for (let i in this.indexes) {
      let n = this.indexes[i];
      for (let o in n) e[n[o].bucketInstanceId] || (this.removeBucketCrossTileIDs(i, n[o]), delete n[o], t = true);
    }
    return t;
  }
};
var cn = class {
  constructor() {
    this.layerIndexes = {}, this.crossTileIDs = new ch(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
  }
  addLayer(e, t, i) {
    let n = this.layerIndexes[e.id];
    n === void 0 && (n = this.layerIndexes[e.id] = new ph());
    let o = false, a = {};
    n.handleWrapJump(i);
    for (let s3 of t) {
      let l = s3.getBucket(e);
      !l || e.id !== l.layerIds[0] || (l.bucketInstanceId || (l.bucketInstanceId = ++this.maxBucketInstanceId), n.addBucket(s3.tileID, l, this.crossTileIDs) && (o = true), a[l.bucketInstanceId] = true);
    }
    return n.removeStaleBuckets(a) && (o = true), o;
  }
  pruneUnusedLayers(e) {
    let t = {};
    e.forEach((i) => {
      t[i] = true;
    });
    for (let i in this.layerIndexes) t[i] || delete this.layerIndexes[i];
  }
};
var jl = (r50, e) => Di(r50, e && e.filter((t) => t.identifier !== "source.canvas"));
var CA = ym();
var pn = class extends me {
  constructor(t, i = {}) {
    super();
    this._rtlPluginLoaded = () => {
      for (let t3 in this.sourceCaches) {
        let i3 = this.sourceCaches[t3].getSource().type;
        (i3 === "vector" || i3 === "geojson") && this.sourceCaches[t3].reload();
      }
    };
    this.map = t, this.dispatcher = new qo(Go(), t._getMapId()), this.dispatcher.registerMessageHandler("GG", (n, o) => this.getGlyphs(n, o)), this.dispatcher.registerMessageHandler("GI", (n, o) => this.getImages(n, o)), this.imageManager = new xl(), this.imageManager.setEventedParent(this), this.glyphManager = new bl(t._requestManager, i.localIdeographFontFamily), this.lineAtlas = new vl(256, 512), this.crossTileSymbolIndex = new cn(), this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new Ri(), this._loaded = false, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("SR", qa()), Fr().on(Jo, this._rtlPluginLoaded), this.on("data", (n) => {
      if (n.dataType !== "source" || n.sourceDataType !== "metadata") return;
      let o = this.sourceCaches[n.sourceId];
      if (!o) return;
      let a = o.getSource();
      if (!(!a || !a.vectorLayerIds)) for (let s3 in this._layers) {
        let l = this._layers[s3];
        l.source === a.id && this._validateLayer(l);
      }
    });
  }
  loadURL(t, i = {}, n) {
    this.fire(new z("dataloading", { dataType: "style" })), i.validate = typeof i.validate == "boolean" ? i.validate : true;
    let o = this.map._requestManager.transformRequest(t, "Style");
    this._loadStyleRequest = new AbortController(), mr(o, this._loadStyleRequest).then((a) => {
      this._loadStyleRequest = null, this._load(a.data, i, n);
    }).catch((a) => {
      this._loadStyleRequest = null, a && this.fire(new Z(a));
    });
  }
  loadJSON(t, i = {}, n) {
    this.fire(new z("dataloading", { dataType: "style" })), this._frameRequest = new AbortController(), J.frameAsync(this._frameRequest).then(() => {
      this._frameRequest = null, i.validate = i.validate !== false, this._load(t, i, n);
    }).catch(() => {
    });
  }
  loadEmpty() {
    this.fire(new z("dataloading", { dataType: "style" })), this._load(CA, { validate: false });
  }
  _load(t, i, n) {
    var a;
    let o = i.transformStyle ? i.transformStyle(n, t) : t;
    if (!(i.validate && jl(this, Ue(o)))) {
      this._loaded = true, this.stylesheet = o;
      for (let s3 in o.sources) this.addSource(s3, o.sources[s3], { validate: false });
      o.sprite ? this._loadSprite(o.sprite) : this.imageManager.setLoaded(true), this.glyphManager.setURL(o.glyphs), this._createLayers(), this.light = new _l(this.stylesheet.light), this.map.setTerrain((a = this.stylesheet.terrain) != null ? a : null), this.fire(new z("data", { dataType: "style" })), this.fire(new z("style.load"));
    }
  }
  _createLayers() {
    let t = ep(this.stylesheet.layers);
    this.dispatcher.broadcast("SL", t), this._order = t.map((i) => i.id), this._layers = {}, this._serializedLayers = null;
    for (let i of t) {
      let n = yl(i);
      n.setEventedParent(this, { layer: { id: i.id } }), this._layers[i.id] = n;
    }
  }
  _loadSprite(t, i = false, n = void 0) {
    this.imageManager.setLoaded(false), this._spriteRequest = new AbortController();
    let o;
    Jy(t, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then((a) => {
      if (this._spriteRequest = null, a) for (let s3 in a) {
        this._spritesImagesIds[s3] = [];
        let l = this._spritesImagesIds[s3] ? this._spritesImagesIds[s3].filter((u) => !(u in a)) : [];
        for (let u of l) this.imageManager.removeImage(u), this._changedImages[u] = true;
        for (let u in a[s3]) {
          let c3 = s3 === "default" ? u : "".concat(s3, ":").concat(u);
          this._spritesImagesIds[s3].push(c3), c3 in this.imageManager.images ? this.imageManager.updateImage(c3, a[s3][u], false) : this.imageManager.addImage(c3, a[s3][u]), i && (this._changedImages[c3] = true);
        }
      }
    }).catch((a) => {
      this._spriteRequest = null, o = a, this.fire(new Z(o));
    }).finally(() => {
      this.imageManager.setLoaded(true), this._availableImages = this.imageManager.listImages(), i && (this._changed = true), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new z("data", { dataType: "style" })), n && n(o);
    });
  }
  _unloadSprite() {
    for (let t of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(t), this._changedImages[t] = true;
    this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new z("data", { dataType: "style" }));
  }
  _validateLayer(t) {
    let i = this.sourceCaches[t.source];
    if (!i) return;
    let n = t.sourceLayer;
    if (!n) return;
    let o = i.getSource();
    (o.type === "geojson" || o.vectorLayerIds && o.vectorLayerIds.indexOf(n) === -1) && this.fire(new Z(new Error('Source layer "'.concat(n, '" ') + 'does not exist on source "'.concat(o.id, '" ') + 'as specified by style layer "'.concat(t.id, '".'))));
  }
  loaded() {
    if (!this._loaded || Object.keys(this._updatedSources).length) return false;
    for (let t in this.sourceCaches) if (!this.sourceCaches[t].loaded()) return false;
    return !!this.imageManager.isLoaded();
  }
  _serializeByIds(t) {
    let i = this._serializedAllLayers();
    if (!t || t.length === 0) return Object.values(i);
    let n = [];
    for (let o of t) i[o] && n.push(i[o]);
    return n;
  }
  _serializedAllLayers() {
    let t = this._serializedLayers;
    if (t) return t;
    t = this._serializedLayers = {};
    let i = Object.keys(this._layers);
    for (let n of i) {
      let o = this._layers[n];
      o.type !== "custom" && (t[n] = o.serialize());
    }
    return t;
  }
  hasTransitions() {
    if (this.light && this.light.hasTransition()) return true;
    for (let t in this.sourceCaches) if (this.sourceCaches[t].hasTransition()) return true;
    for (let t in this._layers) if (this._layers[t].hasTransition()) return true;
    return false;
  }
  _checkLoaded() {
    if (!this._loaded) throw new Error("Style is not done loading.");
  }
  update(t) {
    if (!this._loaded) return;
    let i = this._changed;
    if (i) {
      let o = Object.keys(this._updatedLayers), a = Object.keys(this._removedLayers);
      (o.length || a.length) && this._updateWorkerLayers(o, a);
      for (let s3 in this._updatedSources) {
        let l = this._updatedSources[s3];
        if (l === "reload") this._reloadSource(s3);
        else if (l === "clear") this._clearSource(s3);
        else throw new Error("Invalid action ".concat(l));
      }
      this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
      for (let s3 in this._updatedPaintProps) this._layers[s3].updateTransitions(t);
      this.light.updateTransitions(t), this._resetUpdates();
    }
    let n = {};
    for (let o in this.sourceCaches) {
      let a = this.sourceCaches[o];
      n[o] = a.used, a.used = false;
    }
    for (let o of this._order) {
      let a = this._layers[o];
      a.recalculate(t, this._availableImages), !a.isHidden(t.zoom) && a.source && (this.sourceCaches[a.source].used = true);
    }
    for (let o in n) {
      let a = this.sourceCaches[o];
      !!n[o] != !!a.used && a.fire(new z("data", { sourceDataType: "visibility", dataType: "source", sourceId: o }));
    }
    this.light.recalculate(t), this.z = t.zoom, i && this.fire(new z("data", { dataType: "style" }));
  }
  _updateTilesForChangedImages() {
    let t = Object.keys(this._changedImages);
    if (t.length) {
      for (let i in this.sourceCaches) this.sourceCaches[i].reloadTilesForDependencies(["icons", "patterns"], t);
      this._changedImages = {};
    }
  }
  _updateTilesForChangedGlyphs() {
    if (this._glyphsDidChange) {
      for (let t in this.sourceCaches) this.sourceCaches[t].reloadTilesForDependencies(["glyphs"], [""]);
      this._glyphsDidChange = false;
    }
  }
  _updateWorkerLayers(t, i) {
    this.dispatcher.broadcast("UL", { layers: this._serializeByIds(t), removedIds: i });
  }
  _resetUpdates() {
    this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = false;
  }
  setState(t, i = {}) {
    var l;
    this._checkLoaded();
    let n = this.serialize();
    if (t = i.transformStyle ? i.transformStyle(n, t) : t, ((l = i.validate) != null ? l : true) && jl(this, Ue(t))) return false;
    t = ct(t), t.layers = ep(t.layers);
    let a = $f(n, t), s3 = this._getOperationsToPerform(a);
    if (s3.unimplemented.length > 0) throw new Error("Unimplemented: ".concat(s3.unimplemented.join(", "), "."));
    if (s3.operations.length === 0) return false;
    for (let u of s3.operations) u();
    return this.stylesheet = t, this._serializedLayers = null, true;
  }
  _getOperationsToPerform(t) {
    let i = [], n = [];
    for (let o of t) switch (o.command) {
      case "setCenter":
      case "setZoom":
      case "setBearing":
      case "setPitch":
        continue;
      case "addLayer":
        i.push(() => this.addLayer.apply(this, o.args));
        break;
      case "removeLayer":
        i.push(() => this.removeLayer.apply(this, o.args));
        break;
      case "setPaintProperty":
        i.push(() => this.setPaintProperty.apply(this, o.args));
        break;
      case "setLayoutProperty":
        i.push(() => this.setLayoutProperty.apply(this, o.args));
        break;
      case "setFilter":
        i.push(() => this.setFilter.apply(this, o.args));
        break;
      case "addSource":
        i.push(() => this.addSource.apply(this, o.args));
        break;
      case "removeSource":
        i.push(() => this.removeSource.apply(this, o.args));
        break;
      case "setLayerZoomRange":
        i.push(() => this.setLayerZoomRange.apply(this, o.args));
        break;
      case "setLight":
        i.push(() => this.setLight.apply(this, o.args));
        break;
      case "setGeoJSONSourceData":
        i.push(() => this.setGeoJSONSourceData.apply(this, o.args));
        break;
      case "setGlyphs":
        i.push(() => this.setGlyphs.apply(this, o.args));
        break;
      case "setSprite":
        i.push(() => this.setSprite.apply(this, o.args));
        break;
      case "setTerrain":
        i.push(() => this.map.setTerrain.apply(this, o.args));
        break;
      case "setTransition":
        i.push(() => {
        });
        break;
      default:
        n.push(o.command);
        break;
    }
    return { operations: i, unimplemented: n };
  }
  addImage(t, i) {
    if (this.getImage(t)) return this.fire(new Z(new Error('An image named "'.concat(t, '" already exists.'))));
    this.imageManager.addImage(t, i), this._afterImageUpdated(t);
  }
  updateImage(t, i) {
    this.imageManager.updateImage(t, i);
  }
  getImage(t) {
    return this.imageManager.getImage(t);
  }
  removeImage(t) {
    if (!this.getImage(t)) return this.fire(new Z(new Error('An image named "'.concat(t, '" does not exist.'))));
    this.imageManager.removeImage(t), this._afterImageUpdated(t);
  }
  _afterImageUpdated(t) {
    this._availableImages = this.imageManager.listImages(), this._changedImages[t] = true, this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new z("data", { dataType: "style" }));
  }
  listImages() {
    return this._checkLoaded(), this.imageManager.listImages();
  }
  addSource(t, i, n = {}) {
    if (this._checkLoaded(), this.sourceCaches[t] !== void 0) throw new Error('Source "'.concat(t, '" already exists.'));
    if (!i.type) throw new Error("The type property must be defined, but only the following properties were given: ".concat(Object.keys(i).join(", "), "."));
    if (["vector", "raster", "geojson", "video", "image"].indexOf(i.type) >= 0 && this._validate(Ue.source, "sources.".concat(t), i, null, n)) return;
    this.map && this.map._collectResourceTiming && (i.collectResourceTiming = true);
    let s3 = this.sourceCaches[t] = new sr(t, i, this.dispatcher);
    s3.style = this, s3.setEventedParent(this, () => ({ isSourceLoaded: s3.loaded(), source: s3.serialize(), sourceId: t })), s3.onAdd(this.map), this._changed = true;
  }
  removeSource(t) {
    if (this._checkLoaded(), this.sourceCaches[t] === void 0) throw new Error("There is no source with this ID");
    for (let n in this._layers) if (this._layers[n].source === t) return this.fire(new Z(new Error('Source "'.concat(t, '" cannot be removed while layer "').concat(n, '" is using it.'))));
    let i = this.sourceCaches[t];
    delete this.sourceCaches[t], delete this._updatedSources[t], i.fire(new z("data", { sourceDataType: "metadata", dataType: "source", sourceId: t })), i.setEventedParent(null), i.onRemove(this.map), this._changed = true;
  }
  setGeoJSONSourceData(t, i) {
    if (this._checkLoaded(), this.sourceCaches[t] === void 0) throw new Error("There is no source with this ID=".concat(t));
    let n = this.sourceCaches[t].getSource();
    if (n.type !== "geojson") throw new Error("geojsonSource.type is ".concat(n.type, ", which is !== 'geojson"));
    n.setData(i), this._changed = true;
  }
  getSource(t) {
    return this.sourceCaches[t] && this.sourceCaches[t].getSource();
  }
  addLayer(t, i, n = {}) {
    this._checkLoaded();
    let o = t.id;
    if (this.getLayer(o)) {
      this.fire(new Z(new Error('Layer "'.concat(o, '" already exists on this map.'))));
      return;
    }
    let a;
    if (t.type === "custom") {
      if (jl(this, Ky(t))) return;
      a = yl(t);
    } else {
      if ("source" in t && typeof t.source == "object" && (this.addSource(o, t.source), t = ct(t), t = O(t, { source: o })), this._validate(Ue.layer, "layers.".concat(o), t, { arrayIndex: -1 }, n)) return;
      a = yl(t), this._validateLayer(a), a.setEventedParent(this, { layer: { id: o } });
    }
    let s3 = i ? this._order.indexOf(i) : this._order.length;
    if (i && s3 === -1) {
      this.fire(new Z(new Error('Cannot add layer "'.concat(o, '" before non-existing layer "').concat(i, '".'))));
      return;
    }
    if (this._order.splice(s3, 0, o), this._layerOrderChanged = true, this._layers[o] = a, this._removedLayers[o] && a.source && a.type !== "custom") {
      let l = this._removedLayers[o];
      delete this._removedLayers[o], l.type !== a.type ? this._updatedSources[a.source] = "clear" : (this._updatedSources[a.source] = "reload", this.sourceCaches[a.source].pause());
    }
    this._updateLayer(a), a.onAdd && a.onAdd(this.map);
  }
  moveLayer(t, i) {
    if (this._checkLoaded(), this._changed = true, !this._layers[t]) {
      this.fire(new Z(new Error("The layer '".concat(t, "' does not exist in the map's style and cannot be moved."))));
      return;
    }
    if (t === i) return;
    let o = this._order.indexOf(t);
    this._order.splice(o, 1);
    let a = i ? this._order.indexOf(i) : this._order.length;
    if (i && a === -1) {
      this.fire(new Z(new Error('Cannot move layer "'.concat(t, '" before non-existing layer "').concat(i, '".'))));
      return;
    }
    this._order.splice(a, 0, t), this._layerOrderChanged = true;
  }
  removeLayer(t) {
    this._checkLoaded();
    let i = this._layers[t];
    if (!i) {
      this.fire(new Z(new Error('Cannot remove non-existing layer "'.concat(t, '".'))));
      return;
    }
    i.setEventedParent(null);
    let n = this._order.indexOf(t);
    this._order.splice(n, 1), this._layerOrderChanged = true, this._changed = true, this._removedLayers[t] = i, delete this._layers[t], this._serializedLayers && delete this._serializedLayers[t], delete this._updatedLayers[t], delete this._updatedPaintProps[t], i.onRemove && i.onRemove(this.map);
  }
  getLayer(t) {
    return this._layers[t];
  }
  getLayersOrder() {
    return [...this._order];
  }
  hasLayer(t) {
    return t in this._layers;
  }
  setLayerZoomRange(t, i, n) {
    this._checkLoaded();
    let o = this.getLayer(t);
    if (!o) {
      this.fire(new Z(new Error('Cannot set the zoom range of non-existing layer "'.concat(t, '".'))));
      return;
    }
    o.minzoom === i && o.maxzoom === n || (i != null && (o.minzoom = i), n != null && (o.maxzoom = n), this._updateLayer(o));
  }
  setFilter(t, i, n = {}) {
    this._checkLoaded();
    let o = this.getLayer(t);
    if (!o) {
      this.fire(new Z(new Error('Cannot filter non-existing layer "'.concat(t, '".'))));
      return;
    }
    if (!Kt(o.filter, i)) {
      if (i == null) {
        o.filter = void 0, this._updateLayer(o);
        return;
      }
      this._validate(Ue.filter, "layers.".concat(o.id, ".filter"), i, null, n) || (o.filter = ct(i), this._updateLayer(o));
    }
  }
  getFilter(t) {
    return ct(this.getLayer(t).filter);
  }
  setLayoutProperty(t, i, n, o = {}) {
    this._checkLoaded();
    let a = this.getLayer(t);
    if (!a) {
      this.fire(new Z(new Error('Cannot style non-existing layer "'.concat(t, '".'))));
      return;
    }
    Kt(a.getLayoutProperty(i), n) || (a.setLayoutProperty(i, n, o), this._updateLayer(a));
  }
  getLayoutProperty(t, i) {
    let n = this.getLayer(t);
    if (!n) {
      this.fire(new Z(new Error('Cannot get style of non-existing layer "'.concat(t, '".'))));
      return;
    }
    return n.getLayoutProperty(i);
  }
  setPaintProperty(t, i, n, o = {}) {
    this._checkLoaded();
    let a = this.getLayer(t);
    if (!a) {
      this.fire(new Z(new Error('Cannot style non-existing layer "'.concat(t, '".'))));
      return;
    }
    if (Kt(a.getPaintProperty(i), n)) return;
    a.setPaintProperty(i, n, o) && this._updateLayer(a), this._changed = true, this._updatedPaintProps[t] = true, this._serializedLayers = null;
  }
  getPaintProperty(t, i) {
    return this.getLayer(t).getPaintProperty(i);
  }
  setFeatureState(t, i) {
    this._checkLoaded();
    let n = t.source, o = t.sourceLayer, a = this.sourceCaches[n];
    if (a === void 0) {
      this.fire(new Z(new Error("The source '".concat(n, "' does not exist in the map's style."))));
      return;
    }
    let s3 = a.getSource().type;
    if (s3 === "geojson" && o) {
      this.fire(new Z(new Error("GeoJSON sources cannot have a sourceLayer parameter.")));
      return;
    }
    if (s3 === "vector" && !o) {
      this.fire(new Z(new Error("The sourceLayer parameter must be provided for vector source types.")));
      return;
    }
    t.id === void 0 && this.fire(new Z(new Error("The feature id parameter must be provided."))), a.setFeatureState(o, t.id, i);
  }
  removeFeatureState(t, i) {
    this._checkLoaded();
    let n = t.source, o = this.sourceCaches[n];
    if (o === void 0) {
      this.fire(new Z(new Error("The source '".concat(n, "' does not exist in the map's style."))));
      return;
    }
    let a = o.getSource().type, s3 = a === "vector" ? t.sourceLayer : void 0;
    if (a === "vector" && !s3) {
      this.fire(new Z(new Error("The sourceLayer parameter must be provided for vector source types.")));
      return;
    }
    if (i && typeof t.id != "string" && typeof t.id != "number") {
      this.fire(new Z(new Error("A feature id is required to remove its specific state property.")));
      return;
    }
    o.removeFeatureState(s3, t.id, i);
  }
  getFeatureState(t) {
    this._checkLoaded();
    let i = t.source, n = t.sourceLayer, o = this.sourceCaches[i];
    if (o === void 0) {
      this.fire(new Z(new Error("The source '".concat(i, "' does not exist in the map's style."))));
      return;
    }
    if (o.getSource().type === "vector" && !n) {
      this.fire(new Z(new Error("The sourceLayer parameter must be provided for vector source types.")));
      return;
    }
    return t.id === void 0 && this.fire(new Z(new Error("The feature id parameter must be provided."))), o.getFeatureState(n, t.id);
  }
  getTransition() {
    return O({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
  }
  serialize() {
    if (!this._loaded) return;
    let t = bn(this.sourceCaches, (a) => a.serialize()), i = this._serializeByIds(this._order), n = this.map.getTerrain() || void 0, o = this.stylesheet;
    return Va({ version: o.version, name: o.name, metadata: o.metadata, light: o.light, center: o.center, zoom: o.zoom, bearing: o.bearing, pitch: o.pitch, sprite: o.sprite, glyphs: o.glyphs, transition: o.transition, sources: t, layers: i, terrain: n }, (a) => a !== void 0);
  }
  _updateLayer(t) {
    this._updatedLayers[t.id] = true, t.source && !this._updatedSources[t.source] && this.sourceCaches[t.source].getSource().type !== "raster" && (this._updatedSources[t.source] = "reload", this.sourceCaches[t.source].pause()), this._serializedLayers = null, this._changed = true;
  }
  _flattenAndSortRenderedFeatures(t) {
    let i = (s3) => this._layers[s3].type === "fill-extrusion", n = {}, o = [];
    for (let s3 = this._order.length - 1; s3 >= 0; s3--) {
      let l = this._order[s3];
      if (i(l)) {
        n[l] = s3;
        for (let u of t) {
          let c3 = u[l];
          if (c3) for (let p of c3) o.push(p);
        }
      }
    }
    o.sort((s3, l) => l.intersectionZ - s3.intersectionZ);
    let a = [];
    for (let s3 = this._order.length - 1; s3 >= 0; s3--) {
      let l = this._order[s3];
      if (i(l)) for (let u = o.length - 1; u >= 0; u--) {
        let c3 = o[u].feature;
        if (n[c3.layer.id] < s3) break;
        a.push(c3), o.pop();
      }
      else for (let u of t) {
        let c3 = u[l];
        if (c3) for (let p of c3) a.push(p.feature);
      }
    }
    return a;
  }
  queryRenderedFeatures(t, i, n) {
    i && i.filter && this._validate(Ue.filter, "queryRenderedFeatures.filter", i.filter, null, i);
    let o = {};
    if (i && i.layers) {
      if (!Array.isArray(i.layers)) return this.fire(new Z(new Error("parameters.layers must be an Array."))), [];
      for (let l of i.layers) {
        let u = this._layers[l];
        if (!u) return this.fire(new Z(new Error("The layer '".concat(l, "' does not exist in the map's style and cannot be queried for features.")))), [];
        o[u.source] = true;
      }
    }
    let a = [];
    i.availableImages = this._availableImages;
    let s3 = this._serializedAllLayers();
    for (let l in this.sourceCaches) i.layers && !o[l] || a.push(og(this.sourceCaches[l], this._layers, s3, t, i, n));
    return this.placement && a.push(ag(this._layers, s3, this.sourceCaches, t, i, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(a);
  }
  querySourceFeatures(t, i) {
    i && i.filter && this._validate(Ue.filter, "querySourceFeatures.filter", i.filter, null, i);
    let n = this.sourceCaches[t];
    return n ? sg(n, i) : [];
  }
  getLight() {
    return this.light.getLight();
  }
  setLight(t, i = {}) {
    this._checkLoaded();
    let n = this.light.getLight(), o = false;
    for (let s3 in t) if (!Kt(t[s3], n[s3])) {
      o = true;
      break;
    }
    if (!o) return;
    let a = { now: J.now(), transition: O({ duration: 300, delay: 0 }, this.stylesheet.transition) };
    this.light.setLight(t, i), this.light.updateTransitions(a);
  }
  _validate(t, i, n, o, a = {}) {
    return a && a.validate === false ? false : jl(this, t.call(Ue, O({ key: i, style: this.serialize(), value: n, styleSpec: A }, o)));
  }
  _remove(t = true) {
    this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), Fr().off(Jo, this._rtlPluginLoaded);
    for (let i in this._layers) this._layers[i].setEventedParent(null);
    for (let i in this.sourceCaches) {
      let n = this.sourceCaches[i];
      n.setEventedParent(null), n.onRemove(this.map);
    }
    this.imageManager.setEventedParent(null), this.setEventedParent(null), t && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(t);
  }
  _clearSource(t) {
    this.sourceCaches[t].clearTiles();
  }
  _reloadSource(t) {
    this.sourceCaches[t].resume(), this.sourceCaches[t].reload();
  }
  _updateSources(t) {
    for (let i in this.sourceCaches) this.sourceCaches[i].update(t, this.map.terrain);
  }
  _generateCollisionBoxes() {
    for (let t in this.sourceCaches) this._reloadSource(t);
  }
  _updatePlacement(t, i, n, o, a = false) {
    let s3 = false, l = false, u = {};
    for (let p of this._order) {
      let h = this._layers[p];
      if (h.type !== "symbol") continue;
      if (!u[h.source]) {
        let d = this.sourceCaches[h.source];
        u[h.source] = d.getRenderableIds(true).map((y) => d.getTileByID(y)).sort((y, g) => g.tileID.overscaledZ - y.tileID.overscaledZ || (y.tileID.isLessThan(g.tileID) ? -1 : 1));
      }
      let f = this.crossTileSymbolIndex.addLayer(h, u[h.source], t.center.lng);
      s3 = s3 || f;
    }
    if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), a = a || this._layerOrderChanged || n === 0, (a || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(J.now(), t.zoom)) && (this.pauseablePlacement = new ql(t, this.map.terrain, this._order, a, i, n, o, this.placement), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, u), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(J.now()), l = true), s3 && this.pauseablePlacement.placement.setStale()), l || s3) for (let p of this._order) {
      let h = this._layers[p];
      h.type === "symbol" && this.placement.updateLayerOpacities(h, u[h.source]);
    }
    return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(J.now());
  }
  _releaseSymbolFadeTiles() {
    for (let t in this.sourceCaches) this.sourceCaches[t].releaseSymbolFadeTiles();
  }
  async getImages(t, i) {
    let n = await this.imageManager.getImages(i.icons);
    this._updateTilesForChangedImages();
    let o = this.sourceCaches[i.source];
    return o && o.setDependencies(i.tileID.key, i.type, i.icons), n;
  }
  async getGlyphs(t, i) {
    let n = await this.glyphManager.getGlyphs(i.stacks), o = this.sourceCaches[i.source];
    return o && o.setDependencies(i.tileID.key, i.type, [""]), n;
  }
  getGlyphsUrl() {
    return this.stylesheet.glyphs || null;
  }
  setGlyphs(t, i = {}) {
    this._checkLoaded(), !(t && this._validate(Ue.glyphs, "glyphs", t, null, i)) && (this._glyphsDidChange = true, this.stylesheet.glyphs = t, this.glyphManager.entries = {}, this.glyphManager.setURL(t));
  }
  addSprite(t, i, n = {}, o) {
    this._checkLoaded();
    let a = [{ id: t, url: i }], s3 = [...tn(this.stylesheet.sprite), ...a];
    this._validate(Ue.sprite, "sprite", s3, null, n) || (this.stylesheet.sprite = s3, this._loadSprite(a, true, o));
  }
  removeSprite(t) {
    this._checkLoaded();
    let i = tn(this.stylesheet.sprite);
    if (!i.find((n) => n.id === t)) {
      this.fire(new Z(new Error('Sprite "'.concat(t, `" doesn't exists on this map.`))));
      return;
    }
    if (this._spritesImagesIds[t]) for (let n of this._spritesImagesIds[t]) this.imageManager.removeImage(n), this._changedImages[n] = true;
    i.splice(i.findIndex((n) => n.id === t), 1), this.stylesheet.sprite = i.length > 0 ? i : void 0, delete this._spritesImagesIds[t], this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new z("data", { dataType: "style" }));
  }
  getSprite() {
    return tn(this.stylesheet.sprite);
  }
  setSprite(t, i = {}, n) {
    this._checkLoaded(), !(t && this._validate(Ue.sprite, "sprite", t, null, i)) && (this.stylesheet.sprite = t, t ? this._loadSprite(t, true, n) : (this._unloadSprite(), n && n(null)));
  }
};
c();
c();
var Zl = be([{ name: "a_pos", type: "Int16", components: 2 }]);
c();
c();
var Fg = "#ifdef GL_ES\nprecision mediump float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\n";
c();
var Rg = "#ifdef GL_ES\nprecision highp float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}\n#ifdef TERRAIN3D\nuniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;\n#endif\nconst highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {\n#ifdef TERRAIN3D\nhighp float d=unpack(texture2D(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));\n#else\nreturn 1.0;\n#endif\n}float calculate_visibility(vec4 pos) {\n#ifdef TERRAIN3D\nvec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;\n#else\nreturn 1.0;\n#endif\n}float ele(vec2 pos) {\n#ifdef TERRAIN3D\nvec4 rgb=(texture2D(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;\n#else\nreturn 0.0;\n#endif\n}float get_elevation(vec2 pos) {\n#ifdef TERRAIN3D\nvec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;\n#else\nreturn 0.0;\n#endif\n}";
c();
var Bg = "uniform vec4 u_color;uniform float u_opacity;void main() {gl_FragColor=u_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
c();
var Og = "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}";
c();
var Vg = "uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
c();
var Ug = "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}";
c();
var Ng = "varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));gl_FragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
c();
var Gg = "uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);float ele=get_elevation(circle_center);v_visibility=calculate_visibility(u_matrix*vec4(circle_center,ele,1.0));if (u_pitch_with_map) {vec2 corner_position=circle_center;if (u_scale_with_map) {corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;} else {vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,ele,1);} else {gl_Position=u_matrix*vec4(circle_center,ele,1);if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);}";
c();
var qg = "void main() {gl_FragColor=vec4(1.0);}";
c();
var jg = "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}";
c();
var Zg = "uniform highp float u_intensity;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
c();
var Hg = "uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,0,1);gl_Position=u_matrix*pos;}";
c();
var $g = "uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}";
c();
var Wg = "uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}";
c();
var Xg = "varying float v_placed;varying float v_notUsed;void main() {float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {gl_FragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {gl_FragColor*=.1;}}";
c();
var Kg = "attribute vec2 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_anchor_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);gl_Position=u_matrix*vec4(a_pos,get_elevation(a_pos),1.0);gl_Position.xy+=(a_extrude+a_shift)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}";
c();
var Jg = "varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}";
c();
var Yg = "attribute vec2 a_pos;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}";
c();
var Qg = "uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}";
c();
var ex = "attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,get_elevation(a_pos),1);}";
c();
var tx = "#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_FragColor=color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
c();
var rx = "attribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);}";
c();
var ix = "varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=outline_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
c();
var nx = "attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}";
c();
var ox = "uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
c();
var ax = "uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}";
c();
var sx = "#ifdef GL_ES\nprecision highp float;\n#endif\nuniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
c();
var lx = "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}";
c();
var ux = "varying vec4 v_color;void main() {gl_FragColor=v_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
c();
var cx = "uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;\n#ifdef TERRAIN3D\nattribute vec2 a_centroid;\n#endif\nvarying vec4 v_color;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec3 normal=a_normal_ed.xyz;\n#ifdef TERRAIN3D\nfloat height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);\n#else\nfloat height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;\n#endif\nbase=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);gl_Position=u_matrix*vec4(a_pos,t > 0.0 ? height : base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}";
c();
var px = "uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
c();
var hx = "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;\n#ifdef TERRAIN3D\nattribute vec2 a_centroid;\n#endif\nvarying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;\n#ifdef TERRAIN3D\nfloat height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);\n#else\nfloat height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;\n#endif\nbase=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float z=t > 0.0 ? height : base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0\n? a_pos\n: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}";
c();
var fx = "#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
c();
var mx = "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}";
c();
var dx = "uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;\n#define PI 3.141592653589793\nvoid main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
c();
var yx = "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;}";
c();
var gx = "uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
c();
var xx = "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}";
c();
var bx = "uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec2 v_uv;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,v_uv);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
c();
var _x = "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_uv_x;attribute float a_split_index;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec2 v_uv;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}";
c();
var vx = "#ifdef GL_ES\nprecision highp float;\n#endif\nuniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
c();
var wx = "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}";
c();
var Sx = "uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
c();
var Px = "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}";
c();
var Tx = "uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
c();
var Ax = "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}";
c();
var Mx = "uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
c();
var Ix = "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0),z,1.0);v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}";
c();
var Cx = "#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
c();
var Ex = "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset),z,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}";
c();
var kx = "#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
c();
var Lx = "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale),z,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}";
c();
var Dx = "varying float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {gl_FragColor=pack(v_depth);}";
c();
var zx = "precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;varying vec2 v_texture_pos;void main() {vec4 rgba=texture2D(u_texture,v_texture_pos);gl_FragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}";
c();
var Fx = "uniform sampler2D u_texture;varying vec2 v_texture_pos;void main() {gl_FragColor=texture2D(u_texture,v_texture_pos);}";
c();
var Hl = "attribute vec3 a_pos3d;uniform mat4 u_matrix;uniform float u_ele_delta;varying vec2 v_texture_pos;varying float v_depth;void main() {float extent=8192.0;float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/extent;gl_Position=u_matrix*vec4(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta,1.0);v_depth=gl_Position.z/gl_Position.w;}";
var mi = { prelude: Ie(Fg, Rg), background: Ie(Bg, Og), backgroundPattern: Ie(Vg, Ug), circle: Ie(Ng, Gg), clippingMask: Ie(qg, jg), heatmap: Ie(Zg, Hg), heatmapTexture: Ie($g, Wg), collisionBox: Ie(Xg, Kg), collisionCircle: Ie(Jg, Yg), debug: Ie(Qg, ex), fill: Ie(tx, rx), fillOutline: Ie(ix, nx), fillOutlinePattern: Ie(ox, ax), fillPattern: Ie(sx, lx), fillExtrusion: Ie(ux, cx), fillExtrusionPattern: Ie(px, hx), hillshadePrepare: Ie(fx, mx), hillshade: Ie(dx, yx), line: Ie(gx, xx), lineGradient: Ie(bx, _x), linePattern: Ie(vx, wx), lineSDF: Ie(Sx, Px), raster: Ie(Tx, Ax), symbolIcon: Ie(Mx, Ix), symbolSDF: Ie(Cx, Ex), symbolTextAndIcon: Ie(kx, Lx), terrain: Ie(Fx, Hl), terrainDepth: Ie(Dx, Hl), terrainCoords: Ie(zx, Hl) };
function Ie(r50, e) {
  let t = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, i = e.match(/attribute ([\w]+) ([\w]+)/g), n = r50.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), o = e.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), a = o ? o.concat(n) : n, s3 = {};
  return r50 = r50.replace(t, (l, u, c3, p, h) => (s3[h] = true, u === "define" ? "\n#ifndef HAS_UNIFORM_u_".concat(h, "\nvarying ").concat(c3, " ").concat(p, " ").concat(h, ";\n#else\nuniform ").concat(c3, " ").concat(p, " u_").concat(h, ";\n#endif\n") : "\n#ifdef HAS_UNIFORM_u_".concat(h, "\n    ").concat(c3, " ").concat(p, " ").concat(h, " = u_").concat(h, ";\n#endif\n"))), e = e.replace(t, (l, u, c3, p, h) => {
    let f = p === "float" ? "vec2" : "vec4", d = h.match(/color/) ? "color" : f;
    return s3[h] ? u === "define" ? "\n#ifndef HAS_UNIFORM_u_".concat(h, "\nuniform lowp float u_").concat(h, "_t;\nattribute ").concat(c3, " ").concat(f, " a_").concat(h, ";\nvarying ").concat(c3, " ").concat(p, " ").concat(h, ";\n#else\nuniform ").concat(c3, " ").concat(p, " u_").concat(h, ";\n#endif\n") : d === "vec4" ? "\n#ifndef HAS_UNIFORM_u_".concat(h, "\n    ").concat(h, " = a_").concat(h, ";\n#else\n    ").concat(c3, " ").concat(p, " ").concat(h, " = u_").concat(h, ";\n#endif\n") : "\n#ifndef HAS_UNIFORM_u_".concat(h, "\n    ").concat(h, " = unpack_mix_").concat(d, "(a_").concat(h, ", u_").concat(h, "_t);\n#else\n    ").concat(c3, " ").concat(p, " ").concat(h, " = u_").concat(h, ";\n#endif\n") : u === "define" ? "\n#ifndef HAS_UNIFORM_u_".concat(h, "\nuniform lowp float u_").concat(h, "_t;\nattribute ").concat(c3, " ").concat(f, " a_").concat(h, ";\n#else\nuniform ").concat(c3, " ").concat(p, " u_").concat(h, ";\n#endif\n") : d === "vec4" ? "\n#ifndef HAS_UNIFORM_u_".concat(h, "\n    ").concat(c3, " ").concat(p, " ").concat(h, " = a_").concat(h, ";\n#else\n    ").concat(c3, " ").concat(p, " ").concat(h, " = u_").concat(h, ";\n#endif\n") : "\n#ifndef HAS_UNIFORM_u_".concat(h, "\n    ").concat(c3, " ").concat(p, " ").concat(h, " = unpack_mix_").concat(d, "(a_").concat(h, ", u_").concat(h, "_t);\n#else\n    ").concat(c3, " ").concat(p, " ").concat(h, " = u_").concat(h, ";\n#endif\n");
  }), { fragmentSource: r50, vertexSource: e, staticAttributes: i, staticUniforms: a };
}
c();
c();
var $l = class {
  constructor() {
    this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
  }
  bind(e, t, i, n, o, a, s3, l, u) {
    this.context = e;
    let c3 = this.boundPaintVertexBuffers.length !== n.length;
    for (let h = 0; !c3 && h < n.length; h++) this.boundPaintVertexBuffers[h] !== n[h] && (c3 = true);
    !this.vao || this.boundProgram !== t || this.boundLayoutVertexBuffer !== i || c3 || this.boundIndexBuffer !== o || this.boundVertexOffset !== a || this.boundDynamicVertexBuffer !== s3 || this.boundDynamicVertexBuffer2 !== l || this.boundDynamicVertexBuffer3 !== u ? this.freshBind(t, i, n, o, a, s3, l, u) : (e.bindVertexArray.set(this.vao), s3 && s3.bind(), o && o.dynamicDraw && o.bind(), l && l.bind(), u && u.bind());
  }
  freshBind(e, t, i, n, o, a, s3, l) {
    let u = e.numAttributes, c3 = this.context, p = c3.gl;
    this.vao && this.destroy(), this.vao = c3.createVertexArray(), c3.bindVertexArray.set(this.vao), this.boundProgram = e, this.boundLayoutVertexBuffer = t, this.boundPaintVertexBuffers = i, this.boundIndexBuffer = n, this.boundVertexOffset = o, this.boundDynamicVertexBuffer = a, this.boundDynamicVertexBuffer2 = s3, this.boundDynamicVertexBuffer3 = l, t.enableAttributes(p, e);
    for (let h of i) h.enableAttributes(p, e);
    a && a.enableAttributes(p, e), s3 && s3.enableAttributes(p, e), l && l.enableAttributes(p, e), t.bind(), t.setVertexAttribPointers(p, e, o);
    for (let h of i) h.bind(), h.setVertexAttribPointers(p, e, o);
    a && (a.bind(), a.setVertexAttribPointers(p, e, o)), n && n.bind(), s3 && (s3.bind(), s3.setVertexAttribPointers(p, e, o)), l && (l.bind(), l.setVertexAttribPointers(p, e, o)), c3.currentNumAttributes = u;
  }
  destroy() {
    this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
  }
};
c();
var Rx = (r50, e) => ({ u_depth: new Y(r50, e.u_depth), u_terrain: new Y(r50, e.u_terrain), u_terrain_dim: new V(r50, e.u_terrain_dim), u_terrain_matrix: new te(r50, e.u_terrain_matrix), u_terrain_unpack: new Ar(r50, e.u_terrain_unpack), u_terrain_exaggeration: new V(r50, e.u_terrain_exaggeration) });
var Bx = (r50, e) => ({ u_matrix: new te(r50, e.u_matrix), u_texture: new Y(r50, e.u_texture), u_ele_delta: new V(r50, e.u_ele_delta) });
var Ox = (r50, e) => ({ u_matrix: new te(r50, e.u_matrix), u_ele_delta: new V(r50, e.u_ele_delta) });
var Vx = (r50, e) => ({ u_matrix: new te(r50, e.u_matrix), u_texture: new Y(r50, e.u_texture), u_terrain_coords_id: new V(r50, e.u_terrain_coords_id), u_ele_delta: new V(r50, e.u_ele_delta) });
var Ux = (r50, e) => ({ u_matrix: r50, u_texture: 0, u_ele_delta: e });
var Nx = (r50, e) => ({ u_matrix: r50, u_ele_delta: e });
var Gx = (r50, e, t) => ({ u_matrix: r50, u_terrain_coords_id: e / 255, u_texture: 0, u_ele_delta: t });
function hh(r50) {
  let e = [];
  for (let t = 0; t < r50.length; t++) {
    if (r50[t] === null) continue;
    let i = r50[t].split(" ");
    e.push(i.pop());
  }
  return e;
}
var Wl = class {
  constructor(e, t, i, n, o, a) {
    let s3 = e.gl;
    this.program = s3.createProgram();
    let l = hh(t.staticAttributes), u = i ? i.getBinderAttributes() : [], c3 = l.concat(u), p = mi.prelude.staticUniforms ? hh(mi.prelude.staticUniforms) : [], h = t.staticUniforms ? hh(t.staticUniforms) : [], f = i ? i.getBinderUniforms() : [], d = p.concat(h).concat(f), y = [];
    for (let P of d) y.indexOf(P) < 0 && y.push(P);
    let g = i ? i.defines() : [];
    o && g.push("#define OVERDRAW_INSPECTOR;"), a && g.push("#define TERRAIN3D;");
    let x = g.concat(mi.prelude.fragmentSource, t.fragmentSource).join("\n"), v = g.concat(mi.prelude.vertexSource, t.vertexSource).join("\n"), b = s3.createShader(s3.FRAGMENT_SHADER);
    if (s3.isContextLost()) {
      this.failedToCreate = true;
      return;
    }
    if (s3.shaderSource(b, x), s3.compileShader(b), !s3.getShaderParameter(b, s3.COMPILE_STATUS)) throw new Error("Could not compile fragment shader: ".concat(s3.getShaderInfoLog(b)));
    s3.attachShader(this.program, b);
    let w = s3.createShader(s3.VERTEX_SHADER);
    if (s3.isContextLost()) {
      this.failedToCreate = true;
      return;
    }
    if (s3.shaderSource(w, v), s3.compileShader(w), !s3.getShaderParameter(w, s3.COMPILE_STATUS)) throw new Error("Could not compile vertex shader: ".concat(s3.getShaderInfoLog(w)));
    s3.attachShader(this.program, w), this.attributes = {};
    let S = {};
    this.numAttributes = c3.length;
    for (let P = 0; P < this.numAttributes; P++) c3[P] && (s3.bindAttribLocation(this.program, P, c3[P]), this.attributes[c3[P]] = P);
    if (s3.linkProgram(this.program), !s3.getProgramParameter(this.program, s3.LINK_STATUS)) throw new Error("Program failed to link: ".concat(s3.getProgramInfoLog(this.program)));
    s3.deleteShader(w), s3.deleteShader(b);
    for (let P = 0; P < y.length; P++) {
      let k = y[P];
      if (k && !S[k]) {
        let I = s3.getUniformLocation(this.program, k);
        I && (S[k] = I);
      }
    }
    this.fixedUniforms = n(e, S), this.terrainUniforms = Rx(e, S), this.binderUniforms = i ? i.getUniforms(e, S) : [];
  }
  draw(e, t, i, n, o, a, s3, l, u, c3, p, h, f, d, y, g, x, v) {
    let b = e.gl;
    if (this.failedToCreate) return;
    if (e.program.set(this.program), e.setDepthMode(i), e.setStencilMode(n), e.setColorMode(o), e.setCullFace(a), l) {
      e.activeTexture.set(b.TEXTURE2), b.bindTexture(b.TEXTURE_2D, l.depthTexture), e.activeTexture.set(b.TEXTURE3), b.bindTexture(b.TEXTURE_2D, l.texture);
      for (let S in this.terrainUniforms) this.terrainUniforms[S].set(l[S]);
    }
    for (let S in this.fixedUniforms) this.fixedUniforms[S].set(s3[S]);
    y && y.setUniforms(e, this.binderUniforms, f, { zoom: d });
    let w = 0;
    switch (t) {
      case b.LINES:
        w = 2;
        break;
      case b.TRIANGLES:
        w = 3;
        break;
      case b.LINE_STRIP:
        w = 1;
        break;
    }
    for (let S of h.get()) {
      let P = S.vaos || (S.vaos = {});
      (P[u] || (P[u] = new $l())).bind(e, this, c3, y ? y.getPaintVertexBuffers() : [], p, S.vertexOffset, g, x, v), b.drawElements(t, S.primitiveLength * w, b.UNSIGNED_SHORT, S.primitiveOffset * w * 2);
    }
  }
};
c();
c();
c();
function Xl(r50, e, t) {
  let i = 1 / He(t, 1, e.transform.tileZoom), n = Math.pow(2, t.tileID.overscaledZ), o = t.tileSize * Math.pow(2, e.transform.tileZoom) / n, a = o * (t.tileID.canonical.x + t.tileID.wrap * n), s3 = o * t.tileID.canonical.y;
  return { u_image: 0, u_texsize: t.imageAtlasTexture.size, u_scale: [i, r50.fromScale, r50.toScale], u_fade: r50.t, u_pixel_coord_upper: [a >> 16, s3 >> 16], u_pixel_coord_lower: [a & 65535, s3 & 65535] };
}
function qx(r50, e, t, i) {
  let n = t.imageManager.getPattern(r50.from.toString()), o = t.imageManager.getPattern(r50.to.toString()), { width: a, height: s3 } = t.imageManager.getPixelSize(), l = Math.pow(2, i.tileID.overscaledZ), u = i.tileSize * Math.pow(2, t.transform.tileZoom) / l, c3 = u * (i.tileID.canonical.x + i.tileID.wrap * l), p = u * i.tileID.canonical.y;
  return { u_image: 0, u_pattern_tl_a: n.tl, u_pattern_br_a: n.br, u_pattern_tl_b: o.tl, u_pattern_br_b: o.br, u_texsize: [a, s3], u_mix: e.t, u_pattern_size_a: n.displaySize, u_pattern_size_b: o.displaySize, u_scale_a: e.fromScale, u_scale_b: e.toScale, u_tile_units_to_pixels: 1 / He(i, 1, t.transform.tileZoom), u_pixel_coord_upper: [c3 >> 16, p >> 16], u_pixel_coord_lower: [c3 & 65535, p & 65535] };
}
var jx = (r50, e) => ({ u_matrix: new te(r50, e.u_matrix), u_lightpos: new st(r50, e.u_lightpos), u_lightintensity: new V(r50, e.u_lightintensity), u_lightcolor: new st(r50, e.u_lightcolor), u_vertical_gradient: new V(r50, e.u_vertical_gradient), u_opacity: new V(r50, e.u_opacity) });
var Zx = (r50, e) => ({ u_matrix: new te(r50, e.u_matrix), u_lightpos: new st(r50, e.u_lightpos), u_lightintensity: new V(r50, e.u_lightintensity), u_lightcolor: new st(r50, e.u_lightcolor), u_vertical_gradient: new V(r50, e.u_vertical_gradient), u_height_factor: new V(r50, e.u_height_factor), u_image: new Y(r50, e.u_image), u_texsize: new ee(r50, e.u_texsize), u_pixel_coord_upper: new ee(r50, e.u_pixel_coord_upper), u_pixel_coord_lower: new ee(r50, e.u_pixel_coord_lower), u_scale: new st(r50, e.u_scale), u_fade: new V(r50, e.u_fade), u_opacity: new V(r50, e.u_opacity) });
var fh = (r50, e, t, i) => {
  let n = e.style.light, o = n.properties.get("position"), a = [o.x, o.y, o.z], s3 = vo.create();
  n.properties.get("anchor") === "viewport" && vo.fromRotation(s3, -e.transform.angle), yt.transformMat3(a, a, s3);
  let l = n.properties.get("color");
  return { u_matrix: r50, u_lightpos: a, u_lightintensity: n.properties.get("intensity"), u_lightcolor: [l.r, l.g, l.b], u_vertical_gradient: +t, u_opacity: i };
};
var Hx = (r50, e, t, i, n, o, a) => O(fh(r50, e, t, i), Xl(o, e, a), { u_height_factor: -Math.pow(2, n.overscaledZ) / a.tileSize / 8 });
c();
var $x = (r50, e) => ({ u_matrix: new te(r50, e.u_matrix) });
var Wx = (r50, e) => ({ u_matrix: new te(r50, e.u_matrix), u_image: new Y(r50, e.u_image), u_texsize: new ee(r50, e.u_texsize), u_pixel_coord_upper: new ee(r50, e.u_pixel_coord_upper), u_pixel_coord_lower: new ee(r50, e.u_pixel_coord_lower), u_scale: new st(r50, e.u_scale), u_fade: new V(r50, e.u_fade) });
var Xx = (r50, e) => ({ u_matrix: new te(r50, e.u_matrix), u_world: new ee(r50, e.u_world) });
var Kx = (r50, e) => ({ u_matrix: new te(r50, e.u_matrix), u_world: new ee(r50, e.u_world), u_image: new Y(r50, e.u_image), u_texsize: new ee(r50, e.u_texsize), u_pixel_coord_upper: new ee(r50, e.u_pixel_coord_upper), u_pixel_coord_lower: new ee(r50, e.u_pixel_coord_lower), u_scale: new st(r50, e.u_scale), u_fade: new V(r50, e.u_fade) });
var mh = (r50) => ({ u_matrix: r50 });
var dh = (r50, e, t, i) => O(mh(r50), Xl(t, e, i));
var Jx = (r50, e) => ({ u_matrix: r50, u_world: e });
var Yx = (r50, e, t, i, n) => O(dh(r50, e, t, i), { u_world: n });
c();
var Qx = (r50, e) => ({ u_camera_to_center_distance: new V(r50, e.u_camera_to_center_distance), u_scale_with_map: new Y(r50, e.u_scale_with_map), u_pitch_with_map: new Y(r50, e.u_pitch_with_map), u_extrude_scale: new ee(r50, e.u_extrude_scale), u_device_pixel_ratio: new V(r50, e.u_device_pixel_ratio), u_matrix: new te(r50, e.u_matrix) });
var eb = (r50, e, t, i) => {
  let n = r50.transform, o, a;
  if (i.paint.get("circle-pitch-alignment") === "map") {
    let s3 = He(t, 1, n.zoom);
    o = true, a = [s3, s3];
  } else o = false, a = n.pixelsToGLUnits;
  return { u_camera_to_center_distance: n.cameraToCenterDistance, u_scale_with_map: +(i.paint.get("circle-pitch-scale") === "map"), u_matrix: r50.translatePosMatrix(e.posMatrix, t, i.paint.get("circle-translate"), i.paint.get("circle-translate-anchor")), u_pitch_with_map: +o, u_device_pixel_ratio: r50.pixelRatio, u_extrude_scale: a };
};
c();
var tb = (r50, e) => ({ u_matrix: new te(r50, e.u_matrix), u_camera_to_center_distance: new V(r50, e.u_camera_to_center_distance), u_pixels_to_tile_units: new V(r50, e.u_pixels_to_tile_units), u_extrude_scale: new ee(r50, e.u_extrude_scale), u_overscale_factor: new V(r50, e.u_overscale_factor) });
var rb = (r50, e) => ({ u_matrix: new te(r50, e.u_matrix), u_inv_matrix: new te(r50, e.u_inv_matrix), u_camera_to_center_distance: new V(r50, e.u_camera_to_center_distance), u_viewport_size: new ee(r50, e.u_viewport_size) });
var ib = (r50, e, t) => {
  let i = He(t, 1, e.zoom), n = Math.pow(2, e.zoom - t.tileID.overscaledZ), o = t.tileID.overscaleFactor();
  return { u_matrix: r50, u_camera_to_center_distance: e.cameraToCenterDistance, u_pixels_to_tile_units: i, u_extrude_scale: [e.pixelsToGLUnits[0] / (i * n), e.pixelsToGLUnits[1] / (i * n)], u_overscale_factor: o };
};
var nb = (r50, e, t) => ({ u_matrix: r50, u_inv_matrix: e, u_camera_to_center_distance: t.cameraToCenterDistance, u_viewport_size: [t.width, t.height] });
c();
var ob = (r50, e) => ({ u_color: new Ct(r50, e.u_color), u_matrix: new te(r50, e.u_matrix), u_overlay: new Y(r50, e.u_overlay), u_overlay_scale: new V(r50, e.u_overlay_scale) });
var yh = (r50, e, t = 1) => ({ u_matrix: r50, u_color: e, u_overlay: 0, u_overlay_scale: t });
c();
var ab = (r50, e) => ({ u_matrix: new te(r50, e.u_matrix) });
var gh = (r50) => ({ u_matrix: r50 });
c();
var sb = (r50, e) => ({ u_extrude_scale: new V(r50, e.u_extrude_scale), u_intensity: new V(r50, e.u_intensity), u_matrix: new te(r50, e.u_matrix) });
var lb = (r50, e) => ({ u_matrix: new te(r50, e.u_matrix), u_world: new ee(r50, e.u_world), u_image: new Y(r50, e.u_image), u_color_ramp: new Y(r50, e.u_color_ramp), u_opacity: new V(r50, e.u_opacity) });
var ub = (r50, e, t, i) => ({ u_matrix: r50, u_extrude_scale: He(e, 1, t), u_intensity: i });
var cb = (r50, e, t, i) => {
  let n = G.create();
  G.ortho(n, 0, r50.width, r50.height, 0, 0, 1);
  let o = r50.context.gl;
  return { u_matrix: n, u_world: [o.drawingBufferWidth, o.drawingBufferHeight], u_image: t, u_color_ramp: i, u_opacity: e.paint.get("heatmap-opacity") };
};
c();
var pb = (r50, e) => ({ u_matrix: new te(r50, e.u_matrix), u_image: new Y(r50, e.u_image), u_latrange: new ee(r50, e.u_latrange), u_light: new ee(r50, e.u_light), u_shadow: new Ct(r50, e.u_shadow), u_highlight: new Ct(r50, e.u_highlight), u_accent: new Ct(r50, e.u_accent) });
var hb = (r50, e) => ({ u_matrix: new te(r50, e.u_matrix), u_image: new Y(r50, e.u_image), u_dimension: new ee(r50, e.u_dimension), u_zoom: new V(r50, e.u_zoom), u_unpack: new Ar(r50, e.u_unpack) });
var fb = (r50, e, t, i) => {
  let n = t.paint.get("hillshade-shadow-color"), o = t.paint.get("hillshade-highlight-color"), a = t.paint.get("hillshade-accent-color"), s3 = t.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
  t.paint.get("hillshade-illumination-anchor") === "viewport" && (s3 -= r50.transform.angle);
  let l = !r50.options.moving;
  return { u_matrix: i ? i.posMatrix : r50.transform.calculatePosMatrix(e.tileID.toUnwrapped(), l), u_image: 0, u_latrange: EA(r50, e.tileID), u_light: [t.paint.get("hillshade-exaggeration"), s3], u_shadow: n, u_highlight: o, u_accent: a };
};
var mb = (r50, e) => {
  let t = e.stride, i = G.create();
  return G.ortho(i, 0, 8192, -8192, 0, 0, 1), G.translate(i, i, [0, -8192, 0]), { u_matrix: i, u_image: 1, u_dimension: [t, t], u_zoom: r50.overscaledZ, u_unpack: e.getUnpackVector() };
};
function EA(r50, e) {
  let t = Math.pow(2, e.canonical.z), i = e.canonical.y;
  return [new ze(0, i / t).toLngLat().lat, new ze(0, (i + 1) / t).toLngLat().lat];
}
c();
var db = (r50, e) => ({ u_matrix: new te(r50, e.u_matrix), u_ratio: new V(r50, e.u_ratio), u_device_pixel_ratio: new V(r50, e.u_device_pixel_ratio), u_units_to_pixels: new ee(r50, e.u_units_to_pixels) });
var yb = (r50, e) => ({ u_matrix: new te(r50, e.u_matrix), u_ratio: new V(r50, e.u_ratio), u_device_pixel_ratio: new V(r50, e.u_device_pixel_ratio), u_units_to_pixels: new ee(r50, e.u_units_to_pixels), u_image: new Y(r50, e.u_image), u_image_height: new V(r50, e.u_image_height) });
var gb = (r50, e) => ({ u_matrix: new te(r50, e.u_matrix), u_texsize: new ee(r50, e.u_texsize), u_ratio: new V(r50, e.u_ratio), u_device_pixel_ratio: new V(r50, e.u_device_pixel_ratio), u_image: new Y(r50, e.u_image), u_units_to_pixels: new ee(r50, e.u_units_to_pixels), u_scale: new st(r50, e.u_scale), u_fade: new V(r50, e.u_fade) });
var xb = (r50, e) => ({ u_matrix: new te(r50, e.u_matrix), u_ratio: new V(r50, e.u_ratio), u_device_pixel_ratio: new V(r50, e.u_device_pixel_ratio), u_units_to_pixels: new ee(r50, e.u_units_to_pixels), u_patternscale_a: new ee(r50, e.u_patternscale_a), u_patternscale_b: new ee(r50, e.u_patternscale_b), u_sdfgamma: new V(r50, e.u_sdfgamma), u_image: new Y(r50, e.u_image), u_tex_y_a: new V(r50, e.u_tex_y_a), u_tex_y_b: new V(r50, e.u_tex_y_b), u_mix: new V(r50, e.u_mix) });
var Kl = (r50, e, t, i) => {
  let n = r50.transform;
  return { u_matrix: Sb(r50, e, t, i), u_ratio: 1 / He(e, 1, n.zoom), u_device_pixel_ratio: r50.pixelRatio, u_units_to_pixels: [1 / n.pixelsToGLUnits[0], 1 / n.pixelsToGLUnits[1]] };
};
var bb = (r50, e, t, i, n) => O(Kl(r50, e, t, n), { u_image: 0, u_image_height: i });
var _b = (r50, e, t, i, n) => {
  let o = r50.transform, a = wb(e, o);
  return { u_matrix: Sb(r50, e, t, n), u_texsize: e.imageAtlasTexture.size, u_ratio: 1 / He(e, 1, o.zoom), u_device_pixel_ratio: r50.pixelRatio, u_image: 0, u_scale: [a, i.fromScale, i.toScale], u_fade: i.t, u_units_to_pixels: [1 / o.pixelsToGLUnits[0], 1 / o.pixelsToGLUnits[1]] };
};
var vb = (r50, e, t, i, n, o) => {
  let a = r50.transform, s3 = r50.lineAtlas, l = wb(e, a), u = t.layout.get("line-cap") === "round", c3 = s3.getDash(i.from, u), p = s3.getDash(i.to, u), h = c3.width * n.fromScale, f = p.width * n.toScale;
  return O(Kl(r50, e, t, o), { u_patternscale_a: [l / h, -c3.height / 2], u_patternscale_b: [l / f, -p.height / 2], u_sdfgamma: s3.width / (Math.min(h, f) * 256 * r50.pixelRatio) / 2, u_image: 0, u_tex_y_a: c3.y, u_tex_y_b: p.y, u_mix: n.t });
};
function wb(r50, e) {
  return 1 / He(r50, 1, e.tileZoom);
}
function Sb(r50, e, t, i) {
  return r50.translatePosMatrix(i ? i.posMatrix : e.tileID.posMatrix, e, t.paint.get("line-translate"), t.paint.get("line-translate-anchor"));
}
c();
var Pb = (r50, e) => ({ u_matrix: new te(r50, e.u_matrix), u_tl_parent: new ee(r50, e.u_tl_parent), u_scale_parent: new V(r50, e.u_scale_parent), u_buffer_scale: new V(r50, e.u_buffer_scale), u_fade_t: new V(r50, e.u_fade_t), u_opacity: new V(r50, e.u_opacity), u_image0: new Y(r50, e.u_image0), u_image1: new Y(r50, e.u_image1), u_brightness_low: new V(r50, e.u_brightness_low), u_brightness_high: new V(r50, e.u_brightness_high), u_saturation_factor: new V(r50, e.u_saturation_factor), u_contrast_factor: new V(r50, e.u_contrast_factor), u_spin_weights: new st(r50, e.u_spin_weights) });
var Tb = (r50, e, t, i, n) => ({ u_matrix: r50, u_tl_parent: e, u_scale_parent: t, u_buffer_scale: 1, u_fade_t: i.mix, u_opacity: i.opacity * n.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: n.paint.get("raster-brightness-min"), u_brightness_high: n.paint.get("raster-brightness-max"), u_saturation_factor: DA(n.paint.get("raster-saturation")), u_contrast_factor: LA(n.paint.get("raster-contrast")), u_spin_weights: kA(n.paint.get("raster-hue-rotate")) });
function kA(r50) {
  r50 *= Math.PI / 180;
  let e = Math.sin(r50), t = Math.cos(r50);
  return [(2 * t + 1) / 3, (-Math.sqrt(3) * e - t + 1) / 3, (Math.sqrt(3) * e - t + 1) / 3];
}
function LA(r50) {
  return r50 > 0 ? 1 / (1 - r50) : 1 + r50;
}
function DA(r50) {
  return r50 > 0 ? 1 - 1 / (1.001 - r50) : -r50;
}
c();
var Ab = (r50, e) => ({ u_is_size_zoom_constant: new Y(r50, e.u_is_size_zoom_constant), u_is_size_feature_constant: new Y(r50, e.u_is_size_feature_constant), u_size_t: new V(r50, e.u_size_t), u_size: new V(r50, e.u_size), u_camera_to_center_distance: new V(r50, e.u_camera_to_center_distance), u_pitch: new V(r50, e.u_pitch), u_rotate_symbol: new Y(r50, e.u_rotate_symbol), u_aspect_ratio: new V(r50, e.u_aspect_ratio), u_fade_change: new V(r50, e.u_fade_change), u_matrix: new te(r50, e.u_matrix), u_label_plane_matrix: new te(r50, e.u_label_plane_matrix), u_coord_matrix: new te(r50, e.u_coord_matrix), u_is_text: new Y(r50, e.u_is_text), u_pitch_with_map: new Y(r50, e.u_pitch_with_map), u_texsize: new ee(r50, e.u_texsize), u_texture: new Y(r50, e.u_texture) });
var Mb = (r50, e) => ({ u_is_size_zoom_constant: new Y(r50, e.u_is_size_zoom_constant), u_is_size_feature_constant: new Y(r50, e.u_is_size_feature_constant), u_size_t: new V(r50, e.u_size_t), u_size: new V(r50, e.u_size), u_camera_to_center_distance: new V(r50, e.u_camera_to_center_distance), u_pitch: new V(r50, e.u_pitch), u_rotate_symbol: new Y(r50, e.u_rotate_symbol), u_aspect_ratio: new V(r50, e.u_aspect_ratio), u_fade_change: new V(r50, e.u_fade_change), u_matrix: new te(r50, e.u_matrix), u_label_plane_matrix: new te(r50, e.u_label_plane_matrix), u_coord_matrix: new te(r50, e.u_coord_matrix), u_is_text: new Y(r50, e.u_is_text), u_pitch_with_map: new Y(r50, e.u_pitch_with_map), u_texsize: new ee(r50, e.u_texsize), u_texture: new Y(r50, e.u_texture), u_gamma_scale: new V(r50, e.u_gamma_scale), u_device_pixel_ratio: new V(r50, e.u_device_pixel_ratio), u_is_halo: new Y(r50, e.u_is_halo) });
var Ib = (r50, e) => ({ u_is_size_zoom_constant: new Y(r50, e.u_is_size_zoom_constant), u_is_size_feature_constant: new Y(r50, e.u_is_size_feature_constant), u_size_t: new V(r50, e.u_size_t), u_size: new V(r50, e.u_size), u_camera_to_center_distance: new V(r50, e.u_camera_to_center_distance), u_pitch: new V(r50, e.u_pitch), u_rotate_symbol: new Y(r50, e.u_rotate_symbol), u_aspect_ratio: new V(r50, e.u_aspect_ratio), u_fade_change: new V(r50, e.u_fade_change), u_matrix: new te(r50, e.u_matrix), u_label_plane_matrix: new te(r50, e.u_label_plane_matrix), u_coord_matrix: new te(r50, e.u_coord_matrix), u_is_text: new Y(r50, e.u_is_text), u_pitch_with_map: new Y(r50, e.u_pitch_with_map), u_texsize: new ee(r50, e.u_texsize), u_texsize_icon: new ee(r50, e.u_texsize_icon), u_texture: new Y(r50, e.u_texture), u_texture_icon: new Y(r50, e.u_texture_icon), u_gamma_scale: new V(r50, e.u_gamma_scale), u_device_pixel_ratio: new V(r50, e.u_device_pixel_ratio), u_is_halo: new Y(r50, e.u_is_halo) });
var xh = (r50, e, t, i, n, o, a, s3, l, u) => {
  let c3 = n.transform;
  return { u_is_size_zoom_constant: +(r50 === "constant" || r50 === "source"), u_is_size_feature_constant: +(r50 === "constant" || r50 === "camera"), u_size_t: e ? e.uSizeT : 0, u_size: e ? e.uSize : 0, u_camera_to_center_distance: c3.cameraToCenterDistance, u_pitch: c3.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +t, u_aspect_ratio: c3.width / c3.height, u_fade_change: n.options.fadeDuration ? n.symbolFadeChange : 1, u_matrix: o, u_label_plane_matrix: a, u_coord_matrix: s3, u_is_text: +l, u_pitch_with_map: +i, u_texsize: u, u_texture: 0 };
};
var bh = (r50, e, t, i, n, o, a, s3, l, u, c3) => {
  let p = n.transform;
  return O(xh(r50, e, t, i, n, o, a, s3, l, u), { u_gamma_scale: i ? Math.cos(p._pitch) * p.cameraToCenterDistance : 1, u_device_pixel_ratio: n.pixelRatio, u_is_halo: +c3 });
};
var Cb = (r50, e, t, i, n, o, a, s3, l, u) => O(bh(r50, e, t, i, n, o, a, s3, true, l, true), { u_texsize_icon: u, u_texture_icon: 1 });
c();
var Eb = (r50, e) => ({ u_matrix: new te(r50, e.u_matrix), u_opacity: new V(r50, e.u_opacity), u_color: new Ct(r50, e.u_color) });
var kb = (r50, e) => ({ u_matrix: new te(r50, e.u_matrix), u_opacity: new V(r50, e.u_opacity), u_image: new Y(r50, e.u_image), u_pattern_tl_a: new ee(r50, e.u_pattern_tl_a), u_pattern_br_a: new ee(r50, e.u_pattern_br_a), u_pattern_tl_b: new ee(r50, e.u_pattern_tl_b), u_pattern_br_b: new ee(r50, e.u_pattern_br_b), u_texsize: new ee(r50, e.u_texsize), u_mix: new V(r50, e.u_mix), u_pattern_size_a: new ee(r50, e.u_pattern_size_a), u_pattern_size_b: new ee(r50, e.u_pattern_size_b), u_scale_a: new V(r50, e.u_scale_a), u_scale_b: new V(r50, e.u_scale_b), u_pixel_coord_upper: new ee(r50, e.u_pixel_coord_upper), u_pixel_coord_lower: new ee(r50, e.u_pixel_coord_lower), u_tile_units_to_pixels: new V(r50, e.u_tile_units_to_pixels) });
var Lb = (r50, e, t) => ({ u_matrix: r50, u_opacity: e, u_color: t });
var Db = (r50, e, t, i, n, o) => O(qx(i, o, t, n), { u_matrix: r50, u_opacity: e });
var zb = { fillExtrusion: jx, fillExtrusionPattern: Zx, fill: $x, fillPattern: Wx, fillOutline: Xx, fillOutlinePattern: Kx, circle: Qx, collisionBox: tb, collisionCircle: rb, debug: ob, clippingMask: ab, heatmap: sb, heatmapTexture: lb, hillshade: pb, hillshadePrepare: hb, line: db, lineGradient: yb, linePattern: gb, lineSDF: xb, raster: Pb, symbolIcon: Ab, symbolSDF: Mb, symbolTextAndIcon: Ib, background: Eb, backgroundPattern: kb, terrain: Bx, terrainDepth: Ox, terrainCoords: Vx };
c();
c();
var Jl = class {
  constructor(e, t, i) {
    this.context = e;
    let n = e.gl;
    this.buffer = n.createBuffer(), this.dynamicDraw = !!i, this.context.unbindVAO(), e.bindElementBuffer.set(this.buffer), n.bufferData(n.ELEMENT_ARRAY_BUFFER, t.arrayBuffer, this.dynamicDraw ? n.DYNAMIC_DRAW : n.STATIC_DRAW), this.dynamicDraw || delete t.arrayBuffer;
  }
  bind() {
    this.context.bindElementBuffer.set(this.buffer);
  }
  updateData(e) {
    let t = this.context.gl;
    if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
    this.context.unbindVAO(), this.bind(), t.bufferSubData(t.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer);
  }
  destroy() {
    let e = this.context.gl;
    this.buffer && (e.deleteBuffer(this.buffer), delete this.buffer);
  }
};
c();
var zA = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
var Yl = class {
  constructor(e, t, i, n) {
    this.length = t.length, this.attributes = i, this.itemSize = t.bytesPerElement, this.dynamicDraw = n, this.context = e;
    let o = e.gl;
    this.buffer = o.createBuffer(), e.bindVertexBuffer.set(this.buffer), o.bufferData(o.ARRAY_BUFFER, t.arrayBuffer, this.dynamicDraw ? o.DYNAMIC_DRAW : o.STATIC_DRAW), this.dynamicDraw || delete t.arrayBuffer;
  }
  bind() {
    this.context.bindVertexBuffer.set(this.buffer);
  }
  updateData(e) {
    if (e.length !== this.length) throw new Error("Length of new data is ".concat(e.length, ", which doesn't match current length of ").concat(this.length));
    let t = this.context.gl;
    this.bind(), t.bufferSubData(t.ARRAY_BUFFER, 0, e.arrayBuffer);
  }
  enableAttributes(e, t) {
    for (let i = 0; i < this.attributes.length; i++) {
      let n = this.attributes[i], o = t.attributes[n.name];
      o !== void 0 && e.enableVertexAttribArray(o);
    }
  }
  setVertexAttribPointers(e, t, i) {
    for (let n = 0; n < this.attributes.length; n++) {
      let o = this.attributes[n], a = t.attributes[o.name];
      a !== void 0 && e.vertexAttribPointer(a, o.components, e[zA[o.type]], false, this.itemSize, o.offset + this.itemSize * (i || 0));
    }
  }
  destroy() {
    let e = this.context.gl;
    this.buffer && (e.deleteBuffer(this.buffer), delete this.buffer);
  }
};
c();
c();
c();
var _h = /* @__PURE__ */ new WeakMap();
function hn(r50) {
  var e;
  if (_h.has(r50)) return _h.get(r50);
  {
    let t = (e = r50.getParameter(r50.VERSION)) == null ? void 0 : e.startsWith("WebGL 2.0");
    return _h.set(r50, t), t;
  }
}
var xe = class {
  constructor(e) {
    this.gl = e.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
  }
  get() {
    return this.current;
  }
  set(e) {
  }
  getDefault() {
    return this.default;
  }
  setDefault() {
    this.set(this.default);
  }
};
var Ql = class extends xe {
  getDefault() {
    return W.transparent;
  }
  set(e) {
    let t = this.current;
    e.r === t.r && e.g === t.g && e.b === t.b && e.a === t.a && !this.dirty || (this.gl.clearColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = false);
  }
};
var eu = class extends xe {
  getDefault() {
    return 1;
  }
  set(e) {
    e === this.current && !this.dirty || (this.gl.clearDepth(e), this.current = e, this.dirty = false);
  }
};
var tu = class extends xe {
  getDefault() {
    return 0;
  }
  set(e) {
    e === this.current && !this.dirty || (this.gl.clearStencil(e), this.current = e, this.dirty = false);
  }
};
var ru = class extends xe {
  getDefault() {
    return [true, true, true, true];
  }
  set(e) {
    let t = this.current;
    e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && !this.dirty || (this.gl.colorMask(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = false);
  }
};
var iu = class extends xe {
  getDefault() {
    return true;
  }
  set(e) {
    e === this.current && !this.dirty || (this.gl.depthMask(e), this.current = e, this.dirty = false);
  }
};
var nu = class extends xe {
  getDefault() {
    return 255;
  }
  set(e) {
    e === this.current && !this.dirty || (this.gl.stencilMask(e), this.current = e, this.dirty = false);
  }
};
var ou = class extends xe {
  getDefault() {
    return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
  }
  set(e) {
    let t = this.current;
    e.func === t.func && e.ref === t.ref && e.mask === t.mask && !this.dirty || (this.gl.stencilFunc(e.func, e.ref, e.mask), this.current = e, this.dirty = false);
  }
};
var au = class extends xe {
  getDefault() {
    let e = this.gl;
    return [e.KEEP, e.KEEP, e.KEEP];
  }
  set(e) {
    let t = this.current;
    e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && !this.dirty || (this.gl.stencilOp(e[0], e[1], e[2]), this.current = e, this.dirty = false);
  }
};
var su = class extends xe {
  getDefault() {
    return false;
  }
  set(e) {
    if (e === this.current && !this.dirty) return;
    let t = this.gl;
    e ? t.enable(t.STENCIL_TEST) : t.disable(t.STENCIL_TEST), this.current = e, this.dirty = false;
  }
};
var lu = class extends xe {
  getDefault() {
    return [0, 1];
  }
  set(e) {
    let t = this.current;
    e[0] === t[0] && e[1] === t[1] && !this.dirty || (this.gl.depthRange(e[0], e[1]), this.current = e, this.dirty = false);
  }
};
var uu = class extends xe {
  getDefault() {
    return false;
  }
  set(e) {
    if (e === this.current && !this.dirty) return;
    let t = this.gl;
    e ? t.enable(t.DEPTH_TEST) : t.disable(t.DEPTH_TEST), this.current = e, this.dirty = false;
  }
};
var cu = class extends xe {
  getDefault() {
    return this.gl.LESS;
  }
  set(e) {
    e === this.current && !this.dirty || (this.gl.depthFunc(e), this.current = e, this.dirty = false);
  }
};
var pu = class extends xe {
  getDefault() {
    return false;
  }
  set(e) {
    if (e === this.current && !this.dirty) return;
    let t = this.gl;
    e ? t.enable(t.BLEND) : t.disable(t.BLEND), this.current = e, this.dirty = false;
  }
};
var hu = class extends xe {
  getDefault() {
    let e = this.gl;
    return [e.ONE, e.ZERO];
  }
  set(e) {
    let t = this.current;
    e[0] === t[0] && e[1] === t[1] && !this.dirty || (this.gl.blendFunc(e[0], e[1]), this.current = e, this.dirty = false);
  }
};
var fu = class extends xe {
  getDefault() {
    return W.transparent;
  }
  set(e) {
    let t = this.current;
    e.r === t.r && e.g === t.g && e.b === t.b && e.a === t.a && !this.dirty || (this.gl.blendColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = false);
  }
};
var mu = class extends xe {
  getDefault() {
    return this.gl.FUNC_ADD;
  }
  set(e) {
    e === this.current && !this.dirty || (this.gl.blendEquation(e), this.current = e, this.dirty = false);
  }
};
var du = class extends xe {
  getDefault() {
    return false;
  }
  set(e) {
    if (e === this.current && !this.dirty) return;
    let t = this.gl;
    e ? t.enable(t.CULL_FACE) : t.disable(t.CULL_FACE), this.current = e, this.dirty = false;
  }
};
var yu = class extends xe {
  getDefault() {
    return this.gl.BACK;
  }
  set(e) {
    e === this.current && !this.dirty || (this.gl.cullFace(e), this.current = e, this.dirty = false);
  }
};
var gu = class extends xe {
  getDefault() {
    return this.gl.CCW;
  }
  set(e) {
    e === this.current && !this.dirty || (this.gl.frontFace(e), this.current = e, this.dirty = false);
  }
};
var xu = class extends xe {
  getDefault() {
    return null;
  }
  set(e) {
    e === this.current && !this.dirty || (this.gl.useProgram(e), this.current = e, this.dirty = false);
  }
};
var bu = class extends xe {
  getDefault() {
    return this.gl.TEXTURE0;
  }
  set(e) {
    e === this.current && !this.dirty || (this.gl.activeTexture(e), this.current = e, this.dirty = false);
  }
};
var _u = class extends xe {
  getDefault() {
    let e = this.gl;
    return [0, 0, e.drawingBufferWidth, e.drawingBufferHeight];
  }
  set(e) {
    let t = this.current;
    e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && !this.dirty || (this.gl.viewport(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = false);
  }
};
var vu = class extends xe {
  getDefault() {
    return null;
  }
  set(e) {
    if (e === this.current && !this.dirty) return;
    let t = this.gl;
    t.bindFramebuffer(t.FRAMEBUFFER, e), this.current = e, this.dirty = false;
  }
};
var wu = class extends xe {
  getDefault() {
    return null;
  }
  set(e) {
    if (e === this.current && !this.dirty) return;
    let t = this.gl;
    t.bindRenderbuffer(t.RENDERBUFFER, e), this.current = e, this.dirty = false;
  }
};
var Su = class extends xe {
  getDefault() {
    return null;
  }
  set(e) {
    if (e === this.current && !this.dirty) return;
    let t = this.gl;
    t.bindTexture(t.TEXTURE_2D, e), this.current = e, this.dirty = false;
  }
};
var Pu = class extends xe {
  getDefault() {
    return null;
  }
  set(e) {
    if (e === this.current && !this.dirty) return;
    let t = this.gl;
    t.bindBuffer(t.ARRAY_BUFFER, e), this.current = e, this.dirty = false;
  }
};
var Tu = class extends xe {
  getDefault() {
    return null;
  }
  set(e) {
    let t = this.gl;
    t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, e), this.current = e, this.dirty = false;
  }
};
var Au = class extends xe {
  getDefault() {
    return null;
  }
  set(e) {
    var i;
    if (e === this.current && !this.dirty) return;
    let t = this.gl;
    hn(t) ? t.bindVertexArray(e) : (i = t.getExtension("OES_vertex_array_object")) == null || i.bindVertexArrayOES(e), this.current = e, this.dirty = false;
  }
};
var Mu = class extends xe {
  getDefault() {
    return 4;
  }
  set(e) {
    if (e === this.current && !this.dirty) return;
    let t = this.gl;
    t.pixelStorei(t.UNPACK_ALIGNMENT, e), this.current = e, this.dirty = false;
  }
};
var Iu = class extends xe {
  getDefault() {
    return false;
  }
  set(e) {
    if (e === this.current && !this.dirty) return;
    let t = this.gl;
    t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e), this.current = e, this.dirty = false;
  }
};
var Cu = class extends xe {
  getDefault() {
    return false;
  }
  set(e) {
    if (e === this.current && !this.dirty) return;
    let t = this.gl;
    t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, e), this.current = e, this.dirty = false;
  }
};
var la = class extends xe {
  constructor(e, t) {
    super(e), this.context = e, this.parent = t;
  }
  getDefault() {
    return null;
  }
};
var Eu = class extends la {
  setDirty() {
    this.dirty = true;
  }
  set(e) {
    if (e === this.current && !this.dirty) return;
    this.context.bindFramebuffer.set(this.parent);
    let t = this.gl;
    t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, e, 0), this.current = e, this.dirty = false;
  }
};
var ku = class extends la {
  set(e) {
    if (e === this.current && !this.dirty) return;
    this.context.bindFramebuffer.set(this.parent);
    let t = this.gl;
    t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, e), this.current = e, this.dirty = false;
  }
};
var Lu = class extends la {
  set(e) {
    if (e === this.current && !this.dirty) return;
    this.context.bindFramebuffer.set(this.parent);
    let t = this.gl;
    t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, e), this.current = e, this.dirty = false;
  }
};
var Du = class {
  constructor(e, t, i, n, o) {
    this.context = e, this.width = t, this.height = i;
    let a = e.gl, s3 = this.framebuffer = a.createFramebuffer();
    if (this.colorAttachment = new Eu(e, s3), n) this.depthAttachment = o ? new Lu(e, s3) : new ku(e, s3);
    else if (o) throw new Error("Stencil cannot be set without depth");
    if (a.checkFramebufferStatus(a.FRAMEBUFFER) !== a.FRAMEBUFFER_COMPLETE) throw new Error("Framebuffer is not complete");
  }
  destroy() {
    let e = this.context.gl, t = this.colorAttachment.get();
    if (t && e.deleteTexture(t), this.depthAttachment) {
      let i = this.depthAttachment.get();
      i && e.deleteRenderbuffer(i);
    }
    e.deleteFramebuffer(this.framebuffer);
  }
};
c();
var FA = 0;
var Fb = 1;
var RA = 771;
var Ce = class {
  constructor(e, t, i) {
    this.blendFunction = e, this.blendColor = t, this.mask = i;
  }
};
Ce.Replace = [Fb, FA];
Ce.disabled = new Ce(Ce.Replace, W.transparent, [false, false, false, false]);
Ce.unblended = new Ce(Ce.Replace, W.transparent, [true, true, true, true]);
Ce.alphaBlended = new Ce([Fb, RA], W.transparent, [true, true, true, true]);
var zu = class {
  constructor(e) {
    var t, i;
    if (this.gl = e, this.clearColor = new Ql(this), this.clearDepth = new eu(this), this.clearStencil = new tu(this), this.colorMask = new ru(this), this.depthMask = new iu(this), this.stencilMask = new nu(this), this.stencilFunc = new ou(this), this.stencilOp = new au(this), this.stencilTest = new su(this), this.depthRange = new lu(this), this.depthTest = new uu(this), this.depthFunc = new cu(this), this.blend = new pu(this), this.blendFunc = new hu(this), this.blendColor = new fu(this), this.blendEquation = new mu(this), this.cullFace = new du(this), this.cullFaceSide = new yu(this), this.frontFace = new gu(this), this.program = new xu(this), this.activeTexture = new bu(this), this.viewport = new _u(this), this.bindFramebuffer = new vu(this), this.bindRenderbuffer = new wu(this), this.bindTexture = new Su(this), this.bindVertexBuffer = new Pu(this), this.bindElementBuffer = new Tu(this), this.bindVertexArray = new Au(this), this.pixelStoreUnpack = new Mu(this), this.pixelStoreUnpackPremultiplyAlpha = new Iu(this), this.pixelStoreUnpackFlipY = new Cu(this), this.extTextureFilterAnisotropic = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE), hn(e)) {
      this.HALF_FLOAT = e.HALF_FLOAT;
      let n = e.getExtension("EXT_color_buffer_half_float");
      this.RGBA16F = (t = e.RGBA16F) != null ? t : n == null ? void 0 : n.RGBA16F_EXT, this.RGB16F = (i = e.RGB16F) != null ? i : n == null ? void 0 : n.RGB16F_EXT, e.getExtension("EXT_color_buffer_float");
    } else {
      e.getExtension("EXT_color_buffer_half_float"), e.getExtension("OES_texture_half_float_linear");
      let n = e.getExtension("OES_texture_half_float");
      this.HALF_FLOAT = n == null ? void 0 : n.HALF_FLOAT_OES;
    }
  }
  setDefault() {
    this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
  }
  setDirty() {
    this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.bindVertexArray.dirty = true, this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
  }
  createIndexBuffer(e, t) {
    return new Jl(this, e, t);
  }
  createVertexBuffer(e, t, i) {
    return new Yl(this, e, t, i);
  }
  createRenderbuffer(e, t, i) {
    let n = this.gl, o = n.createRenderbuffer();
    return this.bindRenderbuffer.set(o), n.renderbufferStorage(n.RENDERBUFFER, e, t, i), this.bindRenderbuffer.set(null), o;
  }
  createFramebuffer(e, t, i, n) {
    return new Du(this, e, t, i, n);
  }
  clear({ color: e, depth: t, stencil: i }) {
    let n = this.gl, o = 0;
    e && (o |= n.COLOR_BUFFER_BIT, this.clearColor.set(e), this.colorMask.set([true, true, true, true])), typeof t < "u" && (o |= n.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(t), this.depthMask.set(true)), typeof i < "u" && (o |= n.STENCIL_BUFFER_BIT, this.clearStencil.set(i), this.stencilMask.set(255)), n.clear(o);
  }
  setCullFace(e) {
    e.enable === false ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(e.mode), this.frontFace.set(e.frontFace));
  }
  setDepthMode(e) {
    e.func === this.gl.ALWAYS && !e.mask ? this.depthTest.set(false) : (this.depthTest.set(true), this.depthFunc.set(e.func), this.depthMask.set(e.mask), this.depthRange.set(e.range));
  }
  setStencilMode(e) {
    e.test.func === this.gl.ALWAYS && !e.mask ? this.stencilTest.set(false) : (this.stencilTest.set(true), this.stencilMask.set(e.mask), this.stencilOp.set([e.fail, e.depthFail, e.pass]), this.stencilFunc.set({ func: e.test.func, ref: e.ref, mask: e.test.mask }));
  }
  setColorMode(e) {
    Kt(e.blendFunction, Ce.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(e.blendFunction), this.blendColor.set(e.blendColor)), this.colorMask.set(e.mask);
  }
  createVertexArray() {
    var e;
    return hn(this.gl) ? this.gl.createVertexArray() : (e = this.gl.getExtension("OES_vertex_array_object")) == null ? void 0 : e.createVertexArrayOES();
  }
  deleteVertexArray(e) {
    var t;
    return hn(this.gl) ? this.gl.deleteVertexArray(e) : (t = this.gl.getExtension("OES_vertex_array_object")) == null ? void 0 : t.deleteVertexArrayOES(e);
  }
  unbindVAO() {
    this.bindVertexArray.set(null);
  }
};
c();
var Q = class {
  constructor(e, t, i) {
    this.func = e, this.mask = t, this.range = i;
  }
};
Q.ReadOnly = false;
Q.ReadWrite = true;
Q.disabled = new Q(519, Q.ReadOnly, [0, 1]);
c();
var he = class {
  constructor(e, t, i, n, o, a) {
    this.test = e, this.ref = t, this.mask = i, this.fail = n, this.depthFail = o, this.pass = a;
  }
};
he.disabled = new he({ func: 519, mask: 0 }, 0, 0, 7680, 7680, 7680);
c();
var le = class {
  constructor(e, t, i) {
    this.enable = e, this.mode = t, this.frontFace = i;
  }
};
le.disabled = new le(false, 1029, 2305);
le.backCCW = new le(true, 1029, 2305);
c();
var wh = s(ye(), 1);
c();
var Fu;
function vh(r50, e, t, i, n, o, a) {
  let s3 = r50.context, l = s3.gl, u = r50.useProgram("collisionBox"), c3 = [], p = 0, h = 0;
  for (let v = 0; v < i.length; v++) {
    let b = i[v], w = e.getTile(b), S = w.getBucket(t);
    if (!S) continue;
    let P = b.posMatrix;
    (n[0] !== 0 || n[1] !== 0) && (P = r50.translatePosMatrix(b.posMatrix, w, n, o));
    let k = a ? S.textCollisionBox : S.iconCollisionBox, I = S.collisionCircleArray;
    if (I.length > 0) {
      let C = G.create(), M = P;
      G.mul(C, S.placementInvProjMatrix, r50.transform.glCoordMatrix), G.mul(C, C, S.placementViewportMatrix), c3.push({ circleArray: I, circleOffset: h, transform: M, invTransform: C, coord: b }), p += I.length / 4, h = p;
    }
    k && u.draw(s3, l.LINES, Q.disabled, he.disabled, r50.colorModeForRenderPass(), le.disabled, ib(P, r50.transform, w), r50.style.map.terrain && r50.style.map.terrain.getTerrainData(b), t.id, k.layoutVertexBuffer, k.indexBuffer, k.segments, null, r50.transform.zoom, null, null, k.collisionVertexBuffer);
  }
  if (!a || !c3.length) return;
  let f = r50.useProgram("collisionCircle"), d = new Rs();
  d.resize(p * 4), d._trim();
  let y = 0;
  for (let v of c3) for (let b = 0; b < v.circleArray.length / 4; b++) {
    let w = b * 4, S = v.circleArray[w + 0], P = v.circleArray[w + 1], k = v.circleArray[w + 2], I = v.circleArray[w + 3];
    d.emplace(y++, S, P, k, I, 0), d.emplace(y++, S, P, k, I, 1), d.emplace(y++, S, P, k, I, 2), d.emplace(y++, S, P, k, I, 3);
  }
  (!Fu || Fu.length < p * 2) && (Fu = BA(p));
  let g = s3.createIndexBuffer(Fu, true), x = s3.createVertexBuffer(d, My.members, true);
  for (let v of c3) {
    let b = nb(v.transform, v.invTransform, r50.transform);
    f.draw(s3, l.TRIANGLES, Q.disabled, he.disabled, r50.colorModeForRenderPass(), le.disabled, b, r50.style.map.terrain && r50.style.map.terrain.getTerrainData(v.coord), t.id, x, g, fe.simpleSegment(0, v.circleOffset * 2, v.circleArray.length, v.circleArray.length / 2), null, r50.transform.zoom, null, null, null);
  }
  x.destroy(), g.destroy();
}
function BA(r50) {
  let e = r50 * 2, t = new Os();
  t.resize(e), t._trim();
  for (let i = 0; i < e; i++) {
    let n = i * 6;
    t.uint16[n + 0] = i * 4 + 0, t.uint16[n + 1] = i * 4 + 1, t.uint16[n + 2] = i * 4 + 2, t.uint16[n + 3] = i * 4 + 2, t.uint16[n + 4] = i * 4 + 3, t.uint16[n + 5] = i * 4 + 0;
  }
  return t;
}
var OA = G.identity(new Float32Array(16));
function Ob(r50, e, t, i, n) {
  if (r50.renderPass !== "translucent") return;
  let o = he.disabled, a = r50.colorModeForRenderPass();
  (t._unevaluatedLayout.hasValue("text-variable-anchor") || t._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && UA(i, r50, t, e, t.layout.get("text-rotation-alignment"), t.layout.get("text-pitch-alignment"), n), t.paint.get("icon-opacity").constantOr(1) !== 0 && Rb(r50, e, t, i, false, t.paint.get("icon-translate"), t.paint.get("icon-translate-anchor"), t.layout.get("icon-rotation-alignment"), t.layout.get("icon-pitch-alignment"), t.layout.get("icon-keep-upright"), o, a), t.paint.get("text-opacity").constantOr(1) !== 0 && Rb(r50, e, t, i, true, t.paint.get("text-translate"), t.paint.get("text-translate-anchor"), t.layout.get("text-rotation-alignment"), t.layout.get("text-pitch-alignment"), t.layout.get("text-keep-upright"), o, a), e.map.showCollisionBoxes && (vh(r50, e, t, i, t.paint.get("text-translate"), t.paint.get("text-translate-anchor"), true), vh(r50, e, t, i, t.paint.get("icon-translate"), t.paint.get("icon-translate-anchor"), false));
}
function VA(r50, e, t, i, n, o) {
  let { horizontalAlign: a, verticalAlign: s3 } = ll(r50), l = -(a - 0.5) * e, u = -(s3 - 0.5) * t;
  return new wh.default((l / n + i[0]) * o, (u / n + i[1]) * o);
}
function UA(r50, e, t, i, n, o, a) {
  let s3 = e.transform, l = n === "map", u = o === "map";
  for (let c3 of r50) {
    let p = i.getTile(c3), h = p.getBucket(t);
    if (!h || !h.text || !h.text.segments.get().length) continue;
    let f = h.textSizeData, d = ui(f, s3.zoom), y = He(p, 1, e.transform.zoom), g = Qo(c3.posMatrix, u, l, e.transform, y), x = t.layout.get("icon-text-fit") !== "none" && h.hasIconData();
    if (d) {
      let v = Math.pow(2, s3.zoom - p.tileID.overscaledZ), b = e.style.map.terrain ? (w, S) => e.style.map.terrain.getElevation(c3, w, S) : null;
      NA(h, l, u, a, s3, g, c3.posMatrix, v, d, x, b);
    }
  }
}
function NA(r50, e, t, i, n, o, a, s3, l, u, c3) {
  let p = r50.text.placedSymbolArray, h = r50.text.dynamicLayoutVertexArray, f = r50.icon.dynamicLayoutVertexArray, d = {};
  h.clear();
  for (let y = 0; y < p.length; y++) {
    let g = p.get(y), x = r50.allowVerticalPlacement && !g.placedOrientation, v = !g.hidden && g.crossTileID && !x ? i[g.crossTileID] : null;
    if (!v) hi(g.numGlyphs, h);
    else {
      let b = new wh.default(g.anchorX, g.anchorY), w = xt(b, t ? a : o, c3), S = ea(n.cameraToCenterDistance, w.signedDistanceFromCamera), P = Qi(r50.textSizeData, l, g) * S / Er;
      t && (P *= r50.tilePixelRatio / s3);
      let { width: k, height: I, anchor: C, textOffset: M, textBoxScale: F } = v, D = VA(C, k, I, M, F, P), E = t ? xt(b.add(D), o, c3).point : w.point.add(e ? D.rotate(-n.angle) : D), T = r50.allowVerticalPlacement && g.placedOrientation === 2 ? Math.PI / 2 : 0;
      for (let N = 0; N < g.numGlyphs; N++) ci(h, E, T);
      u && g.associatedIconIndex >= 0 && (d[g.associatedIconIndex] = { shiftedAnchor: E, angle: T });
    }
  }
  if (u) {
    f.clear();
    let y = r50.icon.placedSymbolArray;
    for (let g = 0; g < y.length; g++) {
      let x = y.get(g);
      if (x.hidden) hi(x.numGlyphs, f);
      else {
        let v = d[g];
        if (!v) hi(x.numGlyphs, f);
        else for (let b = 0; b < x.numGlyphs; b++) ci(f, v.shiftedAnchor, v.angle);
      }
    }
    r50.icon.dynamicLayoutVertexBuffer.updateData(f);
  }
  r50.text.dynamicLayoutVertexBuffer.updateData(h);
}
function GA(r50, e, t) {
  return t.iconsInText && e ? "symbolTextAndIcon" : r50 ? "symbolSDF" : "symbolIcon";
}
function Rb(r50, e, t, i, n, o, a, s3, l, u, c3, p) {
  let h = r50.context, f = h.gl, d = r50.transform, y = s3 === "map", g = l === "map", x = s3 !== "viewport" && t.layout.get("symbol-placement") !== "point", v = y && !g && !x, b = !t.layout.get("symbol-sort-key").isConstant(), w = false, S = r50.depthModeForSublayer(0, Q.ReadOnly), P = t._unevaluatedLayout.hasValue("text-variable-anchor") || t._unevaluatedLayout.hasValue("text-variable-anchor-offset"), k = [];
  for (let I of i) {
    let C = e.getTile(I), M = C.getBucket(t);
    if (!M) continue;
    let F = n ? M.text : M.icon;
    if (!F || !F.segments.get().length || !F.hasVisibleVertices) continue;
    let D = F.programConfigurations.get(t.id), E = n || M.sdfIcons, T = n ? M.textSizeData : M.iconSizeData, N = g || d.pitch !== 0, X = r50.useProgram(GA(E, n, M), D), ie = ui(T, d.zoom), K = r50.style.map.terrain && r50.style.map.terrain.getTerrainData(I), $, Ke = [0, 0], Oe, ue, Te = null, Je;
    if (n) {
      if (Oe = C.glyphAtlasTexture, ue = f.LINEAR, $ = C.glyphAtlasTexture.size, M.iconsInText) {
        Ke = C.imageAtlasTexture.size, Te = C.imageAtlasTexture;
        let je = T.kind === "composite" || T.kind === "camera";
        Je = N || r50.options.rotating || r50.options.zooming || je ? f.LINEAR : f.NEAREST;
      }
    } else {
      let je = t.layout.get("icon-size").constantOr(0) !== 1 || M.iconsNeedLinear;
      Oe = C.imageAtlasTexture, ue = E || r50.options.rotating || r50.options.zooming || je || N ? f.LINEAR : f.NEAREST, $ = C.imageAtlasTexture.size;
    }
    let pr = He(C, 1, r50.transform.zoom), hr = Qo(I.posMatrix, g, y, r50.transform, pr), Lt = Fl(I.posMatrix, g, y, r50.transform, pr), Ht = P && M.hasTextData(), Or = t.layout.get("icon-text-fit") !== "none" && Ht && M.hasIconData();
    if (x) {
      let je = r50.style.map.terrain ? (Xt, Ur) => r50.style.map.terrain.getElevation(I, Xt, Ur) : null, ut = t.layout.get("text-rotation-alignment") === "map";
      Ag(M, I.posMatrix, r50, n, hr, Lt, g, u, ut, je);
    }
    let $t = r50.translatePosMatrix(I.posMatrix, C, o, a), Wt = x || n && P || Or ? OA : hr, Ye = r50.translatePosMatrix(Lt, C, o, a, true), it = E && t.paint.get(n ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0, Qe;
    E ? M.iconsInText ? Qe = Cb(T.kind, ie, v, g, r50, $t, Wt, Ye, $, Ke) : Qe = bh(T.kind, ie, v, g, r50, $t, Wt, Ye, n, $, true) : Qe = xh(T.kind, ie, v, g, r50, $t, Wt, Ye, n, $);
    let Vr = { program: X, buffers: F, uniformValues: Qe, atlasTexture: Oe, atlasTextureIcon: Te, atlasInterpolation: ue, atlasInterpolationIcon: Je, isSDF: E, hasHalo: it };
    if (b && M.canOverlap) {
      w = true;
      let je = F.segments.get();
      for (let ut of je) k.push({ segments: new fe([ut]), sortKey: ut.sortKey, state: Vr, terrainData: K });
    } else k.push({ segments: F.segments, sortKey: 0, state: Vr, terrainData: K });
  }
  w && k.sort((I, C) => I.sortKey - C.sortKey);
  for (let I of k) {
    let C = I.state;
    if (h.activeTexture.set(f.TEXTURE0), C.atlasTexture.bind(C.atlasInterpolation, f.CLAMP_TO_EDGE), C.atlasTextureIcon && (h.activeTexture.set(f.TEXTURE1), C.atlasTextureIcon && C.atlasTextureIcon.bind(C.atlasInterpolationIcon, f.CLAMP_TO_EDGE)), C.isSDF) {
      let M = C.uniformValues;
      C.hasHalo && (M.u_is_halo = 1, Bb(C.buffers, I.segments, t, r50, C.program, S, c3, p, M, I.terrainData)), M.u_is_halo = 0;
    }
    Bb(C.buffers, I.segments, t, r50, C.program, S, c3, p, C.uniformValues, I.terrainData);
  }
}
function Bb(r50, e, t, i, n, o, a, s3, l, u) {
  let c3 = i.context, p = c3.gl;
  n.draw(c3, p.TRIANGLES, o, a, s3, le.disabled, l, u, t.id, r50.layoutVertexBuffer, r50.indexBuffer, e, t.paint, i.transform.zoom, r50.programConfigurations.get(t.id), r50.dynamicLayoutVertexBuffer, r50.opacityVertexBuffer);
}
c();
function Vb(r50, e, t, i) {
  if (r50.renderPass !== "translucent") return;
  let n = t.paint.get("circle-opacity"), o = t.paint.get("circle-stroke-width"), a = t.paint.get("circle-stroke-opacity"), s3 = !t.layout.get("circle-sort-key").isConstant();
  if (n.constantOr(1) === 0 && (o.constantOr(1) === 0 || a.constantOr(1) === 0)) return;
  let l = r50.context, u = l.gl, c3 = r50.depthModeForSublayer(0, Q.ReadOnly), p = he.disabled, h = r50.colorModeForRenderPass(), f = [];
  for (let d = 0; d < i.length; d++) {
    let y = i[d], g = e.getTile(y), x = g.getBucket(t);
    if (!x) continue;
    let v = x.programConfigurations.get(t.id), b = r50.useProgram("circle", v), w = x.layoutVertexBuffer, S = x.indexBuffer, P = r50.style.map.terrain && r50.style.map.terrain.getTerrainData(y), k = eb(r50, y, g, t), I = { programConfiguration: v, program: b, layoutVertexBuffer: w, indexBuffer: S, uniformValues: k, terrainData: P };
    if (s3) {
      let C = x.segments.get();
      for (let M of C) f.push({ segments: new fe([M]), sortKey: M.sortKey, state: I });
    } else f.push({ segments: x.segments, sortKey: 0, state: I });
  }
  s3 && f.sort((d, y) => d.sortKey - y.sortKey);
  for (let d of f) {
    let { programConfiguration: y, program: g, layoutVertexBuffer: x, indexBuffer: v, uniformValues: b, terrainData: w } = d.state, S = d.segments;
    g.draw(l, u.TRIANGLES, c3, p, h, le.disabled, b, w, t.id, x, v, S, t.paint, r50.transform.zoom, y);
  }
}
c();
function Ub(r50, e, t, i) {
  if (t.paint.get("heatmap-opacity") !== 0) if (r50.renderPass === "offscreen") {
    let n = r50.context, o = n.gl, a = he.disabled, s3 = new Ce([o.ONE, o.ONE], W.transparent, [true, true, true, true]);
    qA(n, r50, t), n.clear({ color: W.transparent });
    for (let l = 0; l < i.length; l++) {
      let u = i[l];
      if (e.hasRenderableParent(u)) continue;
      let c3 = e.getTile(u), p = c3.getBucket(t);
      if (!p) continue;
      let h = p.programConfigurations.get(t.id), f = r50.useProgram("heatmap", h), { zoom: d } = r50.transform;
      f.draw(n, o.TRIANGLES, Q.disabled, a, s3, le.disabled, ub(u.posMatrix, c3, d, t.paint.get("heatmap-intensity")), null, t.id, p.layoutVertexBuffer, p.indexBuffer, p.segments, t.paint, r50.transform.zoom, h);
    }
    n.viewport.set([0, 0, r50.width, r50.height]);
  } else r50.renderPass === "translucent" && (r50.context.setColorMode(r50.colorModeForRenderPass()), ZA(r50, t));
}
function qA(r50, e, t) {
  let i = r50.gl;
  r50.activeTexture.set(i.TEXTURE1), r50.viewport.set([0, 0, e.width / 4, e.height / 4]);
  let n = t.heatmapFbo;
  if (n) i.bindTexture(i.TEXTURE_2D, n.colorAttachment.get()), r50.bindFramebuffer.set(n.framebuffer);
  else {
    let o = i.createTexture();
    i.bindTexture(i.TEXTURE_2D, o), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.LINEAR), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, i.LINEAR), n = t.heatmapFbo = r50.createFramebuffer(e.width / 4, e.height / 4, false, false), jA(r50, e, o, n);
  }
}
function jA(r50, e, t, i) {
  var s3, l;
  let n = r50.gl, o = (s3 = r50.HALF_FLOAT) != null ? s3 : n.UNSIGNED_BYTE, a = (l = r50.RGBA16F) != null ? l : n.RGBA;
  n.texImage2D(n.TEXTURE_2D, 0, a, e.width / 4, e.height / 4, 0, n.RGBA, o, null), i.colorAttachment.set(t);
}
function ZA(r50, e) {
  let t = r50.context, i = t.gl, n = e.heatmapFbo;
  if (!n) return;
  t.activeTexture.set(i.TEXTURE0), i.bindTexture(i.TEXTURE_2D, n.colorAttachment.get()), t.activeTexture.set(i.TEXTURE1);
  let o = e.colorRampTexture;
  o || (o = e.colorRampTexture = new _e(t, e.colorRamp, i.RGBA)), o.bind(i.LINEAR, i.CLAMP_TO_EDGE), r50.useProgram("heatmapTexture").draw(t, i.TRIANGLES, Q.disabled, he.disabled, r50.colorModeForRenderPass(), le.disabled, cb(r50, e, 0, 1), null, e.id, r50.viewportBuffer, r50.quadTriangleIndexBuffer, r50.viewportSegments, e.paint, r50.transform.zoom);
}
c();
function Nb(r50, e, t, i) {
  if (r50.renderPass !== "translucent") return;
  let n = t.paint.get("line-opacity"), o = t.paint.get("line-width");
  if (n.constantOr(1) === 0 || o.constantOr(1) === 0) return;
  let a = r50.depthModeForSublayer(0, Q.ReadOnly), s3 = r50.colorModeForRenderPass(), l = t.paint.get("line-dasharray"), u = t.paint.get("line-pattern"), c3 = u.constantOr(1), p = t.paint.get("line-gradient"), h = t.getCrossfadeParameters(), f = c3 ? "linePattern" : l ? "lineSDF" : p ? "lineGradient" : "line", d = r50.context, y = d.gl, g = true;
  for (let x of i) {
    let v = e.getTile(x);
    if (c3 && !v.patternsLoaded()) continue;
    let b = v.getBucket(t);
    if (!b) continue;
    let w = b.programConfigurations.get(t.id), S = r50.context.program.get(), P = r50.useProgram(f, w), k = g || P.program !== S, I = r50.style.map.terrain && r50.style.map.terrain.getTerrainData(x), C = u.constantOr(null);
    if (C && v.imageAtlas) {
      let D = v.imageAtlas, E = D.patternPositions[C.to.toString()], T = D.patternPositions[C.from.toString()];
      E && T && w.setConstantPatternPositions(E, T);
    }
    let M = I ? x : null, F = c3 ? _b(r50, v, t, h, M) : l ? vb(r50, v, t, l, h, M) : p ? bb(r50, v, t, b.lineClipsArray.length, M) : Kl(r50, v, t, M);
    if (c3) d.activeTexture.set(y.TEXTURE0), v.imageAtlasTexture.bind(y.LINEAR, y.CLAMP_TO_EDGE), w.updatePaintBuffers(h);
    else if (l && (k || r50.lineAtlas.dirty)) d.activeTexture.set(y.TEXTURE0), r50.lineAtlas.bind(d);
    else if (p) {
      let D = b.gradients[t.id], E = D.texture;
      if (t.gradientVersion !== D.version) {
        let T = 256;
        if (t.stepInterpolant) {
          let N = e.getSource().maxzoom, X = x.canonical.z === N ? Math.ceil(1 << r50.transform.maxZoom - x.canonical.z) : 1, $ = b.maxLineLength / 8192 * 1024 * X;
          T = Ae(af($), 256, d.maxTextureSize);
        }
        D.gradient = $s({ expression: t.gradientExpression(), evaluationKey: "lineProgress", resolution: T, image: D.gradient || void 0, clips: b.lineClipsArray }), D.texture ? D.texture.update(D.gradient) : D.texture = new _e(d, D.gradient, y.RGBA), D.version = t.gradientVersion, E = D.texture;
      }
      d.activeTexture.set(y.TEXTURE0), E.bind(t.stepInterpolant ? y.NEAREST : y.LINEAR, y.CLAMP_TO_EDGE);
    }
    P.draw(d, y.TRIANGLES, a, r50.stencilModeForClipping(x), s3, le.disabled, F, I, t.id, b.layoutVertexBuffer, b.indexBuffer, b.segments, t.paint, r50.transform.zoom, w, b.layoutVertexBuffer2), g = false;
  }
}
c();
c();
function Ru(r50, e, t, i, n) {
  if (!t || !i || !i.imageAtlas) return;
  let o = i.imageAtlas.patternPositions, a = o[t.to.toString()], s3 = o[t.from.toString()];
  if (!a && s3 && (a = s3), !s3 && a && (s3 = a), !a || !s3) {
    let l = n.getPaintProperty(e);
    a = o[l], s3 = o[l];
  }
  a && s3 && r50.setConstantPatternPositions(a, s3);
}
function qb(r50, e, t, i) {
  let n = t.paint.get("fill-color"), o = t.paint.get("fill-opacity");
  if (o.constantOr(1) === 0) return;
  let a = r50.colorModeForRenderPass(), s3 = t.paint.get("fill-pattern"), l = r50.opaquePassEnabledForLayer() && !s3.constantOr(1) && n.constantOr(W.transparent).a === 1 && o.constantOr(0) === 1 ? "opaque" : "translucent";
  if (r50.renderPass === l) {
    let u = r50.depthModeForSublayer(1, r50.renderPass === "opaque" ? Q.ReadWrite : Q.ReadOnly);
    Gb(r50, e, t, i, u, a, false);
  }
  if (r50.renderPass === "translucent" && t.paint.get("fill-antialias")) {
    let u = r50.depthModeForSublayer(t.getPaintProperty("fill-outline-color") ? 2 : 0, Q.ReadOnly);
    Gb(r50, e, t, i, u, a, true);
  }
}
function Gb(r50, e, t, i, n, o, a) {
  let s3 = r50.context.gl, l = "fill-pattern", u = t.paint.get(l), c3 = u && u.constantOr(1), p = t.getCrossfadeParameters(), h, f, d, y, g;
  a ? (f = c3 && !t.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", h = s3.LINES) : (f = c3 ? "fillPattern" : "fill", h = s3.TRIANGLES);
  let x = u.constantOr(null);
  for (let v of i) {
    let b = e.getTile(v);
    if (c3 && !b.patternsLoaded()) continue;
    let w = b.getBucket(t);
    if (!w) continue;
    let S = w.programConfigurations.get(t.id), P = r50.useProgram(f, S), k = r50.style.map.terrain && r50.style.map.terrain.getTerrainData(v);
    c3 && (r50.context.activeTexture.set(s3.TEXTURE0), b.imageAtlasTexture.bind(s3.LINEAR, s3.CLAMP_TO_EDGE), S.updatePaintBuffers(p)), Ru(S, l, x, b, t);
    let I = k ? v : null, C = I ? I.posMatrix : v.posMatrix, M = r50.translatePosMatrix(C, b, t.paint.get("fill-translate"), t.paint.get("fill-translate-anchor"));
    if (!a) y = w.indexBuffer, g = w.segments, d = c3 ? dh(M, r50, p, b) : mh(M);
    else {
      y = w.indexBuffer2, g = w.segments2;
      let F = [s3.drawingBufferWidth, s3.drawingBufferHeight];
      d = f === "fillOutlinePattern" && c3 ? Yx(M, r50, p, b, F) : Jx(M, F);
    }
    P.draw(r50.context, h, n, r50.stencilModeForClipping(v), o, le.disabled, d, k, t.id, w.layoutVertexBuffer, y, g, t.paint, r50.transform.zoom, S);
  }
}
c();
function jb(r50, e, t, i) {
  let n = t.paint.get("fill-extrusion-opacity");
  if (n !== 0 && r50.renderPass === "translucent") {
    let o = new Q(r50.context.gl.LEQUAL, Q.ReadWrite, r50.depthRangeFor3D);
    if (n === 1 && !t.paint.get("fill-extrusion-pattern").constantOr(1)) {
      let a = r50.colorModeForRenderPass();
      Sh(r50, e, t, i, o, he.disabled, a);
    } else Sh(r50, e, t, i, o, he.disabled, Ce.disabled), Sh(r50, e, t, i, o, r50.stencilModeFor3D(), r50.colorModeForRenderPass());
  }
}
function Sh(r50, e, t, i, n, o, a) {
  let s3 = r50.context, l = s3.gl, u = "fill-extrusion-pattern", c3 = t.paint.get(u), p = c3.constantOr(1), h = t.getCrossfadeParameters(), f = t.paint.get("fill-extrusion-opacity"), d = c3.constantOr(null);
  for (let y of i) {
    let g = e.getTile(y), x = g.getBucket(t);
    if (!x) continue;
    let v = r50.style.map.terrain && r50.style.map.terrain.getTerrainData(y), b = x.programConfigurations.get(t.id), w = r50.useProgram(p ? "fillExtrusionPattern" : "fillExtrusion", b);
    p && (r50.context.activeTexture.set(l.TEXTURE0), g.imageAtlasTexture.bind(l.LINEAR, l.CLAMP_TO_EDGE), b.updatePaintBuffers(h)), Ru(b, u, d, g, t);
    let S = r50.translatePosMatrix(y.posMatrix, g, t.paint.get("fill-extrusion-translate"), t.paint.get("fill-extrusion-translate-anchor")), P = t.paint.get("fill-extrusion-vertical-gradient"), k = p ? Hx(S, r50, P, f, y, h, g) : fh(S, r50, P, f);
    w.draw(s3, s3.gl.TRIANGLES, n, o, a, le.backCCW, k, v, t.id, x.layoutVertexBuffer, x.indexBuffer, x.segments, t.paint, r50.transform.zoom, b, r50.style.map.terrain && x.centroidVertexBuffer);
  }
}
c();
function Zb(r50, e, t, i) {
  if (r50.renderPass !== "offscreen" && r50.renderPass !== "translucent") return;
  let n = r50.context, o = r50.depthModeForSublayer(0, Q.ReadOnly), a = r50.colorModeForRenderPass(), [s3, l] = r50.renderPass === "translucent" ? r50.stencilConfigForOverlap(i) : [{}, i];
  for (let u of l) {
    let c3 = e.getTile(u);
    typeof c3.needsHillshadePrepare < "u" && c3.needsHillshadePrepare && r50.renderPass === "offscreen" ? $A(r50, c3, t, o, he.disabled, a) : r50.renderPass === "translucent" && HA(r50, u, c3, t, o, s3[u.overscaledZ], a);
  }
  n.viewport.set([0, 0, r50.width, r50.height]);
}
function HA(r50, e, t, i, n, o, a) {
  let s3 = r50.context, l = s3.gl, u = t.fbo;
  if (!u) return;
  let c3 = r50.useProgram("hillshade"), p = r50.style.map.terrain && r50.style.map.terrain.getTerrainData(e);
  s3.activeTexture.set(l.TEXTURE0), l.bindTexture(l.TEXTURE_2D, u.colorAttachment.get());
  let h = p ? e : null;
  c3.draw(s3, l.TRIANGLES, n, o, a, le.disabled, fb(r50, t, i, h), p, i.id, r50.rasterBoundsBuffer, r50.quadTriangleIndexBuffer, r50.rasterBoundsSegments);
}
function $A(r50, e, t, i, n, o) {
  let a = r50.context, s3 = a.gl, l = e.dem;
  if (l && l.data) {
    let u = l.dim, c3 = l.stride, p = l.getPixels();
    if (a.activeTexture.set(s3.TEXTURE1), a.pixelStoreUnpackPremultiplyAlpha.set(false), e.demTexture = e.demTexture || r50.getTileTexture(c3), e.demTexture) {
      let f = e.demTexture;
      f.update(p, { premultiply: false }), f.bind(s3.NEAREST, s3.CLAMP_TO_EDGE);
    } else e.demTexture = new _e(a, p, s3.RGBA, { premultiply: false }), e.demTexture.bind(s3.NEAREST, s3.CLAMP_TO_EDGE);
    a.activeTexture.set(s3.TEXTURE0);
    let h = e.fbo;
    if (!h) {
      let f = new _e(a, { width: u, height: u, data: null }, s3.RGBA);
      f.bind(s3.LINEAR, s3.CLAMP_TO_EDGE), h = e.fbo = a.createFramebuffer(u, u, true, false), h.colorAttachment.set(f.texture);
    }
    a.bindFramebuffer.set(h.framebuffer), a.viewport.set([0, 0, u, u]), r50.useProgram("hillshadePrepare").draw(a, s3.TRIANGLES, i, n, o, le.disabled, mb(e.tileID, l), null, t.id, r50.rasterBoundsBuffer, r50.quadTriangleIndexBuffer, r50.rasterBoundsSegments), e.needsHillshadePrepare = false;
  }
}
c();
function Hb(r50, e, t, i) {
  if (r50.renderPass !== "translucent" || t.paint.get("raster-opacity") === 0 || !i.length) return;
  let n = r50.context, o = n.gl, a = e.getSource(), s3 = r50.useProgram("raster"), l = r50.colorModeForRenderPass(), [u, c3] = a instanceof Et ? [{}, i] : r50.stencilConfigForOverlap(i), p = c3[c3.length - 1].overscaledZ, h = !r50.options.moving;
  for (let f of c3) {
    let d = r50.depthModeForSublayer(f.overscaledZ - p, t.paint.get("raster-opacity") === 1 ? Q.ReadWrite : Q.ReadOnly, o.LESS), y = e.getTile(f);
    y.registerFadeDuration(t.paint.get("raster-fade-duration"));
    let g = e.findLoadedParent(f, 0), x = WA(y, g, e, t, r50.transform, r50.style.map.terrain), v, b, w = t.paint.get("raster-resampling") === "nearest" ? o.NEAREST : o.LINEAR;
    n.activeTexture.set(o.TEXTURE0), y.texture.bind(w, o.CLAMP_TO_EDGE, o.LINEAR_MIPMAP_NEAREST), n.activeTexture.set(o.TEXTURE1), g ? (g.texture.bind(w, o.CLAMP_TO_EDGE, o.LINEAR_MIPMAP_NEAREST), v = Math.pow(2, g.tileID.overscaledZ - y.tileID.overscaledZ), b = [y.tileID.canonical.x * v % 1, y.tileID.canonical.y * v % 1]) : y.texture.bind(w, o.CLAMP_TO_EDGE, o.LINEAR_MIPMAP_NEAREST);
    let S = r50.style.map.terrain && r50.style.map.terrain.getTerrainData(f), P = S ? f : null, k = P ? P.posMatrix : r50.transform.calculatePosMatrix(f.toUnwrapped(), h), I = Tb(k, b || [0, 0], v || 1, x, t);
    a instanceof Et ? s3.draw(n, o.TRIANGLES, d, he.disabled, l, le.disabled, I, S, t.id, a.boundsBuffer, r50.quadTriangleIndexBuffer, a.boundsSegments) : s3.draw(n, o.TRIANGLES, d, u[f.overscaledZ], l, le.disabled, I, S, t.id, r50.rasterBoundsBuffer, r50.quadTriangleIndexBuffer, r50.rasterBoundsSegments);
  }
}
function WA(r50, e, t, i, n, o) {
  let a = i.paint.get("raster-fade-duration");
  if (!o && a > 0) {
    let s3 = J.now(), l = (s3 - r50.timeAdded) / a, u = e ? (s3 - e.timeAdded) / a : -1, c3 = t.getSource(), p = n.coveringZoomLevel({ tileSize: c3.tileSize, roundZoom: c3.roundZoom }), h = !e || Math.abs(e.tileID.overscaledZ - p) > Math.abs(r50.tileID.overscaledZ - p), f = h && r50.refreshedUponExpiration ? 1 : Ae(h ? l : 1 - u, 0, 1);
    return r50.refreshedUponExpiration && l >= 1 && (r50.refreshedUponExpiration = false), e ? { opacity: 1, mix: 1 - f } : { opacity: f, mix: 0 };
  } else return { opacity: 1, mix: 0 };
}
c();
function $b(r50, e, t, i) {
  let n = t.paint.get("background-color"), o = t.paint.get("background-opacity");
  if (o === 0) return;
  let a = r50.context, s3 = a.gl, l = r50.transform, u = l.tileSize, c3 = t.paint.get("background-pattern");
  if (r50.isPatternMissing(c3)) return;
  let p = !c3 && n.a === 1 && o === 1 && r50.opaquePassEnabledForLayer() ? "opaque" : "translucent";
  if (r50.renderPass !== p) return;
  let h = he.disabled, f = r50.depthModeForSublayer(0, p === "opaque" ? Q.ReadWrite : Q.ReadOnly), d = r50.colorModeForRenderPass(), y = r50.useProgram(c3 ? "backgroundPattern" : "background"), g = i || l.coveringTiles({ tileSize: u, terrain: r50.style.map.terrain });
  c3 && (a.activeTexture.set(s3.TEXTURE0), r50.imageManager.bind(r50.context));
  let x = t.getCrossfadeParameters();
  for (let v of g) {
    let b = i ? v.posMatrix : r50.transform.calculatePosMatrix(v.toUnwrapped()), w = c3 ? Db(b, o, r50, c3, { tileID: v, tileSize: u }, x) : Lb(b, o, n), S = r50.style.map.terrain && r50.style.map.terrain.getTerrainData(v);
    y.draw(a, s3.TRIANGLES, f, h, d, le.disabled, w, S, t.id, r50.tileExtentBuffer, r50.quadTriangleIndexBuffer, r50.tileExtentSegments);
  }
}
c();
var XA = new W(1, 0, 0, 1);
var KA = new W(0, 1, 0, 1);
var JA = new W(0, 0, 1, 1);
var YA = new W(1, 0, 1, 1);
var QA = new W(0, 1, 1, 1);
function Kb(r50) {
  let e = r50.transform.padding, t = 3;
  Wb(r50, r50.transform.height - (e.top || 0), t, XA), Wb(r50, e.bottom || 0, t, KA), Xb(r50, e.left || 0, t, JA), Xb(r50, r50.transform.width - (e.right || 0), t, YA);
  let i = r50.transform.centerPoint;
  eM(r50, i.x, r50.transform.height - i.y, QA);
}
function eM(r50, e, t, i) {
  Bu(r50, e - 2 / 2, t - 20 / 2, 2, 20, i), Bu(r50, e - 20 / 2, t - 2 / 2, 20, 2, i);
}
function Wb(r50, e, t, i) {
  Bu(r50, 0, e + t / 2, r50.transform.width, t, i);
}
function Xb(r50, e, t, i) {
  Bu(r50, e - t / 2, 0, t, r50.transform.height, i);
}
function Bu(r50, e, t, i, n, o) {
  let a = r50.context, s3 = a.gl;
  s3.enable(s3.SCISSOR_TEST), s3.scissor(e * r50.pixelRatio, t * r50.pixelRatio, i * r50.pixelRatio, n * r50.pixelRatio), a.clear({ color: o }), s3.disable(s3.SCISSOR_TEST);
}
function Jb(r50, e, t) {
  for (let i = 0; i < t.length; i++) tM(r50, e, t[i]);
}
function tM(r50, e, t) {
  let i = r50.context, n = i.gl, o = t.posMatrix, a = r50.useProgram("debug"), s3 = Q.disabled, l = he.disabled, u = r50.colorModeForRenderPass(), c3 = "$debug", p = r50.style.map.terrain && r50.style.map.terrain.getTerrainData(t);
  i.activeTexture.set(n.TEXTURE0);
  let h = e.getTileByID(t.key).latestRawTileData, f = h && h.byteLength || 0, d = Math.floor(f / 1024), y = e.getTile(t).tileSize, g = 512 / Math.min(y, 512) * (t.overscaledZ / r50.transform.zoom) * 0.5, x = t.canonical.toString();
  t.overscaledZ !== t.canonical.z && (x += " => ".concat(t.overscaledZ));
  let v = "".concat(x, " ").concat(d, "kB");
  rM(r50, v), a.draw(i, n.TRIANGLES, s3, l, Ce.alphaBlended, le.disabled, yh(o, W.transparent, g), null, c3, r50.debugBuffer, r50.quadTriangleIndexBuffer, r50.debugSegments), a.draw(i, n.LINE_STRIP, s3, l, u, le.disabled, yh(o, W.red), p, c3, r50.debugBuffer, r50.tileBorderIndexBuffer, r50.debugSegments);
}
function rM(r50, e) {
  r50.initDebugOverlayCanvas();
  let t = r50.debugOverlayCanvas, i = r50.context.gl, n = r50.debugOverlayCanvas.getContext("2d");
  n.clearRect(0, 0, t.width, t.height), n.shadowColor = "white", n.shadowBlur = 2, n.lineWidth = 1.5, n.strokeStyle = "white", n.textBaseline = "top", n.font = "bold 36px Open Sans, sans-serif", n.fillText(e, 5, 5), n.strokeText(e, 5, 5), r50.debugOverlayTexture.update(t), r50.debugOverlayTexture.bind(i.LINEAR, i.CLAMP_TO_EDGE);
}
function Yb(r50, e) {
  let t = null, n = Object.values(r50._layers).flatMap((l) => l.source && !l.isHidden(e) ? [r50.sourceCaches[l.source]] : []), o = n.filter((l) => l.getSource().type === "vector"), a = n.filter((l) => l.getSource().type !== "vector"), s3 = (l) => {
    (!t || t.getSource().maxzoom < l.getSource().maxzoom) && (t = l);
  };
  return o.forEach((l) => s3(l)), t || a.forEach((l) => s3(l)), t;
}
c();
function Qb(r50, e, t) {
  let i = r50.context, n = t.implementation;
  if (r50.renderPass === "offscreen") {
    let o = n.prerender;
    o && (r50.setCustomLayerDefaults(), i.setColorMode(r50.colorModeForRenderPass()), o.call(n, i.gl, r50.transform.customLayerMatrix()), i.setDirty(), r50.setBaseState());
  } else if (r50.renderPass === "translucent") {
    r50.setCustomLayerDefaults(), i.setColorMode(r50.colorModeForRenderPass()), i.setStencilMode(he.disabled);
    let o = n.renderingMode === "3d" ? new Q(r50.context.gl.LEQUAL, Q.ReadWrite, r50.depthRangeFor3D) : r50.depthModeForSublayer(0, Q.ReadOnly);
    i.setDepthMode(o), n.render(i.gl, r50.transform.customLayerMatrix()), i.setDirty(), r50.setBaseState(), i.bindFramebuffer.set(null);
  }
}
c();
function e_(r50, e) {
  let t = r50.context, i = t.gl, n = Ce.unblended, o = new Q(i.LEQUAL, Q.ReadWrite, [0, 1]), a = e.getTerrainMesh(), s3 = e.sourceCache.getRenderableTiles(), l = r50.useProgram("terrainDepth");
  t.bindFramebuffer.set(e.getFramebuffer("depth").framebuffer), t.viewport.set([0, 0, r50.width / devicePixelRatio, r50.height / devicePixelRatio]), t.clear({ color: W.transparent, depth: 1 });
  for (let u of s3) {
    let c3 = e.getTerrainData(u.tileID), p = r50.transform.calculatePosMatrix(u.tileID.toUnwrapped()), h = Nx(p, e.getMeshFrameDelta(r50.transform.zoom));
    l.draw(t, i.TRIANGLES, o, he.disabled, n, le.backCCW, h, c3, "terrain", a.vertexBuffer, a.indexBuffer, a.segments);
  }
  t.bindFramebuffer.set(null), t.viewport.set([0, 0, r50.width, r50.height]);
}
function t_(r50, e) {
  let t = r50.context, i = t.gl, n = Ce.unblended, o = new Q(i.LEQUAL, Q.ReadWrite, [0, 1]), a = e.getTerrainMesh(), s3 = e.getCoordsTexture(), l = e.sourceCache.getRenderableTiles(), u = r50.useProgram("terrainCoords");
  t.bindFramebuffer.set(e.getFramebuffer("coords").framebuffer), t.viewport.set([0, 0, r50.width / devicePixelRatio, r50.height / devicePixelRatio]), t.clear({ color: W.transparent, depth: 1 }), e.coordsIndex = [];
  for (let c3 of l) {
    let p = e.getTerrainData(c3.tileID);
    t.activeTexture.set(i.TEXTURE0), i.bindTexture(i.TEXTURE_2D, s3.texture);
    let h = r50.transform.calculatePosMatrix(c3.tileID.toUnwrapped()), f = Gx(h, 255 - e.coordsIndex.length, e.getMeshFrameDelta(r50.transform.zoom));
    u.draw(t, i.TRIANGLES, o, he.disabled, n, le.backCCW, f, p, "terrain", a.vertexBuffer, a.indexBuffer, a.segments), e.coordsIndex.push(c3.tileID.key);
  }
  t.bindFramebuffer.set(null), t.viewport.set([0, 0, r50.width, r50.height]);
}
function Ph(r50, e, t) {
  let i = r50.context, n = i.gl, o = r50.colorModeForRenderPass(), a = new Q(n.LEQUAL, Q.ReadWrite, r50.depthRangeFor3D), s3 = r50.useProgram("terrain"), l = e.getTerrainMesh();
  i.bindFramebuffer.set(null), i.viewport.set([0, 0, r50.width, r50.height]);
  for (let u of t) {
    let c3 = r50.renderToTexture.getTexture(u), p = e.getTerrainData(u.tileID);
    i.activeTexture.set(n.TEXTURE0), n.bindTexture(n.TEXTURE_2D, c3.texture);
    let h = r50.transform.calculatePosMatrix(u.tileID.toUnwrapped()), f = Ux(h, e.getMeshFrameDelta(r50.transform.zoom));
    s3.draw(i, n.TRIANGLES, a, he.disabled, o, le.backCCW, f, p, "terrain", l.vertexBuffer, l.indexBuffer, l.segments);
  }
}
var Ou = class {
  constructor(e, t) {
    this.context = new zu(e), this.transform = t, this._tileTextures = {}, this.terrainFacilitator = { dirty: true, matrix: G.identity(new Float64Array(16)), renderTime: 0 }, this.setup(), this.numSublayers = sr.maxUnderzooming + sr.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new cn();
  }
  resize(e, t, i) {
    if (this.width = Math.floor(e * i), this.height = Math.floor(t * i), this.pixelRatio = i, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (let n of this.style._order) this.style._layers[n].resize();
  }
  setup() {
    let e = this.context, t = new Pr();
    t.emplaceBack(0, 0), t.emplaceBack(8192, 0), t.emplaceBack(0, 8192), t.emplaceBack(8192, 8192), this.tileExtentBuffer = e.createVertexBuffer(t, Zl.members), this.tileExtentSegments = fe.simpleSegment(0, 0, 4, 2);
    let i = new Pr();
    i.emplaceBack(0, 0), i.emplaceBack(8192, 0), i.emplaceBack(0, 8192), i.emplaceBack(8192, 8192), this.debugBuffer = e.createVertexBuffer(i, Zl.members), this.debugSegments = fe.simpleSegment(0, 0, 4, 5);
    let n = new Gi();
    n.emplaceBack(0, 0, 0, 0), n.emplaceBack(8192, 0, 8192, 0), n.emplaceBack(0, 8192, 0, 8192), n.emplaceBack(8192, 8192, 8192, 8192), this.rasterBoundsBuffer = e.createVertexBuffer(n, zr.members), this.rasterBoundsSegments = fe.simpleSegment(0, 0, 4, 2);
    let o = new Pr();
    o.emplaceBack(0, 0), o.emplaceBack(1, 0), o.emplaceBack(0, 1), o.emplaceBack(1, 1), this.viewportBuffer = e.createVertexBuffer(o, Zl.members), this.viewportSegments = fe.simpleSegment(0, 0, 4, 2);
    let a = new yo();
    a.emplaceBack(0), a.emplaceBack(1), a.emplaceBack(3), a.emplaceBack(2), a.emplaceBack(0), this.tileBorderIndexBuffer = e.createIndexBuffer(a);
    let s3 = new tt();
    s3.emplaceBack(0, 1, 2), s3.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = e.createIndexBuffer(s3);
    let l = this.context.gl;
    this.stencilClearMode = new he({ func: l.ALWAYS, mask: 0 }, 0, 255, l.ZERO, l.ZERO, l.ZERO);
  }
  clearStencil() {
    let e = this.context, t = e.gl;
    this.nextStencilID = 1, this.currentStencilSource = void 0;
    let i = G.create();
    G.ortho(i, 0, this.width, this.height, 0, 0, 1), G.scale(i, i, [t.drawingBufferWidth, t.drawingBufferHeight, 0]), this.useProgram("clippingMask").draw(e, t.TRIANGLES, Q.disabled, this.stencilClearMode, Ce.disabled, le.disabled, gh(i), null, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
  }
  _renderTileClippingMasks(e, t) {
    if (this.currentStencilSource === e.source || !e.isTileClipped() || !t || !t.length) return;
    this.currentStencilSource = e.source;
    let i = this.context, n = i.gl;
    this.nextStencilID + t.length > 256 && this.clearStencil(), i.setColorMode(Ce.disabled), i.setDepthMode(Q.disabled);
    let o = this.useProgram("clippingMask");
    this._tileClippingMaskIDs = {};
    for (let a of t) {
      let s3 = this._tileClippingMaskIDs[a.key] = this.nextStencilID++, l = this.style.map.terrain && this.style.map.terrain.getTerrainData(a);
      o.draw(i, n.TRIANGLES, Q.disabled, new he({ func: n.ALWAYS, mask: 0 }, s3, 255, n.KEEP, n.KEEP, n.REPLACE), Ce.disabled, le.disabled, gh(a.posMatrix), l, "$clipping", this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
    }
  }
  stencilModeFor3D() {
    this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
    let e = this.nextStencilID++, t = this.context.gl;
    return new he({ func: t.NOTEQUAL, mask: 255 }, e, 255, t.KEEP, t.KEEP, t.REPLACE);
  }
  stencilModeForClipping(e) {
    let t = this.context.gl;
    return new he({ func: t.EQUAL, mask: 255 }, this._tileClippingMaskIDs[e.key], 0, t.KEEP, t.KEEP, t.REPLACE);
  }
  stencilConfigForOverlap(e) {
    let t = this.context.gl, i = e.sort((a, s3) => s3.overscaledZ - a.overscaledZ), n = i[i.length - 1].overscaledZ, o = i[0].overscaledZ - n + 1;
    if (o > 1) {
      this.currentStencilSource = void 0, this.nextStencilID + o > 256 && this.clearStencil();
      let a = {};
      for (let s3 = 0; s3 < o; s3++) a[s3 + n] = new he({ func: t.GEQUAL, mask: 255 }, s3 + this.nextStencilID, 255, t.KEEP, t.KEEP, t.REPLACE);
      return this.nextStencilID += o, [a, i];
    }
    return [{ [n]: he.disabled }, i];
  }
  colorModeForRenderPass() {
    let e = this.context.gl;
    return this._showOverdrawInspector ? new Ce([e.CONSTANT_COLOR, e.ONE], new W(0.125, 0.125, 0.125, 0), [true, true, true, true]) : this.renderPass === "opaque" ? Ce.unblended : Ce.alphaBlended;
  }
  depthModeForSublayer(e, t, i) {
    if (!this.opaquePassEnabledForLayer()) return Q.disabled;
    let n = 1 - ((1 + this.currentLayer) * this.numSublayers + e) * this.depthEpsilon;
    return new Q(i || this.context.gl.LEQUAL, t, [n, n]);
  }
  opaquePassEnabledForLayer() {
    return this.currentLayer < this.opaquePassCutoff;
  }
  render(e, t) {
    this.style = e, this.options = t, this.lineAtlas = e.lineAtlas, this.imageManager = e.imageManager, this.glyphManager = e.glyphManager, this.symbolFadeChange = e.placement.symbolFadeChange(J.now()), this.imageManager.beginFrame();
    let i = this.style._order, n = this.style.sourceCaches, o = {}, a = {}, s3 = {};
    for (let l in n) {
      let u = n[l];
      u.used && u.prepare(this.context), o[l] = u.getVisibleCoordinates(), a[l] = o[l].slice().reverse(), s3[l] = u.getVisibleCoordinates(true).reverse();
    }
    this.opaquePassCutoff = 1 / 0;
    for (let l = 0; l < i.length; l++) {
      let u = i[l];
      if (this.style._layers[u].is3D()) {
        this.opaquePassCutoff = l;
        break;
      }
    }
    this.maybeDrawDepthAndCoords(false), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
    for (let l of i) {
      let u = this.style._layers[l];
      if (!u.hasOffscreenPass() || u.isHidden(this.transform.zoom)) continue;
      let c3 = a[u.source];
      u.type !== "custom" && !c3.length || this.renderLayer(this, n[u.source], u, c3);
    }
    if (this.context.bindFramebuffer.set(null), this.context.clear({ color: t.showOverdrawInspector ? W.black : W.transparent, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = t.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture) for (this.renderPass = "opaque", this.currentLayer = i.length - 1; this.currentLayer >= 0; this.currentLayer--) {
      let l = this.style._layers[i[this.currentLayer]], u = n[l.source], c3 = o[l.source];
      this._renderTileClippingMasks(l, c3), this.renderLayer(this, u, l, c3);
    }
    for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < i.length; this.currentLayer++) {
      let l = this.style._layers[i[this.currentLayer]], u = n[l.source];
      if (this.renderToTexture && this.renderToTexture.renderLayer(l)) continue;
      let c3 = (l.type === "symbol" ? s3 : a)[l.source];
      this._renderTileClippingMasks(l, o[l.source]), this.renderLayer(this, u, l, c3);
    }
    if (this.options.showTileBoundaries) {
      let l = Yb(this.style, this.transform.zoom);
      l && Jb(this, l, l.getVisibleCoordinates());
    }
    this.options.showPadding && Kb(this), this.context.setDefault();
  }
  maybeDrawDepthAndCoords(e) {
    if (!this.style || !this.style.map || !this.style.map.terrain) return;
    let t = this.terrainFacilitator.matrix, i = this.transform.projMatrix, n = this.terrainFacilitator.dirty;
    n || (n = e ? !G.exactEquals(t, i) : !G.equals(t, i)), n || (n = this.style.map.terrain.sourceCache.tilesAfterTime(this.terrainFacilitator.renderTime).length > 0), n && (G.copy(t, i), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = false, e_(this, this.style.map.terrain), t_(this, this.style.map.terrain));
  }
  renderLayer(e, t, i, n) {
    if (!i.isHidden(this.transform.zoom) && !(i.type !== "background" && i.type !== "custom" && !(n || []).length)) switch (this.id = i.id, i.type) {
      case "symbol":
        Ob(e, t, i, n, this.style.placement.variableOffsets);
        break;
      case "circle":
        Vb(e, t, i, n);
        break;
      case "heatmap":
        Ub(e, t, i, n);
        break;
      case "line":
        Nb(e, t, i, n);
        break;
      case "fill":
        qb(e, t, i, n);
        break;
      case "fill-extrusion":
        jb(e, t, i, n);
        break;
      case "hillshade":
        Zb(e, t, i, n);
        break;
      case "raster":
        Hb(e, t, i, n);
        break;
      case "background":
        $b(e, t, i, n);
        break;
      case "custom":
        Qb(e, t, i);
        break;
    }
  }
  translatePosMatrix(e, t, i, n, o) {
    if (!i[0] && !i[1]) return e;
    let a = o ? n === "map" ? this.transform.angle : 0 : n === "viewport" ? -this.transform.angle : 0;
    if (a) {
      let u = Math.sin(a), c3 = Math.cos(a);
      i = [i[0] * c3 - i[1] * u, i[0] * u + i[1] * c3];
    }
    let s3 = [o ? i[0] : He(t, i[0], this.transform.zoom), o ? i[1] : He(t, i[1], this.transform.zoom), 0], l = new Float32Array(16);
    return G.translate(l, e, s3), l;
  }
  saveTileTexture(e) {
    let t = this._tileTextures[e.size[0]];
    t ? t.push(e) : this._tileTextures[e.size[0]] = [e];
  }
  getTileTexture(e) {
    let t = this._tileTextures[e];
    return t && t.length > 0 ? t.pop() : null;
  }
  isPatternMissing(e) {
    if (!e) return false;
    if (!e.from || !e.to) return true;
    let t = this.imageManager.getPattern(e.from.toString()), i = this.imageManager.getPattern(e.to.toString());
    return !t || !i;
  }
  useProgram(e, t) {
    this.cache = this.cache || {};
    let i = e + (t ? t.cacheKey : "") + (this._showOverdrawInspector ? "/overdraw" : "") + (this.style.map.terrain ? "/terrain" : "");
    return this.cache[i] || (this.cache[i] = new Wl(this.context, mi[e], t, zb[e], this._showOverdrawInspector, this.style.map.terrain)), this.cache[i];
  }
  setCustomLayerDefaults() {
    this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
  }
  setBaseState() {
    let e = this.context.gl;
    this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e.FUNC_ADD);
  }
  initDebugOverlayCanvas() {
    if (this.debugOverlayCanvas == null) {
      this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512;
      let e = this.context.gl;
      this.debugOverlayTexture = new _e(this.context, this.debugOverlayCanvas, e.RGBA);
    }
  }
  destroy() {
    this.debugOverlayTexture && this.debugOverlayTexture.destroy();
  }
  overLimit() {
    let { drawingBufferWidth: e, drawingBufferHeight: t } = this.context.gl;
    return this.width !== e || this.height !== t;
  }
};
c();
var $e = s(ye(), 1);
c();
var Vu = class r46 {
  constructor(e, t) {
    this.points = e;
    this.planes = t;
  }
  static fromInvProjectionMatrix(e, t, i) {
    let n = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]], o = Math.pow(2, i), a = n.map((u) => {
      u = Ge.transformMat4([], u, e);
      let c3 = 1 / u[3] / t * o;
      return Ge.mul(u, u, [c3, c3, 1 / u[3], c3]);
    }), l = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((u) => {
      let c3 = yt.sub([], a[u[0]], a[u[1]]), p = yt.sub([], a[u[2]], a[u[1]]), h = yt.normalize([], yt.cross([], c3, p)), f = -yt.dot(h, a[u[1]]);
      return h.concat(f);
    });
    return new r46(a, l);
  }
};
var ua = class r47 {
  constructor(e, t) {
    this.min = e, this.max = t, this.center = yt.scale([], yt.add([], this.min, this.max), 0.5);
  }
  quadrant(e) {
    let t = [e % 2 === 0, e < 2], i = yt.clone(this.min), n = yt.clone(this.max);
    for (let o = 0; o < t.length; o++) i[o] = t[o] ? this.min[o] : this.center[o], n[o] = t[o] ? this.center[o] : this.max[o];
    return n[2] = this.max[2], new r47(i, n);
  }
  distanceX(e) {
    return Math.max(Math.min(this.max[0], e[0]), this.min[0]) - e[0];
  }
  distanceY(e) {
    return Math.max(Math.min(this.max[1], e[1]), this.min[1]) - e[1];
  }
  intersects(e) {
    let t = [[this.min[0], this.min[1], this.min[2], 1], [this.max[0], this.min[1], this.min[2], 1], [this.max[0], this.max[1], this.min[2], 1], [this.min[0], this.max[1], this.min[2], 1], [this.min[0], this.min[1], this.max[2], 1], [this.max[0], this.min[1], this.max[2], 1], [this.max[0], this.max[1], this.max[2], 1], [this.min[0], this.max[1], this.max[2], 1]], i = true;
    for (let n = 0; n < e.planes.length; n++) {
      let o = e.planes[n], a = 0;
      for (let s3 = 0; s3 < t.length; s3++) Ge.dot(o, t[s3]) >= 0 && a++;
      if (a === 0) return 0;
      a !== t.length && (i = false);
    }
    if (i) return 2;
    for (let n = 0; n < 3; n++) {
      let o = Number.MAX_VALUE, a = -Number.MAX_VALUE;
      for (let s3 = 0; s3 < e.points.length; s3++) {
        let l = e.points[s3][n] - this.min[n];
        o = Math.min(o, l), a = Math.max(a, l);
      }
      if (a < 0 || o > this.max[n] - this.min[n]) return 0;
    }
    return 1;
  }
};
c();
var r_ = s(ye(), 1);
var ca = class r48 {
  constructor(e = 0, t = 0, i = 0, n = 0) {
    if (isNaN(e) || e < 0 || isNaN(t) || t < 0 || isNaN(i) || i < 0 || isNaN(n) || n < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
    this.top = e, this.bottom = t, this.left = i, this.right = n;
  }
  interpolate(e, t, i) {
    return t.top != null && e.top != null && (this.top = Se.number(e.top, t.top, i)), t.bottom != null && e.bottom != null && (this.bottom = Se.number(e.bottom, t.bottom, i)), t.left != null && e.left != null && (this.left = Se.number(e.left, t.left, i)), t.right != null && e.right != null && (this.right = Se.number(e.right, t.right, i)), this;
  }
  getCenter(e, t) {
    let i = Ae((this.left + e - this.right) / 2, 0, e), n = Ae((this.top + t - this.bottom) / 2, 0, t);
    return new r_.default(i, n);
  }
  equals(e) {
    return this.top === e.top && this.bottom === e.bottom && this.left === e.left && this.right === e.right;
  }
  clone() {
    return new r48(this.top, this.bottom, this.left, this.right);
  }
  toJSON() {
    return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
  }
};
var Uu = 85.051129;
var Nu = class r49 {
  constructor(e, t, i, n, o) {
    this.tileSize = 512, this._renderWorldCopies = o === void 0 ? true : !!o, this._minZoom = e || 0, this._maxZoom = t || 22, this._minPitch = i == null ? 0 : i, this._maxPitch = n == null ? 60 : n, this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new re(0, 0), this._elevation = 0, this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._unmodified = true, this._edgeInsets = new ca(), this._posMatrixCache = {}, this._alignedPosMatrixCache = {}, this.minElevationForCurrentTile = 0;
  }
  clone() {
    let e = new r49(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);
    return e.apply(this), e;
  }
  apply(e) {
    this.tileSize = e.tileSize, this.latRange = e.latRange, this.width = e.width, this.height = e.height, this._center = e._center, this._elevation = e._elevation, this.minElevationForCurrentTile = e.minElevationForCurrentTile, this.zoom = e.zoom, this.angle = e.angle, this._fov = e._fov, this._pitch = e._pitch, this._unmodified = e._unmodified, this._edgeInsets = e._edgeInsets.clone(), this._calcMatrices();
  }
  get minZoom() {
    return this._minZoom;
  }
  set minZoom(e) {
    this._minZoom !== e && (this._minZoom = e, this.zoom = Math.max(this.zoom, e));
  }
  get maxZoom() {
    return this._maxZoom;
  }
  set maxZoom(e) {
    this._maxZoom !== e && (this._maxZoom = e, this.zoom = Math.min(this.zoom, e));
  }
  get minPitch() {
    return this._minPitch;
  }
  set minPitch(e) {
    this._minPitch !== e && (this._minPitch = e, this.pitch = Math.max(this.pitch, e));
  }
  get maxPitch() {
    return this._maxPitch;
  }
  set maxPitch(e) {
    this._maxPitch !== e && (this._maxPitch = e, this.pitch = Math.min(this.pitch, e));
  }
  get renderWorldCopies() {
    return this._renderWorldCopies;
  }
  set renderWorldCopies(e) {
    e === void 0 ? e = true : e === null && (e = false), this._renderWorldCopies = e;
  }
  get worldSize() {
    return this.tileSize * this.scale;
  }
  get centerOffset() {
    return this.centerPoint._sub(this.size._div(2));
  }
  get size() {
    return new $e.default(this.width, this.height);
  }
  get bearing() {
    return -this.angle / Math.PI * 180;
  }
  set bearing(e) {
    let t = -Jt(e, -180, 180) * Math.PI / 180;
    this.angle !== t && (this._unmodified = false, this.angle = t, this._calcMatrices(), this.rotationMatrix = _o.create(), _o.rotate(this.rotationMatrix, this.rotationMatrix, this.angle));
  }
  get pitch() {
    return this._pitch / Math.PI * 180;
  }
  set pitch(e) {
    let t = Ae(e, this.minPitch, this.maxPitch) / 180 * Math.PI;
    this._pitch !== t && (this._unmodified = false, this._pitch = t, this._calcMatrices());
  }
  get fov() {
    return this._fov / Math.PI * 180;
  }
  set fov(e) {
    e = Math.max(0.01, Math.min(60, e)), this._fov !== e && (this._unmodified = false, this._fov = e / 180 * Math.PI, this._calcMatrices());
  }
  get zoom() {
    return this._zoom;
  }
  set zoom(e) {
    let t = Math.min(Math.max(e, this.minZoom), this.maxZoom);
    this._zoom !== t && (this._unmodified = false, this._zoom = t, this.tileZoom = Math.max(0, Math.floor(t)), this.scale = this.zoomScale(t), this._constrain(), this._calcMatrices());
  }
  get center() {
    return this._center;
  }
  set center(e) {
    e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = false, this._center = e, this._constrain(), this._calcMatrices());
  }
  get elevation() {
    return this._elevation;
  }
  set elevation(e) {
    e !== this._elevation && (this._elevation = e, this._constrain(), this._calcMatrices());
  }
  get padding() {
    return this._edgeInsets.toJSON();
  }
  set padding(e) {
    this._edgeInsets.equals(e) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, e, 1), this._calcMatrices());
  }
  get centerPoint() {
    return this._edgeInsets.getCenter(this.width, this.height);
  }
  isPaddingEqual(e) {
    return this._edgeInsets.equals(e);
  }
  interpolatePadding(e, t, i) {
    this._unmodified = false, this._edgeInsets.interpolate(e, t, i), this._constrain(), this._calcMatrices();
  }
  coveringZoomLevel(e) {
    let t = (e.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / e.tileSize));
    return Math.max(0, t);
  }
  getVisibleUnwrappedCoordinates(e) {
    let t = [new an(0, e)];
    if (this._renderWorldCopies) {
      let i = this.pointCoordinate(new $e.default(0, 0)), n = this.pointCoordinate(new $e.default(this.width, 0)), o = this.pointCoordinate(new $e.default(this.width, this.height)), a = this.pointCoordinate(new $e.default(0, this.height)), s3 = Math.floor(Math.min(i.x, n.x, o.x, a.x)), l = Math.floor(Math.max(i.x, n.x, o.x, a.x)), u = 1;
      for (let c3 = s3 - u; c3 <= l + u; c3++) c3 !== 0 && t.push(new an(c3, e));
    }
    return t;
  }
  coveringTiles(e) {
    var x, v;
    let t = this.coveringZoomLevel(e), i = t;
    if (e.minzoom !== void 0 && t < e.minzoom) return [];
    e.maxzoom !== void 0 && t > e.maxzoom && (t = e.maxzoom);
    let n = this.pointCoordinate(this.getCameraPoint()), o = ze.fromLngLat(this.center), a = Math.pow(2, t), s3 = [a * n.x, a * n.y, 0], l = [a * o.x, a * o.y, 0], u = Vu.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, t), c3 = e.minzoom || 0;
    !e.terrain && this.pitch <= 60 && this._edgeInsets.top < 0.1 && (c3 = t);
    let p = e.terrain ? 2 / Math.min(this.tileSize, e.tileSize) * this.tileSize : 3, h = (b) => ({ aabb: new ua([b * a, 0, 0], [(b + 1) * a, a, 0]), zoom: 0, x: 0, y: 0, wrap: b, fullyVisible: false }), f = [], d = [], y = t, g = e.reparseOverscaled ? i : t;
    if (this._renderWorldCopies) for (let b = 1; b <= 3; b++) f.push(h(-b)), f.push(h(b));
    for (f.push(h(0)); f.length > 0; ) {
      let b = f.pop(), w = b.x, S = b.y, P = b.fullyVisible;
      if (!P) {
        let D = b.aabb.intersects(u);
        if (D === 0) continue;
        P = D === 2;
      }
      let k = e.terrain ? s3 : l, I = b.aabb.distanceX(k), C = b.aabb.distanceY(k), M = Math.max(Math.abs(I), Math.abs(C)), F = p + (1 << y - b.zoom) - 2;
      if (b.zoom === y || M > F && b.zoom >= c3) {
        let D = y - b.zoom, E = s3[0] - 0.5 - (w << D), T = s3[1] - 0.5 - (S << D);
        d.push({ tileID: new Xe(b.zoom === y ? g : b.zoom, b.wrap, b.zoom, w, S), distanceSq: Zi.sqrLen([l[0] - 0.5 - w, l[1] - 0.5 - S]), tileDistanceToCamera: Math.sqrt(E * E + T * T) });
        continue;
      }
      for (let D = 0; D < 4; D++) {
        let E = (w << 1) + D % 2, T = (S << 1) + (D >> 1), N = b.zoom + 1, X = b.aabb.quadrant(D);
        if (e.terrain) {
          let ie = new Xe(N, b.wrap, N, E, T), K = e.terrain.getMinMaxElevation(ie), $ = (x = K.minElevation) != null ? x : this.elevation, Ke = (v = K.maxElevation) != null ? v : this.elevation;
          X = new ua([X.min[0], X.min[1], $], [X.max[0], X.max[1], Ke]);
        }
        f.push({ aabb: X, zoom: N, x: E, y: T, wrap: b.wrap, fullyVisible: P });
      }
    }
    return d.sort((b, w) => b.distanceSq - w.distanceSq).map((b) => b.tileID);
  }
  resize(e, t) {
    this.width = e, this.height = t, this.pixelsToGLUnits = [2 / e, -2 / t], this._constrain(), this._calcMatrices();
  }
  get unmodified() {
    return this._unmodified;
  }
  zoomScale(e) {
    return Math.pow(2, e);
  }
  scaleZoom(e) {
    return Math.log(e) / Math.LN2;
  }
  project(e) {
    let t = Ae(e.lat, -Uu, Uu);
    return new $e.default(Lr(e.lng) * this.worldSize, Dr(t) * this.worldSize);
  }
  unproject(e) {
    return new ze(e.x / this.worldSize, e.y / this.worldSize).toLngLat();
  }
  get point() {
    return this.project(this.center);
  }
  getCameraPosition() {
    let e = this.pointLocation(this.getCameraPoint()), t = Math.cos(this._pitch) * this.cameraToCenterDistance / this._pixelPerMeter;
    return { lngLat: e, altitude: t + this.elevation };
  }
  recalculateZoom(e) {
    let t = this.elevation, i = Math.cos(this._pitch) * this.cameraToCenterDistance / this._pixelPerMeter, n = this.pointLocation(this.centerPoint, e), o = e.getElevationForLngLatZoom(n, this.tileZoom);
    if (!(this.elevation - o)) return;
    let s3 = i + t - o, c3 = Math.cos(this._pitch) * this.cameraToCenterDistance / s3 / Il(1, n.lat) / this.tileSize, p = this.scaleZoom(c3);
    this._elevation = o, this._center = n, this.zoom = p;
  }
  setLocationAtPoint(e, t) {
    let i = this.pointCoordinate(t), n = this.pointCoordinate(this.centerPoint), o = this.locationCoordinate(e), a = new ze(o.x - (i.x - n.x), o.y - (i.y - n.y));
    this.center = this.coordinateLocation(a), this._renderWorldCopies && (this.center = this.center.wrap());
  }
  locationPoint(e, t) {
    return t ? this.coordinatePoint(this.locationCoordinate(e), t.getElevationForLngLatZoom(e, this.tileZoom), this.pixelMatrix3D) : this.coordinatePoint(this.locationCoordinate(e));
  }
  pointLocation(e, t) {
    return this.coordinateLocation(this.pointCoordinate(e, t));
  }
  locationCoordinate(e) {
    return ze.fromLngLat(e);
  }
  coordinateLocation(e) {
    return e && e.toLngLat();
  }
  pointCoordinate(e, t) {
    if (t) {
      let y = t.pointCoordinate(e);
      if (y != null) return y;
    }
    let i = 0, n = [e.x, e.y, 0, 1], o = [e.x, e.y, 1, 1];
    Ge.transformMat4(n, n, this.pixelMatrixInverse), Ge.transformMat4(o, o, this.pixelMatrixInverse);
    let a = n[3], s3 = o[3], l = n[0] / a, u = o[0] / s3, c3 = n[1] / a, p = o[1] / s3, h = n[2] / a, f = o[2] / s3, d = h === f ? 0 : (i - h) / (f - h);
    return new ze(Se.number(l, u, d) / this.worldSize, Se.number(c3, p, d) / this.worldSize);
  }
  coordinatePoint(e, t = 0, i = this.pixelMatrix) {
    let n = [e.x * this.worldSize, e.y * this.worldSize, t, 1];
    return Ge.transformMat4(n, n, i), new $e.default(n[0] / n[3], n[1] / n[3]);
  }
  getBounds() {
    let e = Math.max(0, this.height / 2 - this.getHorizon());
    return new lt().extend(this.pointLocation(new $e.default(0, e))).extend(this.pointLocation(new $e.default(this.width, e))).extend(this.pointLocation(new $e.default(this.width, this.height))).extend(this.pointLocation(new $e.default(0, this.height)));
  }
  getMaxBounds() {
    return !this.latRange || this.latRange.length !== 2 || !this.lngRange || this.lngRange.length !== 2 ? null : new lt([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]);
  }
  getHorizon() {
    return Math.tan(Math.PI / 2 - this._pitch) * this.cameraToCenterDistance * 0.85;
  }
  setMaxBounds(e) {
    e ? (this.lngRange = [e.getWest(), e.getEast()], this.latRange = [e.getSouth(), e.getNorth()], this._constrain()) : (this.lngRange = null, this.latRange = [-Uu, Uu]);
  }
  calculatePosMatrix(e, t = false) {
    let i = e.key, n = t ? this._alignedPosMatrixCache : this._posMatrixCache;
    if (n[i]) return n[i];
    let o = e.canonical, a = this.worldSize / this.zoomScale(o.z), s3 = o.x + Math.pow(2, o.z) * e.wrap, l = G.identity(new Float64Array(16));
    return G.translate(l, l, [s3 * a, o.y * a, 0]), G.scale(l, l, [a / 8192, a / 8192, 1]), G.multiply(l, t ? this.alignedProjMatrix : this.projMatrix, l), n[i] = new Float32Array(l), n[i];
  }
  customLayerMatrix() {
    return this.mercatorMatrix.slice();
  }
  getConstrained(e, t) {
    t = Ae(+t, this.minZoom, this.maxZoom);
    let i = { center: new re(e.lng, e.lat), zoom: t }, n = this.lngRange;
    if (!this._renderWorldCopies && n === null) {
      let b = 179.9999999999;
      n = [-b, b];
    }
    let o = this.tileSize * this.zoomScale(i.zoom), a = 0, s3 = o, l = 0, u = o, c3 = 0, p = 0, { x: h, y: f } = this.size;
    if (this.latRange) {
      let b = this.latRange;
      a = Dr(b[1]) * o, s3 = Dr(b[0]) * o, s3 - a < f && (c3 = f / (s3 - a));
    }
    n && (l = Jt(Lr(n[0]) * o, 0, o), u = Jt(Lr(n[1]) * o, 0, o), u < l && (u += o), u - l < h && (p = h / (u - l)));
    let { x: d, y } = this.project.call({ worldSize: o }, e), g, x, v = Math.max(p || 0, c3 || 0);
    if (v) {
      let b = new $e.default(p ? (u + l) / 2 : d, c3 ? (s3 + a) / 2 : y);
      return i.center = this.unproject.call({ worldSize: o }, b).wrap(), i.zoom += this.scaleZoom(v), i;
    }
    if (this.latRange) {
      let b = f / 2;
      y - b < a && (x = a + b), y + b > s3 && (x = s3 - b);
    }
    if (n) {
      let b = (l + u) / 2, w = d;
      this._renderWorldCopies && (w = Jt(d, b - o / 2, b + o / 2));
      let S = h / 2;
      w - S < l && (g = l + S), w + S > u && (g = u - S);
    }
    if (g !== void 0 || x !== void 0) {
      let b = new $e.default(g != null ? g : d, x != null ? x : y);
      i.center = this.unproject.call({ worldSize: o }, b).wrap();
    }
    return i;
  }
  _constrain() {
    if (!this.center || !this.width || !this.height || this._constraining) return;
    this._constraining = true;
    let e = this._unmodified, { center: t, zoom: i } = this.getConstrained(this.center, this.zoom);
    this.center = t, this.zoom = i, this._unmodified = e, this._constraining = false;
  }
  _calcMatrices() {
    if (!this.height) return;
    let e = this._fov / 2, t = this.centerOffset, i = this.point.x, n = this.point.y;
    this.cameraToCenterDistance = 0.5 / Math.tan(e) * this.height, this._pixelPerMeter = Il(1, this.center.lat) * this.worldSize;
    let o = G.identity(new Float64Array(16));
    G.scale(o, o, [this.width / 2, -this.height / 2, 1]), G.translate(o, o, [1, -1, 0]), this.labelPlaneMatrix = o, o = G.identity(new Float64Array(16)), G.scale(o, o, [1, -1, 1]), G.translate(o, o, [-1, -1, 0]), G.scale(o, o, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = o;
    let a = this.cameraToCenterDistance + this._elevation * this._pixelPerMeter / Math.cos(this._pitch), s3 = Math.min(this.elevation, this.minElevationForCurrentTile), l = a - s3 * this._pixelPerMeter / Math.cos(this._pitch), u = s3 < 0 ? l : a, c3 = Math.PI / 2 + this._pitch, p = this._fov * (0.5 + t.y / this.height), h = Math.sin(p) * u / Math.sin(Ae(Math.PI - c3 - p, 0.01, Math.PI - 0.01)), f = this.getHorizon(), y = 2 * Math.atan(f / this.cameraToCenterDistance) * (0.5 + t.y / (f * 2)), g = Math.sin(y) * u / Math.sin(Ae(Math.PI - c3 - y, 0.01, Math.PI - 0.01)), x = Math.min(h, g), v = (Math.cos(Math.PI / 2 - this._pitch) * x + u) * 1.01, b = this.height / 50;
    o = new Float64Array(16), G.perspective(o, this._fov, this.width / this.height, b, v), o[8] = -t.x * 2 / this.width, o[9] = t.y * 2 / this.height, G.scale(o, o, [1, -1, 1]), G.translate(o, o, [0, 0, -this.cameraToCenterDistance]), G.rotateX(o, o, this._pitch), G.rotateZ(o, o, this.angle), G.translate(o, o, [-i, -n, 0]), this.mercatorMatrix = G.scale([], o, [this.worldSize, this.worldSize, this.worldSize]), G.scale(o, o, [1, 1, this._pixelPerMeter]), this.pixelMatrix = G.multiply(new Float64Array(16), this.labelPlaneMatrix, o), G.translate(o, o, [0, 0, -this.elevation]), this.projMatrix = o, this.invProjMatrix = G.invert([], o), this.pixelMatrix3D = G.multiply(new Float64Array(16), this.labelPlaneMatrix, o);
    let w = this.width % 2 / 2, S = this.height % 2 / 2, P = Math.cos(this.angle), k = Math.sin(this.angle), I = i - Math.round(i) + P * w + k * S, C = n - Math.round(n) + P * S + k * w, M = new Float64Array(o);
    if (G.translate(M, M, [I > 0.5 ? I - 1 : I, C > 0.5 ? C - 1 : C, 0]), this.alignedProjMatrix = M, o = G.invert(new Float64Array(16), this.pixelMatrix), !o) throw new Error("failed to invert matrix");
    this.pixelMatrixInverse = o, this._posMatrixCache = {}, this._alignedPosMatrixCache = {};
  }
  maxPitchScaleFactor() {
    if (!this.pixelMatrixInverse) return 1;
    let e = this.pointCoordinate(new $e.default(0, 0)), t = [e.x * this.worldSize, e.y * this.worldSize, 0, 1];
    return Ge.transformMat4(t, t, this.pixelMatrix)[3] / this.cameraToCenterDistance;
  }
  getCameraPoint() {
    let e = this._pitch, t = Math.tan(e) * (this.cameraToCenterDistance || 1);
    return this.centerPoint.add(new $e.default(0, t));
  }
  getCameraQueryGeometry(e) {
    let t = this.getCameraPoint();
    if (e.length === 1) return [e[0], t];
    {
      let i = t.x, n = t.y, o = t.x, a = t.y;
      for (let s3 of e) i = Math.min(i, s3.x), n = Math.min(n, s3.y), o = Math.max(o, s3.x), a = Math.max(a, s3.y);
      return [new $e.default(i, n), new $e.default(o, n), new $e.default(o, a), new $e.default(i, a), new $e.default(i, n)];
    }
  }
  lngLatToCameraDepth(e, t) {
    let i = this.locationCoordinate(e), n = [i.x * this.worldSize, i.y * this.worldSize, t, 1];
    return Ge.transformMat4(n, n, this.projMatrix), n[2] / n[3];
  }
};
c();
c();
function Gu(r50, e) {
  let t = false, i = null, n = null, o, a = () => {
    i = null, t && (r50.apply(n, o), i = setTimeout(a, e), t = false);
  };
  return (...s3) => (t = true, n = this, o = s3, i || a(), i);
}
var pa = class {
  constructor(e) {
    this._getCurrentHash = () => {
      let e3 = window.location.hash.replace("#", "");
      if (this._hashName) {
        let t;
        return e3.split("&").map((i) => i.split("=")).forEach((i) => {
          i[0] === this._hashName && (t = i);
        }), (t && t[1] || "").split("/");
      }
      return e3.split("/");
    };
    this._onHashChange = () => {
      let e3 = this._getCurrentHash();
      if (e3.length >= 3 && !e3.some((t) => isNaN(t))) {
        let t = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(e3[3] || 0) : this._map.getBearing();
        return this._map.jumpTo({ center: [+e3[2], +e3[1]], zoom: +e3[0], bearing: t, pitch: +(e3[4] || 0) }), true;
      }
      return false;
    };
    this._updateHashUnthrottled = () => {
      let e3 = window.location.href.replace(/(#.+)?$/, this.getHashString());
      try {
        window.history.replaceState(window.history.state, null, e3);
      } catch {
      }
    };
    this._updateHash = Gu(this._updateHashUnthrottled, 30 * 1e3 / 100);
    this._hashName = e && encodeURIComponent(e);
  }
  addTo(e) {
    return this._map = e, addEventListener("hashchange", this._onHashChange, false), this._map.on("moveend", this._updateHash), this;
  }
  remove() {
    return removeEventListener("hashchange", this._onHashChange, false), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), delete this._map, this;
  }
  getHashString(e) {
    let t = this._map.getCenter(), i = Math.round(this._map.getZoom() * 100) / 100, n = Math.ceil((i * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), o = Math.pow(10, n), a = Math.round(t.lng * o) / o, s3 = Math.round(t.lat * o) / o, l = this._map.getBearing(), u = this._map.getPitch(), c3 = "";
    if (e ? c3 += "/".concat(a, "/").concat(s3, "/").concat(i) : c3 += "".concat(i, "/").concat(s3, "/").concat(a), (l || u) && (c3 += "/".concat(Math.round(l * 10) / 10)), u && (c3 += "/".concat(Math.round(u))), this._hashName) {
      let p = this._hashName, h = false, f = window.location.hash.slice(1).split("&").map((d) => {
        let y = d.split("=")[0];
        return y === p ? (h = true, "".concat(y, "=").concat(c3)) : d;
      }).filter((d) => d);
      return h || f.push("".concat(p, "=").concat(c3)), "#".concat(f.join("&"));
    }
    return "#".concat(c3);
  }
};
c();
c();
var i_ = s(ye(), 1);
var Hu = { linearity: 0.3, easing: gn(0, 0, 0.3, 1) };
var iM = O({ deceleration: 2500, maxSpeed: 1400 }, Hu);
var nM = O({ deceleration: 20, maxSpeed: 1400 }, Hu);
var oM = O({ deceleration: 1e3, maxSpeed: 360 }, Hu);
var aM = O({ deceleration: 1e3, maxSpeed: 90 }, Hu);
var Zu = class {
  constructor(e) {
    this._map = e, this.clear();
  }
  clear() {
    this._inertiaBuffer = [];
  }
  record(e) {
    this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: J.now(), settings: e });
  }
  _drainInertiaBuffer() {
    let e = this._inertiaBuffer, t = J.now(), i = 160;
    for (; e.length > 0 && t - e[0].time > i; ) e.shift();
  }
  _onMoveEnd(e) {
    if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
    let t = { zoom: 0, bearing: 0, pitch: 0, pan: new i_.default(0, 0), pinchAround: void 0, around: void 0 };
    for (let { settings: a } of this._inertiaBuffer) t.zoom += a.zoomDelta || 0, t.bearing += a.bearingDelta || 0, t.pitch += a.pitchDelta || 0, a.panDelta && t.pan._add(a.panDelta), a.around && (t.around = a.around), a.pinchAround && (t.pinchAround = a.pinchAround);
    let n = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, o = {};
    if (t.pan.mag()) {
      let a = ju(t.pan.mag(), n, O({}, iM, e || {}));
      o.offset = t.pan.mult(a.amount / t.pan.mag()), o.center = this._map.transform.center, qu(o, a);
    }
    if (t.zoom) {
      let a = ju(t.zoom, n, nM);
      o.zoom = this._map.transform.zoom + a.amount, qu(o, a);
    }
    if (t.bearing) {
      let a = ju(t.bearing, n, oM);
      o.bearing = this._map.transform.bearing + Ae(a.amount, -179, 179), qu(o, a);
    }
    if (t.pitch) {
      let a = ju(t.pitch, n, aM);
      o.pitch = this._map.transform.pitch + a.amount, qu(o, a);
    }
    if (o.zoom || o.bearing) {
      let a = t.pinchAround === void 0 ? t.around : t.pinchAround;
      o.around = a ? this._map.unproject(a) : this._map.getCenter();
    }
    return this.clear(), O(o, { noMoveStart: true });
  }
};
function qu(r50, e) {
  (!r50.duration || r50.duration < e.duration) && (r50.duration = e.duration, r50.easing = e.easing);
}
function ju(r50, e, t) {
  let { maxSpeed: i, linearity: n, deceleration: o } = t, a = Ae(r50 * n / (e / 1e3), -i, i), s3 = Math.abs(a) / (o * n);
  return { easing: t.easing, duration: s3 * 1e3, amount: a * (s3 / 2) };
}
c();
c();
var n_ = s(ye(), 1);
var rt = class extends z {
  preventDefault() {
    this._defaultPrevented = true;
  }
  get defaultPrevented() {
    return this._defaultPrevented;
  }
  constructor(e, t, i, n = {}) {
    let o = L.mousePos(t.getCanvas(), i), a = t.unproject(o);
    super(e, O({ point: o, lngLat: a, originalEvent: i }, n)), this._defaultPrevented = false, this.target = t;
  }
};
var Rr = class extends z {
  preventDefault() {
    this._defaultPrevented = true;
  }
  get defaultPrevented() {
    return this._defaultPrevented;
  }
  constructor(e, t, i) {
    let n = e === "touchend" ? i.changedTouches : i.touches, o = L.touchPos(t.getCanvasContainer(), n), a = o.map((u) => t.unproject(u)), s3 = o.reduce((u, c3, p, h) => u.add(c3.div(h.length)), new n_.default(0, 0)), l = t.unproject(s3);
    super(e, { points: o, point: s3, lngLats: a, lngLat: l, originalEvent: i }), this._defaultPrevented = false;
  }
};
var ha = class extends z {
  preventDefault() {
    this._defaultPrevented = true;
  }
  get defaultPrevented() {
    return this._defaultPrevented;
  }
  constructor(e, t, i) {
    super(e, { originalEvent: i }), this._defaultPrevented = false;
  }
};
var $u = class {
  constructor(e, t) {
    this._map = e, this._clickTolerance = t.clickTolerance;
  }
  reset() {
    delete this._mousedownPos;
  }
  wheel(e) {
    return this._firePreventable(new ha(e.type, this._map, e));
  }
  mousedown(e, t) {
    return this._mousedownPos = t, this._firePreventable(new rt(e.type, this._map, e));
  }
  mouseup(e) {
    this._map.fire(new rt(e.type, this._map, e));
  }
  click(e, t) {
    this._mousedownPos && this._mousedownPos.dist(t) >= this._clickTolerance || this._map.fire(new rt(e.type, this._map, e));
  }
  dblclick(e) {
    return this._firePreventable(new rt(e.type, this._map, e));
  }
  mouseover(e) {
    this._map.fire(new rt(e.type, this._map, e));
  }
  mouseout(e) {
    this._map.fire(new rt(e.type, this._map, e));
  }
  touchstart(e) {
    return this._firePreventable(new Rr(e.type, this._map, e));
  }
  touchmove(e) {
    this._map.fire(new Rr(e.type, this._map, e));
  }
  touchend(e) {
    this._map.fire(new Rr(e.type, this._map, e));
  }
  touchcancel(e) {
    this._map.fire(new Rr(e.type, this._map, e));
  }
  _firePreventable(e) {
    if (this._map.fire(e), e.defaultPrevented) return {};
  }
  isEnabled() {
    return true;
  }
  isActive() {
    return false;
  }
  enable() {
  }
  disable() {
  }
};
var Wu = class {
  constructor(e) {
    this._map = e;
  }
  reset() {
    this._delayContextMenu = false, this._ignoreContextMenu = true, delete this._contextMenuEvent;
  }
  mousemove(e) {
    this._map.fire(new rt(e.type, this._map, e));
  }
  mousedown() {
    this._delayContextMenu = true, this._ignoreContextMenu = false;
  }
  mouseup() {
    this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new rt("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
  }
  contextmenu(e) {
    this._delayContextMenu ? this._contextMenuEvent = e : this._ignoreContextMenu || this._map.fire(new rt(e.type, this._map, e)), this._map.listens("contextmenu") && e.preventDefault();
  }
  isEnabled() {
    return true;
  }
  isActive() {
    return false;
  }
  enable() {
  }
  disable() {
  }
};
c();
c();
var o_ = s(ye(), 1);
var kt = class {
  constructor(e) {
    this._map = e;
  }
  get transform() {
    return this._map._requestedCameraState || this._map.transform;
  }
  get center() {
    return { lng: this.transform.center.lng, lat: this.transform.center.lat };
  }
  get zoom() {
    return this.transform.zoom;
  }
  get pitch() {
    return this.transform.pitch;
  }
  get bearing() {
    return this.transform.bearing;
  }
  unproject(e) {
    return this.transform.pointLocation(o_.default.convert(e), this._map.terrain);
  }
};
var fa = class {
  constructor(e, t) {
    this._map = e, this._tr = new kt(e), this._el = e.getCanvasContainer(), this._container = e.getContainer(), this._clickTolerance = t.clickTolerance || 1;
  }
  isEnabled() {
    return !!this._enabled;
  }
  isActive() {
    return !!this._active;
  }
  enable() {
    console.warn("boxZoom will not work. Use SDK interaction events instead.");
  }
  disable() {
    this.isEnabled() && (this._enabled = false);
  }
  mousedown(e, t) {
    this.isEnabled() && e.shiftKey && e.button === 0 && (L.disableDrag(), this._startPos = this._lastPos = t, this._active = true);
  }
  mousemoveWindow(e, t) {
    if (!this._active) return;
    let i = t;
    if (this._lastPos.equals(i) || !this._box && i.dist(this._startPos) < this._clickTolerance) return;
    let n = this._startPos;
    this._lastPos = i, this._box || (this._box = L.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", e));
    let o = Math.min(n.x, i.x), a = Math.max(n.x, i.x), s3 = Math.min(n.y, i.y), l = Math.max(n.y, i.y);
    L.setTransform(this._box, "translate(".concat(o, "px,").concat(s3, "px)")), this._box.style.width = "".concat(a - o, "px"), this._box.style.height = "".concat(l - s3, "px");
  }
  mouseupWindow(e, t) {
    if (!this._active || e.button !== 0) return;
    let i = this._startPos, n = t;
    if (this.reset(), L.suppressClick(), i.x === n.x && i.y === n.y) this._fireEvent("boxzoomcancel", e);
    else return this._map.fire(new z("boxzoomend", { originalEvent: e })), { cameraAnimation: (o) => o.fitScreenCoordinates(i, n, this._tr.bearing, { linear: true }) };
  }
  keydown(e) {
    this._active && e.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", e));
  }
  reset() {
    this._active = false, this._container.classList.remove("maplibregl-crosshair"), this._box && (L.remove(this._box), this._box = null), L.enableDrag(), delete this._startPos, delete this._lastPos;
  }
  _fireEvent(e, t) {
    return this._map.fire(new z(e, { originalEvent: t }));
  }
};
c();
c();
var a_ = s(ye(), 1);
c();
function ma(r50, e) {
  if (r50.length !== e.length) throw new Error("The number of touches and points are not equal - touches ".concat(r50.length, ", points ").concat(e.length));
  let t = {};
  for (let i = 0; i < r50.length; i++) t[r50[i].identifier] = e[i];
  return t;
}
function sM(r50) {
  let e = new a_.default(0, 0);
  for (let t of r50) e._add(t);
  return e.div(r50.length);
}
var Ah = 500;
var lM = 500;
var Xu = 30;
var Th = class {
  constructor(e) {
    this.reset(), this.numTouches = e.numTouches;
  }
  reset() {
    delete this.centroid, delete this.startTime, delete this.touches, this.aborted = false;
  }
  touchstart(e, t, i) {
    (this.centroid || i.length > this.numTouches) && (this.aborted = true), !this.aborted && (this.startTime === void 0 && (this.startTime = e.timeStamp), i.length === this.numTouches && (this.centroid = sM(t), this.touches = ma(i, t)));
  }
  touchmove(e, t, i) {
    if (this.aborted || !this.centroid) return;
    let n = ma(i, t);
    for (let o in this.touches) {
      let a = this.touches[o], s3 = n[o];
      (!s3 || s3.dist(a) > Xu) && (this.aborted = true);
    }
  }
  touchend(e, t, i) {
    if ((!this.centroid || e.timeStamp - this.startTime > lM) && (this.aborted = true), i.length === 0) {
      let n = !this.aborted && this.centroid;
      if (this.reset(), n) return n;
    }
  }
};
var di = class {
  constructor(e) {
    this.singleTap = new Th(e), this.numTaps = e.numTaps, this.reset();
  }
  reset() {
    this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
  }
  touchstart(e, t, i) {
    this.singleTap.touchstart(e, t, i);
  }
  touchmove(e, t, i) {
    this.singleTap.touchmove(e, t, i);
  }
  touchend(e, t, i) {
    let n = this.singleTap.touchend(e, t, i);
    if (n) {
      let o = e.timeStamp - this.lastTime < Ah, a = !this.lastTap || this.lastTap.dist(n) < Xu;
      if ((!o || !a) && this.reset(), this.count++, this.lastTime = e.timeStamp, this.lastTap = n, this.count === this.numTaps) return this.reset(), n;
    }
  }
};
var Ku = class {
  constructor(e) {
    this._tr = new kt(e), this._zoomIn = new di({ numTouches: 1, numTaps: 2 }), this._zoomOut = new di({ numTouches: 2, numTaps: 1 }), this.reset();
  }
  reset() {
    this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
  }
  touchstart(e, t, i) {
    this._zoomIn.touchstart(e, t, i), this._zoomOut.touchstart(e, t, i);
  }
  touchmove(e, t, i) {
    this._zoomIn.touchmove(e, t, i), this._zoomOut.touchmove(e, t, i);
  }
  touchend(e, t, i) {
    let n = this._zoomIn.touchend(e, t, i), o = this._zoomOut.touchend(e, t, i), a = this._tr;
    if (n) return this._active = true, e.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (s3) => s3.easeTo({ duration: 300, zoom: a.zoom + 1, around: a.unproject(n) }, { originalEvent: e }) };
    if (o) return this._active = true, e.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (s3) => s3.easeTo({ duration: 300, zoom: a.zoom - 1, around: a.unproject(o) }, { originalEvent: e }) };
  }
  touchcancel() {
    this.reset();
  }
  enable() {
    this._enabled = true;
  }
  disable() {
    this._enabled = false, this.reset();
  }
  isEnabled() {
    return this._enabled;
  }
  isActive() {
    return this._active;
  }
};
c();
c();
var ur = class {
  constructor(e) {
    this._enabled = !!e.enable, this._moveStateManager = e.moveStateManager, this._clickTolerance = e.clickTolerance || 1, this._moveFunction = e.move, this._activateOnStart = !!e.activateOnStart, e.assignEvents(this), this.reset();
  }
  reset(e) {
    this._active = false, this._moved = false, delete this._lastPoint, this._moveStateManager.endMove(e);
  }
  _move(...e) {
    let t = this._moveFunction(...e);
    if (t.bearingDelta || t.pitchDelta || t.around || t.panDelta) return this._active = true, t;
  }
  dragStart(e, t) {
    !this.isEnabled() || this._lastPoint || this._moveStateManager.isValidStartEvent(e) && (this._moveStateManager.startMove(e), this._lastPoint = t.length ? t[0] : t, this._activateOnStart && this._lastPoint && (this._active = true));
  }
  dragMove(e, t) {
    if (!this.isEnabled()) return;
    let i = this._lastPoint;
    if (!i) return;
    if (e.preventDefault(), !this._moveStateManager.isValidMoveEvent(e)) {
      this.reset(e);
      return;
    }
    let n = t.length ? t[0] : t;
    if (!(!this._moved && n.dist(i) < this._clickTolerance)) return this._moved = true, this._lastPoint = n, this._move(i, n);
  }
  dragEnd(e) {
    !this.isEnabled() || !this._lastPoint || this._moveStateManager.isValidEndEvent(e) && (this._moved && L.suppressClick(), this.reset(e));
  }
  enable() {
    this._enabled = true;
  }
  disable() {
    this._enabled = false, this.reset();
  }
  isEnabled() {
    return this._enabled;
  }
  isActive() {
    return this._active;
  }
  getClickTolerance() {
    return this._clickTolerance;
  }
};
c();
var uM = 0;
var cM = 2;
var pM = { [uM]: 1, [cM]: 2 };
function hM(r50, e) {
  let t = pM[e];
  return r50.buttons === void 0 || (r50.buttons & t) !== t;
}
var fn = class {
  constructor(e) {
    this._correctEvent = e.checkCorrectEvent;
  }
  startMove(e) {
    let t = L.mouseButton(e);
    this._eventButton = t;
  }
  endMove(e) {
    delete this._eventButton;
  }
  isValidStartEvent(e) {
    return this._correctEvent(e);
  }
  isValidMoveEvent(e) {
    return !hM(e, this._eventButton);
  }
  isValidEndEvent(e) {
    return L.mouseButton(e) === this._eventButton;
  }
};
var da = class {
  constructor() {
    this._firstTouch = void 0;
  }
  _isOneFingerTouch(e) {
    return e.targetTouches.length === 1;
  }
  _isSameTouchEvent(e) {
    return e.targetTouches[0].identifier === this._firstTouch;
  }
  startMove(e) {
    let t = e.targetTouches[0].identifier;
    this._firstTouch = t;
  }
  endMove(e) {
    delete this._firstTouch;
  }
  isValidStartEvent(e) {
    return this._isOneFingerTouch(e);
  }
  isValidMoveEvent(e) {
    return this._isOneFingerTouch(e) && this._isSameTouchEvent(e);
  }
  isValidEndEvent(e) {
    return this._isOneFingerTouch(e) && this._isSameTouchEvent(e);
  }
};
var Mh = 0;
var s_ = 2;
var Ih = (r50) => {
  r50.mousedown = r50.dragStart, r50.mousemoveWindow = r50.dragMove, r50.mouseup = r50.dragEnd, r50.contextmenu = function(e) {
    e.preventDefault();
  };
};
var l_ = ({ enable: r50, clickTolerance: e }) => {
  let t = new fn({ checkCorrectEvent: (i) => L.mouseButton(i) === Mh && !i.ctrlKey });
  return new ur({ clickTolerance: e, move: (i, n) => ({ around: n, panDelta: n.sub(i) }), activateOnStart: true, moveStateManager: t, enable: r50, assignEvents: Ih });
};
var Ju = ({ enable: r50, clickTolerance: e, bearingDegreesPerPixelMoved: t = 0.8 }) => {
  let i = new fn({ checkCorrectEvent: (n) => L.mouseButton(n) === Mh && n.ctrlKey || L.mouseButton(n) === s_ });
  return new ur({ clickTolerance: e, move: (n, o) => ({ bearingDelta: (o.x - n.x) * t }), moveStateManager: i, enable: r50, assignEvents: Ih });
};
var Yu = ({ enable: r50, clickTolerance: e, pitchDegreesPerPixelMoved: t = -0.5 }) => {
  let i = new fn({ checkCorrectEvent: (n) => L.mouseButton(n) === Mh && n.ctrlKey || L.mouseButton(n) === s_ });
  return new ur({ clickTolerance: e, move: (n, o) => ({ pitchDelta: (o.y - n.y) * t }), moveStateManager: i, enable: r50, assignEvents: Ih });
};
c();
var Qu = s(ye(), 1);
var ec = class {
  constructor(e, t) {
    this._clickTolerance = e.clickTolerance || 1, this._map = t, this.reset();
  }
  reset() {
    this._active = false, this._touches = {}, this._sum = new Qu.default(0, 0);
  }
  minTouchs() {
    return this._map.cooperativeGestures.isEnabled() ? 2 : 1;
  }
  touchstart(e, t, i) {
    return this._calculateTransform(e, t, i);
  }
  touchmove(e, t, i) {
    if (!(!this._active || i.length < this.minTouchs())) return e.preventDefault(), this._calculateTransform(e, t, i);
  }
  touchend(e, t, i) {
    this._calculateTransform(e, t, i), this._active && i.length < this.minTouchs() && this.reset();
  }
  touchcancel() {
    this.reset();
  }
  _calculateTransform(e, t, i) {
    i.length > 0 && (this._active = true);
    let n = ma(i, t), o = new Qu.default(0, 0), a = new Qu.default(0, 0), s3 = 0;
    for (let c3 in n) {
      let p = n[c3], h = this._touches[c3];
      h && (o._add(p), a._add(p.sub(h)), s3++, n[c3] = p);
    }
    if (this._touches = n, s3 < this.minTouchs() || !a.mag()) return;
    let l = a.div(s3);
    return this._sum._add(l), this._sum.mag() < this._clickTolerance ? void 0 : { around: o.div(s3), panDelta: l };
  }
  enable() {
    this._enabled = true;
  }
  disable() {
    this._enabled = false, this.reset();
  }
  isEnabled() {
    return this._enabled;
  }
  isActive() {
    return this._active;
  }
};
c();
var ya = class {
  constructor() {
    this.reset();
  }
  reset() {
    this._active = false, delete this._firstTwoTouches;
  }
  touchstart(e, t, i) {
    this._firstTwoTouches || i.length < 2 || (this._firstTwoTouches = [i[0].identifier, i[1].identifier], this._start([t[0], t[1]]));
  }
  touchmove(e, t, i) {
    if (!this._firstTwoTouches) return;
    e.preventDefault();
    let [n, o] = this._firstTwoTouches, a = tc(i, t, n), s3 = tc(i, t, o);
    if (!a || !s3) return;
    let l = this._aroundCenter ? null : a.add(s3).div(2);
    return this._move([a, s3], l, e);
  }
  touchend(e, t, i) {
    if (!this._firstTwoTouches) return;
    let [n, o] = this._firstTwoTouches, a = tc(i, t, n), s3 = tc(i, t, o);
    a && s3 || (this._active && L.suppressClick(), this.reset());
  }
  touchcancel() {
    this.reset();
  }
  enable(e) {
    this._enabled = true, this._aroundCenter = !!e && e.around === "center";
  }
  disable() {
    this._enabled = false, this.reset();
  }
  isEnabled() {
    return !!this._enabled;
  }
  isActive() {
    return !!this._active;
  }
};
function tc(r50, e, t) {
  for (let i = 0; i < r50.length; i++) if (r50[i].identifier === t) return e[i];
}
var fM = 0.1;
function u_(r50, e) {
  return Math.log(r50 / e) / Math.LN2;
}
var ga = class extends ya {
  reset() {
    super.reset(), delete this._distance, delete this._startDistance;
  }
  _start(e) {
    this._startDistance = this._distance = e[0].dist(e[1]);
  }
  _move(e, t) {
    let i = this._distance;
    if (this._distance = e[0].dist(e[1]), !(!this._active && Math.abs(u_(this._distance, this._startDistance)) < fM)) return this._active = true, { zoomDelta: u_(this._distance, i), pinchAround: t };
  }
};
var mM = 25;
function c_(r50, e) {
  return r50.angleWith(e) * 180 / Math.PI;
}
var xa = class extends ya {
  reset() {
    super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
  }
  _start(e) {
    this._startVector = this._vector = e[0].sub(e[1]), this._minDiameter = e[0].dist(e[1]);
  }
  _move(e, t, i) {
    let n = this._vector;
    if (this._vector = e[0].sub(e[1]), !(!this._active && this._isBelowThreshold(this._vector))) return this._active = true, { bearingDelta: c_(this._vector, n), pinchAround: t };
  }
  _isBelowThreshold(e) {
    this._minDiameter = Math.min(this._minDiameter, e.mag());
    let t = Math.PI * this._minDiameter, i = mM / t * 360, n = c_(e, this._startVector);
    return Math.abs(n) < i;
  }
};
function Ch(r50) {
  return Math.abs(r50.y) > Math.abs(r50.x);
}
var dM = 100;
var ba = class extends ya {
  constructor(t) {
    super();
    this._currentTouchCount = 0;
    this._map = t;
  }
  reset() {
    super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
  }
  touchstart(t, i, n) {
    super.touchstart(t, i, n), this._currentTouchCount = n.length;
  }
  _start(t) {
    this._lastPoints = t, Ch(t[0].sub(t[1])) && (this._valid = false);
  }
  _move(t, i, n) {
    if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
    let o = t[0].sub(this._lastPoints[0]), a = t[1].sub(this._lastPoints[1]);
    return this._valid = this.gestureBeginsVertically(o, a, n.timeStamp), this._valid ? (this._lastPoints = t, this._active = true, { pitchDelta: (o.y + a.y) / 2 * -0.5 }) : void 0;
  }
  gestureBeginsVertically(t, i, n) {
    if (this._valid !== void 0) return this._valid;
    let o = 2, a = t.mag() >= o, s3 = i.mag() >= o;
    if (!a && !s3) return;
    if (!a || !s3) return this._firstMove === void 0 && (this._firstMove = n), n - this._firstMove < dM ? void 0 : false;
    let l = t.y > 0 == i.y > 0;
    return Ch(t) && Ch(i) && l;
  }
};
c();
var yM = { panStep: 100, bearingStep: 15, pitchStep: 10 };
var _a = class {
  constructor(e) {
    this._tr = new kt(e);
    let t = yM;
    this._panStep = t.panStep, this._bearingStep = t.bearingStep, this._pitchStep = t.pitchStep, this._rotationDisabled = false;
  }
  reset() {
    this._active = false;
  }
  keydown(e) {
    if (e.altKey || e.ctrlKey || e.metaKey) return;
    let t = 0, i = 0, n = 0, o = 0, a = 0;
    switch (e.keyCode) {
      case 61:
      case 107:
      case 171:
      case 187:
        t = 1;
        break;
      case 189:
      case 109:
      case 173:
        t = -1;
        break;
      case 37:
        e.shiftKey ? i = -1 : (e.preventDefault(), o = -1);
        break;
      case 39:
        e.shiftKey ? i = 1 : (e.preventDefault(), o = 1);
        break;
      case 38:
        e.shiftKey ? n = 1 : (e.preventDefault(), a = -1);
        break;
      case 40:
        e.shiftKey ? n = -1 : (e.preventDefault(), a = 1);
        break;
      default:
        return;
    }
    return this._rotationDisabled && (i = 0, n = 0), { cameraAnimation: (s3) => {
      let l = this._tr;
      s3.easeTo({ duration: 300, easeId: "keyboardHandler", easing: gM, zoom: t ? Math.round(l.zoom) + t * (e.shiftKey ? 2 : 1) : l.zoom, bearing: l.bearing + i * this._bearingStep, pitch: l.pitch + n * this._pitchStep, offset: [-o * this._panStep, -a * this._panStep], center: l.center }, { originalEvent: e });
    } };
  }
  enable() {
    console.warn("maplibre keyboard events are not supported, use SDK keyboard events instead.");
  }
  disable() {
    this._enabled = false, this.reset();
  }
  isEnabled() {
    return this._enabled;
  }
  isActive() {
    return this._active;
  }
  disableRotation() {
    this._rotationDisabled = true;
  }
  enableRotation() {
    this._rotationDisabled = false;
  }
};
function gM(r50) {
  return r50 * (2 - r50);
}
c();
var p_ = 4.000244140625;
var xM = 1 / 100;
var bM = 1 / 450;
var _M = 2;
var va = class {
  constructor(e, t) {
    this._onTimeout = (e3) => {
      this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(e3);
    };
    this._map = e, this._tr = new kt(e), this._triggerRenderFrame = t, this._delta = 0, this._defaultZoomRate = xM, this._wheelZoomRate = bM;
  }
  setZoomRate(e) {
    this._defaultZoomRate = e;
  }
  setWheelZoomRate(e) {
    this._wheelZoomRate = e;
  }
  isEnabled() {
    return !!this._enabled;
  }
  isActive() {
    return !!this._active || this._finishTimeout !== void 0;
  }
  isZooming() {
    return !!this._zooming;
  }
  enable(e) {
    console.log("Enable maplibre scrollZoom events will not work. Use Mappedin SDK interactions events instead.");
  }
  disable() {
    this.isEnabled() && (this._enabled = false);
  }
  wheel(e) {
    if (!this.isEnabled() || this._map.cooperativeGestures.isEnabled() && !e[this._map.cooperativeGestures._bypassKey]) return;
    let t = e.deltaMode === WheelEvent.DOM_DELTA_LINE ? e.deltaY * 40 : e.deltaY, i = J.now(), n = i - (this._lastWheelEventTime || 0);
    this._lastWheelEventTime = i, t !== 0 && t % p_ === 0 ? this._type = "wheel" : t !== 0 && Math.abs(t) < 4 ? this._type = "trackpad" : n > 400 ? (this._type = null, this._lastValue = t, this._timeout = setTimeout(this._onTimeout, 40, e)) : this._type || (this._type = Math.abs(n * t) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, t += this._lastValue)), e.shiftKey && t && (t = t / 4), this._type && (this._lastWheelEvent = e, this._delta -= t, this._active || this._start(e)), e.preventDefault();
  }
  _start(e) {
    if (!this._delta) return;
    this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
    let t = L.mousePos(this._map.getCanvas(), e), i = this._tr;
    t.y > i.transform.height / 2 - i.transform.getHorizon() ? this._around = re.convert(this._aroundCenter ? i.center : i.unproject(t)) : this._around = re.convert(i.center), this._aroundPoint = i.transform.locationPoint(this._around), this._frameId || (this._frameId = true, this._triggerRenderFrame());
  }
  renderFrame() {
    if (!this._frameId || (this._frameId = null, !this.isActive())) return;
    let e = this._tr.transform;
    if (this._delta !== 0) {
      let s3 = this._type === "wheel" && Math.abs(this._delta) > p_ ? this._wheelZoomRate : this._defaultZoomRate, l = _M / (1 + Math.exp(-Math.abs(this._delta * s3)));
      this._delta < 0 && l !== 0 && (l = 1 / l);
      let u = typeof this._targetZoom == "number" ? e.zoomScale(this._targetZoom) : e.scale;
      this._targetZoom = Math.min(e.maxZoom, Math.max(e.minZoom, e.scaleZoom(u * l))), this._type === "wheel" && (this._startZoom = e.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
    }
    let t = typeof this._targetZoom == "number" ? this._targetZoom : e.zoom, i = this._startZoom, n = this._easing, o = false, a;
    if (this._type === "wheel" && i && n) {
      let s3 = Math.min((J.now() - this._lastWheelEventTime) / 200, 1), l = n(s3);
      a = Se.number(i, t, l), s3 < 1 ? this._frameId || (this._frameId = true) : o = true;
    } else a = t, o = true;
    return this._active = true, o && (this._active = false, this._finishTimeout = setTimeout(() => {
      this._zooming = false, this._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
    }, 200)), { noInertia: true, needsRenderFrame: !o, zoomDelta: a - e.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
  }
  _smoothOutEasing(e) {
    let t = xn;
    if (this._prevEase) {
      let i = this._prevEase, n = (J.now() - i.start) / i.duration, o = i.easing(n + 0.01) - i.easing(n), a = 0.27 / Math.sqrt(o * o + 1e-4) * 0.01, s3 = Math.sqrt(0.27 * 0.27 - a * a);
      t = gn(a, s3, 0.25, 1);
    }
    return this._prevEase = { start: J.now(), duration: e, easing: t }, t;
  }
  reset() {
    this._active = false, this._zooming = false, delete this._targetZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
  }
};
c();
var wa = class {
  constructor(e, t) {
    this._clickZoom = e, this._tapZoom = t;
  }
  enable() {
    this._clickZoom.enable(), this._tapZoom.enable();
  }
  disable() {
    this._clickZoom.disable(), this._tapZoom.disable();
  }
  isEnabled() {
    return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
  }
  isActive() {
    return this._clickZoom.isActive() || this._tapZoom.isActive();
  }
};
c();
var rc = class {
  constructor(e) {
    this._tr = new kt(e), this.reset();
  }
  reset() {
    this._active = false;
  }
  dblclick(e, t) {
    return e.preventDefault(), { cameraAnimation: (i) => {
      i.easeTo({ duration: 300, zoom: this._tr.zoom + (e.shiftKey ? -1 : 1), around: this._tr.unproject(t) }, { originalEvent: e });
    } };
  }
  enable() {
    this._enabled = true;
  }
  disable() {
    this._enabled = false, this.reset();
  }
  isEnabled() {
    return this._enabled;
  }
  isActive() {
    return this._active;
  }
};
c();
var ic = class {
  constructor() {
    this._tap = new di({ numTouches: 1, numTaps: 1 }), this.reset();
  }
  reset() {
    this._active = false, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
  }
  touchstart(e, t, i) {
    if (!this._swipePoint) if (!this._tapTime) this._tap.touchstart(e, t, i);
    else {
      let n = t[0], o = e.timeStamp - this._tapTime < Ah, a = this._tapPoint.dist(n) < Xu;
      !o || !a ? this.reset() : i.length > 0 && (this._swipePoint = n, this._swipeTouch = i[0].identifier);
    }
  }
  touchmove(e, t, i) {
    if (!this._tapTime) this._tap.touchmove(e, t, i);
    else if (this._swipePoint) {
      if (i[0].identifier !== this._swipeTouch) return;
      let n = t[0], o = n.y - this._swipePoint.y;
      return this._swipePoint = n, e.preventDefault(), this._active = true, { zoomDelta: o / 128 };
    }
  }
  touchend(e, t, i) {
    if (this._tapTime) this._swipePoint && i.length === 0 && this.reset();
    else {
      let n = this._tap.touchend(e, t, i);
      n && (this._tapTime = e.timeStamp, this._tapPoint = n);
    }
  }
  touchcancel() {
    this.reset();
  }
  enable() {
    this._enabled = true;
  }
  disable() {
    this._enabled = false, this.reset();
  }
  isEnabled() {
    return this._enabled;
  }
  isActive() {
    return this._active;
  }
};
c();
var Sa = class {
  constructor(e, t, i) {
    this._el = e, this._mousePan = t, this._touchPan = i;
  }
  enable(e) {
    console.log("Maplibre interaction is not supported. Use Mappedin SDK interaction instead");
  }
  disable() {
    this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
  }
  isEnabled() {
    return this._mousePan.isEnabled() && this._touchPan.isEnabled();
  }
  isActive() {
    return this._mousePan.isActive() || this._touchPan.isActive();
  }
};
c();
var Pa = class {
  constructor(e, t, i) {
    this._pitchWithRotate = e.pitchWithRotate, this._mouseRotate = t, this._mousePitch = i;
  }
  enable() {
    console.warn("dragRotate does not work. Use SDK interaction events instead.");
  }
  disable() {
    this._mouseRotate.disable(), this._mousePitch.disable();
  }
  isEnabled() {
    return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
  }
  isActive() {
    return this._mouseRotate.isActive() || this._mousePitch.isActive();
  }
};
c();
var Ta = class {
  constructor(e, t, i, n) {
    this._el = e, this._touchZoom = t, this._touchRotate = i, this._tapDragZoom = n, this._rotationDisabled = false, this._enabled = true;
  }
  enable(e) {
    this._touchZoom.enable(e), this._rotationDisabled || this._touchRotate.enable(e), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
  }
  disable() {
    this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
  }
  isEnabled() {
    return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
  }
  isActive() {
    return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
  }
  disableRotation() {
    this._rotationDisabled = true, this._touchRotate.disable();
  }
  enableRotation() {
    this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
  }
};
c();
var Aa = class {
  constructor(e, t) {
    this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey";
    this._map = e, this._options = t, this._enabled = false;
  }
  isActive() {
    return false;
  }
  reset() {
  }
  _setupUI() {
    if (this._container) return;
    let e = this._map.getCanvasContainer();
    e.classList.add("maplibregl-cooperative-gestures"), this._container = L.create("div", "maplibregl-cooperative-gesture-screen", e);
    let t = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
    this._bypassKey === "metaKey" && (t = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
    let i = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"), n = document.createElement("div");
    n.className = "maplibregl-desktop-message", n.textContent = t, this._container.appendChild(n);
    let o = document.createElement("div");
    o.className = "maplibregl-mobile-message", o.textContent = i, this._container.appendChild(o), this._container.setAttribute("aria-hidden", "true");
  }
  _destoryUI() {
    this._container && (L.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container;
  }
  enable() {
    this._setupUI(), this._enabled = true;
  }
  disable() {
    this._enabled = false, this._destoryUI();
  }
  isEnabled() {
    return this._enabled;
  }
  touchmove(e) {
    this._onCooperativeGesture(e.touches.length === 1);
  }
  wheel(e) {
    this._map.scrollZoom.isEnabled() && this._onCooperativeGesture(!e[this._bypassKey]);
  }
  _onCooperativeGesture(e) {
    !this._enabled || !e || (this._container.classList.add("maplibregl-show"), setTimeout(() => {
      this._container.classList.remove("maplibregl-show");
    }, 100));
  }
};
var h_ = s(ye(), 1);
var nc = (r50) => r50.zoom || r50.drag || r50.pitch || r50.rotate;
var kh = class extends z {
};
function Eh(r50) {
  return r50.panDelta && r50.panDelta.mag() || r50.zoomDelta || r50.bearingDelta || r50.pitchDelta;
}
var oc = class {
  constructor(e, t) {
    this.handleWindowEvent = (e3) => {
      this.handleEvent(e3, "".concat(e3.type, "Window"));
    };
    this.handleEvent = (e3, t3) => {
      if (e3.type === "blur") {
        this.stop(true);
        return;
      }
      this._updatingCamera = true;
      let i3 = e3.type === "renderFrame" ? void 0 : e3, n = { needsRenderFrame: false }, o = {}, a = {}, s3 = e3.touches, l = s3 ? this._getMapTouches(s3) : void 0, u = l ? L.touchPos(this._map.getCanvas(), l) : L.mousePos(this._map.getCanvas(), e3);
      for (let { handlerName: h, handler: f, allowed: d } of this._handlers) {
        if (!f.isEnabled()) continue;
        let y;
        this._blockedByActive(a, d, h) ? f.reset() : f[t3 || e3.type] && (y = f[t3 || e3.type](e3, u, l), this.mergeHandlerResult(n, o, y, h, i3), y && y.needsRenderFrame && this._triggerRenderFrame()), (y || f.isActive()) && (a[h] = f);
      }
      let c3 = {};
      for (let h in this._previousActiveHandlers) a[h] || (c3[h] = i3);
      this._previousActiveHandlers = a, (Object.keys(c3).length || Eh(n)) && (this._changes.push([n, o, c3]), this._triggerRenderFrame()), (Object.keys(a).length || Eh(n)) && this._map._stop(true), this._updatingCamera = false;
      let { cameraAnimation: p } = n;
      p && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], p(this._map));
    };
    this._map = e, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new Zu(e), this._bearingSnap = t.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(t);
    let i = this._el;
    this._listeners = [[i, "touchstart", { passive: true }], [i, "touchmove", { passive: false }], [i, "touchend", void 0], [i, "touchcancel", void 0], [i, "mousedown", void 0], [i, "mousemove", void 0], [i, "mouseup", void 0], [document, "mousemove", { capture: true }], [document, "mouseup", void 0], [i, "mouseover", void 0], [i, "mouseout", void 0], [i, "dblclick", void 0], [i, "click", void 0], [i, "keydown", { capture: false }], [i, "keyup", void 0], [i, "wheel", { passive: false }], [i, "contextmenu", void 0], [window, "blur", void 0]];
    for (let [n, o, a] of this._listeners) ;
  }
  destroy() {
    for (let [e, t, i] of this._listeners) L.removeEventListener(e, t, e === document ? this.handleWindowEvent : this.handleEvent, i);
  }
  _addDefaultHandlers(e) {
    let t = this._map, i = t.getCanvasContainer();
    this._add("mapEvent", new $u(t, e));
    let n = t.boxZoom = new fa(t, e);
    this._add("boxZoom", n), e.interactive && e.boxZoom && n.enable();
    let o = t.cooperativeGestures = new Aa(t, e.cooperativeGestures);
    this._add("cooperativeGestures", o), e.cooperativeGestures && o.enable();
    let a = new Ku(t), s3 = new rc(t);
    t.doubleClickZoom = new wa(s3, a), this._add("tapZoom", a), this._add("clickZoom", s3), e.interactive && e.doubleClickZoom && t.doubleClickZoom.enable();
    let l = new ic();
    this._add("tapDragZoom", l);
    let u = t.touchPitch = new ba(t);
    this._add("touchPitch", u), e.interactive && e.touchPitch && t.touchPitch.enable(e.touchPitch);
    let c3 = Ju(e), p = Yu(e);
    t.dragRotate = new Pa(e, c3, p), this._add("mouseRotate", c3, ["mousePitch"]), this._add("mousePitch", p, ["mouseRotate"]), e.interactive && e.dragRotate && t.dragRotate.enable();
    let h = l_(e), f = new ec(e, t);
    t.dragPan = new Sa(i, h, f), this._add("mousePan", h), this._add("touchPan", f, ["touchZoom", "touchRotate"]), e.interactive && e.dragPan && t.dragPan.enable(e.dragPan);
    let d = new xa(), y = new ga();
    t.touchZoomRotate = new Ta(i, y, d, l), this._add("touchRotate", d, ["touchPan", "touchZoom"]), this._add("touchZoom", y, ["touchPan", "touchRotate"]), e.interactive && e.touchZoomRotate && t.touchZoomRotate.enable(e.touchZoomRotate);
    let g = t.scrollZoom = new va(t, () => this._triggerRenderFrame());
    this._add("scrollZoom", g, ["mousePan"]), e.interactive && e.scrollZoom && t.scrollZoom.enable(e.scrollZoom);
    let x = t.keyboard = new _a(t);
    this._add("keyboard", x), e.interactive && e.keyboard && t.keyboard.enable(), this._add("blockableMapEvent", new Wu(t));
  }
  _add(e, t, i) {
    this._handlers.push({ handlerName: e, handler: t, allowed: i }), this._handlersById[e] = t;
  }
  stop(e) {
    if (!this._updatingCamera) {
      for (let { handler: t } of this._handlers) t.reset();
      this._inertia.clear(), this._fireEvents({}, {}, e), this._changes = [];
    }
  }
  isActive() {
    for (let { handler: e } of this._handlers) if (e.isActive()) return true;
    return false;
  }
  isZooming() {
    return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
  }
  isRotating() {
    return !!this._eventsInProgress.rotate;
  }
  isMoving() {
    return !!nc(this._eventsInProgress) || this.isZooming();
  }
  _blockedByActive(e, t, i) {
    for (let n in e) if (n !== i && (!t || t.indexOf(n) < 0)) return true;
    return false;
  }
  _getMapTouches(e) {
    let t = [];
    for (let i of e) {
      let n = i.target;
      this._el.contains(n) && t.push(i);
    }
    return t;
  }
  mergeHandlerResult(e, t, i, n, o) {
    if (!i) return;
    O(e, i);
    let a = { handlerName: n, originalEvent: i.originalEvent || o };
    i.zoomDelta !== void 0 && (t.zoom = a), i.panDelta !== void 0 && (t.drag = a), i.pitchDelta !== void 0 && (t.pitch = a), i.bearingDelta !== void 0 && (t.rotate = a);
  }
  _applyChanges() {
    let e = {}, t = {}, i = {};
    for (let [n, o, a] of this._changes) n.panDelta && (e.panDelta = (e.panDelta || new h_.default(0, 0))._add(n.panDelta)), n.zoomDelta && (e.zoomDelta = (e.zoomDelta || 0) + n.zoomDelta), n.bearingDelta && (e.bearingDelta = (e.bearingDelta || 0) + n.bearingDelta), n.pitchDelta && (e.pitchDelta = (e.pitchDelta || 0) + n.pitchDelta), n.around !== void 0 && (e.around = n.around), n.pinchAround !== void 0 && (e.pinchAround = n.pinchAround), n.noInertia && (e.noInertia = n.noInertia), O(t, o), O(i, a);
    this._updateMapTransform(e, t, i), this._changes = [];
  }
  _updateMapTransform(e, t, i) {
    let n = this._map, o = n._getTransformForUpdate(), a = n.terrain;
    if (!Eh(e) && !(a && this._terrainMovement)) return this._fireEvents(t, i, true);
    let { panDelta: s3, zoomDelta: l, bearingDelta: u, pitchDelta: c3, around: p, pinchAround: h } = e;
    h !== void 0 && (p = h), n._stop(true), p = p || n.transform.centerPoint;
    let f = o.pointLocation(s3 ? p.sub(s3) : p);
    u && (o.bearing += u), c3 && (o.pitch += c3), l && (o.zoom += l), a ? !this._terrainMovement && (t.drag || t.zoom) ? (this._terrainMovement = true, this._map._elevationFreeze = true, o.setLocationAtPoint(f, p), this._map.once("moveend", () => {
      this._map._elevationFreeze = false, this._terrainMovement = false, o.recalculateZoom(n.terrain);
    })) : t.drag && this._terrainMovement ? o.center = o.pointLocation(o.centerPoint.sub(s3)) : o.setLocationAtPoint(f, p) : o.setLocationAtPoint(f, p), n._applyUpdatedTransform(o), this._map._update(), e.noInertia || this._inertia.record(e), this._fireEvents(t, i, true);
  }
  _fireEvents(e, t, i) {
    let n = nc(this._eventsInProgress), o = nc(e), a = {};
    for (let c3 in e) {
      let { originalEvent: p } = e[c3];
      this._eventsInProgress[c3] || (a["".concat(c3, "start")] = p), this._eventsInProgress[c3] = e[c3];
    }
    !n && o && this._fireEvent("movestart", o.originalEvent);
    for (let c3 in a) this._fireEvent(c3, a[c3]);
    o && this._fireEvent("move", o.originalEvent);
    for (let c3 in e) {
      let { originalEvent: p } = e[c3];
      this._fireEvent(c3, p);
    }
    let s3 = {}, l;
    for (let c3 in this._eventsInProgress) {
      let { handlerName: p, originalEvent: h } = this._eventsInProgress[c3];
      this._handlersById[p].isActive() || (delete this._eventsInProgress[c3], l = t[p] || h, s3["".concat(c3, "end")] = l);
    }
    for (let c3 in s3) this._fireEvent(c3, s3[c3]);
    let u = nc(this._eventsInProgress);
    if (i && (n || o) && !u) {
      this._updatingCamera = true;
      let c3 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), p = (h) => h !== 0 && -this._bearingSnap < h && h < this._bearingSnap;
      c3 && (c3.essential || !J.prefersReducedMotion) ? (p(c3.bearing || this._map.getBearing()) && (c3.bearing = 0), c3.freezeElevation = true, this._map.easeTo(c3, { originalEvent: l })) : (this._map.fire(new z("moveend", { originalEvent: l })), p(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = false;
    }
  }
  _fireEvent(e, t) {
    this._map.fire(new z(e, t ? { originalEvent: t } : {}));
  }
  _requestFrame() {
    return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e) => {
      delete this._frameId, this.handleEvent(new kh("renderFrame", { timeStamp: e })), this._applyChanges();
    });
  }
  _triggerRenderFrame() {
    this._frameId === void 0 && (this._frameId = this._requestFrame());
  }
};
c();
var Zt = s(ye(), 1);
var ac = class extends me {
  constructor(t, i) {
    super();
    this._renderFrameCallback = () => {
      let t3 = Math.min((J.now() - this._easeStart) / this._easeOptions.duration, 1);
      this._onEaseFrame(this._easeOptions.easing(t3)), t3 < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
    };
    this._moving = false, this._zooming = false, this.transform = t, this._bearingSnap = i.bearingSnap, this.on("moveend", () => {
      delete this._requestedCameraState;
    });
  }
  getCenter() {
    return new re(this.transform.center.lng, this.transform.center.lat);
  }
  setCenter(t, i) {
    return this.jumpTo({ center: t }, i);
  }
  panBy(t, i, n) {
    return t = Zt.default.convert(t).mult(-1), this.panTo(this.transform.center, O({ offset: t }, i), n);
  }
  panTo(t, i, n) {
    return this.easeTo(O({ center: t }, i), n);
  }
  getZoom() {
    return this.transform.zoom;
  }
  setZoom(t, i) {
    return this.jumpTo({ zoom: t }, i), this;
  }
  zoomTo(t, i, n) {
    return this.easeTo(O({ zoom: t }, i), n);
  }
  zoomIn(t, i) {
    return this.zoomTo(this.getZoom() + 1, t, i), this;
  }
  zoomOut(t, i) {
    return this.zoomTo(this.getZoom() - 1, t, i), this;
  }
  getBearing() {
    return this.transform.bearing;
  }
  setBearing(t, i) {
    return this.jumpTo({ bearing: t }, i), this;
  }
  getPadding() {
    return this.transform.padding;
  }
  setPadding(t, i) {
    return this.jumpTo({ padding: t }, i), this;
  }
  rotateTo(t, i, n) {
    return this.easeTo(O({ bearing: t }, i), n);
  }
  resetNorth(t, i) {
    return this.rotateTo(0, O({ duration: 1e3 }, t), i), this;
  }
  resetNorthPitch(t, i) {
    return this.easeTo(O({ bearing: 0, pitch: 0, duration: 1e3 }, t), i), this;
  }
  snapToNorth(t, i) {
    return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(t, i) : this;
  }
  getPitch() {
    return this.transform.pitch;
  }
  setPitch(t, i) {
    return this.jumpTo({ pitch: t }, i), this;
  }
  cameraForBounds(t, i) {
    t = lt.convert(t);
    let n = i && i.bearing || 0;
    return this._cameraForBoxAndBearing(t.getNorthWest(), t.getSouthEast(), n, i);
  }
  _cameraForBoxAndBearing(t, i, n, o) {
    let a = { top: 0, bottom: 0, right: 0, left: 0 };
    if (o = O({ padding: a, offset: [0, 0], maxZoom: this.transform.maxZoom }, o), typeof o.padding == "number") {
      let ie = o.padding;
      o.padding = { top: ie, bottom: ie, right: ie, left: ie };
    }
    o.padding = O(a, o.padding);
    let s3 = this.transform, l = s3.padding, u = new lt(t, i), c3 = s3.project(u.getNorthWest()), p = s3.project(u.getNorthEast()), h = s3.project(u.getSouthEast()), f = s3.project(u.getSouthWest()), d = Tc(-n), y = c3.rotate(d), g = p.rotate(d), x = h.rotate(d), v = f.rotate(d), b = new Zt.default(Math.max(y.x, g.x, v.x, x.x), Math.max(y.y, g.y, v.y, x.y)), w = new Zt.default(Math.min(y.x, g.x, v.x, x.x), Math.min(y.y, g.y, v.y, x.y)), S = b.sub(w), P = (s3.width - (l.left + l.right + o.padding.left + o.padding.right)) / S.x, k = (s3.height - (l.top + l.bottom + o.padding.top + o.padding.bottom)) / S.y;
    if (k < 0 || P < 0) {
      Ee("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
      return;
    }
    let I = Math.min(s3.scaleZoom(s3.scale * Math.min(P, k)), o.maxZoom), C = Zt.default.convert(o.offset), M = (o.padding.left - o.padding.right) / 2, F = (o.padding.top - o.padding.bottom) / 2, E = new Zt.default(M, F).rotate(Tc(n)), N = C.add(E).mult(s3.scale / s3.zoomScale(I));
    return { center: s3.unproject(c3.add(h).div(2).sub(N)), zoom: I, bearing: n };
  }
  fitBounds(t, i, n) {
    return this._fitInternal(this.cameraForBounds(t, i), i, n);
  }
  fitScreenCoordinates(t, i, n, o, a) {
    return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(Zt.default.convert(t)), this.transform.pointLocation(Zt.default.convert(i)), n, o), o, a);
  }
  _fitInternal(t, i, n) {
    return t ? (i = O(t, i), delete i.padding, i.linear ? this.easeTo(i, n) : this.flyTo(i, n)) : this;
  }
  jumpTo(t, i) {
    this.stop();
    let n = this._getTransformForUpdate(), o = false, a = false, s3 = false;
    return "zoom" in t && n.zoom !== +t.zoom && (o = true, n.zoom = +t.zoom), t.center !== void 0 && (n.center = re.convert(t.center)), "bearing" in t && n.bearing !== +t.bearing && (a = true, n.bearing = +t.bearing), "pitch" in t && n.pitch !== +t.pitch && (s3 = true, n.pitch = +t.pitch), t.padding != null && !n.isPaddingEqual(t.padding) && (n.padding = t.padding), this._applyUpdatedTransform(n), this.fire(new z("movestart", i)).fire(new z("move", i)), o && this.fire(new z("zoomstart", i)).fire(new z("zoom", i)).fire(new z("zoomend", i)), a && this.fire(new z("rotatestart", i)).fire(new z("rotate", i)).fire(new z("rotateend", i)), s3 && this.fire(new z("pitchstart", i)).fire(new z("pitch", i)).fire(new z("pitchend", i)), this.fire(new z("moveend", i));
  }
  calculateCameraOptionsFromTo(t, i, n, o = 0) {
    let a = ze.fromLngLat(t, i), s3 = ze.fromLngLat(n, o), l = s3.x - a.x, u = s3.y - a.y, c3 = s3.z - a.z, p = Math.hypot(l, u, c3);
    if (p === 0) throw new Error("Can't calculate camera options with same From and To");
    let h = Math.hypot(l, u), f = this.transform.scaleZoom(this.transform.cameraToCenterDistance / p / this.transform.tileSize), d = Math.atan2(l, -u) * 180 / Math.PI, y = Math.acos(h / p) * 180 / Math.PI;
    return y = c3 < 0 ? 90 - y : 90 + y, { center: s3.toLngLat(), zoom: f, pitch: y, bearing: d };
  }
  easeTo(t, i) {
    var k;
    this._stop(false, t.easeId), t = O({ offset: [0, 0], duration: 500, easing: xn }, t), (t.animate === false || !t.essential && J.prefersReducedMotion) && (t.duration = 0);
    let n = this._getTransformForUpdate(), o = this.getZoom(), a = this.getBearing(), s3 = this.getPitch(), l = this.getPadding(), u = "bearing" in t ? this._normalizeBearing(t.bearing, a) : a, c3 = "pitch" in t ? +t.pitch : s3, p = "padding" in t ? t.padding : n.padding, h = Zt.default.convert(t.offset), f = n.centerPoint.add(h), d = n.pointLocation(f), { center: y, zoom: g } = n.getConstrained(re.convert(t.center || d), (k = t.zoom) != null ? k : o);
    this._normalizeCenter(y);
    let x = n.project(d), v = n.project(y).sub(x), b = n.zoomScale(g - o), w, S;
    t.around && (w = re.convert(t.around), S = n.locationPoint(w));
    let P = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
    return this._zooming = this._zooming || g !== o, this._rotating = this._rotating || a !== u, this._pitching = this._pitching || c3 !== s3, this._padding = !n.isPaddingEqual(p), this._easeId = t.easeId, this._prepareEase(i, t.noMoveStart, P), this.terrain && this._prepareElevation(y), this._ease((I) => {
      if (this._zooming && (n.zoom = Se.number(o, g, I)), this._rotating && (n.bearing = Se.number(a, u, I)), this._pitching && (n.pitch = Se.number(s3, c3, I)), this._padding && (n.interpolatePadding(l, p, I), f = n.centerPoint.add(h)), this.terrain && !t.freezeElevation && this._updateElevation(I), w) n.setLocationAtPoint(w, S);
      else {
        let C = n.zoomScale(n.zoom - o), M = g > o ? Math.min(2, b) : Math.max(0.5, b), F = Math.pow(M, 1 - I), D = n.unproject(x.add(v.mult(I * F)).mult(C));
        n.setLocationAtPoint(n.renderWorldCopies ? D.wrap() : D, f);
      }
      this._applyUpdatedTransform(n), this._fireMoveEvents(i);
    }, (I) => {
      this.terrain && this._finalizeElevation(), this._afterEase(i, I);
    }, t), this;
  }
  _prepareEase(t, i, n = {}) {
    this._moving = true, !i && !n.moving && this.fire(new z("movestart", t)), this._zooming && !n.zooming && this.fire(new z("zoomstart", t)), this._rotating && !n.rotating && this.fire(new z("rotatestart", t)), this._pitching && !n.pitching && this.fire(new z("pitchstart", t));
  }
  _prepareElevation(t) {
    this._elevationCenter = t, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(t, this.transform.tileZoom), this._elevationFreeze = true;
  }
  _updateElevation(t) {
    this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
    let i = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
    if (t < 1 && i !== this._elevationTarget) {
      let n = this._elevationTarget - this._elevationStart, o = (i - (n * t + this._elevationStart)) / (1 - t);
      this._elevationStart += t * (n - o), this._elevationTarget = i;
    }
    this.transform.elevation = Se.number(this._elevationStart, this._elevationTarget, t);
  }
  _finalizeElevation() {
    this._elevationFreeze = false, this.transform.recalculateZoom(this.terrain);
  }
  _getTransformForUpdate() {
    return this.transformCameraUpdate ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
  }
  _applyUpdatedTransform(t) {
    if (!this.transformCameraUpdate) return;
    let i = t.clone(), { center: n, zoom: o, pitch: a, bearing: s3, elevation: l } = this.transformCameraUpdate(i);
    n && (i.center = n), o !== void 0 && (i.zoom = o), a !== void 0 && (i.pitch = a), s3 !== void 0 && (i.bearing = s3), l !== void 0 && (i.elevation = l), this.transform.apply(i);
  }
  _fireMoveEvents(t) {
    this.fire(new z("move", t)), this._zooming && this.fire(new z("zoom", t)), this._rotating && this.fire(new z("rotate", t)), this._pitching && this.fire(new z("pitch", t));
  }
  _afterEase(t, i) {
    if (this._easeId && i && this._easeId === i) return;
    delete this._easeId;
    let n = this._zooming, o = this._rotating, a = this._pitching;
    this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._padding = false, n && this.fire(new z("zoomend", t)), o && this.fire(new z("rotateend", t)), a && this.fire(new z("pitchend", t)), this.fire(new z("moveend", t));
  }
  flyTo(t, i) {
    var ie;
    if (!t.essential && J.prefersReducedMotion) {
      let K = fr(t, ["center", "zoom", "bearing", "pitch", "around"]);
      return this.jumpTo(K, i);
    }
    this.stop(), t = O({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: xn }, t);
    let n = this._getTransformForUpdate(), o = this.getZoom(), a = this.getBearing(), s3 = this.getPitch(), l = this.getPadding(), u = "bearing" in t ? this._normalizeBearing(t.bearing, a) : a, c3 = "pitch" in t ? +t.pitch : s3, p = "padding" in t ? t.padding : n.padding, h = Zt.default.convert(t.offset), f = n.centerPoint.add(h), d = n.pointLocation(f), { center: y, zoom: g } = n.getConstrained(re.convert(t.center || d), (ie = t.zoom) != null ? ie : o);
    this._normalizeCenter(y);
    let x = n.zoomScale(g - o), v = n.project(d), b = n.project(y).sub(v), w = t.curve, S = Math.max(n.width, n.height), P = S / x, k = b.mag();
    if ("minZoom" in t) {
      let K = Ae(Math.min(t.minZoom, o, g), n.minZoom, n.maxZoom), $ = S / n.zoomScale(K - o);
      w = Math.sqrt($ / k * 2);
    }
    let I = w * w;
    function C(K) {
      let $ = (P * P - S * S + (K ? -1 : 1) * I * I * k * k) / (2 * (K ? P : S) * I * k);
      return Math.log(Math.sqrt($ * $ + 1) - $);
    }
    function M(K) {
      return (Math.exp(K) - Math.exp(-K)) / 2;
    }
    function F(K) {
      return (Math.exp(K) + Math.exp(-K)) / 2;
    }
    function D(K) {
      return M(K) / F(K);
    }
    let E = C(false), T = function(K) {
      return F(E) / F(E + w * K);
    }, N = function(K) {
      return S * ((F(E) * D(E + w * K) - M(E)) / I) / k;
    }, X = (C(true) - E) / w;
    if (Math.abs(k) < 1e-6 || !isFinite(X)) {
      if (Math.abs(S - P) < 1e-6) return this.easeTo(t, i);
      let K = P < S ? -1 : 1;
      X = Math.abs(Math.log(P / S)) / w, N = function() {
        return 0;
      }, T = function($) {
        return Math.exp(K * w * $);
      };
    }
    if ("duration" in t) t.duration = +t.duration;
    else {
      let K = "screenSpeed" in t ? +t.screenSpeed / w : +t.speed;
      t.duration = 1e3 * X / K;
    }
    return t.maxDuration && t.duration > t.maxDuration && (t.duration = 0), this._zooming = true, this._rotating = a !== u, this._pitching = c3 !== s3, this._padding = !n.isPaddingEqual(p), this._prepareEase(i, false), this.terrain && this._prepareElevation(y), this._ease((K) => {
      let $ = K * X, Ke = 1 / T($);
      n.zoom = K === 1 ? g : o + n.scaleZoom(Ke), this._rotating && (n.bearing = Se.number(a, u, K)), this._pitching && (n.pitch = Se.number(s3, c3, K)), this._padding && (n.interpolatePadding(l, p, K), f = n.centerPoint.add(h)), this.terrain && !t.freezeElevation && this._updateElevation(K);
      let Oe = K === 1 ? y : n.unproject(v.add(b.mult(N($))).mult(Ke));
      n.setLocationAtPoint(n.renderWorldCopies ? Oe.wrap() : Oe, f), this._applyUpdatedTransform(n), this._fireMoveEvents(i);
    }, () => {
      this.terrain && this._finalizeElevation(), this._afterEase(i);
    }, t), this;
  }
  isEasing() {
    return !!this._easeFrameId;
  }
  stop() {
    return this._stop();
  }
  _stop(t, i) {
    if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
      let n = this._onEaseEnd;
      delete this._onEaseEnd, n.call(this, i);
    }
    if (!t) {
      let n = this.handlers;
      n && n.stop(false);
    }
    return this;
  }
  _ease(t, i, n) {
    n.animate === false || n.duration === 0 ? (t(1), i()) : (this._easeStart = J.now(), this._easeOptions = n, this._onEaseFrame = t, this._onEaseEnd = i, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
  }
  _normalizeBearing(t, i) {
    t = Jt(t, -180, 180);
    let n = Math.abs(t - i);
    return Math.abs(t - 360 - i) < n && (t -= 360), Math.abs(t + 360 - i) < n && (t += 360), t;
  }
  _normalizeCenter(t) {
    let i = this.transform;
    if (!i.renderWorldCopies || i.lngRange) return;
    let n = t.lng - i.center.lng;
    t.lng += n > 180 ? -360 : n < -180 ? 360 : 0;
  }
  queryTerrainElevation(t) {
    return this.terrain ? this.terrain.getElevationForLngLatZoom(re.convert(t), this.transform.tileZoom) - this.transform.elevation : null;
  }
};
var cr = s(ye(), 1);
c();
var Lh = { compact: true, customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>' };
var Ma = class {
  constructor(e = Lh) {
    this._toggleAttribution = () => {
      this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
    };
    this._updateData = (e3) => {
      e3 && (e3.sourceDataType === "metadata" || e3.sourceDataType === "visibility" || e3.dataType === "style" || e3.type === "terrain") && this._updateAttributions();
    };
    this._updateCompact = () => {
      this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === false ? this._container.setAttribute("open", "") : !this._container.classList.contains("maplibregl-compact") && !this._container.classList.contains("maplibregl-attrib-empty") && (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
    };
    this._updateCompactMinimize = () => {
      this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
    };
    this.options = e;
  }
  getDefaultPosition() {
    return "bottom-right";
  }
  onAdd(e) {
    return this._map = e, this._compact = this.options.compact, this._container = L.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = L.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = L.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
  }
  onRemove() {
    L.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
  }
  _setElementTitle(e, t) {
    let i = this._map._getUIString("AttributionControl.".concat(t));
    e.title = i, e.setAttribute("aria-label", i);
  }
  _updateAttributions() {
    if (!this._map.style) return;
    let e = [];
    if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e = e.concat(this.options.customAttribution.map((n) => typeof n != "string" ? "" : n)) : typeof this.options.customAttribution == "string" && e.push(this.options.customAttribution)), this._map.style.stylesheet) {
      let n = this._map.style.stylesheet;
      this.styleOwner = n.owner, this.styleId = n.id;
    }
    let t = this._map.style.sourceCaches;
    for (let n in t) {
      let o = t[n];
      if (o.used || o.usedForTerrain) {
        let a = o.getSource();
        a.attribution && e.indexOf(a.attribution) < 0 && e.push(a.attribution);
      }
    }
    e = e.filter((n) => String(n).trim()), e.sort((n, o) => n.length - o.length), e = e.filter((n, o) => {
      for (let a = o + 1; a < e.length; a++) if (e[a].indexOf(n) >= 0) return false;
      return true;
    });
    let i = e.join(" | ");
    i !== this._attribHTML && (this._attribHTML = i, e.length ? (this._innerContainer.innerHTML = i, this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
  }
};
c();
var Ia = class {
  constructor(e = {}) {
    this._updateCompact = () => {
      let e3 = this._container.children;
      if (e3.length) {
        let t = e3[0];
        this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== false && t.classList.add("maplibregl-compact") : t.classList.remove("maplibregl-compact");
      }
    };
    this.options = e;
  }
  getDefaultPosition() {
    return "bottom-left";
  }
  onAdd(e) {
    this._map = e, this._compact = this.options && this.options.compact, this._container = L.create("div", "maplibregl-ctrl");
    let t = L.create("a", "maplibregl-ctrl-logo");
    return t.target = "_blank", t.rel = "noopener nofollow", t.href = "https://maplibre.org/", t.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), t.setAttribute("rel", "noopener nofollow"), this._container.appendChild(t), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
  }
  onRemove() {
    L.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
  }
};
c();
var sc = class {
  constructor() {
    this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
  }
  add(e) {
    let t = ++this._id;
    return this._queue.push({ callback: e, id: t, cancelled: false }), t;
  }
  remove(e) {
    let t = this._currentlyRunning, i = t ? this._queue.concat(t) : this._queue;
    for (let n of i) if (n.id === e) {
      n.cancelled = true;
      return;
    }
  }
  run(e = 0) {
    if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
    let t = this._currentlyRunning = this._queue;
    this._queue = [];
    for (let i of t) if (!i.cancelled && (i.callback(e), this._cleared)) break;
    this._cleared = false, this._currentlyRunning = false;
  }
  clear() {
    this._currentlyRunning && (this._cleared = true), this._queue = [];
  }
};
c();
var uc = ((i) => (i.create = "create", i.load = "load", i.fullLoad = "fullLoad", i))(uc || {});
var lc = null;
var Ca = [];
var vM = 60;
var Dh = 1e3 / vM;
var zh = "loadTime";
var Fh = "fullLoadTime";
var mn = { mark(r50) {
  performance.mark(r50);
}, frame(r50) {
  let e = r50;
  if (lc != null) {
    let t = e - lc;
    Ca.push(t);
  }
  lc = e;
}, clearMetrics() {
  lc = null, Ca = [], performance.clearMeasures(zh), performance.clearMeasures(Fh);
  for (let r50 in uc) performance.clearMarks(uc[r50]);
}, getPerformanceMetrics() {
  performance.measure(zh, "create", "load"), performance.measure(Fh, "create", "fullLoad");
  let r50 = performance.getEntriesByName(zh)[0].duration, e = performance.getEntriesByName(Fh)[0].duration, t = Ca.length, n = 1 / (Ca.reduce((s3, l) => s3 + l, 0) / t / 1e3), o = Ca.filter((s3) => s3 > Dh).reduce((s3, l) => s3 + (l - Dh) / Dh, 0), a = o / (t + o) * 100;
  return { loadTime: r50, fullLoadTime: e, fps: n, percentDroppedFrames: a, totalFrames: t };
} };
c();
c();
var f_ = be([{ name: "a_pos3d", type: "Int16", components: 3 }]);
c();
var cc = class extends me {
  constructor(e) {
    super(), this.sourceCache = e, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.deltaZoom = 1, e.usedForTerrain = true, e.tileSize = this.tileSize * 2 ** this.deltaZoom;
  }
  destruct() {
    this.sourceCache.usedForTerrain = false, this.sourceCache.tileSize = null;
  }
  update(e, t) {
    this.sourceCache.update(e, t), this._renderableTilesKeys = [];
    let i = {};
    for (let n of e.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: false, terrain: t })) i[n.key] = true, this._renderableTilesKeys.push(n.key), this._tiles[n.key] || (n.posMatrix = new Float64Array(16), G.ortho(n.posMatrix, 0, 8192, 0, 8192, 0, 1), this._tiles[n.key] = new ln(n, this.tileSize));
    for (let n in this._tiles) i[n] || delete this._tiles[n];
  }
  freeRtt(e) {
    for (let t in this._tiles) {
      let i = this._tiles[t];
      (!e || i.tileID.equals(e) || i.tileID.isChildOf(e) || e.isChildOf(i.tileID)) && (i.rtt = []);
    }
  }
  getRenderableTiles() {
    return this._renderableTilesKeys.map((e) => this.getTileByID(e));
  }
  getTileByID(e) {
    return this._tiles[e];
  }
  getTerrainCoords(e) {
    let t = {};
    for (let i of this._renderableTilesKeys) {
      let n = this._tiles[i].tileID;
      if (n.canonical.equals(e.canonical)) {
        let o = e.clone();
        o.posMatrix = new Float64Array(16), G.ortho(o.posMatrix, 0, 8192, 0, 8192, 0, 1), t[i] = o;
      } else if (n.canonical.isChildOf(e.canonical)) {
        let o = e.clone();
        o.posMatrix = new Float64Array(16);
        let a = n.canonical.z - e.canonical.z, s3 = n.canonical.x - (n.canonical.x >> a << a), l = n.canonical.y - (n.canonical.y >> a << a), u = 8192 >> a;
        G.ortho(o.posMatrix, 0, u, 0, u, 0, 1), G.translate(o.posMatrix, o.posMatrix, [-s3 * u, -l * u, 0]), t[i] = o;
      } else if (e.canonical.isChildOf(n.canonical)) {
        let o = e.clone();
        o.posMatrix = new Float64Array(16);
        let a = e.canonical.z - n.canonical.z, s3 = e.canonical.x - (e.canonical.x >> a << a), l = e.canonical.y - (e.canonical.y >> a << a), u = 8192 >> a;
        G.ortho(o.posMatrix, 0, 8192, 0, 8192, 0, 1), G.translate(o.posMatrix, o.posMatrix, [s3 * u, l * u, 0]), G.scale(o.posMatrix, o.posMatrix, [1 / 2 ** a, 1 / 2 ** a, 0]), t[i] = o;
      }
    }
    return t;
  }
  getSourceTile(e, t) {
    let i = this.sourceCache._source, n = e.overscaledZ - this.deltaZoom;
    if (n > i.maxzoom && (n = i.maxzoom), n < i.minzoom) return null;
    this._sourceTileCache[e.key] || (this._sourceTileCache[e.key] = e.scaledTo(n).key);
    let o = this.sourceCache.getTileByID(this._sourceTileCache[e.key]);
    if (!(o && o.dem) && t) for (; n >= i.minzoom && !(o && o.dem); ) o = this.sourceCache.getTileByID(e.scaledTo(n--).key);
    return o;
  }
  tilesAfterTime(e = Date.now()) {
    return Object.values(this._tiles).filter((t) => t.timeAdded >= e);
  }
};
var pc = class {
  constructor(e, t, i) {
    this.painter = e, this.sourceCache = new cc(t), this.options = i, this.exaggeration = typeof i.exaggeration == "number" ? i.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
  }
  getDEMElevation(e, t, i, n = 8192) {
    var f;
    if (!(t >= 0 && t < n && i >= 0 && i < n)) return 0;
    let o = this.getTerrainData(e), a = (f = o.tile) == null ? void 0 : f.dem;
    if (!a) return 0;
    let s3 = Zi.transformMat4([], [t / n * 8192, i / n * 8192], o.u_terrain_matrix), l = [s3[0] * a.dim, s3[1] * a.dim], u = Math.floor(l[0]), c3 = Math.floor(l[1]), p = l[0] - u, h = l[1] - c3;
    return a.get(u, c3) * (1 - p) * (1 - h) + a.get(u + 1, c3) * p * (1 - h) + a.get(u, c3 + 1) * (1 - p) * h + a.get(u + 1, c3 + 1) * p * h;
  }
  getElevationForLngLatZoom(e, t) {
    let { tileID: i, mercatorX: n, mercatorY: o } = this._getOverscaledTileIDFromLngLatZoom(e, t);
    return this.getElevation(i, n % 8192, o % 8192, 8192);
  }
  getElevation(e, t, i, n = 8192) {
    return this.getDEMElevation(e, t, i, n) * this.exaggeration;
  }
  getTerrainData(e) {
    if (!this._emptyDemTexture) {
      let n = this.painter.context, o = new we({ width: 1, height: 1 }, new Uint8Array(1 * 4));
      this._emptyDepthTexture = new _e(n, o, n.gl.RGBA, { premultiply: false }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new _e(n, new we({ width: 1, height: 1 }), n.gl.RGBA, { premultiply: false }), this._emptyDemTexture.bind(n.gl.NEAREST, n.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = G.identity([]);
    }
    let t = this.sourceCache.getSourceTile(e, true);
    if (t && t.dem && (!t.demTexture || t.needsTerrainPrepare)) {
      let n = this.painter.context;
      t.demTexture = this.painter.getTileTexture(t.dem.stride), t.demTexture ? t.demTexture.update(t.dem.getPixels(), { premultiply: false }) : t.demTexture = new _e(n, t.dem.getPixels(), n.gl.RGBA, { premultiply: false }), t.demTexture.bind(n.gl.NEAREST, n.gl.CLAMP_TO_EDGE), t.needsTerrainPrepare = false;
    }
    let i = t && t + t.tileID.key + e.key;
    if (i && !this._demMatrixCache[i]) {
      let n = this.sourceCache.sourceCache._source.maxzoom, o = e.canonical.z - t.tileID.canonical.z;
      e.overscaledZ > e.canonical.z && (e.canonical.z >= n ? o = e.canonical.z - n : Ee("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
      let a = e.canonical.x - (e.canonical.x >> o << o), s3 = e.canonical.y - (e.canonical.y >> o << o), l = G.fromScaling(new Float64Array(16), [1 / (8192 << o), 1 / (8192 << o), 0]);
      G.translate(l, l, [a * 8192, s3 * 8192, 0]), this._demMatrixCache[e.key] = { matrix: l, coord: e };
    }
    return { u_depth: 2, u_terrain: 3, u_terrain_dim: t && t.dem && t.dem.dim || 1, u_terrain_matrix: i ? this._demMatrixCache[e.key].matrix : this._emptyDemMatrix, u_terrain_unpack: t && t.dem && t.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (t && t.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: t };
  }
  getFramebuffer(e) {
    let t = this.painter, i = t.width / devicePixelRatio, n = t.height / devicePixelRatio;
    return this._fbo && (this._fbo.width !== i || this._fbo.height !== n) && (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new _e(t.context, { width: i, height: n, data: null }, t.context.gl.RGBA, { premultiply: false }), this._fboCoordsTexture.bind(t.context.gl.NEAREST, t.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new _e(t.context, { width: i, height: n, data: null }, t.context.gl.RGBA, { premultiply: false }), this._fboDepthTexture.bind(t.context.gl.NEAREST, t.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = t.context.createFramebuffer(i, n, true, false), this._fbo.depthAttachment.set(t.context.createRenderbuffer(t.context.gl.DEPTH_COMPONENT16, i, n))), this._fbo.colorAttachment.set(e === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
  }
  getCoordsTexture() {
    let e = this.painter.context;
    if (this._coordsTexture) return this._coordsTexture;
    let t = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
    for (let o = 0, a = 0; o < this._coordsTextureSize; o++) for (let s3 = 0; s3 < this._coordsTextureSize; s3++, a += 4) t[a + 0] = s3 & 255, t[a + 1] = o & 255, t[a + 2] = s3 >> 8 << 4 | o >> 8, t[a + 3] = 0;
    let i = new we({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(t.buffer)), n = new _e(e, i, e.gl.RGBA, { premultiply: false });
    return n.bind(e.gl.NEAREST, e.gl.CLAMP_TO_EDGE), this._coordsTexture = n, n;
  }
  pointCoordinate(e) {
    this.painter.maybeDrawDepthAndCoords(true);
    let t = new Uint8Array(4), i = this.painter.context, n = i.gl, o = Math.round(e.x * this.painter.pixelRatio / devicePixelRatio), a = Math.round(e.y * this.painter.pixelRatio / devicePixelRatio), s3 = Math.round(this.painter.height / devicePixelRatio);
    i.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), n.readPixels(o, s3 - a - 1, 1, 1, n.RGBA, n.UNSIGNED_BYTE, t), i.bindFramebuffer.set(null);
    let l = t[0] + (t[2] >> 4 << 8), u = t[1] + ((t[2] & 15) << 8), c3 = this.coordsIndex[255 - t[3]], p = c3 && this.sourceCache.getTileByID(c3);
    if (!p) return null;
    let h = this._coordsTextureSize, f = (1 << p.tileID.canonical.z) * h;
    return new ze((p.tileID.canonical.x * h + l) / f + p.tileID.wrap, (p.tileID.canonical.y * h + u) / f, this.getElevation(p.tileID, l, u, h));
  }
  depthAtPoint(e) {
    let t = new Uint8Array(4), i = this.painter.context, n = i.gl;
    return i.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), n.readPixels(e.x, this.painter.height / devicePixelRatio - e.y - 1, 1, 1, n.RGBA, n.UNSIGNED_BYTE, t), i.bindFramebuffer.set(null), (t[0] / (256 * 256 * 256) + t[1] / (256 * 256) + t[2] / 256 + t[3]) / 256;
  }
  getTerrainMesh() {
    if (this._mesh) return this._mesh;
    let e = this.painter.context, t = new Ms(), i = new tt(), n = this.meshSize, o = 8192 / n, a = n * n;
    for (let p = 0; p <= n; p++) for (let h = 0; h <= n; h++) t.emplaceBack(h * o, p * o, 0);
    for (let p = 0; p < a; p += n + 1) for (let h = 0; h < n; h++) i.emplaceBack(h + p, n + h + p + 1, n + h + p + 2), i.emplaceBack(h + p, n + h + p + 2, h + p + 1);
    let s3 = t.length, l = s3 + (n + 1) * 2;
    for (let p of [0, 1]) for (let h = 0; h <= n; h++) for (let f of [0, 1]) t.emplaceBack(h * o, p * 8192, f);
    for (let p = 0; p < n * 2; p += 2) i.emplaceBack(l + p, l + p + 1, l + p + 3), i.emplaceBack(l + p, l + p + 3, l + p + 2), i.emplaceBack(s3 + p, s3 + p + 3, s3 + p + 1), i.emplaceBack(s3 + p, s3 + p + 2, s3 + p + 3);
    let u = t.length, c3 = u + (n + 1) * 2;
    for (let p of [0, 1]) for (let h = 0; h <= n; h++) for (let f of [0, 1]) t.emplaceBack(p * 8192, h * o, f);
    for (let p = 0; p < n * 2; p += 2) i.emplaceBack(u + p, u + p + 1, u + p + 3), i.emplaceBack(u + p, u + p + 3, u + p + 2), i.emplaceBack(c3 + p, c3 + p + 3, c3 + p + 1), i.emplaceBack(c3 + p, c3 + p + 2, c3 + p + 3);
    return this._mesh = { indexBuffer: e.createIndexBuffer(i), vertexBuffer: e.createVertexBuffer(t, f_.members), segments: fe.simpleSegment(0, 0, t.length, i.length) }, this._mesh;
  }
  getMeshFrameDelta(e) {
    return 2 * Math.PI * jo / Math.pow(2, e) / 5;
  }
  getMinTileElevationForLngLatZoom(e, t) {
    var n;
    let { tileID: i } = this._getOverscaledTileIDFromLngLatZoom(e, t);
    return (n = this.getMinMaxElevation(i).minElevation) != null ? n : 0;
  }
  getMinMaxElevation(e) {
    let t = this.getTerrainData(e).tile, i = { minElevation: null, maxElevation: null };
    return t && t.dem && (i.minElevation = t.dem.min * this.exaggeration, i.maxElevation = t.dem.max * this.exaggeration), i;
  }
  _getOverscaledTileIDFromLngLatZoom(e, t) {
    let i = ze.fromLngLat(e.wrap()), n = (1 << t) * 8192, o = i.x * n, a = i.y * n, s3 = Math.floor(o / 8192), l = Math.floor(a / 8192);
    return { tileID: new Xe(t, 0, t, s3, l), mercatorX: o, mercatorY: a };
  }
};
c();
c();
var hc = class {
  constructor(e, t, i) {
    this._context = e;
    this._size = t;
    this._tileSize = i;
    this._objects = [], this._recentlyUsed = [], this._stamp = 0;
  }
  destruct() {
    for (let e of this._objects) e.texture.destroy(), e.fbo.destroy();
  }
  _createObject(e) {
    let t = this._context.createFramebuffer(this._tileSize, this._tileSize, true, true), i = new _e(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA);
    return i.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), t.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), t.colorAttachment.set(i.texture), { id: e, fbo: t, texture: i, stamp: -1, inUse: false };
  }
  getObjectForId(e) {
    return this._objects[e];
  }
  useObject(e) {
    e.inUse = true, this._recentlyUsed = this._recentlyUsed.filter((t) => e.id !== t), this._recentlyUsed.push(e.id);
  }
  stampObject(e) {
    e.stamp = ++this._stamp;
  }
  getOrCreateFreeObject() {
    for (let t of this._recentlyUsed) if (!this._objects[t].inUse) return this._objects[t];
    if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
    let e = this._createObject(this._objects.length);
    return this._objects.push(e), e;
  }
  freeObject(e) {
    e.inUse = false;
  }
  freeAllObjects() {
    for (let e of this._objects) this.freeObject(e);
  }
  isFull() {
    return this._objects.length < this._size ? false : this._objects.some((e) => !e.inUse) === false;
  }
};
var dn = { background: true, fill: true, line: true, raster: true, hillshade: true };
var fc = class {
  constructor(e, t) {
    this.painter = e, this.terrain = t, this.pool = new hc(e.context, 30, t.sourceCache.tileSize * t.qualityFactor);
  }
  destruct() {
    this.pool.destruct();
  }
  getTexture(e) {
    return this.pool.getObjectForId(e.rtt[this._stacks.length - 1].id).texture;
  }
  prepareForRender(e, t) {
    this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = e._order.filter((i) => !e._layers[i].isHidden(t)), this._coordsDescendingInv = {};
    for (let i in e.sourceCaches) {
      this._coordsDescendingInv[i] = {};
      let n = e.sourceCaches[i].getVisibleCoordinates();
      for (let o of n) {
        let a = this.terrain.sourceCache.getTerrainCoords(o);
        for (let s3 in a) this._coordsDescendingInv[i][s3] || (this._coordsDescendingInv[i][s3] = []), this._coordsDescendingInv[i][s3].push(a[s3]);
      }
    }
    this._coordsDescendingInvStr = {};
    for (let i of e._order) {
      let n = e._layers[i], o = n.source;
      if (dn[n.type] && !this._coordsDescendingInvStr[o]) {
        this._coordsDescendingInvStr[o] = {};
        for (let a in this._coordsDescendingInv[o]) this._coordsDescendingInvStr[o][a] = this._coordsDescendingInv[o][a].map((s3) => s3.key).sort().join();
      }
    }
    for (let i of this._renderableTiles) for (let n in this._coordsDescendingInvStr) {
      let o = this._coordsDescendingInvStr[n][i.tileID.key];
      o && o !== i.rttCoords[n] && (i.rtt = []);
    }
  }
  renderLayer(e) {
    if (e.isHidden(this.painter.transform.zoom)) return false;
    let t = e.type, i = this.painter, n = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e.id;
    if (dn[t] && ((!this._prevType || !dn[this._prevType]) && this._stacks.push([]), this._prevType = t, this._stacks[this._stacks.length - 1].push(e.id), !n)) return true;
    if (dn[this._prevType] || dn[t] && n) {
      this._prevType = t;
      let o = this._stacks.length - 1, a = this._stacks[o] || [];
      for (let s3 of this._renderableTiles) {
        if (this.pool.isFull() && (Ph(this.painter, this.terrain, this._rttTiles), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(s3), s3.rtt[o]) {
          let u = this.pool.getObjectForId(s3.rtt[o].id);
          if (u.stamp === s3.rtt[o].stamp) {
            this.pool.useObject(u);
            continue;
          }
        }
        let l = this.pool.getOrCreateFreeObject();
        this.pool.useObject(l), this.pool.stampObject(l), s3.rtt[o] = { id: l.id, stamp: l.stamp }, i.context.bindFramebuffer.set(l.fbo.framebuffer), i.context.clear({ color: W.transparent, stencil: 0 }), i.currentStencilSource = void 0;
        for (let u = 0; u < a.length; u++) {
          let c3 = i.style._layers[a[u]], p = c3.source ? this._coordsDescendingInv[c3.source][s3.tileID.key] : [s3.tileID];
          i.context.viewport.set([0, 0, l.fbo.width, l.fbo.height]), i._renderTileClippingMasks(c3, p), i.renderLayer(i, i.style.sourceCaches[c3.source], c3, p), c3.source && (s3.rttCoords[c3.source] = this._coordsDescendingInvStr[c3.source][s3.tileID.key]);
        }
      }
      return Ph(this.painter, this.terrain, this._rttTiles), this._rttTiles = [], this.pool.freeAllObjects(), dn[t];
    }
    return false;
  }
};
c();
var m_ = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "MapLibre logo", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "TerrainControl.Enable": "Enable terrain", "TerrainControl.Disable": "Disable terrain", "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map", "CooperativeGesturesHandler.MacHelpText": "Use  + scroll to zoom the map", "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map" };
var wM = Fa.version;
var dc = -2;
var d_ = 22;
var Br = 0;
var y_ = 80;
var mc = 85;
var SM = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: dc, maxZoom: d_, minPitch: Br, maxPitch: y_, interactive: true, scrollZoom: true, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, cooperativeGestures: false, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: true, hash: false, attributionControl: Lh, maplibreLogo: false, failIfMajorPerformanceCaveat: false, preserveDrawingBuffer: false, trackResize: true, renderWorldCopies: true, refreshExpiredTiles: true, maxTileCacheSize: null, maxTileCacheZoomLevels: nt.MAX_TILE_CACHE_ZOOM_LEVELS, localIdeographFontFamily: "sans-serif", transformRequest: null, transformCameraUpdate: null, fadeDuration: 300, crossSourceCollisions: true, validateStyle: true, maxCanvasSize: [4096, 4096] };
var Rh = class extends ac {
  constructor(t) {
    if (mn.mark("create"), t = O({}, SM, t), t.minZoom != null && t.maxZoom != null && t.minZoom > t.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
    if (t.minPitch != null && t.maxPitch != null && t.minPitch > t.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
    if (t.minPitch != null && t.minPitch < Br) throw new Error("minPitch must be greater than or equal to ".concat(Br));
    if (t.maxPitch != null && t.maxPitch > mc) throw new Error("maxPitch must be less than or equal to ".concat(mc));
    let i = new Nu(t.minZoom, t.maxZoom, t.minPitch, t.maxPitch, t.renderWorldCopies);
    super(i, { bearingSnap: t.bearingSnap });
    this._contextLost = (t3) => {
      t3.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new z("webglcontextlost", { originalEvent: t3 }));
    };
    this._contextRestored = (t3) => {
      this._setupPainter(), this.resize(), this._update(), this.fire(new z("webglcontextrestored", { originalEvent: t3 }));
    };
    this._onMapScroll = (t3) => {
      if (t3.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
    };
    this._onWindowOnline = () => {
      this._update();
    };
    if (this._interactive = t.interactive, this._maxTileCacheSize = t.maxTileCacheSize, this._maxTileCacheZoomLevels = t.maxTileCacheZoomLevels, this._failIfMajorPerformanceCaveat = t.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = t.preserveDrawingBuffer, this._antialias = t.antialias, this._trackResize = t.trackResize, this._bearingSnap = t.bearingSnap, this._refreshExpiredTiles = t.refreshExpiredTiles, this._fadeDuration = t.fadeDuration, this._crossSourceCollisions = t.crossSourceCollisions, this._crossFadingFactor = 1, this._collectResourceTiming = t.collectResourceTiming, this._renderTaskQueue = new sc(), this._controls = [], this._mapId = Oa(), this._locale = O({}, m_, t.locale), this._clickTolerance = t.clickTolerance, this._overridePixelRatio = t.pixelRatio, this._maxCanvasSize = t.maxCanvasSize, this.transformCameraUpdate = t.transformCameraUpdate, this._imageQueueHandle = at.addThrottleControl(() => this.isMoving()), this._requestManager = new ja(t.transformRequest), typeof t.container == "string") {
      if (this._container = document.getElementById(t.container), !this._container) throw new Error("Container '".concat(t.container, "' not found."));
    } else if (t.container instanceof HTMLElement) this._container = t.container;
    else throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
    if (t.maxBounds && this.setMaxBounds(t.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", () => this._update(false)), this.on("moveend", () => this._update(false)), this.on("zoom", () => this._update(true)), this.on("terrain", () => {
      this.painter.terrainFacilitator.dirty = true, this._update(true);
    }), this.once("idle", () => {
      this._idleTriggered = true;
    }), typeof window < "u") {
      addEventListener("online", this._onWindowOnline, false);
      let o = false, a = Gu((s3) => {
        this._trackResize && !this._removed && this.resize(s3)._update();
      }, 50);
      this._resizeObserver = new ResizeObserver((s3) => {
        if (!o) {
          o = true;
          return;
        }
        a(s3);
      }), this._resizeObserver.observe(this._container);
    }
    this.handlers = new oc(this, t);
    let n = typeof t.hash == "string" && t.hash || void 0;
    this._hash = t.hash && new pa(n).addTo(this), (!this._hash || !this._hash._onHashChange()) && (this.jumpTo({ center: t.center, zoom: t.zoom, bearing: t.bearing, pitch: t.pitch }), t.bounds && (this.resize(), this.fitBounds(t.bounds, O({}, t.fitBoundsOptions, { duration: 0 })))), this.resize(), this._localIdeographFontFamily = t.localIdeographFontFamily, this._validateStyle = t.validateStyle, t.style && this.setStyle(t.style, { localIdeographFontFamily: t.localIdeographFontFamily }), t.attributionControl && this.addControl(new Ma(typeof t.attributionControl == "boolean" ? void 0 : t.attributionControl)), t.maplibreLogo && this.addControl(new Ia(), t.logoPosition), this.on("style.load", () => {
      this.transform.unmodified && this.jumpTo(this.style.stylesheet);
    }), this.on("data", (o) => {
      this._update(o.dataType === "style"), this.fire(new z("".concat(o.dataType, "data"), o));
    }), this.on("dataloading", (o) => {
      this.fire(new z("".concat(o.dataType, "dataloading"), o));
    }), this.on("dataabort", (o) => {
      this.fire(new z("sourcedataabort", o));
    });
  }
  _getMapId() {
    return this._mapId;
  }
  addControl(t, i) {
    if (i === void 0 && (t.getDefaultPosition ? i = t.getDefaultPosition() : i = "top-right"), !t || !t.onAdd) return this.fire(new Z(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
    let n = t.onAdd(this);
    this._controls.push(t);
    let o = this._controlPositions[i];
    return i.indexOf("bottom") !== -1 ? o.insertBefore(n, o.firstChild) : o.appendChild(n), this;
  }
  removeControl(t) {
    if (!t || !t.onRemove) return this.fire(new Z(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
    let i = this._controls.indexOf(t);
    return i > -1 && this._controls.splice(i, 1), t.onRemove(this), this;
  }
  hasControl(t) {
    return this._controls.indexOf(t) > -1;
  }
  calculateCameraOptionsFromTo(t, i, n, o) {
    return o == null && this.terrain && (o = this.terrain.getElevationForLngLatZoom(n, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(t, i, n, o);
  }
  resize(t) {
    var l;
    let i = this._containerDimensions(), n = i[0], o = i[1], a = this._getClampedPixelRatio(n, o);
    if (this._resizeCanvas(n, o, a), this.painter.resize(n, o, a), this.painter.overLimit()) {
      let u = this.painter.context.gl;
      this._maxCanvasSize = [u.drawingBufferWidth, u.drawingBufferHeight];
      let c3 = this._getClampedPixelRatio(n, o);
      this._resizeCanvas(n, o, c3), this.painter.resize(n, o, c3);
    }
    this.transform.resize(n, o), (l = this._requestedCameraState) == null || l.resize(n, o);
    let s3 = !this._moving;
    return s3 && (this.stop(), this.fire(new z("movestart", t)).fire(new z("move", t))), this.fire(new z("resize", t)), s3 && this.fire(new z("moveend", t)), this;
  }
  _getClampedPixelRatio(t, i) {
    let { 0: n, 1: o } = this._maxCanvasSize, a = this.getPixelRatio(), s3 = t * a, l = i * a, u = s3 > n ? n / s3 : 1, c3 = l > o ? o / l : 1;
    return Math.min(u, c3) * a;
  }
  getPixelRatio() {
    var t;
    return (t = this._overridePixelRatio) != null ? t : devicePixelRatio;
  }
  setPixelRatio(t) {
    this._overridePixelRatio = t, this.resize();
  }
  getBounds() {
    return this.transform.getBounds();
  }
  getMaxBounds() {
    return this.transform.getMaxBounds();
  }
  setMaxBounds(t) {
    return this.transform.setMaxBounds(lt.convert(t)), this._update();
  }
  setMinZoom(t) {
    if (t = t == null ? dc : t, t >= dc && t <= this.transform.maxZoom) return this.transform.minZoom = t, this._update(), this.getZoom() < t && this.setZoom(t), this;
    throw new Error("minZoom must be between ".concat(dc, " and the current maxZoom, inclusive"));
  }
  getMinZoom() {
    return this.transform.minZoom;
  }
  setMaxZoom(t) {
    if (t = t == null ? d_ : t, t >= this.transform.minZoom) return this.transform.maxZoom = t, this._update(), this.getZoom() > t && this.setZoom(t), this;
    throw new Error("maxZoom must be greater than the current minZoom");
  }
  getMaxZoom() {
    return this.transform.maxZoom;
  }
  setMinPitch(t) {
    if (t = t == null ? Br : t, t < Br) throw new Error("minPitch must be greater than or equal to ".concat(Br));
    if (t >= Br && t <= this.transform.maxPitch) return this.transform.minPitch = t, this._update(), this.getPitch() < t && this.setPitch(t), this;
    throw new Error("minPitch must be between ".concat(Br, " and the current maxPitch, inclusive"));
  }
  getMinPitch() {
    return this.transform.minPitch;
  }
  setMaxPitch(t) {
    if (t = t == null ? y_ : t, t > mc) throw new Error("maxPitch must be less than or equal to ".concat(mc));
    if (t >= this.transform.minPitch) return this.transform.maxPitch = t, this._update(), this.getPitch() > t && this.setPitch(t), this;
    throw new Error("maxPitch must be greater than the current minPitch");
  }
  getMaxPitch() {
    return this.transform.maxPitch;
  }
  getRenderWorldCopies() {
    return this.transform.renderWorldCopies;
  }
  setRenderWorldCopies(t) {
    return this.transform.renderWorldCopies = t, this._update();
  }
  project(t) {
    return this.transform.locationPoint(re.convert(t), this.style && this.terrain);
  }
  unproject(t) {
    return this.transform.pointLocation(cr.default.convert(t), this.terrain);
  }
  isMoving() {
    var t;
    return this._moving || ((t = this.handlers) == null ? void 0 : t.isMoving());
  }
  isZooming() {
    var t;
    return this._zooming || ((t = this.handlers) == null ? void 0 : t.isZooming());
  }
  isRotating() {
    var t;
    return this._rotating || ((t = this.handlers) == null ? void 0 : t.isRotating());
  }
  _createDelegatedListener(t, i, n) {
    if (t === "mouseenter" || t === "mouseover") {
      let o = false;
      return { layer: i, listener: n, delegates: { mousemove: (l) => {
        let u = this.getLayer(i) ? this.queryRenderedFeatures(l.point, { layers: [i] }) : [];
        u.length ? o || (o = true, n.call(this, new rt(t, this, l.originalEvent, { features: u }))) : o = false;
      }, mouseout: () => {
        o = false;
      } } };
    } else if (t === "mouseleave" || t === "mouseout") {
      let o = false;
      return { layer: i, listener: n, delegates: { mousemove: (l) => {
        (this.getLayer(i) ? this.queryRenderedFeatures(l.point, { layers: [i] }) : []).length ? o = true : o && (o = false, n.call(this, new rt(t, this, l.originalEvent)));
      }, mouseout: (l) => {
        o && (o = false, n.call(this, new rt(t, this, l.originalEvent)));
      } } };
    } else {
      let o = (a) => {
        let s3 = this.getLayer(i) ? this.queryRenderedFeatures(a.point, { layers: [i] }) : [];
        s3.length && (a.features = s3, n.call(this, a), delete a.features);
      };
      return { layer: i, listener: n, delegates: { [t]: o } };
    }
  }
  on(t, i, n) {
    if (n === void 0) return super.on(t, i);
    let o = this._createDelegatedListener(t, i, n);
    this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[t] = this._delegatedListeners[t] || [], this._delegatedListeners[t].push(o);
    for (let a in o.delegates) this.on(a, o.delegates[a]);
    return this;
  }
  once(t, i, n) {
    if (n === void 0) return super.once(t, i);
    let o = this._createDelegatedListener(t, i, n);
    for (let a in o.delegates) this.once(a, o.delegates[a]);
    return this;
  }
  off(t, i, n) {
    if (n === void 0) return super.off(t, i);
    let o = (a) => {
      let s3 = a[t];
      for (let l = 0; l < s3.length; l++) {
        let u = s3[l];
        if (u.layer === i && u.listener === n) {
          for (let c3 in u.delegates) this.off(c3, u.delegates[c3]);
          return s3.splice(l, 1), this;
        }
      }
    };
    return this._delegatedListeners && this._delegatedListeners[t] && o(this._delegatedListeners), this;
  }
  queryRenderedFeatures(t, i) {
    if (!this.style) return [];
    let n, o = t instanceof cr.default || Array.isArray(t), a = o ? t : [[0, 0], [this.transform.width, this.transform.height]];
    if (i = i || (o ? {} : t) || {}, a instanceof cr.default || typeof a[0] == "number") n = [cr.default.convert(a)];
    else {
      let s3 = cr.default.convert(a[0]), l = cr.default.convert(a[1]);
      n = [s3, new cr.default(l.x, s3.y), l, new cr.default(s3.x, l.y), s3];
    }
    return this.style.queryRenderedFeatures(n, i, this.transform);
  }
  querySourceFeatures(t, i) {
    return this.style.querySourceFeatures(t, i);
  }
  setStyle(t, i) {
    return i = O({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, i), i.diff !== false && i.localIdeographFontFamily === this._localIdeographFontFamily && this.style && t ? (this._diffStyle(t, i), this) : (this._localIdeographFontFamily = i.localIdeographFontFamily, this._updateStyle(t, i));
  }
  setTransformRequest(t) {
    return this._requestManager.setTransformRequest(t), this;
  }
  _getUIString(t) {
    let i = this._locale[t];
    if (i == null) throw new Error("Missing UI string '".concat(t, "'"));
    return i;
  }
  _updateStyle(t, i) {
    if (i.transformStyle && this.style && !this.style._loaded) {
      this.style.once("style.load", () => this._updateStyle(t, i));
      return;
    }
    let n = this.style && i.transformStyle ? this.style.serialize() : void 0;
    if (this.style && (this.style.setEventedParent(null), this.style._remove(!t)), t) this.style = new pn(this, i || {});
    else return delete this.style, this;
    return this.style.setEventedParent(this, { style: this.style }), typeof t == "string" ? this.style.loadURL(t, i, n) : this.style.loadJSON(t, i, n), this;
  }
  _lazyInitEmptyStyle() {
    this.style || (this.style = new pn(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
  }
  _diffStyle(t, i) {
    if (typeof t == "string") {
      let n = t, o = this._requestManager.transformRequest(n, "Style");
      mr(o, new AbortController()).then((a) => {
        this._updateDiff(a.data, i);
      }).catch((a) => {
        a && this.fire(new Z(a));
      });
    } else typeof t == "object" && this._updateDiff(t, i);
  }
  _updateDiff(t, i) {
    try {
      this.style.setState(t, i) && this._update(true);
    } catch (n) {
      Ee("Unable to perform style diff: ".concat(n.message || n.error || n, ".  Rebuilding the style from scratch.")), this._updateStyle(t, i);
    }
  }
  getStyle() {
    if (this.style) return this.style.serialize();
  }
  isStyleLoaded() {
    return this.style ? this.style.loaded() : Ee("There is no style added to the map.");
  }
  addSource(t, i) {
    return this._lazyInitEmptyStyle(), this.style.addSource(t, i), this._update(true);
  }
  isSourceLoaded(t) {
    let i = this.style && this.style.sourceCaches[t];
    if (i === void 0) {
      this.fire(new Z(new Error("There is no source with ID '".concat(t, "'"))));
      return;
    }
    return i.loaded();
  }
  setTerrain(t) {
    if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), !t) this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.minElevationForCurrentTile = 0, this.transform.elevation = 0;
    else {
      let i = this.style.sourceCaches[t.source];
      if (!i) throw new Error("cannot load terrain, because there exists no source with ID: ".concat(t.source));
      this.terrain === null && i.reload();
      for (let n in this.style._layers) {
        let o = this.style._layers[n];
        o.type === "hillshade" && o.source === t.source && Ee("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
      }
      this.terrain = new pc(this.painter, i, t), this.painter.renderToTexture = new fc(this.painter, this.terrain), this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this._terrainDataCallback = (n) => {
        n.dataType === "style" ? this.terrain.sourceCache.freeRtt() : n.dataType === "source" && n.tile && (n.sourceId === t.source && !this._elevationFreeze && (this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.terrain.sourceCache.freeRtt(n.tile.tileID));
      }, this.style.on("data", this._terrainDataCallback);
    }
    return this.fire(new z("terrain", { terrain: t })), this;
  }
  getTerrain() {
    var t, i;
    return (i = (t = this.terrain) == null ? void 0 : t.options) != null ? i : null;
  }
  areTilesLoaded() {
    let t = this.style && this.style.sourceCaches;
    for (let i in t) {
      let o = t[i]._tiles;
      for (let a in o) {
        let s3 = o[a];
        if (!(s3.state === "loaded" || s3.state === "errored")) return false;
      }
    }
    return true;
  }
  removeSource(t) {
    return this.style.removeSource(t), this._update(true);
  }
  getSource(t) {
    return this.style.getSource(t);
  }
  addImage(t, i, n = {}) {
    let { pixelRatio: o = 1, sdf: a = false, stretchX: s3, stretchY: l, content: u } = n;
    this._lazyInitEmptyStyle();
    let c3 = 0;
    if (i instanceof HTMLImageElement || pt(i)) {
      let { width: p, height: h, data: f } = J.getImageData(i);
      this.style.addImage(t, { data: new we({ width: p, height: h }, f), pixelRatio: o, stretchX: s3, stretchY: l, content: u, sdf: a, version: c3 });
    } else {
      if (i.width === void 0 || i.height === void 0) return this.fire(new Z(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
      {
        let { width: p, height: h, data: f } = i, d = i;
        return this.style.addImage(t, { data: new we({ width: p, height: h }, new Uint8Array(f)), pixelRatio: o, stretchX: s3, stretchY: l, content: u, sdf: a, version: c3, userImage: d }), d.onAdd && d.onAdd(this, t), this;
      }
    }
  }
  updateImage(t, i) {
    let n = this.style.getImage(t);
    if (!n) return this.fire(new Z(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
    let o = i instanceof HTMLImageElement || pt(i) ? J.getImageData(i) : i, { width: a, height: s3, data: l } = o;
    if (a === void 0 || s3 === void 0) return this.fire(new Z(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
    if (a !== n.data.width || s3 !== n.data.height) return this.fire(new Z(new Error("The width and height of the updated image must be that same as the previous version of the image")));
    let u = !(i instanceof HTMLImageElement || pt(i));
    return n.data.replace(l, u), this.style.updateImage(t, n), this;
  }
  getImage(t) {
    return this.style.getImage(t);
  }
  hasImage(t) {
    return t ? !!this.style.getImage(t) : (this.fire(new Z(new Error("Missing required image id"))), false);
  }
  removeImage(t) {
    this.style.removeImage(t);
  }
  loadImage(t) {
    return at.getImage(this._requestManager.transformRequest(t, "Image"), new AbortController());
  }
  listImages() {
    return this.style.listImages();
  }
  addLayer(t, i) {
    return this._lazyInitEmptyStyle(), this.style.addLayer(t, i), this._update(true);
  }
  moveLayer(t, i) {
    return this.style.moveLayer(t, i), this._update(true);
  }
  removeLayer(t) {
    return this.style.removeLayer(t), this._update(true);
  }
  getLayer(t) {
    return this.style.getLayer(t);
  }
  getLayersOrder() {
    return this.style.getLayersOrder();
  }
  setLayerZoomRange(t, i, n) {
    return this.style.setLayerZoomRange(t, i, n), this._update(true);
  }
  setFilter(t, i, n = {}) {
    return this.style.setFilter(t, i, n), this._update(true);
  }
  getFilter(t) {
    return this.style.getFilter(t);
  }
  setPaintProperty(t, i, n, o = {}) {
    return this.style.setPaintProperty(t, i, n, o), this._update(true);
  }
  getPaintProperty(t, i) {
    return this.style.getPaintProperty(t, i);
  }
  setLayoutProperty(t, i, n, o = {}) {
    return this.style.setLayoutProperty(t, i, n, o), this._update(true);
  }
  getLayoutProperty(t, i) {
    return this.style.getLayoutProperty(t, i);
  }
  setGlyphs(t, i = {}) {
    return this._lazyInitEmptyStyle(), this.style.setGlyphs(t, i), this._update(true);
  }
  getGlyphs() {
    return this.style.getGlyphsUrl();
  }
  addSprite(t, i, n = {}) {
    return this._lazyInitEmptyStyle(), this.style.addSprite(t, i, n, (o) => {
      o || this._update(true);
    }), this;
  }
  removeSprite(t) {
    return this._lazyInitEmptyStyle(), this.style.removeSprite(t), this._update(true);
  }
  getSprite() {
    return this.style.getSprite();
  }
  setSprite(t, i = {}) {
    return this._lazyInitEmptyStyle(), this.style.setSprite(t, i, (n) => {
      n || this._update(true);
    }), this;
  }
  setLight(t, i = {}) {
    return this._lazyInitEmptyStyle(), this.style.setLight(t, i), this._update(true);
  }
  getLight() {
    return this.style.getLight();
  }
  setFeatureState(t, i) {
    return this.style.setFeatureState(t, i), this._update();
  }
  removeFeatureState(t, i) {
    return this.style.removeFeatureState(t, i), this._update();
  }
  getFeatureState(t) {
    return this.style.getFeatureState(t);
  }
  getContainer() {
    return this._container;
  }
  getCanvasContainer() {
    return this._canvasContainer;
  }
  getCanvas() {
    return this._canvas;
  }
  _containerDimensions() {
    let t = 0, i = 0;
    return this._container && (t = this._container.clientWidth || 400, i = this._container.clientHeight || 300), [t, i];
  }
  _setupContainer() {
    let t = this._container;
    t.classList.add("maplibregl-map");
    let i = this._canvasContainer = L.create("div", "maplibregl-canvas-container", t);
    this._interactive && i.classList.add("maplibregl-interactive"), this._canvas = L.create("canvas", "maplibregl-canvas", i), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", "Map"), this._canvas.setAttribute("role", "region");
    let n = this._containerDimensions(), o = this._getClampedPixelRatio(n[0], n[1]);
    this._resizeCanvas(n[0], n[1], o);
    let a = this._controlContainer = L.create("div", "maplibregl-control-container", t), s3 = this._controlPositions = {};
    ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((l) => {
      s3[l] = L.create("div", "maplibregl-ctrl-".concat(l, " "), a);
    });
  }
  _resizeCanvas(t, i, n) {
    this._canvas.width = Math.floor(n * t), this._canvas.height = Math.floor(n * i), this._canvas.style.width = "".concat(t, "px"), this._canvas.style.height = "".concat(i, "px");
  }
  _setupPainter() {
    let t = { alpha: true, stencil: true, depth: true, failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || false }, i = null;
    this._canvas.addEventListener("webglcontextcreationerror", (o) => {
      i = { requestedAttributes: t }, o && (i.statusMessage = o.statusMessage, i.type = o.type);
    }, { once: true });
    let n = this._canvas.getContext("webgl2", t) || this._canvas.getContext("webgl", t);
    if (!n) {
      let o = "Failed to initialize WebGL";
      throw i ? (i.message = o, new Error(JSON.stringify(i))) : new Error(o);
    }
    this.painter = new Ou(n, this.transform), vn.testSupport(n);
  }
  loaded() {
    return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
  }
  _update(t) {
    return !this.style || !this.style._loaded ? this : (this._styleDirty = this._styleDirty || t, this._sourcesDirty = true, this.triggerRepaint(), this);
  }
  _requestRenderFrame(t) {
    return this._update(), this._renderTaskQueue.add(t);
  }
  _cancelRenderFrame(t) {
    this._renderTaskQueue.remove(t);
  }
  _render(t) {
    let i = this._idleTriggered ? this._fadeDuration : 0;
    if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(t), this._removed) return;
    let n = false;
    if (this.style && this._styleDirty) {
      this._styleDirty = false;
      let a = this.transform.zoom, s3 = J.now();
      this.style.zoomHistory.update(a, s3);
      let l = new de(a, { now: s3, fadeDuration: i, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), u = l.crossFadingFactor();
      (u !== 1 || u !== this._crossFadingFactor) && (n = true, this._crossFadingFactor = u), this.style.update(l);
    }
    this.style && this._sourcesDirty && (this._sourcesDirty = false, this.style._updateSources(this.transform)), this.terrain && (this.terrain.sourceCache.update(this.transform, this.terrain), this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this._elevationFreeze || (this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, i, this._crossSourceCollisions), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: i, showPadding: this.showPadding }), this.fire(new z("render")), this.loaded() && !this._loaded && (this._loaded = true, mn.mark("load"), this.fire(new z("load"))), this.style && (this.style.hasTransitions() || n) && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
    let o = this._sourcesDirty || this._styleDirty || this._placementDirty;
    return o || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new z("idle")), this._loaded && !this._fullyLoaded && !o && (this._fullyLoaded = true, mn.mark("fullLoad")), this;
  }
  redraw() {
    return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this;
  }
  remove() {
    var i;
    this._hash && this._hash.remove();
    for (let n of this._controls) n.onRemove(this);
    this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window < "u" && removeEventListener("online", this._onWindowOnline, false), at.removeThrottleControl(this._imageQueueHandle), (i = this._resizeObserver) == null || i.disconnect();
    let t = this.painter.context.gl.getExtension("WEBGL_lose_context");
    t && t.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.removeEventListener("webglcontextlost", this._contextLost, false), L.remove(this._canvasContainer), L.remove(this._controlContainer), this._container.classList.remove("maplibregl-map"), mn.clearMetrics(), this._removed = true, this.fire(new z("remove"));
  }
  triggerRepaint() {
    this.style && !this._frameRequest && (this._frameRequest = new AbortController(), J.frameAsync(this._frameRequest).then((t) => {
      mn.frame(t), this._frameRequest = null, this._render(t);
    }).catch(() => {
    }));
  }
  get showTileBoundaries() {
    return !!this._showTileBoundaries;
  }
  set showTileBoundaries(t) {
    this._showTileBoundaries !== t && (this._showTileBoundaries = t, this._update());
  }
  get showPadding() {
    return !!this._showPadding;
  }
  set showPadding(t) {
    this._showPadding !== t && (this._showPadding = t, this._update());
  }
  get showCollisionBoxes() {
    return !!this._showCollisionBoxes;
  }
  set showCollisionBoxes(t) {
    this._showCollisionBoxes !== t && (this._showCollisionBoxes = t, t ? this.style._generateCollisionBoxes() : this._update());
  }
  get showOverdrawInspector() {
    return !!this._showOverdrawInspector;
  }
  set showOverdrawInspector(t) {
    this._showOverdrawInspector !== t && (this._showOverdrawInspector = t, this._update());
  }
  get repaint() {
    return !!this._repaint;
  }
  set repaint(t) {
    this._repaint !== t && (this._repaint = t, this.triggerRepaint());
  }
  get vertices() {
    return !!this._vertices;
  }
  set vertices(t) {
    this._vertices = t, this._update();
  }
  get version() {
    return wM;
  }
  getCameraTargetElevation() {
    return this.transform.elevation;
  }
};
c();
c();
var g_ = (r50) => {
  r50.touchstart = r50.dragStart, r50.touchmoveWindow = r50.dragMove, r50.touchend = r50.dragEnd;
};
var x_ = ({ enable: r50, clickTolerance: e, bearingDegreesPerPixelMoved: t = 0.8 }) => {
  let i = new da();
  return new ur({ clickTolerance: e, move: (n, o) => ({ bearingDelta: (o.x - n.x) * t }), moveStateManager: i, enable: r50, assignEvents: g_ });
};
var b_ = ({ enable: r50, clickTolerance: e, pitchDegreesPerPixelMoved: t = -0.5 }) => {
  let i = new da();
  return new ur({ clickTolerance: e, move: (n, o) => ({ pitchDelta: (o.y - n.y) * t }), moveStateManager: i, enable: r50, assignEvents: g_ });
};
var PM = { showCompass: true, showZoom: true, visualizePitch: false };
var Bh = class {
  constructor(e) {
    this._updateZoomButtons = () => {
      let e3 = this._map.getZoom(), t = e3 === this._map.getMaxZoom(), i = e3 === this._map.getMinZoom();
      this._zoomInButton.disabled = t, this._zoomOutButton.disabled = i, this._zoomInButton.setAttribute("aria-disabled", t.toString()), this._zoomOutButton.setAttribute("aria-disabled", i.toString());
    };
    this._rotateCompassArrow = () => {
      let e3 = this.options.visualizePitch ? "scale(".concat(1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), 0.5), ") rotateX(").concat(this._map.transform.pitch, "deg) rotateZ(").concat(this._map.transform.angle * (180 / Math.PI), "deg)") : "rotate(".concat(this._map.transform.angle * (180 / Math.PI), "deg)");
      this._compassIcon.style.transform = e3;
    };
    this._setButtonTitle = (e3, t) => {
      let i = this._map._getUIString("NavigationControl.".concat(t));
      e3.title = i, e3.setAttribute("aria-label", i);
    };
    this.options = O({}, PM, e), this._container = L.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", (t) => t.preventDefault()), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", (t) => this._map.zoomIn({}, { originalEvent: t })), L.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", (t) => this._map.zoomOut({}, { originalEvent: t })), L.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", (t) => {
      this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: t }) : this._map.resetNorth({}, { originalEvent: t });
    }), this._compassIcon = L.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
  }
  onAdd(e) {
    return this._map = e, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Oh(this._map, this._compass, this.options.visualizePitch)), this._container;
  }
  onRemove() {
    L.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
  }
  _createButton(e, t) {
    let i = L.create("button", e, this._container);
    return i.type = "button", i.addEventListener("click", t), i;
  }
};
var Oh = class {
  constructor(e, t, i = false) {
    this.mousedown = (e3) => {
      this.startMouse(O({}, e3, { ctrlKey: true, preventDefault: () => e3.preventDefault() }), L.mousePos(this.element, e3)), L.addEventListener(window, "mousemove", this.mousemove), L.addEventListener(window, "mouseup", this.mouseup);
    };
    this.mousemove = (e3) => {
      this.moveMouse(e3, L.mousePos(this.element, e3));
    };
    this.mouseup = (e3) => {
      this.mouseRotate.dragEnd(e3), this.mousePitch && this.mousePitch.dragEnd(e3), this.offTemp();
    };
    this.touchstart = (e3) => {
      e3.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = L.touchPos(this.element, e3.targetTouches)[0], this.startTouch(e3, this._startPos), L.addEventListener(window, "touchmove", this.touchmove, { passive: false }), L.addEventListener(window, "touchend", this.touchend));
    };
    this.touchmove = (e3) => {
      e3.targetTouches.length !== 1 ? this.reset() : (this._lastPos = L.touchPos(this.element, e3.targetTouches)[0], this.moveTouch(e3, this._lastPos));
    };
    this.touchend = (e3) => {
      e3.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
    };
    this.reset = () => {
      this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), this.touchRotate.reset(), this.touchPitch && this.touchPitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
    };
    this._clickTolerance = 10;
    let n = e.dragRotate._mouseRotate.getClickTolerance(), o = e.dragRotate._mousePitch.getClickTolerance();
    this.element = t, this.mouseRotate = Ju({ clickTolerance: n, enable: true }), this.touchRotate = x_({ clickTolerance: n, enable: true }), this.map = e, i && (this.mousePitch = Yu({ clickTolerance: o, enable: true }), this.touchPitch = b_({ clickTolerance: o, enable: true })), L.addEventListener(t, "mousedown", this.mousedown), L.addEventListener(t, "touchstart", this.touchstart, { passive: false }), L.addEventListener(t, "touchcancel", this.reset);
  }
  startMouse(e, t) {
    this.mouseRotate.dragStart(e, t), this.mousePitch && this.mousePitch.dragStart(e, t), L.disableDrag();
  }
  startTouch(e, t) {
    this.touchRotate.dragStart(e, t), this.touchPitch && this.touchPitch.dragStart(e, t), L.disableDrag();
  }
  moveMouse(e, t) {
    let i = this.map, { bearingDelta: n } = this.mouseRotate.dragMove(e, t) || {};
    if (n && i.setBearing(i.getBearing() + n), this.mousePitch) {
      let { pitchDelta: o } = this.mousePitch.dragMove(e, t) || {};
      o && i.setPitch(i.getPitch() + o);
    }
  }
  moveTouch(e, t) {
    let i = this.map, { bearingDelta: n } = this.touchRotate.dragMove(e, t) || {};
    if (n && i.setBearing(i.getBearing() + n), this.touchPitch) {
      let { pitchDelta: o } = this.touchPitch.dragMove(e, t) || {};
      o && i.setPitch(i.getPitch() + o);
    }
  }
  off() {
    let e = this.element;
    L.removeEventListener(e, "mousedown", this.mousedown), L.removeEventListener(e, "touchstart", this.touchstart, { passive: false }), L.removeEventListener(window, "touchmove", this.touchmove, { passive: false }), L.removeEventListener(window, "touchend", this.touchend), L.removeEventListener(e, "touchcancel", this.reset), this.offTemp();
  }
  offTemp() {
    L.enableDrag(), L.removeEventListener(window, "mousemove", this.mousemove), L.removeEventListener(window, "mouseup", this.mouseup), L.removeEventListener(window, "touchmove", this.touchmove, { passive: false }), L.removeEventListener(window, "touchend", this.touchend);
  }
};
c();
c();
var yi;
async function __(r50 = false) {
  if (yi !== void 0 && !r50) return yi;
  if (window.navigator.permissions === void 0) return yi = !!window.navigator.geolocation, yi;
  try {
    yi = (await window.navigator.permissions.query({ name: "geolocation" })).state !== "denied";
  } catch {
    yi = !!window.navigator.geolocation;
  }
  return yi;
}
c();
var ka = s(ye(), 1);
c();
function yc(r50, e, t) {
  let i = new re(r50.lng, r50.lat);
  if (r50 = new re(r50.lng, r50.lat), e) {
    let n = new re(r50.lng - 360, r50.lat), o = new re(r50.lng + 360, r50.lat), a = t.locationPoint(r50).distSqr(e);
    t.locationPoint(n).distSqr(e) < a ? r50 = n : t.locationPoint(o).distSqr(e) < a && (r50 = o);
  }
  for (; Math.abs(r50.lng - t.center.lng) > 180; ) {
    let n = t.locationPoint(r50);
    if (n.x >= 0 && n.y >= 0 && n.x <= t.width && n.y <= t.height) break;
    r50.lng > t.center.lng ? r50.lng -= 360 : r50.lng += 360;
  }
  return r50.lng !== i.lng && t.locationPoint(r50).y > t.height / 2 - t.getHorizon() ? r50 : i;
}
c();
var Ea = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
function gc(r50, e, t) {
  let i = r50.classList;
  for (let n in Ea) i.remove("maplibregl-".concat(t, "-anchor-").concat(n));
  i.add("maplibregl-".concat(t, "-anchor-").concat(e));
}
var yn = class extends me {
  constructor(t) {
    super();
    this._onKeyPress = (t3) => {
      let i = t3.code, n = t3.charCode || t3.keyCode;
      (i === "Space" || i === "Enter" || n === 32 || n === 13) && this.togglePopup();
    };
    this._onMapClick = (t3) => {
      let i = t3.originalEvent.target, n = this._element;
      this._popup && (i === n || n.contains(i)) && this.togglePopup();
    };
    this._update = (t3) => {
      var a;
      if (!this._map) return;
      let i = this._map.loaded() && !this._map.isMoving();
      ((t3 == null ? void 0 : t3.type) === "terrain" || (t3 == null ? void 0 : t3.type) === "render" && !i) && this._map.once("render", this._update), this._map.transform.renderWorldCopies ? this._lngLat = yc(this._lngLat, this._flatPos, this._map.transform) : this._lngLat = (a = this._lngLat) == null ? void 0 : a.wrap(), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationPoint(this._lngLat)._add(this._offset));
      let n = "";
      this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? n = "rotateZ(".concat(this._rotation, "deg)") : this._rotationAlignment === "map" && (n = "rotateZ(".concat(this._rotation - this._map.getBearing(), "deg)"));
      let o = "";
      this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? o = "rotateX(0deg)" : this._pitchAlignment === "map" && (o = "rotateX(".concat(this._map.getPitch(), "deg)")), (!t3 || t3.type === "moveend") && (this._pos = this._pos.round()), L.setTransform(this._element, "".concat(Ea[this._anchor], " translate(").concat(this._pos.x, "px, ").concat(this._pos.y, "px) ").concat(o, " ").concat(n)), J.frameAsync(new AbortController()).then(() => {
        this._updateOpacity(t3 && t3.type === "moveend");
      }).catch(() => {
      });
    };
    this._onMove = (t3) => {
      if (!this._isDragging) {
        let i = this._clickTolerance || this._map._clickTolerance;
        this._isDragging = t3.point.dist(this._pointerdownPos) >= i;
      }
      this._isDragging && (this._pos = t3.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new z("dragstart"))), this.fire(new z("drag")));
    };
    this._onUp = () => {
      this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new z("dragend")), this._state = "inactive";
    };
    this._addDragHandler = (t3) => {
      this._element.contains(t3.originalEvent.target) && (t3.preventDefault(), this._positionDelta = t3.point.sub(this._pos).add(this._offset), this._pointerdownPos = t3.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
    };
    if (this._anchor = t && t.anchor || "center", this._color = t && t.color || "#3FB1CE", this._scale = t && t.scale || 1, this._draggable = t && t.draggable || false, this._clickTolerance = t && t.clickTolerance || 0, this._isDragging = false, this._state = "inactive", this._rotation = t && t.rotation || 0, this._rotationAlignment = t && t.rotationAlignment || "auto", this._pitchAlignment = t && t.pitchAlignment && t.pitchAlignment !== "auto" ? t.pitchAlignment : this._rotationAlignment, this.setOpacity(), this.setOpacity(t == null ? void 0 : t.opacity, t == null ? void 0 : t.opacityWhenCovered), !t || !t.element) {
      this._defaultMarker = true, this._element = L.create("div"), this._element.setAttribute("aria-label", "Map marker");
      let i = L.createNS("http://www.w3.org/2000/svg", "svg"), n = 41, o = 27;
      i.setAttributeNS(null, "display", "block"), i.setAttributeNS(null, "height", "".concat(n, "px")), i.setAttributeNS(null, "width", "".concat(o, "px")), i.setAttributeNS(null, "viewBox", "0 0 ".concat(o, " ").concat(n));
      let a = L.createNS("http://www.w3.org/2000/svg", "g");
      a.setAttributeNS(null, "stroke", "none"), a.setAttributeNS(null, "stroke-width", "1"), a.setAttributeNS(null, "fill", "none"), a.setAttributeNS(null, "fill-rule", "evenodd");
      let s3 = L.createNS("http://www.w3.org/2000/svg", "g");
      s3.setAttributeNS(null, "fill-rule", "nonzero");
      let l = L.createNS("http://www.w3.org/2000/svg", "g");
      l.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), l.setAttributeNS(null, "fill", "#000000");
      let u = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
      for (let v of u) {
        let b = L.createNS("http://www.w3.org/2000/svg", "ellipse");
        b.setAttributeNS(null, "opacity", "0.04"), b.setAttributeNS(null, "cx", "10.5"), b.setAttributeNS(null, "cy", "5.80029008"), b.setAttributeNS(null, "rx", v.rx), b.setAttributeNS(null, "ry", v.ry), l.appendChild(b);
      }
      let c3 = L.createNS("http://www.w3.org/2000/svg", "g");
      c3.setAttributeNS(null, "fill", this._color);
      let p = L.createNS("http://www.w3.org/2000/svg", "path");
      p.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), c3.appendChild(p);
      let h = L.createNS("http://www.w3.org/2000/svg", "g");
      h.setAttributeNS(null, "opacity", "0.25"), h.setAttributeNS(null, "fill", "#000000");
      let f = L.createNS("http://www.w3.org/2000/svg", "path");
      f.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), h.appendChild(f);
      let d = L.createNS("http://www.w3.org/2000/svg", "g");
      d.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), d.setAttributeNS(null, "fill", "#FFFFFF");
      let y = L.createNS("http://www.w3.org/2000/svg", "g");
      y.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
      let g = L.createNS("http://www.w3.org/2000/svg", "circle");
      g.setAttributeNS(null, "fill", "#000000"), g.setAttributeNS(null, "opacity", "0.25"), g.setAttributeNS(null, "cx", "5.5"), g.setAttributeNS(null, "cy", "5.5"), g.setAttributeNS(null, "r", "5.4999962");
      let x = L.createNS("http://www.w3.org/2000/svg", "circle");
      x.setAttributeNS(null, "fill", "#FFFFFF"), x.setAttributeNS(null, "cx", "5.5"), x.setAttributeNS(null, "cy", "5.5"), x.setAttributeNS(null, "r", "5.4999962"), y.appendChild(g), y.appendChild(x), s3.appendChild(l), s3.appendChild(c3), s3.appendChild(h), s3.appendChild(d), s3.appendChild(y), i.appendChild(s3), i.setAttributeNS(null, "height", "".concat(n * this._scale, "px")), i.setAttributeNS(null, "width", "".concat(o * this._scale, "px")), this._element.appendChild(i), this._offset = ka.default.convert(t && t.offset || [0, -14]);
    } else this._element = t.element, this._offset = ka.default.convert(t && t.offset || [0, 0]);
    if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", (i) => {
      i.preventDefault();
    }), this._element.addEventListener("mousedown", (i) => {
      i.preventDefault();
    }), gc(this._element, this._anchor, "marker"), t && t.className) for (let i of t.className.split(" ")) this._element.classList.add(i);
    this._popup = null;
  }
  addTo(t) {
    return this.remove(), this._map = t, t.getCanvasContainer().appendChild(this._element), t.on("move", this._update), t.on("moveend", this._update), t.on("terrain", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
  }
  remove() {
    return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), L.remove(this._element), this._popup && this._popup.remove(), this;
  }
  getLngLat() {
    return this._lngLat;
  }
  setLngLat(t) {
    return this._lngLat = re.convert(t), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
  }
  getElement() {
    return this._element;
  }
  setPopup(t) {
    if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), t) {
      if (!("offset" in t.options)) {
        let o = Math.abs(13.5) / Math.SQRT2;
        t.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [o, (38.1 - 13.5 + o) * -1], "bottom-right": [-o, (38.1 - 13.5 + o) * -1], left: [13.5, (38.1 - 13.5) * -1], right: [-13.5, (38.1 - 13.5) * -1] } : this._offset;
      }
      this._popup = t, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
    }
    return this;
  }
  getPopup() {
    return this._popup;
  }
  togglePopup() {
    let t = this._popup;
    if (this._element.style.opacity === this._opacityWhenCovered) return this;
    if (t) t.isOpen() ? t.remove() : (t.setLngLat(this._lngLat), t.addTo(this._map));
    else return this;
    return this;
  }
  _updateOpacity(t = false) {
    var d, y;
    if (!((d = this._map) == null ? void 0 : d.terrain)) {
      this._element.style.opacity !== this._opacity && (this._element.style.opacity = this._opacity);
      return;
    }
    if (t) this._opacityTimeout = null;
    else {
      if (this._opacityTimeout) return;
      this._opacityTimeout = setTimeout(() => {
        this._opacityTimeout = null;
      }, 100);
    }
    let n = this._map, o = n.terrain.depthAtPoint(this._pos), a = n.terrain.getElevationForLngLatZoom(this._lngLat, n.transform.tileZoom), s3 = n.transform.lngLatToCameraDepth(this._lngLat, a), l = 6e-3;
    if (s3 - o < l) {
      this._element.style.opacity = this._opacity;
      return;
    }
    let u = -this._offset.y / n.transform._pixelPerMeter, c3 = Math.sin(n.getPitch() * Math.PI / 180) * u, p = n.terrain.depthAtPoint(new ka.default(this._pos.x, this._pos.y - this._offset.y)), f = n.transform.lngLatToCameraDepth(this._lngLat, a + c3) - p > l;
    (y = this._popup) != null && y.isOpen() && f && this._popup.remove(), this._element.style.opacity = f ? this._opacityWhenCovered : this._opacity;
  }
  getOffset() {
    return this._offset;
  }
  setOffset(t) {
    return this._offset = ka.default.convert(t), this._update(), this;
  }
  addClassName(t) {
    this._element.classList.add(t);
  }
  removeClassName(t) {
    this._element.classList.remove(t);
  }
  toggleClassName(t) {
    return this._element.classList.toggle(t);
  }
  setDraggable(t) {
    return this._draggable = !!t, this._map && (t ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
  }
  isDraggable() {
    return this._draggable;
  }
  setRotation(t) {
    return this._rotation = t || 0, this._update(), this;
  }
  getRotation() {
    return this._rotation;
  }
  setRotationAlignment(t) {
    return this._rotationAlignment = t || "auto", this._update(), this;
  }
  getRotationAlignment() {
    return this._rotationAlignment;
  }
  setPitchAlignment(t) {
    return this._pitchAlignment = t && t !== "auto" ? t : this._rotationAlignment, this._update(), this;
  }
  getPitchAlignment() {
    return this._pitchAlignment;
  }
  setOpacity(t, i) {
    return t === void 0 && i === void 0 && (this._opacity = "1", this._opacityWhenCovered = "0.2"), t !== void 0 && (this._opacity = t), i !== void 0 && (this._opacityWhenCovered = i), this._map && this._updateOpacity(true), this;
  }
};
var TM = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true };
var xc = 0;
var La = false;
var Vh = class extends me {
  constructor(t) {
    super();
    this._onSuccess = (t3) => {
      if (this._map) {
        if (this._isOutOfMapMaxBounds(t3)) {
          this._setErrorState(), this.fire(new z("outofmaxbounds", t3)), this._updateMarker(), this._finish();
          return;
        }
        if (this.options.trackUserLocation) switch (this._lastKnownPosition = t3, this._watchState) {
          case "WAITING_ACTIVE":
          case "ACTIVE_LOCK":
          case "ACTIVE_ERROR":
            this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
            break;
          case "BACKGROUND":
          case "BACKGROUND_ERROR":
            this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
            break;
          default:
            throw new Error("Unexpected watchState ".concat(this._watchState));
        }
        this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(t3), (!this.options.trackUserLocation || this._watchState === "ACTIVE_LOCK") && this._updateCamera(t3), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new z("geolocate", t3)), this._finish();
      }
    };
    this._updateCamera = (t3) => {
      let i = new re(t3.coords.longitude, t3.coords.latitude), n = t3.coords.accuracy, o = this._map.getBearing(), a = O({ bearing: o }, this.options.fitBoundsOptions), s3 = lt.fromLngLat(i, n);
      this._map.fitBounds(s3, a, { geolocateSource: true });
    };
    this._updateMarker = (t3) => {
      if (t3) {
        let i = new re(t3.coords.longitude, t3.coords.latitude);
        this._accuracyCircleMarker.setLngLat(i).addTo(this._map), this._userLocationDotMarker.setLngLat(i).addTo(this._map), this._accuracy = t3.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
      } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
    };
    this._onZoom = () => {
      this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
    };
    this._onError = (t3) => {
      if (this._map) {
        if (this.options.trackUserLocation) if (t3.code === 1) {
          this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
          let i = this._map._getUIString("GeolocateControl.LocationNotAvailable");
          this._geolocateButton.title = i, this._geolocateButton.setAttribute("aria-label", i), this._geolocationWatchID !== void 0 && this._clearWatch();
        } else {
          if (t3.code === 3 && La) return;
          this._setErrorState();
        }
        this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new z("error", t3)), this._finish();
      }
    };
    this._finish = () => {
      this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
    };
    this._setupUI = (t3) => {
      if (this._map) {
        if (this._container.addEventListener("contextmenu", (i) => i.preventDefault()), this._geolocateButton = L.create("button", "maplibregl-ctrl-geolocate", this._container), L.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", t3 === false) {
          Ee("Geolocation support is not available so the GeolocateControl will be disabled.");
          let i = this._map._getUIString("GeolocateControl.LocationNotAvailable");
          this._geolocateButton.disabled = true, this._geolocateButton.title = i, this._geolocateButton.setAttribute("aria-label", i);
        } else {
          let i = this._map._getUIString("GeolocateControl.FindMyLocation");
          this._geolocateButton.title = i, this._geolocateButton.setAttribute("aria-label", i);
        }
        this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = L.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new yn({ element: this._dotElement }), this._circleElement = L.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new yn({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", () => this.trigger()), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", (i) => {
          let n = i.originalEvent && i.originalEvent.type === "resize";
          !i.geolocateSource && this._watchState === "ACTIVE_LOCK" && !n && (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new z("trackuserlocationend")));
        });
      }
    };
    this.options = O({}, TM, t);
  }
  onAdd(t) {
    return this._map = t, this._container = L.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), __().then((i) => this._setupUI(i)), this._container;
  }
  onRemove() {
    this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), L.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, xc = 0, La = false;
  }
  _isOutOfMapMaxBounds(t) {
    let i = this._map.getMaxBounds(), n = t.coords;
    return i && (n.longitude < i.getWest() || n.longitude > i.getEast() || n.latitude < i.getSouth() || n.latitude > i.getNorth());
  }
  _setErrorState() {
    switch (this._watchState) {
      case "WAITING_ACTIVE":
        this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
        break;
      case "ACTIVE_LOCK":
        this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
        break;
      case "BACKGROUND":
        this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
        break;
      case "ACTIVE_ERROR":
        break;
      default:
        throw new Error("Unexpected watchState ".concat(this._watchState));
    }
  }
  _updateCircleRadius() {
    let t = this._map.getBounds(), i = t.getSouthEast(), n = t.getNorthEast(), o = i.distanceTo(n), a = this._map._container.clientHeight, s3 = Math.ceil(2 * (this._accuracy / (o / a)));
    this._circleElement.style.width = "".concat(s3, "px"), this._circleElement.style.height = "".concat(s3, "px");
  }
  trigger() {
    if (!this._setup) return Ee("Geolocate control triggered before added to a map"), false;
    if (this.options.trackUserLocation) {
      switch (this._watchState) {
        case "OFF":
          this._watchState = "WAITING_ACTIVE", this.fire(new z("trackuserlocationstart"));
          break;
        case "WAITING_ACTIVE":
        case "ACTIVE_LOCK":
        case "ACTIVE_ERROR":
        case "BACKGROUND_ERROR":
          xc--, La = false, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new z("trackuserlocationend"));
          break;
        case "BACKGROUND":
          this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new z("trackuserlocationstart"));
          break;
        default:
          throw new Error("Unexpected watchState ".concat(this._watchState));
      }
      switch (this._watchState) {
        case "WAITING_ACTIVE":
          this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
          break;
        case "ACTIVE_LOCK":
          this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
          break;
        case "OFF":
          break;
        default:
          throw new Error("Unexpected watchState ".concat(this._watchState));
      }
      if (this._watchState === "OFF" && this._geolocationWatchID !== void 0) this._clearWatch();
      else if (this._geolocationWatchID === void 0) {
        this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), xc++;
        let t;
        xc > 1 ? (t = { maximumAge: 6e5, timeout: 0 }, La = true) : (t = this.options.positionOptions, La = false), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, t);
      }
    } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
    return true;
  }
  _clearWatch() {
    window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
  }
};
c();
var AM = { maxWidth: 100, unit: "metric" };
var Uh = class {
  constructor(e) {
    this._onMove = () => {
      v_(this._map, this._container, this.options);
    };
    this.setUnit = (e3) => {
      this.options.unit = e3, v_(this._map, this._container, this.options);
    };
    this.options = { ...AM, ...e };
  }
  getDefaultPosition() {
    return "bottom-left";
  }
  onAdd(e) {
    return this._map = e, this._container = L.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", e.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
  }
  onRemove() {
    L.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
  }
};
function v_(r50, e, t) {
  let i = t && t.maxWidth || 100, n = r50._container.clientHeight / 2, o = r50.unproject([0, n]), a = r50.unproject([i, n]), s3 = o.distanceTo(a);
  if (t && t.unit === "imperial") {
    let l = 3.2808 * s3;
    if (l > 5280) {
      let u = l / 5280;
      Da(e, i, u, r50._getUIString("ScaleControl.Miles"));
    } else Da(e, i, l, r50._getUIString("ScaleControl.Feet"));
  } else if (t && t.unit === "nautical") {
    let l = s3 / 1852;
    Da(e, i, l, r50._getUIString("ScaleControl.NauticalMiles"));
  } else s3 >= 1e3 ? Da(e, i, s3 / 1e3, r50._getUIString("ScaleControl.Kilometers")) : Da(e, i, s3, r50._getUIString("ScaleControl.Meters"));
}
function Da(r50, e, t, i) {
  let n = IM(t), o = n / t;
  r50.style.width = "".concat(e * o, "px"), r50.innerHTML = "".concat(n, "&nbsp;").concat(i);
}
function MM(r50) {
  let e = Math.pow(10, Math.ceil(-Math.log(r50) / Math.LN10));
  return Math.round(r50 * e) / e;
}
function IM(r50) {
  let e = Math.pow(10, "".concat(Math.floor(r50)).length - 1), t = r50 / e;
  return t = t >= 10 ? 10 : t >= 5 ? 5 : t >= 3 ? 3 : t >= 2 ? 2 : t >= 1 ? 1 : MM(t), e * t;
}
c();
var Nh = class extends me {
  constructor(t = {}) {
    super();
    this._onFullscreenChange = () => {
      var i;
      let t3 = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
      for (; (i = t3 == null ? void 0 : t3.shadowRoot) != null && i.fullscreenElement; ) t3 = t3.shadowRoot.fullscreenElement;
      t3 === this._container !== this._fullscreen && this._handleFullscreenChange();
    };
    this._onClickFullscreen = () => {
      this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
    };
    this._fullscreen = false, t && t.container && (t.container instanceof HTMLElement ? this._container = t.container : Ee("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
  }
  onAdd(t) {
    return this._map = t, this._container || (this._container = this._map.getContainer()), this._controlContainer = L.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
  }
  onRemove() {
    L.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
  }
  _setupUI() {
    let t = this._fullscreenButton = L.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
    L.create("span", "maplibregl-ctrl-icon", t).setAttribute("aria-hidden", "true"), t.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
  }
  _updateTitle() {
    let t = this._getTitle();
    this._fullscreenButton.setAttribute("aria-label", t), this._fullscreenButton.title = t;
  }
  _getTitle() {
    return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
  }
  _isFullscreen() {
    return this._fullscreen;
  }
  _handleFullscreenChange() {
    this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new z("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new z("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable());
  }
  _exitFullscreen() {
    window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
  }
  _requestFullscreen() {
    this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
  }
  _togglePseudoFullScreen() {
    this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
  }
};
c();
var Gh = class {
  constructor(e) {
    this._toggleTerrain = () => {
      this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
    };
    this._updateTerrainIcon = () => {
      this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
    };
    this.options = e;
  }
  onAdd(e) {
    return this._map = e, this._container = L.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = L.create("button", "maplibregl-ctrl-terrain", this._container), L.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
  }
  onRemove() {
    L.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
  }
};
c();
var qe = s(ye(), 1);
var CM = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px", subpixelPositioning: false };
var EM = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
var qh = class extends me {
  constructor(t) {
    super();
    this.remove = () => (this._content && L.remove(this._content), this._container && (L.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new z("close"))), this);
    this._onMouseUp = (t3) => {
      this._update(t3.point);
    };
    this._onMouseMove = (t3) => {
      this._update(t3.point);
    };
    this._onDrag = (t3) => {
      this._update(t3.point);
    };
    this._update = (t3) => {
      var l;
      let i = this._lngLat || this._trackPointer;
      if (!this._map || !i || !this._content) return;
      if (!this._container) {
        if (this._container = L.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = L.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className) for (let u of this.options.className.split(" ")) this._container.classList.add(u);
        this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
      }
      if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._map.transform.renderWorldCopies && !this._trackPointer ? this._lngLat = yc(this._lngLat, this._flatPos, this._map.transform) : this._lngLat = (l = this._lngLat) == null ? void 0 : l.wrap(), this._trackPointer && !t3) return;
      let n = this._flatPos = this._pos = this._trackPointer && t3 ? t3 : this._map.project(this._lngLat);
      this._map.terrain && (this._flatPos = this._trackPointer && t3 ? t3 : this._map.transform.locationPoint(this._lngLat));
      let o = this.options.anchor, a = w_(this.options.offset);
      if (!o) {
        let u = this._container.offsetWidth, c3 = this._container.offsetHeight, p;
        n.y + a.bottom.y < c3 ? p = ["top"] : n.y > this._map.transform.height - c3 ? p = ["bottom"] : p = [], n.x < u / 2 ? p.push("left") : n.x > this._map.transform.width - u / 2 && p.push("right"), p.length === 0 ? o = "bottom" : o = p.join("-");
      }
      let s3 = n.add(a[o]);
      this.options.subpixelPositioning || (s3 = s3.round()), L.setTransform(this._container, "".concat(Ea[o], " translate(").concat(s3.x, "px,").concat(s3.y, "px)")), gc(this._container, o, "popup");
    };
    this._onClose = () => {
      this.remove();
    };
    this.options = O(Object.create(CM), t);
  }
  addTo(t) {
    return this._map && this.remove(), this._map = t, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new z("open")), this;
  }
  isOpen() {
    return !!this._map;
  }
  getLngLat() {
    return this._lngLat;
  }
  setLngLat(t) {
    return this._lngLat = re.convert(t), this._pos = null, this._flatPos = null, this._trackPointer = false, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
  }
  trackPointer() {
    return this._trackPointer = true, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
  }
  getElement() {
    return this._container;
  }
  setText(t) {
    return this.setDOMContent(document.createTextNode(t));
  }
  setHTML(t) {
    let i = document.createDocumentFragment(), n = document.createElement("body"), o;
    for (n.innerHTML = t; o = n.firstChild, !!o; ) i.appendChild(o);
    return this.setDOMContent(i);
  }
  getMaxWidth() {
    var t;
    return (t = this._container) == null ? void 0 : t.style.maxWidth;
  }
  setMaxWidth(t) {
    return this.options.maxWidth = t, this._update(), this;
  }
  setDOMContent(t) {
    if (this._content) for (; this._content.hasChildNodes(); ) this._content.firstChild && this._content.removeChild(this._content.firstChild);
    else this._content = L.create("div", "maplibregl-popup-content", this._container);
    return this._content.appendChild(t), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
  }
  addClassName(t) {
    this._container && this._container.classList.add(t);
  }
  removeClassName(t) {
    this._container && this._container.classList.remove(t);
  }
  setOffset(t) {
    return this.options.offset = t, this._update(), this;
  }
  toggleClassName(t) {
    if (this._container) return this._container.classList.toggle(t);
  }
  setSubpixelPositioning(t) {
    this.options.subpixelPositioning = t;
  }
  _createCloseButton() {
    this.options.closeButton && (this._closeButton = L.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.setAttribute("aria-label", "Close popup"), this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
  }
  _focusFirstElement() {
    if (!this.options.focusAfterOpen || !this._container) return;
    let t = this._container.querySelector(EM);
    t && t.focus();
  }
};
function w_(r50) {
  if (r50) if (typeof r50 == "number") {
    let e = Math.round(Math.abs(r50) / Math.SQRT2);
    return { center: new qe.default(0, 0), top: new qe.default(0, r50), "top-left": new qe.default(e, e), "top-right": new qe.default(-e, e), bottom: new qe.default(0, -r50), "bottom-left": new qe.default(e, -e), "bottom-right": new qe.default(-e, -e), left: new qe.default(r50, 0), right: new qe.default(-r50, 0) };
  } else if (r50 instanceof qe.default || Array.isArray(r50)) {
    let e = qe.default.convert(r50);
    return { center: e, top: e, "top-left": e, "top-right": e, bottom: e, "bottom-left": e, "bottom-right": e, left: e, right: e };
  } else return { center: qe.default.convert(r50.center || [0, 0]), top: qe.default.convert(r50.top || [0, 0]), "top-left": qe.default.convert(r50["top-left"] || [0, 0]), "top-right": qe.default.convert(r50["top-right"] || [0, 0]), bottom: qe.default.convert(r50.bottom || [0, 0]), "bottom-left": qe.default.convert(r50["bottom-left"] || [0, 0]), "bottom-right": qe.default.convert(r50["bottom-right"] || [0, 0]), left: qe.default.convert(r50.left || [0, 0]), right: qe.default.convert(r50.right || [0, 0]) };
  else return w_(new qe.default(0, 0));
}
var kM = s(ye(), 1);
var LM = Fa.version;
function bY(r50, e) {
  return Fr().setRTLTextPlugin(r50, e);
}
function _Y() {
  return Fr().getRTLTextPluginStatus();
}
function vY() {
  return LM;
}
function wY() {
  return kr.workerCount;
}
function SY(r50) {
  kr.workerCount = r50;
}
function PY() {
  return nt.MAX_PARALLEL_IMAGE_REQUESTS;
}
function TY(r50) {
  nt.MAX_PARALLEL_IMAGE_REQUESTS = r50;
}
function AY() {
  return nt.WORKER_URL;
}
function MY(r50) {
  nt.WORKER_URL = r50;
}
function IY(r50) {
  return Al().broadcast("IS", r50);
}

export {
  nt,
  D_,
  z_,
  Gr,
  me,
  QT,
  eA,
  re,
  lt,
  ze,
  Zo,
  pi,
  $o,
  Wo,
  Et,
  Xo,
  Ko,
  cA,
  pn,
  ca,
  Gu,
  pa,
  rt,
  Rr,
  ha,
  fa,
  ga,
  xa,
  ba,
  _a,
  va,
  wa,
  Sa,
  Pa,
  Ta,
  Aa,
  Ma,
  Ia,
  Rh,
  Bh,
  yn,
  Vh,
  Uh,
  Nh,
  Gh,
  qh,
  kM,
  bY,
  _Y,
  vY,
  wY,
  SY,
  PY,
  TY,
  AY,
  MY,
  IY
};
//# sourceMappingURL=chunk-STL2KGEZ.js.map
